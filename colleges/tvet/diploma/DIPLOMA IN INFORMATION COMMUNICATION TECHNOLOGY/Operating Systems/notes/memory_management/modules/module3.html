      
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 3 - Memory Protection and Segmentation</title>
  <meta name="description" content="Memory protection and segmentation.">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <article class="learning-module" data-module="3">

    <nav class="module-nav">
      <div class="nav-links">
        <a href="../index.html" class="nav-button">
          <span>‚Üê</span> Home
        </a>
        <a href="module2.html" class="nav-button">
          <span>‚Üê</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 3 of 16</span>
        </div>
        <a href="module4.html" class="nav-button">
          Next <span>‚Üí</span>
        </a>
      </div>
    </nav>

    <header class="module-header">
      <h1>üìö Memory Protection and Segmentation</h1>
      <section class="module-objectives">
        <h2>üéØ Learning Objectives</h2>
        <ul>
          <li>Describe Memory Protection</li>
          <li>Understand Fragmentation</li>
          <li>Define Segmentation and it's purpose</li>
        </ul>
      </section>
    </header>

    <main class="module-content">

      <section>
        <h2>üìö Memory Protection:</h2>
        <p>Memory protection means protecting the OS from user process and protecting process from one another. Memory protection is provided by using a re-location register, with a limit register. Re-location register contains the values of smallest physical address and limit register contains range of logical addresses.</p>
        <p>(Re-location = 100040 and limit = 74600). The logical address must be less than the limit register; the MMU maps the logical address dynamically by adding the value in re-location register. When the CPU scheduler selects a process for execution, the dispatcher loads the re-location and limit register with correct values as a part of context switch. Since every address generated by the CPU is checked against these register we can protect the OS and other users programs and data from being modified.</p>
      </section>

      <section>
        <h2>üìö Fragmentation:</h2>
        <p>Memory fragmentation can be of two types: Internal Fragmentation External Fragmentation
          <ul>
            <li>Internal Fragmentation there is wasted space internal to a portion due to the fact that block of data loaded is smaller than the partition. Eg:-If there is a block of 50kb and if the process requests 40kb and if the block is allocated to the process then there will be 10kb of memory left.</li>
            <li>External Fragmentation exists when there is enough memory space exists to satisfy the request, but it not contiguous i.e., storage is fragmented in to large number of small holes. External Fragmentation may be either minor or a major problem.</li>
          </ul>
        <p>One solution for over-coming external fragmentation is compaction. The goal is to move all the free memory together to form a large block. Compaction is not possible always. If the relocation is static and is done at load time then compaction is not possible. Compaction is possible if the re-location is dynamic and done at execution time.</p>
        <p>Another possible solution to the external fragmentation problem is to permit the logical address space of a process to be non-contiguous, thus allowing the process to be allocated physical memory whenever the latter is available.</p>
      </section>

      <section>
        <h2>üìö 3.1.3 Segmentation</h2>
        <p>Most users do not think memory as a linear array of bytes rather the users thinks memory as a collection of variable sized segments which are dedicated to a particular use such as code, data, stack, heap etc. A logical address is a collection of segments. Each segment has a name and length. The address specifies both the segment name and the offset within the segments. The users specify address by using two quantities: a segment name and an offset. For simplicity the segments are numbered and referred by a segment number. So the logical address consists of <segment number, offset>.</p>
      </section>

      <section>
        <h2>üìù Summary</h2>
        <p>This module addressed Memory Protection that prevents the OS from user process and protect processes from one another. Memory fragmentation is an issue due to the wasted space either internal or external to a portion due to the fact that block of data loaded is smaller than the partition.  Segmentation describes that users do not think memory as a linear array of bytes but rather as a collection of segments.</p>
      </section>

    </main>

    <footer class="module-footer">
      <nav class="module-nav">
        <div class="nav-links">
          <a href="../index.html" class="nav-button">
            <span>‚Üê</span> Home
          </a>
          <a href="module2.html" class="nav-button">
            <span>‚Üê</span> Previous
          </a>
          <div class="module-progress">
            <span>Module 3 of 16</span>
          </div>
          <a href="module4.html" class="nav-button">
            Next <span>‚Üí</span>
          </a>
        </div>
      </nav>
    </footer>

  </article>
</body>
</html>

    