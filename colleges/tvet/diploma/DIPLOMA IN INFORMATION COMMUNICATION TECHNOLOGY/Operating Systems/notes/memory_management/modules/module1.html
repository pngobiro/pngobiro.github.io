      
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 1 - Memory Management</title>
  <meta name="description" content="Introduction to memory management concepts.">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <article class="learning-module" data-module="1">

    <nav class="module-nav">
      <div class="nav-links">
        <a href="../index.html" class="nav-button">
          <span>←</span> Home
        </a>
        <a href="#" class="nav-button" style="visibility: hidden;">
          <span>←</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 1 of 16</span>
        </div>
        <a href="module2.html" class="nav-button">
          Next <span>→</span>
        </a>
      </div>
    </nav>

    <header class="module-header">
      <h1>Unit III: Memory Management</h1>
      <section class="module-objectives">
        <h2>🎯 Learning Objectives</h2>
        <ul>
          <li>Understand the core concepts of memory management.</li>
          <li>Define address binding.</li>
          <li>Explain the different time bindings.</li>
        </ul>
      </section>
    </header>

    <main class="module-content">

      <section>
        <h2>📚 3.1 MEMORY MANAGEMENT</h2>
        <p>Memory management is concerned with managing the primary memory. Memory consists of an array of bytes or words each with their own address. The instructions are fetched from the memory by the CPU based on the value program counter.</p>
        <p>📝 Functions of memory management:</p>
        <ul>
          <li>📚 Keeping track of status of each memory location.</li>
          <li>📚 Determining the allocation policy.</li>
          <li>📚 Memory allocation technique.</li>
          <li>📚 De-allocation technique.</li>
        </ul>
      </section>

      <section>
        <h2>📚 Address Binding</h2>
        <p>Programs are stored on the secondary storage disks as binary executable files. When the programs are to be executed they are brought in to the main memory and placed within a process. The collection of processes on the disk waiting to enter the main memory forms the input queue. One of the processes which are to be executed is fetched from the queue and placed in the main memory. During the execution it fetches instruction and data from main memory. After the process terminates it returns back the memory space. During execution the process will go through different steps and in each step the address is represented in different ways. In source program the address is symbolic. The compiler converts the symbolic address to re-locatable address. The loader will convert this re-locatable address to absolute address.</p>
        <p>📝 Binding of instructions and data can be done at step along the way:</p>
        <ul>
          <li>📚 Compile time:-If we know whether the process resides in memory then absolute code can be generated. If the static address changes then it is necessary to re-compile the code from the beginning.</li>
          <li>📚 Load time:-If the compiler doesn't know whether the process resides in memory then it generates the re-locatable code. In this the binding is delayed until the load time.</li>
          <li>📚 Execution time:-If the process is moved during its execution from one memory segment to another then the binding is delayed until run time. Special hardware is used for this. Most of the general purpose operating system uses this method.</li>
        </ul>
      </section>

      <section>
        <h2>🔍 Logical versus physical address:</h2>
        <p><img src="../assets/images/module1-address-binding-diagram.png" alt="Diagram of Source Program, Compiler/Assembler, Object Module process" width="600" height="300"></p>
      </section>

      <section>
        <h2>📝 Summary</h2>
        <p>This module introduced memory management concepts. The CPU uses the value program counter to fetch the instructions. The memory management has functions such as keeping track of each location, determining the allocation policy, the memory allocation technique, and de-allocation technique. Address binding and its different forms were also described in the chapter.</p>
      </section>

    </main>

    <footer class="module-footer">
      <nav class="module-nav">
        <div class="nav-links">
          <a href="../index.html" class="nav-button">
            <span>←</span> Home
          </a>
          <a href="#" class="nav-button"  style="visibility: hidden;">
            <span>←</span> Previous
          </a>
          <div class="module-progress">
            <span>Module 1 of 16</span>
          </div>
          <a href="module2.html" class="nav-button">
            Next <span>→</span>
          </a>
        </div>
      </nav>
    </footer>

  </article>
</body>
</html>

    