      
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 4 - Paging</title>
  <meta name="description" content="Paging and page table structures.">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <article class="learning-module" data-module="4">

    <nav class="module-nav">
      <div class="nav-links">
        <a href="../index.html" class="nav-button">
          <span>←</span> Home
        </a>
        <a href="module3.html" class="nav-button">
          <span>←</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 4 of 16</span>
        </div>
        <a href="module5.html" class="nav-button">
          Next <span>→</span>
        </a>
      </div>
    </nav>

    <header class="module-header">
      <h1>📚 Paging</h1>
      <section class="module-objectives">
        <h2>🎯 Learning Objectives</h2>
        <ul>
          <li>Define Paging</li>
          <li>Understand the Structure of Page Tables</li>
        </ul>
      </section>
    </header>

    <main class="module-content">

      <section>
        <h2>📚 3.1.4 Paging</h2>
        <p>Paging is a memory management scheme that permits the physical address space of a process to be non-contiguous. Support for paging is handled by hardware. It is used to avoid external fragmentation. Paging avoids the considerable problem of fitting the varying sized memory chunks on to the backing store. When some code or date residing in main memory need to be swapped out, space must be found on backing store.</p>
        <p>📝 Basic Method:</p>
        <p>Physical memory is broken in to fixed sized blocks called frames (f). Logical memory is broken in to blocks of same size called pages (p). When a process is to be executed its pages are loaded in to available frames from backing store. The blocking store is also divided in to fixed-sized blocks of same size as memory frames. The following figure shows paging hardware:</p>
        <p><img src="../assets/images/module4-paging-hardware-diagram.png" alt="Paging hardware diagram" width="600" height="300"></p>
          <ul>
            <li>🔍 CPU</li>
            <li>🔍 Page table</li>
            <li>🔍 Physical memory</li>
          </ul>
        <p>Logical address generated by the CPU is divided in to two parts: page number (p) and page offset (d). The page number (p) is used as index to the page table. The page table contains base address of each page in physical memory. This base address is combined with the page offset to define the physical memory i.e., sent to the memory unit. The page size is defined by the hardware. The size of a power of 2, varying between 512 bytes and 10Mb per page. If the size of logical address space is 2^m address unit and page size is 2^n, then high order m-n designates the page number and n low order bits represents page offset.</p>
        <p><img src="../assets/images/module4-page-table-mapping-diagram.png" alt="Page Table mapping diagram" width="600" height="300"></p>
          <ul>
            <li>🔍 Page table</li>
            <li>🔍 Logical memory</li>
            <li>🔍 Physical Memory</li>
          </ul>
        <p>Eg:-To show how to map logical memory in to physical memory consider a page size of 4 bytes and physical memory of 32 bytes (8 pages). Logical address 0 is page 0 and offset 0. Page 0 is in frame 5. The logical address 0 maps to physical address 20. [(5\*4) + 0]. logical address 3 is page 0 and offset 3 maps to physical address 23 [(5\*4) + 3]. Logical address 4 is page 1 and offset 0 and page 1 is mapped to frame 6. So logical address 4 maps to physical address 24 [(6\*4) + 0]. Logical address 13 is page 3 and offset 1 and page 3 is mapped to frame 2. So logical address 13 maps to physical address 9 [(2\*4) + 1].</p>
        <p>✍️ Hardware Support for Paging:</p>
        <p>The hardware implementation of the page table can be done in several ways:</p>
        <p>The simplest method is that the page table is implemented as a set of dedicated registers. These registers must be built with very high speed logic for making paging address translation. Every accessed memory</p>
      </section>

      <section>
        <h2>📚 3.1.5 Structure Of Page Table</h2>

        <section>
          <h3>a. Hierarchical paging:</h3>
          <p>Recent computer system support a large logical address apace from 2^32 to 2^64. In this system the page table becomes large. So it is very difficult to allocate contiguous main memory for page table. One simple solution to this problem is to divide page table in to smaller pieces. There are several ways to accomplish this division.</p>
          <p><img src="../assets/images/module4-hierarchical-paging-diagram.png" alt="Hierarchical paging diagram" width="600" height="300"></p>
          <ul>
            <li>🔍 Outer Page Table</li>
            <li>🔍 Inner Page Table</li>
            <li>🔍 Memory</li>
          </ul>
          <p>One way is to use two-level paging algorithm in which the page table itself is also paged. Eg:-In a 32 bit</p>
        </section>

        <section>
          <h3>b. Hashed page table:</h3>
          <p>Hashed page table handles the address space larger than 32 bit. The virtual page number is used as hashed value. Linked list is used in the hash table which contains a list of elements that hash to the same location.</p>
          <p>Each element in the hash table contains the following three fields: Virtual page number x Mapped page frame value x Pointer to the next element in the linked list</p>
          <p>Working:</p>
          <p>Virtual page number is taken from virtual address. Virtual page number is hashed in to hash table. Virtual page number is compared with the first element of linked list. Both the values are matched, that value is (page frame) used for calculating the physical address. If not match then entire linked list is searched for matching virtual page number. Clustered pages are similar to hash table but one difference is that each entity in the hash table refer to several pages.</p>
          <p><img src="../assets/images/module4-hashed-page-table-diagram.png" alt="Hashed page table diagram" width="600" height="300"></p>
            <ul>
              <li>🔍 Logical address</li>
              <li>🔍 Hash function</li>
              <li>🔍 Physical Memory</li>
              <li>🔍 Hash Table</li>
            </ul>
        </section>

        <section>
          <h3>c. Inverted Page Tables:</h3>
          <p>Since the address spaces have grown to 64 bits, the traditional page tables become a problem. Even with two level page tables. The table can be too large to handle. An inverted page table has only entry for each page in memory. Each entry consisted of virtual address of the page stored in that read-only location with information about the process that owns that page.</p>
          <p>Each virtual address in the Inverted page table consists of triple <process-id, page number, offset >. The inverted page table entry is a pair <process-id, page number>. When a memory reference is made, the part of virtual address i.e., <process-id, page number> is presented in to memory sub-system. The inverted page table is searched for a match. If a match is found at entry I then the physical address <i offset> is generated. If no match is found then an illegal address access has been attempted. This scheme</p>
          <p><img src="../assets/images/module4-inverted-page-table-diagram.png" alt="Inverted Page Table diagram" width="600" height="300"></p>
            <ul>
              <li>🔍 Logical address</li>
              <li>🔍 CPU</li>
              <li>🔍 Search</li>
              <li>🔍 Physical Memory</li>
              <li>🔍 PID</li>
              <li>🔍 d</li>
            </ul>
        </section>

      </section>

      <section>
        <h2>📝 Summary</h2>
        <p>This module explained the concept of paging that allows the physical address space to be non-contiguous. Also, the structure of the page table and hardware support for paging were discussed. There are different ways to organize page tables: hierarchical paging, hashed page tables, and inverted page tables.</p>
      </section>

    </main>

    <footer class="module-footer">
      <nav class="module-nav">
        <div class="nav-links">
          <a href="../index.html" class="nav-button">
            <span>←</span> Home
          </a>
          <a href="module3.html" class="nav-button">
            <span>←</span> Previous
          </a>
          <div class="module-progress">
            <span>Module 4 of 16</span>
          </div>
          <a href="module5.html" class="nav-button">
            Next <span>→</span>
          </a>
        </div>
      </nav>
    </footer>

  </article>
</body>
</html>

    