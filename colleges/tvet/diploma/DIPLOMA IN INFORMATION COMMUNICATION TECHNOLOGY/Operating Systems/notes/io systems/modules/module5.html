<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>I/O Systems - Module 5</title>
  <meta name="description" content="Detailed transcription of Application I/O Interface section">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <article class="learning-module" data-module="5">
    <nav class="module-nav">
      <div class="nav-links">
        <a href="module4.html" class="nav-button">
          <span>←</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 5 of 8</span>
        </div>
        <a href="module6.html" class="nav-button">
          Next <span>→</span>
        </a>
      </div>
    </nav>

    <main class="module-content">
      <h1>5.1.3 Application I/O Interface</h1>

      <h2>5.1.3.1 Block and Character Devices</h2>
      
      <p>Block devices are accessed a block at a time and are indicated by a "b" as the first character in a long listing on UNIX systems. Operations supported include read() write() and seek().</p>
      <ul>
        <li>Accessing blocks on a hard drive directly (without going through the file system structure) is called raw I/O and can speed up certain operations by bypassing the buffering and locking normally conducted by the OS. (It then becomes the application's responsibility to manage those issues.)</li>
        <li>A new alternative is direct I/O which uses the normal file system access but which disables buffering and locking operations.</li>
      </ul>
      
      <p>Memory-mapped file I/O can be layered on top of block-device drivers.</p>
      <ul>
        <li>Rather than reading in the entire file it is mapped to a range of memory addresses and then paged into memory as needed using the virtual memory system.</li>
        <li>Access to the file is then accomplished through normal memory accesses rather than through read() and write() system calls. This approach is commonly used for executable program code.</li>
      </ul>
      
      <p>Character devices are accessed one byte at a time and are indicated by a "c" in UNIX long listings. Supported operations include get() and put() with more advanced functionality such as reading an entire line supported by higher-level library routines.</p>

      <h2>5.1.3.2 Network Devices</h2>
      
      <p>Because network access is inherently different from local disk access most systems provide a separate interface for network devices.</p>
      
      <p>One common and popular interface is the socket interface which acts like a cable or pipeline connecting two networked entities. Data can be put into the socket at one end and read out sequentially at the other end. Sockets are normally full-duplex allowing for bi-directional data transfer.</p>
      
      <p>The select() system call allows servers (or other applications) to identify sockets which have data waiting without having to poll all available sockets.</p>

      <h2>5.1.3.3 Clocks and Timers</h2>
      
      <p>Three types of time services are commonly needed in modern systems:</p>
      <ul>
        <li>Get the current time of day.</li>
        <li>Get the elapsed time (system or wall clock) since a previous event.</li>
        <li>Set a timer to trigger event X at time T.</li>
      </ul>
      
      <p>Unfortunately time operations are not standard across all systems.</p>
      
      <p>A programmable interrupt timer PIT can be used to trigger operations and to measure elapsed time. It can be set to trigger an interrupt at a specific future time or to trigger interrupts periodically on a regular basis.</p>
      <ul>
        <li>The scheduler uses a PIT to trigger interrupts for ending time slices.</li>
        <li>The disk system may use a PIT to schedule periodic maintenance cleanup such as flushing buffers to disk.</li>
        <li>Networks use PIT to abort or repeat operations that are taking too long to complete. I.e. resending packets if an acknowledgement is not received before the timer goes off.</li>
        <li>More timers than actually exist can be simulated by maintaining an ordered list of timer events and setting the physical timer to go off when the next scheduled event should occur.</li>
      </ul>
      
      <p>On most systems the system clock is implemented by counting interrupts generated by the PIT. Unfortunately this is limited in its resolution to the interrupt frequency of the PIT and may be subject to some drift over time. An alternate approach is to provide direct access to a high frequency hardware counter which provides much higher resolution and accuracy but which does not support interrupts.</p>

      <h2>5.1.3.4 Blocking and Non-blocking I/O</h2>
      
      <p>With blocking I/O a process is moved to the wait queue when an I/O request is made and moved back to the ready queue when the request completes allowing other processes to run in the meantime.</p>
      
      <p>With non-blocking I/O the I/O request returns immediately whether the requested I/O operation has (completely) occurred or not. This allows the process to check for available data without getting hung completely if it is not there.</p>
      
      <p>One approach for programmers to implement non-blocking I/O is to have a multi-threaded application in which one thread makes blocking I/O calls (say to read a keyboard or mouse) while other threads continue to update the screen or perform other tasks.</p>
      
      <p>A subtle variation of the non-blocking I/O is the asynchronous I/O in which the I/O request returns immediately allowing the process to continue on with other tasks and then the process is notified (via changing a process variable or a software interrupt or a callback function) when the I/O operation has completed and the data is available for use. (The regular non-blocking I/O returns immediately with whatever results are available but does not complete the operation and notify the process later.)</p>
      
      <figure>
        <img src="../assets/images/module5-io-methods.jpg" alt="Two I/O methods: (a) synchronous and (b) asynchronous showing the differences in process flow" width="600" height="400">
        <figcaption>Fig: Two I/O methods: (a) synchronous and (b) asynchronous.</figcaption>
      </figure>
    </main>

    <nav class="module-nav">
      <div class="nav-links">
        <a href="module4.html" class="nav-button">
          <span>←</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 5 of 8</span>
        </div>
        <a href="module6.html" class="nav-button">
          Next <span>→</span>
        </a>
      </div>
    </nav>
  </article>
</body>
</html>
