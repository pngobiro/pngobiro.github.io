<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operating Systems Overview - [Course Name]</title>
    <meta name="description" content="Module 1: Operating Systems Overview">
    <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
    <article class="learning-module" data-module="1">
        <nav class="module-nav">
            <div class="nav-links">
                <a href="../index.html" class="nav-button">
                    <span>‚Üê</span> Home
                </a>
                <a href="#" class="nav-button disabled">
                    <span>‚Üê</span> Previous
                </a>
                <div class="module-progress">
                    <span>Module 1 of 3</span>
                </div>
                <a href="module2.html" class="nav-button">
                    Next <span>‚Üí</span>
                </a>
            </div>
        </nav>
        <header class="module-header">
            <h1>Module 1: Operating Systems Overview</h1>
            <section class="module-objectives">
                <h2>üéØ Learning Objectives</h2>
                <ul>
                    <li>Understand the basic functions of operating systems.</li>
                    <li>Explore different operating system structures.</li>
                    <li>Learn about operating system operations and environments.</li>
                </ul>
            </section>
        </header>
        <main class="module-content">
            <section id="section-1-1" class="module-section">
                <h2>1.1 Operating Systems Overview</h2>
                <section id="section-1-1-1" class="module-section">
                    <h3>1.1.1 Operating systems functions</h3>
                    <section id="section-what-is-os" class="module-section">
                        <h4>What is an Operating System?</h4>
                        <p>üìö Content: A program that acts as an intermediary between a user of a computer and the computer hardware</p>
                        <p>Operating system goals:</p>
                        <ul>
                            <li>Execute user programs and make solving user problems easier</li>
                            <li>Make the computer system convenient to use</li>
                            <li>Use the computer hardware in an efficient manner</li>
                        </ul>
                    </section>
                    <section id="section-computer-structure" class="module-section">
                        <h4>Computer System Structure</h4>
                        <p>Computer system can be divided into four components:</p>
                        <ul>
                            <li>Hardware ‚Äì provides basic computing resources CPU, memory, I/O devices</li>
                            <li>Operating system-Controls and coordinates use of hardware among various applications and users</li>
                            <li>Application programs ‚Äì define the ways in which the system resources are used to solve the computing problems of the users
                                -Word processors, compilers, web browsers, database systems, video games</li>
                            <li>Users - People, machines, other computers</li>
                        </ul>
                        <p>Four Components of a Computer System</p>
                        <figure>
                            <img src="../assets/images/module1-computer-components.png" alt="Diagram of Four Components of a Computer System" width="400" height="300">
                            <figcaption>Figure 1: Four Components of a Computer System</figcaption>
                        </figure>
                    </section>
                    <section id="section-process-management" class="module-section">
                        <h4>Process Management</h4>
                        <p>üìö Content:</p>
                        <ul>
                            <li>A process is a program in execution. It is a unit of work within the system. Program is a passive entity, process is an active entity.</li>
                            <li>Process needs resources to accomplish its task
                                <ul>
                                    <li>CPU, memory, I/O, files</li>
                                    <li>Initialization data</li>
                                </ul>
                            </li>
                            <li>Process termination requires reclaim of any reusable resources</li>
                            <li>Single-threaded process has one program counter specifying location of next instruction to execute</li>
                            <li>Process executes instructions sequentially, one at a time, until completion</li>
                            <li>Multi-threaded process has one program counter per thread</li>
                            <li>Typically system has many processes, some user, some operating system running concurrently on one or more CPUs</li>
                            <li>Concurrency by multiplexing the CPUs among the processes / threads</li>
                        </ul>
                    </section>
                    <section id="section-process-management-activities" class="module-section">
                        <h4>Process Management Activities</h4>
                        <p>The operating system is responsible for the following activities in connection with process management:</p>
                        <ul>
                            <li>Creating and deleting both user and system processes</li>
                            <li>Suspending and resuming processes</li>
                            <li>Providing mechanisms for process synchronization</li>
                            <li>Providing mechanisms for process communication</li>
                            <li>Providing mechanisms for deadlock handling</li>
                        </ul>
                    </section>
                    <section id="section-memory-management" class="module-section">
                        <h4>Memory Management</h4>
                        <p>üìö Content:</p>
                        <ul>
                            <li>All data in memory before and after processing</li>
                            <li>All instructions in memory in order to execute</li>
                            <li>Memory management determines what is in memory when</li>
                            <li>Optimizing CPU utilization and computer response to users</li>
                        </ul>
                        <p>Memory management activities:</p>
                        <ul>
                            <li>Keeping track of which parts of memory are currently being used and by whom</li>
                            <li>Deciding which processes (or parts thereof) and data to move into and out of memory</li>
                            <li>Allocating and deal locating memory space as needed</li>
                        </ul>
                    </section>
                    <section id="section-storage-management" class="module-section">
                        <h4>Storage Management</h4>
                        <p>üìö Content:</p>
                        <ul>
                            <li>OS provides uniform, logical view of information storage</li>
                            <li>Abstracts physical properties to logical storage unit - file</li>
                            <li>Each medium is controlled by device (i.e., disk drive, tape drive)</li>
                            <li>Varying properties include access speed, capacity, data-transfer rate, access method (sequential or random)</li>
                        </ul>
                        <p>File-System management:</p>
                        <ul>
                            <li>Files usually organized into directories</li>
                            <li>Access control on most systems to determine who can access what</li>
                        </ul>
                        <p>OS activities include:</p>
                        <ul>
                            <li>Creating and deleting files and directories</li>
                            <li>Primitives to manipulate files and dirs</li>
                            <li>Mapping files onto secondary storage</li>
                            <li>Backup files onto stable (non-volatile) storage media</li>
                        </ul>
                    </section>
                    <section id="section-mass-storage-management" class="module-section">
                        <h4>Mass-Storage Management</h4>
                        <p>üìö Content:</p>
                        <ul>
                            <li>Usually disks used to store data that does not fit in main memory or data that must be kept for a ‚Äúlong‚Äù period of time</li>
                            <li>Proper management is of central importance</li>
                            <li>Entire speed of computer operation hinges on disk subsystem and its algorithms</li>
                        </ul>
                        <p>MASS STORAGE activities:</p>
                        <ul>
                            <li>Free-space management</li>
                            <li>Storage allocation</li>
                            <li>Disk scheduling</li>
                            <li>Some storage need not be fast
                                <ul>
                                    <li>Tertiary storage includes optical storage, magnetic tape</li>
                                    <li>Still must be managed</li>
                                    <li>Varies between WORM (write-once, read-many-times) and RW (read-write)</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                </section>
            </section>

            <section id="section-1-1-2" class="module-section">
                <h2>1.1.2 Operating-System Structure</h2>
                <section id="section-simple-structure" class="module-section">
                    <h3>Simple Structure</h3>
                    <p>üìö Content: Many commercial systems do not have well-defined structures. Frequently, such operating systems started as small, simple, and limited systems and then grew beyond their original scope. MS-DOS is an example of such a system.</p>
                    <figure>
                        <img src="../assets/images/module1-msdos-structure.png" alt="Diagram of MS-DOS Structure" width="300" height="250">
                        <figcaption>Figure 2: MS-DOS Structure</figcaption>
                    </figure>
                    <p>It was written to provide the most functionality in the least space, so it was not divided into modules carefully. In MS-DOS, the interfaces and levels of functionality are not well separated. For instance, application programs are able to access the basic I/O routines to write directly to the display and disk drives. Such freedom leaves MS-DOS vulnerable to errant (or malicious) programs, causing entire system crashes when user programs fail. Of course, MS-DOS was also limited by the hardware of its era. Another example of limited structuring is the original UNIX operating system. UNIX is another system that initially was limited by hardware functionality.</p>
                    <figure>
                        <img src="../assets/images/module1-unix-structure.png" alt="Diagram of UNIX Structure" width="300" height="250">
                        <figcaption>Figure 3: UNIX Structure</figcaption>
                    </figure>
                    <p>It consists of two separable parts: the kernel and the system programs. The kernel is further separated into a series of interfaces and device drivers, which have been added and expanded over the years as UNIX has evolved.</p>
                </section>
                <section id="section-layered-approach" class="module-section">
                    <h3>Layered Approach</h3>
                    <p>üìö Content: The operating system can then retain much greater control over the computer and over the applications that make use of that computer. Implementers have more freedom in changing the inner workings of the system and in creating modular operating systems. Under the top down approach, the overall functionality and features are determined and are separated into components. Information hiding is also important, because it leaves programmers free to implement the low-level routines as they see fit, provided that the external interface of the routine stays unchanged and that the routine itself performs the advertised task. A system can be made modular in many ways. One method is the layered approach, in which the operating system is broken up into a number of layers (levels). The bottom layer (layer 0) is the hardware; the highest (layer N) is the user interface.</p>
                    <figure>
                        <img src="../assets/images/module1-layered-structure.png" alt="Diagram of Layered Structure" width="300" height="250">
                        <figcaption>Figure 4: Layered Structure</figcaption>
                    </figure>
                    <p>An operating-system layer is an implementation of an abstract object made up of data and the operations that can manipulate those data. A typical operating-system layer‚Äîsay, layer M‚Äîconsists of data structures and a set of routines that can be invoked by higher-level layers. Layer M, in turn, can invoke operations on lower-level layers.</p>
                    <p>The main advantage of the layered approach is simplicity of construction and debugging. The layers are selected so that each uses functions (operations) and services of only lower-level layers. This approach simplifies debugging and system verification. The first layer can be debugged without any concern for the rest of the system, because, by definition, it uses only the basic hardware (which is assumed correct) to implement its functions. Once the first layer is debugged, its correct functioning can be assumed while the second layer is debugged, and so on. If an error is found during the debugging of a particular layer, the error must be on that layer, because the layers below it are already debugged. Thus, the design and implementation of the system is simplified.</p>
                    <p>Each layer is implemented with only those operations provided by lower level layers. A layer does not need to know how these operations are implemented; it needs to know only what these operations do. Hence, each layer hides the existence of certain data structures, operations, and hardware from higher-level layers.</p>
                    <p>The major difficulty with the layered approach involves appropriately defining the various layers. The backing-store driver would normally be above the CPU scheduler, because the driver may need to wait for I/O and the CPU can be rescheduled during this time. A final problem with layered implementations is that they tend to be less efficient than other types. For instance, when a user program executes an I/O operation, it executes a system call that is trapped to the I/O layer, which calls the memory-management layer, which in turn calls the CPU-scheduling layer, which is then passed to the hardware.</p>
                </section>
                <section id="section-microkernels" class="module-section">
                    <h3>Microkernels</h3>
                    <p>üìö Content: The kernel became large and difficult to manage. In the mid-1980s, researchers at Carnegie Mellon University developed an operating system called Mach that modularized the kernel using the microkernel approach. This method structures the operating system by removing all nonessential components from the kernel and implementing them as system and user-level programs. The result is a smaller kernel. microkernels provide minimal process and memory management, in addition to a communication facility.</p>
                    <p>The main function of the microkernel is to provide a communication facility between the client program and the various services that are also running in user space. One benefit of the microkernel approach is ease of extending the operating system. All new services are added to user space and consequently do not require modification of the kernel. When the kernel does have to be modified, the changes tend to be fewer, because the microkernel is a smaller kernel.</p>
                    <p>The resulting operating system is easier to port from one hardware design to another. The microkernel also provides more security and reliability, since most services are running as user rather than kernel processes. If a service fails, the rest of the operating system remains untouched.</p>
                </section>
                <section id="section-modules" class="module-section">
                    <h3>Modules</h3>
                    <p>üìö Content: The best current methodology for operating-system design involves using object-oriented programming techniques to create a modular kernel. Here, the kernel has a set of core components and dynamically links in additional services either during boot time or during run time. Such a strategy uses dynamically loadable modules and is common in modern implementations of UNIX, such as Solaris, Linux, and Mac OS X.</p>
                    <figure>
                        <img src="../assets/images/module1-modules-structure.png" alt="Diagram of Modules Structure" width="400" height="300">
                        <figcaption>Figure 5: Modules Structure</figcaption>
                    </figure>
                    <p>A core kernel with seven types of loadable kernel modules:</p>
                    <ol>
                        <li>Scheduling classes</li>
                        <li>File systems</li>
                        <li>Loadable system calls</li>
                        <li>Executable formats</li>
                        <li>STREAMS modules</li>
                        <li>Miscellaneous</li>
                        <li>Device and bus drivers</li>
                    </ol>
                    <p>Such a design allows the kernel to provide core services yet also allows certain features to be implemented dynamically. The overall result resembles a layered system in that each kernel section has defined, protected interfaces; but it is more flexible than a layered system in that any module can call any other module. The approach is like the microkernel approach in that the primary module has only core functions and knowledge of how to load and communicate with other modules; but it is more efficient, because modules do not need to invoke message passing in order to communicate.</p>
                    <p>The Apple Macintosh Mac OS X operating system uses a hybrid structure. Mac OS X (also known as Danvin) structures the operating system using a layered technique where one layer consists of the Mach microkernel. The top layers include application environments and a set of services providing a graphical interface to applications. Below these layers is the kernel environment, which consists primarily of the Mach microkernel and the BSD kernel. Mach provides memory management; support for remote procedure calls (RPCs) and inter process communication (IPC) facilities, including message passing; and thread scheduling. The BSD component provides a BSD command line interface, support for networking and file systems, and an implementation of POSIX APIs, including Pthreads.</p>
                </section>
            </section>

            <section id="section-1-1-3" class="module-section">
                <h2>1.1.3 Operating-System Operations</h2>
                <ol>
                    <li>modern operating systems are interrupt driven. If there are no processes to execute, no I/O devices to service, and no users to whom to respond, an operating system will sit quietly, waiting for something to happen. Events are almost always signaled by the occurrence of an interrupt or a trap</li>
                    <li>A trap (or an exception) is a software-generated interrupt caused either by an error or by a specific request from a user program that an operating-system service is performed.</li>
                    <li>The interrupt-driven nature of an operating system defines that system's general structure. For each type of interrupt, separate segments of code in the operating system determine what action should be taken. An interrupt service routine is provided that is responsible for dealing with the interrupt.</li>
                    <li>The operating system and the users share the hardware and software resources of the computer system, we need to make sure that an error in a user program could cause problems only for the one program that was running. With sharing, many processes could be adversely affected by a bug in one program. For example, if a process gets stuck in an infinite loop, this loop could prevent the correct operation of many other processes.</li>
                    <li>Without protection against these sorts of errors, either the computer must execute only one process at a time or all output must be suspect.</li>
                </ol>
                <section id="section-dual-mode-operation" class="module-section">
                    <h3>Dual-Mode Operation</h3>
                    <p>Dual-mode operation allows OS to protect itself and other system components</p>
                    <p>User mode and kernel mode</p>
                    <p>Mode bit provided by hardware Provides ability to distinguish when system is running user code or kernel code Some instructions designated as privileged, only executable in kernel mode System call changes mode to kernel, return from call resets it to user</p>
                    <p>Transition from User to Kernel Mode</p>
                    <ul>
                        <li>Timer to prevent infinite loop / process hogging resources Set interrupt after specific period</li>
                        <li>Operating system decrements counter</li>
                        <li>When counter zero generate an interrupt</li>
                        <li>Set up before scheduling process to regain control or terminate program that exceeds allotted time</li>
                    </ul>
                    <figure>
                        <img src="../assets/images/module1-user-kernel-mode.png" alt="Diagram of User to Kernel Mode Transition" width="350" height="250">
                        <figcaption>Figure 6: User to Kernel Mode Transition</figcaption>
                    </figure>
                </section>
            </section>

            <section id="section-1-1-4" class="module-section">
                <h2>1.1.4 Protection and security</h2>
                <p>If a computer system has multiple users and allows the concurrent execution of multiple processes, then access to data must be regulated. For that purpose, mechanisms ensure that files, memory segments, CPU, and other resources can be operated on by only those processes that have gained proper authorization from the operating system.</p>
                <section id="section-protection" class="module-section">
                    <h3>Protection</h3>
                    <p>Protection is any mechanism for controlling the access of processes or users to the resources defined by a computer system. This mechanism must provide means for specification of the controls to be imposed and means for enforcement.</p>
                    <p>Protection can improve reliability by detecting latent errors at the interfaces between component subsystems. Early detection of interface errors can often prevent contamination of a healthy subsystem by another subsystem that is malfunctioning. An unprotected resource cannot defend against use (or misuse) by an unauthorized or incompetent user. A protection-oriented system provides a means to distinguish between authorized and unauthorized usage, A system can have adequate protection but still be prone to failure and allow inappropriate access.</p>
                </section>
                <section id="section-security" class="module-section">
                    <h3>Security</h3>
                    <p>It is the job of security to defend a system from external and internal attacks. Such attacks spread across a huge range and include viruses and worms, denial-of service attacks Protection and security require the system to be able to distinguish among all its users. Most operating systems maintain a list of user names and associated user identifiers (user IDs).</p>
                    <ul>
                        <li>User ID then associated with all files, processes of that user to determine access control</li>
                        <li>Group identifier (group ID) allows set of users to be defined and controls managed, then also associated with each process, file Privilege escalation allows user to change to effective ID with more rights</li>
                    </ul>
                </section>
            </section>

            <section id="section-1-1-5" class="module-section">
                <h2>1.1.5 Kernel Data Structures</h2>
                <p>üìö Content: The operating system must keep a lot of information about the current state of the system. As things happen within the system these data structures must be changed to reflect the current reality. For example, a new process might be created when a user logs onto the system. The kernel must create a data structure representing the new process and link it with the data structures representing all of the other processes in the system.</p>
                <p>Mostly these data structures exist in physical memory and are accessible only by the kernel and its subsystems. Data structures contain data and pointers, addresses of other data structures, or the addresses of routines. Taken all together, the data structures used by the Linux kernel can look very confusing. Every data structure has a purpose and although some are used by several kernel subsystems, they are more simple than they appear at first sight.</p>
                <p>Understanding the Linux kernel hinges on understanding its data structures and the use that the various functions within the Linux kernel makes of them. This section bases its description of the Linux kernel on its data structures. It talks about each kernel subsystem in terms of its algorithms, which are its methods of getting things done, and their usage of the kernel's data structures.</p>
            </section>

            <section id="section-1-1-6" class="module-section">
                <h2>1.1.6 Computing Environments</h2>
                <section id="section-traditional-computing" class="module-section">
                    <h3>Traditional Computing</h3>
                    <p>üìö Content: As computing matures, the lines separating many of the traditional computing environments are blurring. this environment consisted of PCs connected to a network, with servers providing file and print services. Terminals attached to mainframes were prevalent at many companies as well, with even fewer remote access and portability options.</p>
                    <p>The current trend is toward providing more ways to access these computing environments. Web technologies are stretching the boundaries of traditional computing. Companies establish portals, which provide web accessibility to their internal servers. Network computers are essentially terminals that understand web-based computing. Handheld computers can synchronize with PCs to allow very portable use of company information. Handheld PDAs can also connect to wireless networks to use the company's web portal.</p>
                    <p>Batch system processed jobs in bulk, with predetermined input. Interactive systems waited for input from users. To optimize the use of the computing resources, multiple users shared time on these systems. Time-sharing systems used a timer and scheduling algorithms to rapidly cycle processes through the CPU, giving each user a share of the resources.</p>
                </section>
                <section id="section-client-server-computing" class="module-section">
                    <h3>Client-Server Computing</h3>
                    <p>üìö Content: Designers have shifted away from centralized system architecture. Terminals connected to centralized systems are now being supplanted by PCs. Correspondingly, user interface functionality once handled directly by the centralized systems is increasingly being handled by the PCs. As a result, many of today‚Äôs systems acts as server systems to satisfy requests generated by client systems Server systems can be broadly categorized as compute servers and file servers:</p>
                    <ul>
                        <li>The compute-server system provides an interface to which a client can send a request to perform an action (for example, read data); in response, the server executes the action and sends back results to the client. A server running a database that responds to client requests for data is an example of such a system.</li>
                        <li>The file-server system provides a file-system interface where clients can create, update, read, and delete files. An example of such a system is a web server that delivers files to clients running web browsers.</li>
                    </ul>
                    <img src="../assets/images/module1-client-server-computing.png" alt="Diagram of Client-Server Computing" width="400" height="300">
                    <figcaption>Figure 7: Client-Server Computing</figcaption>
                </section>
                <section id="section-peer-to-peer-computing" class="module-section">
                    <h3>Peer-to-Peer Computing</h3>
                    <p>üìö Content: In this model, clients and servers are not distinguished from one another; instead, all nodes within the system are considered peers, and each may act as either a client or a server, depending on whether it is requesting or providing a service. Peer-to-peer systems offer an advantage over traditional client-server systems. In a client-server system, the server is a bottleneck; but in a peer-to-peer system, services can be provided by several nodes distributed throughout the network.</p>
                    <p>To participate in a peer-to-peer system, a node must first join the network of peers. Once a node has joined the network, it can begin providing services to‚Äîand requesting services from‚Äîother nodes in the network.</p>
                    <p>Determining what services are available is accomplished in one of two general ways:</p>
                    <ul>
                        <li>When a node joins a network, it registers its service with a centralized lookup service on the network. Any node desiring a specific service first contacts this centralized lookup service to determine which node provides the service. The remainder of the communication takes place between the client and the service provider.</li>
                        <li>A peer acting as a client must first discover what node provides a desired service by broadcasting a request for the service to all other nodes in the network. The node (or nodes) providing that service responds to the peer making the request. To support this approach, a discovery protocol must be provided that allows peers to discover services provided by other peers in the network.</li>
                    </ul>
                </section>
                <section id="section-web-based-computing" class="module-section">
                    <h3>Web-Based Computing</h3>
                    <p>üìö Content: The Web has become ubiquitous, leading to more access by a wider variety of devices than was dreamt of a few years ago. Web computing has increased the emphasis on networking. Devices that were not previously networked now include wired or wireless access. Devices that were networked now have faster network connectivity, provided by either improved networking technology, optimized network implementation code, or both.</p>
                    <p>The implementation of web-based computing has given rise to new categories of devices, such as load balancers, which distribute network connections among a pool of similar servers. Operating systems like Windows 95, which acted as web clients, have evolved into Linux and Windows XP, which can act as web servers as well as clients. Generally, the Web has increased the complexity of devices, because their users require them to be web-enabled.</p>
                </section>
            </section>

            <section id="section-1-1-7" class="module-section">
                <h2>1.1.7 Open-Source Operating Systems</h2>
                <ul>
                    <li>üìö Content: Operating systems made available in source-code format rather than just binary closed-source</li>
                    <li>Counter to the copy protection and Digital Rights Management (DRM) movement</li>
                    <li>Started by Free Software Foundation (FSF), which has ‚Äúcopy left‚Äù GNU Public License (GPL)</li>
                    <li>Examples include GNU/Linux, BSD UNIX (including core of Mac OS X), and Sun Solaris</li>
                </ul>
            </section>
        </main>
        <footer class="module-footer">
            <nav class="module-nav">
                <div class="nav-links">
                    <a href="../index.html" class="nav-button">
                        <span>‚Üê</span> Home
                    </a>
                    <a href="#" class="nav-button disabled">
                        <span>‚Üê</span> Previous
                    </a>
                    <div class="module-progress">
                        <span>Module 1 of 3</span>
                    </div>
                    <a href="module2.html" class="nav-button">
                        Next <span>‚Üí</span>
                    </a>
                </div>
            </nav>
        </footer>
    </article>
</body>
</html>
