<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>July 2017 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-7"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li id="active"><a href="july_2017.html" class="active no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="november_2017.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2016.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">July 2017</h1></header>
<article class="iDevice_wrapper textIdevice" id="id7">
<div class="iDevice emphasis0" >
<div id="ta7_129_2" class="block iDevice_content">
<div class="exe-text"><style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: July 2017</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following file allocation methods:</p>
<p>(i) contiguous;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Contiguous Allocation</strong>:</p>
<p>In <strong>contiguous allocation</strong>, each file occupies a set of <strong>adjacent blocks</strong> on the disk. The disk blocks are allocated to a file in a contiguous manner. This means that if a file requires 'n' blocks of disk space, then 'n' contiguous blocks are allocated to it. The disk address of the first block and the number of blocks allocated are recorded in the directory entry for that file. This method simplifies file access and provides good performance for sequential file access.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (2 marks)</h3>
<div class="question-content">
<p>(ii) linked.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Linked Allocation</strong>:</p>
<p>In <strong>linked allocation</strong>, each file is a <strong>linked list of disk blocks</strong>. The blocks allocated to a file may be scattered anywhere on the disk. Each block contains data and a pointer to the next block in the file. The directory entry for a file contains a pointer to the first block of the file. Following the pointers in each block leads to the subsequent blocks of the file. This method eliminates external fragmentation and allows files to grow dynamically, but it is less efficient for direct access due to the need to traverse the linked list.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (2 marks)</h3>
<div class="question-content">
<p>(b) Outline two approaches that could be used to improve computer file performance.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Disk Caching</strong>: Implementing <strong>disk caching</strong> can significantly improve file access performance. Disk caching uses a portion of main memory (RAM) to store frequently accessed file blocks. When a file is accessed, the system first checks the cache. If the data is found in the cache (cache hit), it is retrieved much faster from RAM than from the disk. This reduces the average access time and improves overall file system performance.</p>
<p data-number="2"><strong>File System Defragmentation</strong>: <strong>File system defragmentation</strong> reorganizes files on the disk to store them in contiguous blocks. Over time, files can become fragmented, meaning their blocks are scattered across the disk. Defragmentation reduces seek times because the disk head needs to move less to read a file. This leads to faster file access and improved file system performance, especially for frequently used files.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (3 marks)</h3>
<div class="question-content">
<p>(c) Four jobs were scheduled as follows: 7 minutes, 3 minutes, 5 minutes and 2 minutes. Compare the turnaround times using each of the following scheduling algorithms:</p>
<p>(i) Shortest Job First (SJF);</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Shortest Job First (SJF)</strong>:</p>
<p>Jobs in order of burst time: 2, 3, 5, 7 minutes.</p>
<p><strong>Gantt chart:</strong> [Job 4 (2)] [Job 2 (5)] [Job 3 (10)] [Job 1 (17)]</p>
<p><strong>Completion times:</strong></p>
<p>Job 4: 2 minutes</p>
<p>Job 2: 2 + 3 = 5 minutes</p>
<p>Job 3: 5 + 5 = 10 minutes</p>
<p>Job 1: 10 + 7 = 17 minutes</p>
<p><strong>Turnaround times (TAT)</strong> = Completion Time - Arrival Time (assuming arrival time is 0 for all jobs):</p>
<p>TAT (Job 4) = 2 minutes</p>
<p>TAT (Job 2) = 5 minutes</p>
<p>TAT (Job 3) = 10 minutes</p>
<p>TAT (Job 1) = 17 minutes</p>
<p><strong>Average Turnaround Time (SJF)</strong> = (2 + 5 + 10 + 17) / 4 = 34 / 4 = 8.5 minutes.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (3 marks)</h3>
<div class="question-content">
<p>(ii) First Come First Served (FCFS).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) First Come First Served (FCFS)</strong>:</p>
<p>Jobs in order of arrival: Job 1 (7), Job 2 (3), Job 3 (5), Job 4 (2) minutes.</p>
<p><strong>Gantt chart:</strong> [Job 1 (7)] [Job 2 (10)] [Job 3 (15)] [Job 4 (17)]</p>
<p><strong>Completion times:</strong></p>
<p>Job 1: 7 minutes</p>
<p>Job 2: 7 + 3 = 10 minutes</p>
<p>Job 3: 10 + 5 = 15 minutes</p>
<p>Job 4: 15 + 2 = 17 minutes</p>
<p><strong>Turnaround times (TAT)</strong> = Completion Time - Arrival Time (assuming arrival time is 0 for all jobs):</p>
<p>TAT (Job 1) = 7 minutes</p>
<p>TAT (Job 2) = 10 minutes</p>
<p>TAT (Job 3) = 15 minutes</p>
<p>TAT (Job 4) = 17 minutes</p>
<p><strong>Average Turnaround Time (FCFS)</strong> = (7 + 10 + 15 + 17) / 4 = 49 / 4 = 12.25 minutes.</p>
<p><strong>Comparison:</strong> The <strong>Shortest Job First (SJF)</strong> algorithm has a <strong>lower average turnaround time (8.5 minutes)</strong> compared to the <strong>First Come First Served (FCFS)</strong> algorithm (12.25 minutes) for these jobs. SJF is generally better at minimizing turnaround time when job burst times are known in advance.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Outline four computer files attributes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Name</strong>: The <strong>name</strong> is a human-readable identifier for the file, used to access and refer to the file within the file system. It's how users and applications identify a specific file. Naming conventions vary between operating systems, but typically include a base name and an extension.</p>
<p data-number="2"><strong>Type</strong>: The <strong>type</strong> of a file indicates its format and intended use. File types can be identified by extensions (e.g., .txt, .jpg, .exe) or internal file headers. The operating system and applications use the file type to determine how to process the file's contents. Common types include text files, executable files, image files, and directories.</p>
<p data-number="3"><strong>Location</strong>: The <strong>location</strong> attribute specifies where the file is stored within the directory structure of the file system. It is often represented as a path, indicating the sequence of directories to traverse to reach the file. The location is crucial for the operating system to find and access the file's data on the storage device.</p>
<p data-number="4"><strong>Size</strong>: The <strong>size</strong> attribute indicates the current amount of storage space occupied by the file, typically measured in bytes, kilobytes, megabytes, or gigabytes. The size reflects the quantity of data stored in the file and is important for managing storage space and understanding file resource usage.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (e) (4 marks)</h3>
<div class="question-content">
<p>(e) With the aid of a diagram in each case, describe two types of directory structures.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Single-Level Directory Structure</strong>:</p>
<p>In a <strong>single-level directory structure</strong>, there is only one directory for all files in the system. All files are placed in this single directory. This is the simplest directory structure.</p>
<p><strong>Diagram:</strong></p>
<pre>+-----------------------+
| Root Directory        |
+-----------------------+
| File A                |
| File B                |
| File C                |
| ...                   |
| File N                |
+-----------------------+
</pre>
<p><strong>Description:</strong> All files are contained within one directory. It is easy to implement but leads to naming conflicts if multiple users or applications need to use the same file name. It also becomes difficult to organize and manage a large number of files.</p>
<p><strong>(ii) Two-Level Directory Structure</strong>:</p>
<p>In a <strong>two-level directory structure</strong>, there is a master directory (root directory) and user directories under it. Each user has their own directory, and they can create files within their directory.</p>
<p><strong>Diagram:</strong></p>
<pre>+-----------------------+
| Root Directory        |
+-----------------------+
| User Directory 1      | --&gt; | File 1A | File 1B | ... |
| User Directory 2      | --&gt; | File 2A | File 2B | ... |
| User Directory 3      | --&gt; | File 3A | File 3B | ... |
| ...                   |
| User Directory N      | --&gt; | File NA | File NB | ... |
+-----------------------+
</pre>
<p><strong>Description:</strong> Each user has their own user directory in the root directory. This structure resolves naming conflicts as each user has a separate namespace for their files. However, it still lacks flexibility for users to create subdirectories to further organize their files.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (1 mark)</h3>
<div class="question-content">
<p>2. (a) (i) State two modes of operations of programmable clocks as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>One-Shot Mode</strong></p>
<p data-number="2"><strong>Square-Wave Mode</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Explain two duties of an I/O control system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Device Driver Management</strong>: The I/O control system is responsible for <strong>managing device drivers</strong>. Device drivers are software modules that interface with specific hardware devices. The I/O control system loads, initializes, and unloads device drivers as needed. It provides a standardized interface for the operating system to communicate with diverse hardware devices, abstracting away the hardware-specific details. This includes handling driver installation, configuration, and updates to ensure proper communication between the OS and hardware.</p>
<p data-number="2"><strong>I/O Request Handling and Scheduling</strong>: The I/O control system <strong>manages and schedules I/O requests</strong> from various processes. When a process initiates an I/O operation, the request is routed to the I/O control system. This system then queues and schedules these requests based on various algorithms (e.g., priority, FCFS, SSTF for disks) to optimize I/O performance and fairness. It ensures that I/O operations are performed in an efficient order, minimizing latency and maximizing throughput. The I/O control system also handles issues like buffering and caching to further improve I/O efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (i) (3 marks)</h3>
<div class="question-content">
<p>(b) A disk has 40 cylinders. An initial request comes in to read a block on cylinder 6. New requests come in for cylinder 1, 31, 11, 29, 4 and 7 in that order.</p>
<p>(i) Calculate the arm motions required using each of the following disk scheduling algorithms:</p>
<p>I. Shortest Seek First (SSF);</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>I. Shortest Seek First (SSF)</strong>:</p>
<p>Initial head position: 6. Requests: 1, 31, 11, 29, 4, 7.</p>
<p>Starting at 6, closest request is 7, then 4, then 1, then 11, then 29, then 31.</p>
<p>Seek sequence: 6 -&gt; 7 -&gt; 4 -&gt; 1 -&gt; 11 -&gt; 29 -&gt; 31.</p>
<p>Arm motions: |7-6| + |4-7| + |1-4| + |11-1| + |29-11| + |31-29|</p>
<p>= 1 + 3 + 3 + 10 + 18 + 2 = 37 cylinders.</p>
<p><strong>Arm motions for SSF: 37 cylinders.</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (i) (1 mark)</h3>
<div class="question-content">
<p>II. First Come First Served (FCFS);</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>II. First Come First Served (FCFS)</strong>:</p>
<p>Initial head position: 6. Requests in order: 1, 31, 11, 29, 4, 7.</p>
<p>Seek sequence: 6 -&gt; 1 -&gt; 31 -&gt; 11 -&gt; 29 -&gt; 4 -&gt; 7.</p>
<p>Arm motions: |1-6| + |31-1| + |11-31| + |29-11| + |4-29| + |7-4|</p>
<p>= 5 + 30 + 20 + 18 + 25 + 3 = 101 cylinders.</p>
<p><strong>Arm motions for FCFS: 101 cylinders.</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (i) (1 mark)</h3>
<div class="question-content">
<p>III. SCAN.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>III. SCAN (Elevator)</strong>:</p>
<p>Assuming SCAN moves towards cylinder 0 initially.</p>
<p>Initial head position: 6. Requests: 1, 31, 11, 29, 4, 7.</p>
<p>Moving towards 0: 6 -&gt; 4 -&gt; 1 -&gt; 0 (turnaround) -&gt; 7 -&gt; 11 -&gt; 29 -&gt; 31.</p>
<p>Seek sequence: 6 -&gt; 4 -&gt; 1 -&gt; 7 -&gt; 11 -&gt; 29 -&gt; 31.</p>
<p>Arm motions: |4-6| + |1-4| + |7-1| + |11-7| + |29-11| + |31-29|</p>
<p>= 2 + 3 + 6 + 4 + 18 + 2 = 35 cylinders.</p>
<p><strong>Arm motions for SCAN: 35 cylinders.</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (ii) (6 marks)</h3>
<div class="question-content">
<p>(ii) Represent graphically each of the disk scheduling algorithms in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Graphical Representation of Disk Scheduling Algorithms</strong>:</p>
<p><strong>I. Shortest Seek First (SSF) Gantt Chart:</strong></p>
<pre>Cylinder: 0---1---2---3---4---5---6---7---8---9---10--11---...---29---30--31---...---40
          |       |       |   Start-&gt;|-&gt;7-&gt;|-&gt;4-&gt;|-&gt;1---------|--------&gt;11----------------------&gt;29----&gt;31|
          +-------+-------+---------+-----+-----+-------------+------------------------------------+-----+
</pre>
<p><strong>II. First Come First Served (FCFS) Gantt Chart:</strong></p>
<pre>Cylinder: 0---1---2---3---4---5---6---7---8---9---10--11---...---29---30--31---...---40
          |-&gt;1----------------------------------------------------------------------------------------&gt;31|
          +--------------------------------------------------------------------------------------------+
          Start-&gt;6------------------------------------------------------------------------------------------&gt;7
                                  |--------------------&gt;11----------------------------------------&gt;29-|
                                  +---------------------+------------------------------------------+
                                                        |-----&gt;4------------------------------------|
                                                        +------+------------------------------------+
</pre>
<p><strong>III. SCAN (Elevator) Gantt Chart:</strong></p>
<pre>Cylinder: 0---1---2---3---4---5---6---7---8---9---10--11---...---29---30--31---...---40
          |-&gt;4-&gt;|-&gt;1-----------------------------------------&gt;7-&gt;|-&gt;11----------------------&gt;29----&gt;31|
          +-----+------+----------------------------------------+------+------------------------------------+
          Start-&gt;6------------------------------------------------------------------------------------------&gt;
</pre>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) A certain organization opted for a client-server model for its operating systems. Explain two advantages that could have influenced the choice.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Resource Sharing and Centralized Management</strong>: The client-server model facilitates <strong>efficient resource sharing</strong>. Servers can provide centralized access to resources such as files, databases, printers, and applications. This reduces redundancy and cost as resources are not duplicated on every client machine. Additionally, it allows for <strong>centralized management and administration</strong> of these resources. IT staff can manage, update, and secure resources from a central server location, simplifying maintenance and improving consistency across the organization.</p>
<p data-number="2"><strong>Improved Security and Scalability</strong>: Client-server architectures often offer <strong>enhanced security</strong>. Security measures can be concentrated on the server-side, making it easier to implement and enforce security policies. Access control, authentication, and data protection are managed centrally, reducing vulnerabilities at individual client machines. Furthermore, client-server systems are generally <strong>more scalable</strong>. As the organization grows, it is easier to add more clients without significantly impacting performance, and server resources can be upgraded or scaled to meet increasing demands. This scalability is crucial for long-term growth and adaptability.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (i) (1 mark)</h3>
<div class="question-content">
<p>(d) An IT professional designed an operating system consisting of several modules. Each module was designed on one below it.</p>
<p>(i) State the name given to the resultant structure after design.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Layered Structure</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (ii) (1 mark)</h3>
<div class="question-content">
<p>(ii) Outline one advantage of this structure.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Simplified Design and Development</strong>: A layered structure <strong>simplifies operating system design and development</strong> by breaking down the system into smaller, more manageable modules or layers. Each layer provides specific services and relies only on the layer below it. This modularity allows developers to focus on implementing and debugging individual layers independently, making the development process more organized and less complex. Changes in one layer are less likely to affect other layers, promoting easier maintenance and updates.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>3. (a) (i) Describe the terms relocating loader as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Relocating Loader</strong>:</p>
<p>A <strong>relocating loader</strong> is a type of loader that can load program code and data into <strong>any available region of memory</strong>. Unlike absolute loaders which require programs to be loaded at a specific memory address, a relocating loader adjusts the program's addresses (both code and data addresses) during loading so that it can run correctly regardless of its actual load address. This is crucial for multiprogramming and dynamic memory management, allowing programs to be loaded into different memory locations each time they are executed, improving memory utilization and flexibility.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (ii) (6 marks)</h3>
<div class="question-content">
<p>(ii) With the aid of a diagram in each case explain the effect of double buffering as compared to single buffering data transfer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Double Buffering vs. Single Buffering Data Transfer</strong>:</p>
<p><strong>Single Buffering</strong>:</p>
<p>In <strong>single buffering</strong>, only <strong>one buffer</strong> is used in system memory for data transfer between an I/O device and the process. The process must wait until the buffer is filled (for input) or emptied (for output) before it can continue processing or initiate another I/O operation. During data transfer, the CPU might be idle, waiting for I/O to complete. This can lead to performance bottlenecks, especially if I/O operations are slow.</p>
<p><strong>Diagram of Single Buffering:</strong></p>
<pre>+---------+     +---------+     +---------+
|  Device | --&gt; |  Buffer | --&gt; | Process |
+---------+     +---------+     +---------+
     Data In          Processing
       |                |
       +----------------+ (Wait Time for Process during I/O)
</pre>
<p><strong>Double Buffering</strong>:</p>
<p>In <strong>double buffering</strong>, <strong>two buffers</strong> are used. While one buffer is being filled by the I/O device (for input) or emptied by the process (for output), the process (or device) can simultaneously work with the other buffer. This allows for <strong>overlapping of I/O operations with processing</strong>, reducing the wait time and improving throughput. While the process is processing data in one buffer, the next block of data can be transferred into the other buffer, and vice versa. This technique minimizes CPU idle time due to I/O waits.</p>
<p><strong>Diagram of Double Buffering:</strong></p>
<pre>          +---------+     +---------+
Device 1 --&gt;| Buffer 1| --&gt; | Process |
          +---------+     +---------+
               ^             | Processing data from Buffer 1
               |
          +---------+     +---------+
Device 2 --&gt;| Buffer 2|     |         |
          +---------+     +---------+
             Filling Buffer 2 (Simultaneous I/O)
</pre>
<p><strong>Effect Comparison:</strong></p>
<p><strong>Single buffering</strong> leads to <strong>alternating periods of I/O and processing</strong>, with CPU often idle during I/O. <strong>Double buffering</strong> enables <strong>concurrent I/O and processing</strong>, significantly reducing CPU idle time and increasing data transfer rates and overall system efficiency by overlapping operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (i) (1 mark)</h3>
<div class="question-content">
<p>(b) Mary's printer has a device that intercepts data sent to it, stores the data in disk files and manages the printing when convenient for the system.</p>
<p>(i) Name the device that Mary had installed in her printer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Spooler</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (ii) (3 marks)</h3>
<div class="question-content">
<p>(ii) Outline three advantages she would get from the device identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Improved System Throughput</strong>: A spooler <strong>improves system throughput</strong> by allowing processes to quickly output data to be printed without waiting for the actual printing to complete. The data is spooled to disk or memory, and the process can continue with other tasks. Printing occurs in the background, managed by the spooler, thus freeing up the CPU and application processes to perform other operations concurrently. This concurrent operation significantly increases overall system efficiency.</p>
<p data-number="2"><strong>Printer Resource Management</strong>: A spooler effectively <strong>manages printer resources</strong>, especially in a shared environment. It can handle multiple print jobs from different users or processes, queuing them and printing them in an orderly fashion. This prevents print jobs from interfering with each other and ensures fair access to the printer. The spooler can also prioritize print jobs, handle printer errors, and provide status information about print queues, making printer usage more organized and efficient.</p>
<p data-number="3"><strong>Support for Delayed and Scheduled Printing</strong>: Spooling allows for <strong>delayed or scheduled printing</strong>. Users can submit print jobs even when the printer is busy or unavailable, and the spooler will store these jobs and print them when the printer becomes free or at a scheduled time. This is particularly useful for large print jobs or for printing during off-peak hours to reduce system load during busy periods. It provides flexibility in managing print tasks and optimizes printer usage based on system load and user needs.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (2 marks)</h3>
<div class="question-content">
<p>(c) Explain the function of job control language as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Job Control Language (JCL) Function</strong>:</p>
<p>The <strong>Job Control Language (JCL)</strong> serves as a <strong>command language</strong> used primarily in batch processing systems to <strong>instruct the operating system on how to run a batch job</strong>. JCL defines the sequence of operations, the programs to be executed, the input and output data sets, and the resources required for a job. It acts as an interface between the user or application and the operating system, specifying all necessary details for the OS to execute a series of tasks automatically without user intervention during processing. JCL enables automation of complex workflows and efficient batch processing.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (6 marks)</h3>
<div class="question-content">
<p>(d) A certain organization bought a new system for its file systems. Explain three considerations that could be put in place with regard to their file management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Data Backup and Recovery Strategy</strong>: A crucial consideration is establishing a robust <strong>data backup and recovery strategy</strong>. This involves regular backups of important files and file system metadata to a separate storage medium. The backup strategy should include scheduling (frequency of backups), selection of data to be backed up, and backup methods (e.g., full, incremental, differential). A well-defined recovery plan is equally important, outlining procedures for restoring data in case of data loss due to hardware failure, software errors, or human mistakes. Regular testing of the recovery process is essential to ensure its effectiveness.</p>
<p data-number="2"><strong>File System Security and Access Control</strong>: Implementing strong <strong>file system security and access control mechanisms</strong> is vital. This includes setting appropriate file permissions and access rights to control who can access, modify, or delete files and directories. Access control should be based on the principle of least privilege, granting users only the necessary permissions for their tasks. Security considerations should also include protection against unauthorized access, malware, and data breaches. Regular security audits and updates are necessary to maintain file system integrity and confidentiality.</p>
<p data-number="3"><strong>File System Organization and Structure</strong>: Careful <strong>planning of file system organization and structure</strong> is important for efficient file management and user accessibility. This involves designing a logical directory hierarchy that is intuitive and easy to navigate for users. Consistent naming conventions for files and directories should be established to improve file findability and organization. The structure should be scalable to accommodate future data growth and organizational changes. A well-organized file system enhances productivity, simplifies file retrieval, and reduces administrative overhead.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>4. (a) (i) Define the term virtual memory as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Virtual Memory</strong>:</p>
<p><strong>Virtual memory</strong> is a memory management technique that <strong>allows processes to execute even if they are not entirely loaded into physical memory</strong>. It creates an illusion of a larger memory space than physically available RAM by using disk space as an extension of RAM. Virtual memory works by swapping pages (blocks of virtual memory) between RAM and disk. This technique enables the execution of programs larger than physical memory and improves the degree of multiprogramming.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (ii) (3 marks)</h3>
<div class="question-content">
<p>(ii) Consider an executing process P that issues I/O request. The processes temporarily stopped. At some later point, a disk interrupt occurs and the driver detects that P's request is satisfied. At some later time, the operating system looks for a job to run and picks P. With the aid of diagrams outline these process states.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Process State Transitions for I/O Request:</strong></p>
<p><strong>Initial State: Running</strong> - Process P is initially in the <strong>running state</strong>, executing on the CPU.</p>
<p><strong>Diagram 1: Running State</strong></p>
<pre>+---------+
| Running | &lt;--- Process P executing
+---------+
</pre>
<p><strong>Transition 1: Blocked/Waiting State</strong> - When Process P issues an I/O request, it transitions to the <strong>blocked (or waiting) state</strong>. It is no longer using the CPU and is waiting for the I/O operation to complete.</p>
<p><strong>Diagram 2: Blocked State</strong></p>
<pre>+---------+      I/O Request
| Running | --------&gt; +---------+
+---------+          | Blocked | &lt;--- Process P waiting for I/O
                       +---------+
</pre>
<p><strong>Transition 2: Ready State</strong> - Upon completion of the I/O request and processing of the disk interrupt, Process P becomes ready to run again. It transitions from the blocked state to the <strong>ready state</strong>, waiting to be scheduled on the CPU.</p>
<p><strong>Diagram 3: Ready State</strong></p>
<pre>+---------+   I/O Complete   +---------+
| Blocked | ----------&gt; |  Ready  | &lt;--- Process P ready to run, waiting for CPU
+---------+              +---------+
</pre>
<p><strong>Transition 3: Running State (again)</strong> - Eventually, the operating system scheduler selects Process P from the ready queue to run on the CPU. Process P transitions back to the <strong>running state</strong>.</p>
<p><strong>Diagram 4: Running State (Resumed)</strong></p>
<pre>+---------+   Scheduled by OS   +---------+
|  Ready  | -----------------&gt; | Running | &lt;--- Process P resumes execution
+---------+                     +---------+
</pre>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Figure 1 shows file system architecture of a certain organization.</p>
<p><img src="Screenshot_2025-03-12_at_12-10-10_2017july.pdf.png" alt="" width="718" height="368" /></p>
<p>Use it to answer the question that follows.</p>
<p>(b) Outline the function of each of the parts marked (i), (ii), (iii) and (iv).</p>
<p><img src="paperpaper-003.png" alt="Figure 1" /></p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) User Program</strong>:</p>
<p>The <strong>User Program</strong> is the <strong>application or software being executed by the user</strong>. It is at the highest level of the file system architecture and interacts with the file system to perform file operations such as creating, reading, writing, and deleting files. The user program makes system calls to request file system services. It represents the interface through which users or applications interact with the file system.</p>
<p><strong>(ii) Logical File System</strong>:</p>
<p>The <strong>Logical File System</strong> layer is responsible for <strong>interpreting file operations</strong> requested by the user program. It manages the directory structure, file naming, and file metadata (attributes). This layer translates logical file operations (like 'open file by name') into a series of lower-level operations that the file organization module can understand. It deals with logical file and directory structures, access control, and file system integrity from a logical perspective.</p>
<p><strong>(iii) File Organization Module</strong>:</p>
<p>The <strong>File Organization Module</strong> (or File System Implementation) is responsible for <strong>mapping logical file blocks to physical blocks on the storage device</strong>. It manages the physical storage space, block allocation, and free space management. This layer implements the file allocation method (e.g., contiguous, linked, indexed) and translates logical block addresses into physical disk addresses. It also handles buffering and caching to optimize disk I/O. This module is the bridge between the logical view of files and the physical storage.</p>
<p><strong>(iv) Basic I/O Supervisor</strong>:</p>
<p>The <strong>Basic I/O Supervisor</strong> (or I/O Control Layer) is the <strong>lowest layer of the file system architecture</strong> that directly interacts with the hardware. It is responsible for <strong>initiating and controlling physical I/O operations</strong>. This layer includes device drivers that communicate with specific disk controllers. It handles the physical transfer of data between memory and the disk, manages I/O channels, and controls the hardware-level operations required to read and write data to the storage device. It provides a hardware-independent interface for the higher file system layers.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Differentiate between monoprogramming and multiprogramming as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Monoprogramming</strong>:</p>
<p><strong>Monoprogramming</strong> is an operating system approach where <strong>only one program can reside in main memory and execute at a time</strong>. When a program is running, it has exclusive control of all system resources, including the CPU, memory, and I/O devices. No other program can be executed until the current program completes. This is a simpler form of operating system, but it leads to <strong>low CPU utilization</strong>, as the CPU often sits idle while the running program is waiting for I/O operations to complete. Throughput is low, and response time can be poor, especially for interactive applications.</p>
<p><strong>Multiprogramming</strong>:</p>
<p><strong>Multiprogramming</strong> is an operating system technique that allows <strong>multiple programs to reside in main memory simultaneously</strong>. The operating system keeps several programs in memory and switches between them to keep the CPU busy. When one program is waiting for an I/O operation, the CPU can switch to another program that is ready to execute. This significantly <strong>improves CPU utilization and system throughput</strong>. Multiprogramming enhances system efficiency by overlapping CPU and I/O operations, leading to better resource utilization and improved responsiveness compared to monoprogramming. It is the basis for modern operating systems.</p>
<p><strong>Key Difference:</strong> Monoprogramming executes one program at a time, leading to idle CPU time, while multiprogramming allows multiple programs to reside in memory and share the CPU, improving CPU utilization and throughput.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>(d) (i) Explain the term starvation as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Starvation in Operating Systems</strong>:</p>
<p><strong>Starvation</strong> in operating systems refers to a situation where a <strong>process is indefinitely denied access to the resources it needs to make progress</strong>, even though the resources are available. This typically occurs in priority scheduling systems where high-priority processes continuously monopolize resources, preventing low-priority processes from ever getting a chance to run or acquire necessary resources. Starvation is a severe form of unfairness and can lead to critical processes being unable to complete, degrading system performance and responsiveness.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (ii) (5 marks)</h3>
<div class="question-content">
<p>(ii) With the aid of a diagram, describe a direct memory access operation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Direct Memory Access (DMA) Operation</strong>:</p>
<p><strong>DMA</strong> is a hardware mechanism that allows <strong>I/O devices to transfer data directly to or from main memory without involving the CPU for every byte transferred</strong>. This significantly reduces CPU overhead and improves the efficiency of data transfers, especially for large blocks of data.</p>
<p><strong>Diagram of DMA Operation:</strong></p>
<pre>+---------+     +----------+     +----------+
|  Device | ----&gt; | DMA      | ----&gt; | Memory   |
+---------+     | Controller|     +----------+
      Request      +----------+         Data Transfer
          ^             | Control Signals
          |             V
          +----------+
          |   CPU    |
          +----------+
            Initialize DMA, Start Transfer
            Interrupt upon Completion
</pre>
<p><strong>Steps in DMA Operation:</strong></p>
<p data-number="1"><strong>CPU Initialization</strong>: The CPU initiates the DMA transfer by <strong>configuring the DMA controller</strong>. It provides the DMA controller with details such as the source address (device buffer), destination address (memory location), the amount of data to be transferred, and the direction of transfer (read or write).</p>
<p data-number="2"><strong>DMA Request</strong>: The I/O device requests a data transfer through the DMA controller.</p>
<p data-number="3"><strong>Bus Grant</strong>: The DMA controller requests control of the system bus from the CPU. Once the CPU grants the bus, the DMA controller becomes the bus master for the duration of the data transfer.</p>
<p data-number="4"><strong>Data Transfer</strong>: The DMA controller directly transfers data between the I/O device and main memory, <strong>bypassing the CPU for each byte transfer</strong>. The DMA controller manages the address and control lines to perform the data transfer in blocks.</p>
<p data-number="5"><strong>Transfer Completion</strong>: Once the data transfer is complete, the DMA controller signals the CPU via an <strong>interrupt</strong>. The CPU is then notified that the data transfer is finished and can proceed with processing the data.</p>
<p><strong>Effect:</strong> DMA operation significantly offloads the CPU from handling byte-by-byte data transfers, allowing the CPU to perform other processing tasks concurrently during I/O operations. This results in faster data transfer rates and improved system performance, especially for high-bandwidth I/O devices.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (2 marks)</h3>
<div class="question-content">
<p>5. (a) State two purposes of device drivers as used in a computer operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Hardware Abstraction</strong>: Device drivers provide a <strong>hardware abstraction layer</strong>. They hide the complexities and specific details of hardware devices from the operating system kernel and application software. Drivers offer a uniform interface for the OS to interact with different types of hardware, regardless of their manufacturer or model. This abstraction simplifies OS development and makes the system more portable, as the OS does not need to be rewritten for every new device.</p>
<p data-number="2"><strong>Device Communication and Control</strong>: Device drivers are responsible for <strong>enabling communication and control of hardware devices</strong>. They contain the specific code and instructions needed to send commands to devices, receive data from them, and handle device-specific operations. Drivers act as translators, converting generic OS requests into device-specific commands and interpreting device responses. They manage the interaction protocols and timing requirements of hardware devices, ensuring correct and efficient operation.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) (i) Outline two operations that could be used to implement a semaphore.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Wait (or P or Acquire) Operation</strong>: The <strong>wait operation</strong>, often denoted as `wait(S)` or `P(S)`, is used to <strong>decrement the semaphore value</strong>. If the semaphore value becomes negative after decrementing, the process executing the wait operation is blocked (put to sleep) and added to the semaphore's waiting queue. The wait operation is used to acquire or request access to a resource protected by the semaphore. It ensures that a process waits until the resource is available (semaphore value is positive).</p>
<p data-number="2"><strong>Signal (or V or Release) Operation</strong>: The <strong>signal operation</strong>, often denoted as `signal(S)` or `V(S)`, is used to <strong>increment the semaphore value</strong>. If there are processes blocked in the semaphore's waiting queue, one of them is unblocked (woken up) and moved to the ready queue. The signal operation is used to release a resource that was being held and to notify waiting processes that the resource might be available. It allows processes to proceed after a resource has been released.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (ii) (6 marks)</h3>
<div class="question-content">
<p>(ii) Describe three requirements for critical section problem as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Mutual Exclusion</strong>: <strong>Mutual exclusion</strong> is a primary requirement. It dictates that <strong>only one process can be inside its critical section at any given time</strong>. If one process is executing in its critical section, no other process is allowed to enter its critical section. This is essential to prevent race conditions and data inconsistency when multiple processes access shared resources. Mutual exclusion ensures that access to shared resources is serialized and controlled, maintaining data integrity.</p>
<p data-number="2"><strong>Progress</strong>: <strong>Progress</strong> ensures that if no process is executing in its critical section and some processes wish to enter their critical sections, then <strong>only those processes that are not in their remainder sections can participate in deciding which will enter its critical section next</strong>, and this selection cannot be postponed indefinitely. In simpler terms, if no process is in a critical section and some processes want to enter, one of them should be able to enter without waiting indefinitely. Progress avoids deadlock or indefinite postponement in entering critical sections.</p>
<p data-number="3"><strong>Bounded Waiting</strong>: <strong>Bounded waiting</strong> requires that there must be a <strong>limit on the number of times other processes can enter their critical sections after a process has made a request to enter its critical section and before that request is granted</strong>. This means no process should face starvation. There should be a guarantee that each process will eventually get to enter its critical section within a bounded amount of time, preventing indefinite delay. Bounded waiting ensures fairness and prevents any process from being perpetually blocked from accessing the critical section.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Differentiate between first fit and next fit dynamic partitioning algorithms.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>First Fit</strong>:</p>
<p><strong>First Fit</strong> is a dynamic memory allocation algorithm that <strong>allocates the first available partition (hole) in memory that is large enough to satisfy the request</strong>. When searching for a free partition, First Fit starts from the beginning of the memory or the list of free partitions and stops as soon as it finds a partition that is large enough. It then allocates the required memory from this partition, potentially splitting the partition if it's larger than needed. First Fit is simple to implement and generally fast for allocation, but it can lead to fragmentation, particularly external fragmentation, and may create many small partitions at the beginning of memory.</p>
<p><strong>Next Fit</strong>:</p>
<p><strong>Next Fit</strong> is similar to First Fit but starts its search for a free partition from the <strong>location where the previous allocation ended</strong>, rather than always starting from the beginning of memory. It keeps track of the last partition allocated and begins searching for the next available partition from that point onwards, wrapping around to the beginning if necessary. Next Fit aims to distribute allocations more evenly across memory, potentially reducing clustering of allocations at the beginning. However, it can also lead to fragmentation and might not always find the best fitting partition, potentially resulting in slightly worse memory utilization compared to First Fit in some scenarios. Next Fit is also relatively simple to implement.</p>
<p><strong>Key Difference:</strong> First Fit always starts searching for a free partition from the beginning of memory, while Next Fit starts its search from the location of the last allocation. Next Fit aims to improve allocation distribution across memory compared to First Fit.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (6 marks)</h3>
<div class="question-content">
<p>(d) An operating system uses detection and recovery methods to deal with possible deadlocks. Explain three criteria that could be used when selecting processes to abort in such an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Process Priority</strong>: <strong>Process priority</strong> can be a criterion for selecting processes to abort. In a priority-based system, it may be more beneficial to <strong>abort lower-priority processes</strong> to resolve a deadlock. Aborting high-priority processes can have more significant consequences, affecting critical system operations or user-critical tasks. By choosing to terminate lower-priority processes, the system aims to minimize the impact on overall system functionality and user experience, preserving the execution of more important tasks.</p>
<p data-number="2"><strong>Process Execution Time/Progress</strong>: The <strong>execution time or progress</strong> of a process can be considered. Processes that have <strong>consumed less CPU time or made less progress</strong> towards completion might be preferable candidates for abortion. Aborting processes that are early in their execution or have not performed much work results in less wasted computation compared to aborting processes that are close to completion or have already performed significant tasks. This criterion aims to minimize the loss of computational effort due to process termination.</p>
<p data-number="3"><strong>Resources Held by Process</strong>: The <strong>number and type of resources held by a process</strong> can influence the selection for abortion. Processes holding <strong>fewer resources or resources that are easily preemptible or less critical</strong> might be chosen for termination. Aborting a process that holds many resources or critical resources can lead to cascading aborts and system instability. Selecting processes holding fewer and less critical resources aims to minimize resource wastage and disruption to other processes. The type of resources (e.g., exclusive locks, shared resources) also plays a role in the decision.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (3 marks)</h3>
<div class="question-content">
<p>6. (a) Outline three functions of a memory manager as used in computers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Memory Allocation and Deallocation</strong>: The memory manager is responsible for <strong>allocating memory to processes when they need it and deallocating memory when processes no longer require it</strong>. This includes keeping track of available memory space, selecting suitable memory blocks for allocation, and reclaiming memory when processes terminate or release memory. Efficient allocation and deallocation are crucial for managing system resources and supporting multiprogramming.</p>
<p data-number="2"><strong>Memory Protection</strong>: The memory manager ensures <strong>memory protection</strong>, preventing processes from accessing memory regions that do not belong to them. This is vital for system stability and security, as it prevents one process from corrupting the memory of another process or the operating system itself. Memory protection mechanisms include techniques like base and limit registers, segmentation, and paging, which define and enforce memory access boundaries for each process.</p>
<p data-number="3"><strong>Virtual Memory Management</strong>: In systems with virtual memory, the memory manager <strong>implements and manages the virtual memory system</strong>. This involves handling page faults, swapping pages between RAM and disk, and maintaining page tables that translate virtual addresses to physical addresses. Virtual memory management allows processes to use more memory than physically available, improving memory utilization and enabling the execution of larger programs. It also handles memory sharing and protection in a virtualized environment.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) (i) State two primitive system calls used in message passing.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Send (message)</strong>: The <strong>send</strong> system call is used by a process to <strong>transmit a message to another process or processes</strong>. It typically involves specifying the destination process (or process group) and the message data. The send operation may be synchronous (blocking) or asynchronous (non-blocking), depending on the communication semantics. It is a fundamental operation for inter-process communication using message passing.</p>
<p data-number="2"><strong>Receive (message)</strong>: The <strong>receive</strong> system call is used by a process to <strong>receive a message</strong>. It typically involves specifying a source process (or allowing messages from any source) and providing a buffer to store the received message. Like send, receive can be synchronous or asynchronous. When synchronous, the receiving process blocks until a message arrives. Receive is the counterpart to send, enabling processes to exchange information via messages.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) A system administrator of a certain organization is contemplating using monitors as inter-process communication method. Explain two challenges the administrator is likely to face.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Complexity in Nested Monitor Calls</strong>: One challenge is the <strong>complexity in handling nested monitor calls</strong>. If a process within a monitor calls another monitor (nested call), it can lead to complications, particularly with respect to mutual exclusion and condition variables. Improperly managed nested monitor calls can potentially lead to deadlocks or unexpected behavior if not carefully designed and implemented. Ensuring correct synchronization and avoiding deadlocks in nested monitor scenarios requires careful consideration of monitor entry and exit protocols and condition variable usage.</p>
<p data-number="2"><strong>Potential for Priority Inversion</strong>: <strong>Priority inversion</strong> can be a challenge when using monitors in priority-based systems. If a high-priority process is blocked waiting to enter a monitor that is currently held by a low-priority process, and if medium-priority processes preempt the low-priority process, the high-priority process can be effectively blocked by medium-priority processes, violating priority order. While monitors provide mutual exclusion, they do not inherently prevent priority inversion, and additional mechanisms (like priority inheritance or priority ceiling protocols) might be needed to mitigate this issue and ensure predictable priority behavior.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (i) (5 marks)</h3>
<div class="question-content">
<p>(c) Process A of capacity 15k was running in the memory, and then processes B of capacity 20k and C of capacity 35k are created. Later process A terminates and is swapped out of memory to disk. Then process D of capacity 10k is created and then process B is swapped out of memory to disk. Then process E of capacity 18k is created. The total memory capacity is 75k.</p>
<p>(i) Use sketches to illustrate this memory allocation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Memory Allocation Sketches:</strong></p>
<p><strong>Initial State: Process A (15k) Running</strong></p>
<pre>+---------------------+
| Process A (15k)     |
+---------------------+
| Free Memory (60k)   |
+---------------------+
Total: 75k
</pre>
<p><strong>Step 1: Processes B (20k) and C (35k) Created</strong> (assuming First-Fit and sufficient contiguous space)</p>
<pre>+---------------------+
| Process A (15k)     |
+---------------------+
| Process B (20k)     |
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
</pre>
<p><strong>Step 2: Process A Terminates and Swapped Out</strong> (Memory becomes free where A was)</p>
<pre>+---------------------+
| Free Memory (15k)   |  &lt;-- Space freed by A
+---------------------+
| Process B (20k)     |
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
</pre>
<p><strong>Step 3: Process D (10k) Created</strong> (allocated in the first available free space)</p>
<pre>+---------------------+
| Process D (10k)     |  &lt;-- Process D allocated in first 10k of free space
+---------------------+
| Free Memory (5k)    |  &lt;-- Remaining from the 15k block
+---------------------+
| Process B (20k)     |
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
</pre>
<p><strong>Step 4: Process B Swapped Out</strong> (Memory becomes free where B was)</p>
<pre>+---------------------+
| Process D (10k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
| Free Memory (20k)   |  &lt;-- Space freed by B
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
</pre>
<p><strong>Step 5: Process E (18k) Created</strong> (allocated in the contiguous free space of 20k)</p>
<pre>+---------------------+
| Process D (10k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
| Process E (18k)     |  &lt;-- Process E allocated in the 20k block
+---------------------+
| Free Memory (2k)    |  &lt;-- Remaining from the 20k block
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
</pre>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) Explain the state that the final memory would have.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Final Memory State</strong>:</p>
<p>The final memory state shows <strong>fragmentation</strong>. We have <strong>Process D (10k)</strong>, followed by <strong>5k of free memory</strong>, then <strong>Process E (18k)</strong>, <strong>2k of free memory</strong>, <strong>Process C (35k)</strong>, and finally another <strong>5k of free memory</strong>. The total free memory is 5k + 2k + 5k = 12k, which is <strong>scattered into three non-contiguous blocks</strong>. This state illustrates <strong>external fragmentation</strong>, where sufficient total free memory exists (12k) but it is not contiguous, potentially making it difficult to allocate larger processes that require contiguous memory blocks, even though the total available memory is adequate.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Mary an IT expert would like to design an operating system for I/O devices. Explain two issues that she could put into consideration.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Device Diversity and Heterogeneity</strong>: A major issue is the <strong>diversity and heterogeneity of I/O devices</strong>. Operating systems need to support a wide range of I/O devices, from keyboards and mice to disks, network interfaces, and specialized sensors. These devices vary greatly in their characteristics (speed, data transfer methods, control interfaces, protocols). Mary needs to design the OS to accommodate this diversity through modular device drivers that can be easily added or updated to support new devices. The OS must provide a consistent and abstract interface for applications to interact with these diverse devices, hiding the hardware-specific details.</p>
<p data-number="2"><strong>Performance and Efficiency of I/O Operations</strong>: <strong>Performance and efficiency of I/O operations</strong> are critical. I/O operations are often the bottleneck in computer systems, especially with increasing data volumes and real-time requirements. Mary must consider efficient I/O management techniques, such as buffering, caching, DMA, and I/O scheduling algorithms, to minimize I/O latency and maximize throughput. The OS design should aim to overlap I/O operations with CPU processing to improve overall system performance. Efficient handling of interrupts, device polling, and data transfer mechanisms are essential for achieving high I/O performance in the operating system.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>7. (a) Explain each of the following terms as used in operating systems.</p>
<p>(i) compaction;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Compaction</strong>:</p>
<p><strong>Compaction</strong> is a memory management technique used to <strong>reduce external fragmentation</strong>. It involves <strong>rearranging the processes in memory</strong> so that all free memory is contiguous in one large block. This is achieved by moving all allocated blocks to one end of memory, leaving all free blocks together in a single block at the other end. Compaction makes it possible to allocate larger contiguous blocks of memory to processes that could not be allocated before due to fragmentation, even if the total amount of free memory was sufficient.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) overlaying.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Overlaying</strong>:</p>
<p><strong>Overlaying</strong> is a memory management technique used in older systems to <strong>enable a program to be larger than the amount of memory allocated to it</strong>. It works by dividing the program into logical units called overlays. Only the overlays currently needed are kept in memory; when a different overlay is needed, it replaces the current one in memory. Overlaying requires manual programming effort to divide the program and manage overlays, and it is less common in modern systems with virtual memory.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (i) (3 marks)</h3>
<div class="question-content">
<p>(b) (i) State three conditions that could cause a program running in a computer to terminate.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Normal Completion</strong>: A program terminates upon <strong>normal completion</strong> when it has <strong>executed all its instructions successfully</strong> and reaches its natural end point. This is the intended and expected termination scenario where the program finishes its task without errors or external interruptions. The program may explicitly terminate itself using an exit system call, or it may implicitly terminate when it reaches the end of its main execution flow.</p>
<p data-number="2"><strong>Voluntary Termination due to Error</strong>: A program may terminate <strong>voluntarily due to an error condition</strong> it encounters during execution. This occurs when the program detects an error it cannot recover from, such as invalid input, file not found, or resource allocation failure. In such cases, the program may decide to terminate itself gracefully to prevent further erroneous operations or system instability. The program typically reports the error condition before terminating.</p>
<p data-number="3"><strong>Involuntary Termination by Operating System</strong>: A program can be <strong>involuntarily terminated by the operating system</strong> due to various reasons. These include fatal errors like segmentation faults (memory access violations), illegal instructions, time limit exceeded, or system crashes. The operating system may terminate a program to protect system integrity, prevent resource hogging, or in response to external signals (e.g., user-initiated termination, process kill command). Involuntary termination is often a result of unrecoverable errors or system-level policies.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) State one scheduling goal that could be achieved in each of the following systems;</p>
<p>I. batch systems;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>I. Batch Systems</strong>:</p>
<p><strong>Maximize throughput</strong> is a primary scheduling goal in batch systems. The objective is to process as many jobs as possible in a given amount of time. Batch systems are designed for high-volume, non-interactive job processing, and maximizing the number of completed jobs (throughput) is a key metric for efficiency. Minimizing turnaround time and maximizing resource utilization also contribute to achieving high throughput.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>II. real time systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>II. Real Time Systems</strong>:</p>
<p><strong>Meeting deadlines</strong> is a critical scheduling goal in real-time systems. Real-time systems must respond to events within strict time constraints. The primary goal is to ensure that tasks are completed before their deadlines to guarantee system correctness and responsiveness. Scheduling algorithms in real-time systems prioritize tasks based on their deadlines and timing requirements to ensure timely execution and prevent deadline misses, which could lead to system failure.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) Table 1 show two concurrent processes P1 and P2 and their timed I/O requests. Use it to answer the question that follows.</p>
<p><strong>Table 1</strong></p>
<table>
<thead>
<tr>
<th>Time</th>
<th>P1</th>
<th>P2</th>
</tr>
</thead>
<tbody>
<tr>
<td data-label="Time">1</td>
<td data-label="P1">Request R1</td>
<td data-label="P2">Request R2</td>
</tr>
<tr>
<td data-label="Time">2</td>
<td data-label="P1">Request R2</td>
<td data-label="P2">Request R1</td>
</tr>
<tr>
<td data-label="Time">3</td>
<td data-label="P1">Release R1</td>
<td data-label="P2">Release R2</td>
</tr>
</tbody>
</table>
<p>Draw the resource allocation graph for these possible executions of the processes, indicating when deadlock occurs.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Resource Allocation Graph and Deadlock Analysis:</strong></p>
<p><strong>Resources:</strong> R1, R2.</p>
<p><strong>Processes:</strong> P1, P2.</p>
<p><strong>Time 1:</strong></p>
<p>P1 requests R1, P2 requests R2.</p>
<p><strong>Graph at Time 1:</strong></p>
<pre>     R1     R2
     /\     /\
    |  |   |  |
    V  V   V  V
   P1--&gt;   P2--&gt;
</pre>
<p>No deadlock yet.</p>
<p><strong>Time 2:</strong></p>
<p>P1 requests R2, P2 requests R1.</p>
<p><strong>Graph at Time 2:</strong></p>
<pre>     R1     R2
     /\     /\
    |  |   |  |
    V  V   V  V
   P1--&gt;   P2--&gt;
    ^       ^
    |       |
    -----   -----
         Requests
</pre>
<p><strong>Deadlock occurs at Time 2.</strong></p>
<p><strong>Deadlock Condition:</strong></p>
<p>At Time 2, P1 is holding R1 and requesting R2. Simultaneously, P2 is holding R2 and requesting R1. This creates a <strong>circular wait</strong> condition: P1 is waiting for a resource (R2) held by P2, and P2 is waiting for a resource (R1) held by P1. This circular dependency forms a cycle in the resource allocation graph, indicating a deadlock.</p>
<p><strong>Resource Allocation Graph Indicating Deadlock:</strong></p>
<pre>     R1     R2
     /\     /\
    |  |   |  |
    V  V   V  V
   P1&lt;--&gt;   P2&lt;--&gt;
     Circular Wait Cycle Detected
</pre>
<p><strong>Time 3:</strong></p>
<p>Release R1 and R2 (These releases cannot happen as deadlock is already present at Time 2).</p>
<p>In a deadlock situation, processes will remain blocked indefinitely unless deadlock resolution mechanisms are employed.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (5 marks)</h3>
<div class="question-content">
<p>(d) With the aid of a sleeping barber classical example, describe the inter-process communication problem as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Sleeping Barber Problem as Inter-Process Communication Example</strong>:</p>
<p>The <strong>Sleeping Barber problem</strong> is a classical synchronization problem that illustrates inter-process communication and synchronization challenges, particularly related to <strong>producer-consumer scenarios and mutual exclusion</strong>. It describes a barbershop with one barber, one barber chair, and a waiting room with a limited number of chairs.</p>
<p><strong>Scenario Description:</strong></p>
<p data-number="1"><strong>Barber's State</strong>: If there are no customers, the barber goes to sleep in the barber chair. The barber is a 'consumer' waiting for customers ('producers').</p>
<p data-number="2"><strong>Customer Arrival</strong>: When a customer arrives, they check if the barber is free.</p>
<p data-number="3"><strong>Waiting Room Full</strong>: If all waiting chairs are occupied, the customer leaves (drops out – resource limit). This illustrates buffer overflow if waiting queue (waiting room) is full.</p>
<p data-number="4"><strong>Waiting Room Available</strong>: If there are chairs available in the waiting room, the customer sits and waits.</p>
<p data-number="5"><strong>Waking the Barber</strong>: If the barber is sleeping, the arriving customer wakes up the barber. Waking up process is a form of inter-process signaling (communication).</p>
<p data-number="6"><strong>Getting Haircut</strong>: Once the barber is awake (or if the barber was already free), the customer gets a haircut. Haircut process is the 'critical section' where barber and customer interact exclusively (mutual exclusion).</p>
<p><strong>Inter-Process Communication and Synchronization Issues Illustrated:</strong></p>
<p data-number="1"><strong>Synchronization</strong>: Synchronization is crucial to manage the states of the barber and customers correctly. The barber needs to sleep when there are no customers and be woken up when a customer arrives. Customers need to wait if the barber is busy or if the waiting room is full.</p>
<p data-number="2"><strong>Mutual Exclusion</strong>: Mutual exclusion is required for accessing shared resources like the barber chair and waiting room chairs. Only one customer can be in the barber chair getting a haircut at a time (barber chair mutual exclusion). Access to waiting room chairs also needs to be managed to prevent race conditions when multiple customers arrive or leave simultaneously.</p>
<p data-number="3"><strong>Producer-Consumer Relationship</strong>: The problem represents a producer-consumer relationship where customers are 'producers' of haircut requests, and the barber is the 'consumer' who provides haircuts. Communication between producers and consumers (customers and barber) needs to be synchronized to avoid issues like the barber trying to cut hair when no customer is present, or customers not being able to get a haircut when the barber is available.</p>
<p data-number="4"><strong>Deadlock and Starvation Potential</strong>: Improper synchronization in the Sleeping Barber problem can lead to deadlock or starvation scenarios. For example, if synchronization mechanisms are not correctly implemented, it's possible for both barber and customers to get stuck in waiting loops, leading to deadlock. Starvation could occur if customers keep arriving and waking up the barber before a waiting customer gets a haircut.</p>
<p><strong>Communication Mechanism</strong>: Condition variables or semaphores are typically used to implement solutions to the Sleeping Barber problem, enabling processes (barber and customers) to communicate and synchronize their actions based on the state of the barbershop (e.g., barber sleeping, waiting chairs available).</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (4 marks)</h3>
<div class="question-content">
<p>8. (a) Differentiate between multiprocessor and distributed types of operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Multiprocessor Operating Systems</strong>:</p>
<p><strong>Multiprocessor operating systems</strong> manage a <strong>single computer system with multiple CPUs (processors)</strong>. These processors share the same physical memory, I/O devices, and system bus. The operating system manages the coordination and communication between these processors to execute tasks in parallel. Multiprocessor systems aim to improve processing speed and system throughput by utilizing multiple CPUs to concurrently execute different parts of a program or multiple programs. They typically use techniques like symmetric multiprocessing (SMP) or asymmetric multiprocessing (AMP) to distribute tasks across processors. Examples include server operating systems and high-performance computing systems.</p>
<p><strong>Distributed Operating Systems</strong>:</p>
<p><strong>Distributed operating systems</strong> manage a <strong>group of independent computers (nodes) that are networked together to work as a single, unified system</strong>. Each computer in a distributed system has its own CPU, memory, and I/O devices, and they communicate with each other over a network. The distributed OS coordinates the activities of these networked computers to achieve a common goal or provide a distributed service. They focus on resource sharing, communication, and fault tolerance across multiple machines. Distributed systems are often used for large-scale applications, cloud computing, and network services. Examples include cluster computing and grid computing environments.</p>
<p><strong>Key Differences:</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Multiprocessor OS</th>
<th>Distributed OS</th>
</tr>
</thead>
<tbody>
<tr>
<td data-label="Feature">Number of Computers</td>
<td data-label="Multiprocessor OS">Single computer with multiple CPUs</td>
<td data-label="Distributed OS">Multiple computers networked together</td>
</tr>
<tr>
<td data-label="Feature">Memory</td>
<td data-label="Multiprocessor OS">Shared physical memory</td>
<td data-label="Distributed OS">Each computer has its own memory (distributed memory)</td>
</tr>
<tr>
<td data-label="Feature">Communication</td>
<td data-label="Multiprocessor OS">Shared memory and system bus</td>
<td data-label="Distributed OS">Network communication (message passing)</td>
</tr>
<tr>
<td data-label="Feature">System Structure</td>
<td data-label="Multiprocessor OS">Tightly coupled system</td>
<td data-label="Distributed OS">Loosely coupled system</td>
</tr>
<tr>
<td data-label="Feature">Goal</td>
<td data-label="Multiprocessor OS">Increase processing speed and throughput within a single system</td>
<td data-label="Distributed OS">Resource sharing, scalability, fault tolerance across multiple systems</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Describe two parts of an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Kernel</strong>: The <strong>kernel</strong> is the <strong>core component of the operating system</strong>. It is the innermost layer and has direct control over the hardware. The kernel provides essential services such as process management, memory management, file system management, device management, and interrupt handling. It acts as the interface between the hardware and the rest of the operating system and applications. The kernel is typically resident in memory and executes in a privileged mode (kernel mode) to control system resources and enforce security. It is responsible for the fundamental operations that make the system functional and responsive.</p>
<p data-number="2"><strong>System Programs (or System Utilities)</strong>: <strong>System programs</strong> are a set of <strong>utility programs that are bundled with the operating system</strong> to assist users and system administrators in managing and utilizing the computer system effectively. These programs provide a range of functions, including file management (e.g., file explorers, command-line shells), system configuration, monitoring, software installation, and network utilities. System programs run in user mode and utilize system calls to request services from the kernel. They enhance the user experience and provide tools for system maintenance and administration, extending the functionality of the core OS kernel.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (i) I. (2 marks)</h3>
<div class="question-content">
<p>(c) Karen was running a system using priority scheduling. She had two processes X and Y with run times of 20 minutes and 60 minutes respectively. Determine the processes to be selected:</p>
<p>(i) I. If both wait for 5 minutes;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>I. If both wait for 5 minutes</strong>:</p>
<p>If both processes X and Y have been waiting for 5 minutes and priority is based on waiting time (aging might increase priority over time), and assuming no initial priority difference, process <strong>X should be selected first</strong> because it has a shorter run time (20 minutes) compared to Y (60 minutes). Selecting the shorter job first, in this context, minimizes the time until the first process completes and may improve overall system responsiveness. However, if initial priorities are different, the higher priority process would be selected regardless of waiting time, until aging increases the waiting process’s priority.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (i) II. (2 marks)</h3>
<div class="question-content">
<p>II. If Y waits for 35 minutes;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>II. If Y waits for 35 minutes</strong>:</p>
<p>If process Y has been waiting for 35 minutes, and process X's waiting time is not specified (assuming shorter or negligible waiting time for X in comparison, or newly arrived), then process <strong>Y should be selected</strong>. The significantly longer waiting time for Y, especially if aging is implemented, would likely have increased its priority considerably. Even if X has a higher initial priority, the prolonged waiting of Y would likely elevate its priority enough to be selected over X to prevent starvation and ensure fairness. Priority scheduling with aging is designed to prioritize longer waiting processes eventually.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (i) III. (1 mark)</h3>
<div class="question-content">
<p>III. If X start at time 0.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>III. If X starts at time 0</strong>:</p>
<p>If process X starts at time 0, it implies <strong>process X is selected first</strong>. In priority scheduling, if process X has a higher priority than Y initially or at time 0, or if X arrives before Y and the scheduling is also considering arrival time along with priority, X would be scheduled to run first. Starting at time 0 simply means X is chosen to run initially, possibly due to its higher priority or earlier arrival.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (ii) (1 mark)</h3>
<div class="question-content">
<p>(ii) Outline the way this technique avoids starvation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Avoidance of Starvation</strong>:</p>
<p>Priority scheduling avoids starvation through <strong>aging</strong>. Aging is a technique that <strong>gradually increases the priority of processes that have been waiting in the ready queue for a long time</strong>. As a process waits longer, its priority increases, making it more likely to be selected for execution, even if it initially had a low priority. Eventually, through aging, even a low-priority process will reach a priority level high enough to be scheduled, preventing indefinite postponement and starvation.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>(d) (i) State four types of access rights that could be granted in a file sharing computer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Read Access</strong>: <strong>Read access</strong> right allows a user or process to <strong>view or read the contents of a file</strong>. With read access, the user can open the file and read its data but cannot make any changes to the file's content. This is a basic access right that grants viewing privileges.</p>
<p data-number="2"><strong>Write Access</strong>: <strong>Write access</strong> right permits a user or process to <strong>modify or write data to a file</strong>. With write access, the user can change the file's contents, append data, or overwrite existing data. Write access usually implies read access as well, as one might need to read a file before modifying it. This right grants modification privileges.</p>
<p data-number="3"><strong>Execute Access</strong>: <strong>Execute access</strong> right allows a user or process to <strong>run or execute a file</strong>, typically applicable to executable files or scripts. For executable files, this right is necessary to launch and run the program. For directories, execute access might mean the ability to search through the directory or access files within it. This right grants execution privileges.</p>
<p data-number="4"><strong>Delete Access</strong>: <strong>Delete access</strong> right grants a user or process the permission to <strong>remove or delete a file</strong>. With delete access, a user can permanently erase the file from the file system. This is a powerful right that should be granted cautiously, as it can lead to data loss if used improperly. This right grants deletion privileges.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) With the aid of an illustration, differentiate the sequential and indexed sequential file organization methods.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Sequential vs. Indexed Sequential File Organization</strong>:</p>
<p><strong>Sequential File Organization</strong>:</p>
<p>In <strong>sequential file organization</strong>, records are stored in a <strong>linear sequence</strong>, one after another, in the order they are entered. Records are typically arranged based on a key field, but access is primarily sequential. To access a specific record, one must traverse through all preceding records. Sequential files are efficient for operations that process records in order, like batch processing, but inefficient for random access or direct access to specific records.</p>
<p><strong>Illustration of Sequential File Organization:</strong></p>
<pre>+-----------------+-----------------+-----------------+-----+-----------------+
| Record 1        | Record 2        | Record 3        | ... | Record N        |
+-----------------+-----------------+-----------------+-----+-----------------+
  (Key: Key1)       (Key: Key2)       (Key: Key3)             (Key: KeyN)
  Stored in sequential order
  Access: Sequential traversal from Record 1 to Record N
</pre>
<p><strong>Indexed Sequential File Organization</strong>:</p>
<p><strong>Indexed sequential file organization</strong> combines sequential access with direct access capabilities by using an <strong>index</strong>. Records are stored sequentially, similar to sequential files, but an index is also created that maps key values to the disk addresses of records or blocks of records. The index allows for direct access to a record by looking up its key in the index and then directly accessing its location on disk. Sequential access is still efficient, and direct access is also supported through the index, making it more versatile than purely sequential organization.</p>
<p><strong>Illustration of Indexed Sequential File Organization:</strong></p>
<pre>Index:
+-----------+-------------+
| Key Value | Disk Address|
+-----------+-------------+
| Key1      | Address 1   | --&gt; +-----------------+-----------------+-----+
| Key5      | Address 5   | --&gt; | Record 1        | Record 2        | ... | Sequential Block 1
| Key10     | Address 10  | --&gt; +-----------------+-----------------+-----+
| ...       | ...         |
| KeyN      | Address N   | --&gt; +-----------------+-----------------+-----+
+-----------+-------------+     | Record X        | Record Y        | ... | Sequential Block N
                                  +-----------------+-----------------+-----+
  Index for Direct Access       Data Records in Sequential Order
  Access: Sequential and Direct (via Index)
</pre>
<p><strong>Key Differentiation:</strong> Sequential files support only sequential access, while indexed sequential files support both sequential access for ordered processing and direct access via an index for efficient retrieval of specific records. Indexed sequential organization provides a balance between sequential processing efficiency and direct access capability.</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer>© 2017 The Kenya National Examinations Council</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="november_2017.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2016.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>