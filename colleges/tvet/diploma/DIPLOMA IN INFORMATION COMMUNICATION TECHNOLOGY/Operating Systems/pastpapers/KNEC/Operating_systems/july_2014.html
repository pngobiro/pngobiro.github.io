<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>July 2014 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-13"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li id="active"><a href="july_2014.html" class="active no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="novemeber_2014.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2013.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">July 2014</h1></header>
<article class="iDevice_wrapper textIdevice" id="id13">
<div class="iDevice emphasis0" >
<div id="ta13_135_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>Operating Systems</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: July 2014</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (i) (4 marks)</h3>
<div class="question-content">
<p>Outline four resources required in a process execution.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>CPU Time</strong>: Processes require CPU time to execute instructions. This is the fundamental resource for computation.</p>
<p data-number="2"><strong>Memory</strong>: Processes need memory to store program code, data, and the process execution context. This includes RAM and potentially virtual memory.</p>
<p data-number="3"><strong>Input/Output (I/O) Resources</strong>: Processes often require I/O resources such as files, network connections, and devices to interact with the external environment.</p>
<p data-number="4"><strong>Files</strong>: Access to files for reading and writing data is crucial for many processes to perform their tasks and manage persistent data.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between interrupt and system call as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Interrupt</strong>:</p>
<p>An <strong>interrupt</strong> is a hardware-generated signal that alerts the operating system to an event that needs immediate attention. It is <strong>asynchronous</strong>, meaning it can occur at any time, independent of the currently running process. Interrupts are typically triggered by external events such as I/O completion, hardware errors, or timer expirations. When an interrupt occurs, the CPU suspends the current process, saves its context, and transfers control to an <strong>interrupt handler</strong> to deal with the event.</p>
<p><strong>System Call</strong>:</p>
<p>A <strong>system call</strong> is a request from a user-level process to the operating system kernel to perform a specific task. It is <strong>synchronous</strong> and <strong>intentional</strong>, initiated by the process when it needs to access kernel services. System calls are used for operations like file I/O, process creation, memory allocation, and inter-process communication. When a system call is made, the process transitions to kernel mode, the kernel performs the requested operation, and then returns control back to the process in user mode.</p>
<p><strong>Key Differences</strong>:</p>
<p>The main difference lies in their origin and purpose. <strong>Interrupts</strong> are hardware-driven, asynchronous signals for handling external events, while <strong>system calls</strong> are software-driven, synchronous requests from processes to access OS services.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the term context switch as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>context switch</strong> is the process of the operating system switching the CPU from one process to another. This involves saving the <strong>current state</strong> of the running process (its context) and restoring the saved state of a different process to be executed. The context typically includes the <strong>program counter</strong>, <strong>registers</strong>, and <strong>memory management information</strong>. Context switching is essential for multitasking, allowing multiple processes to share a single CPU.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>A lecturer described objectives of process scheduling to an operating systems' class. Explain two objectives that he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Maximize CPU Utilization</strong>: Process scheduling aims to keep the CPU as busy as possible, ensuring that there is always a process running. By efficiently switching between processes, the operating system minimizes CPU idle time, leading to better overall system performance. This is crucial for improving throughput and responsiveness.</p>
<p data-number="2"><strong>Minimize Turnaround Time</strong>: Process scheduling strives to reduce the total time it takes for a process to complete execution, known as turnaround time. This includes the time spent waiting in queues, executing on the CPU, and performing I/O. Minimizing turnaround time improves the user experience by providing quicker results and faster application completion.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (6 marks)</h3>
<div class="question-content">
<p>Bruce was required to identify the appropriate memory placement techniques for a proposed operating system. Explain three techniques that he could have considered.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>First-Fit</strong>: This technique allocates the first available memory partition that is large enough to accommodate the process. The operating system scans through the memory partitions from the beginning and selects the first suitable block. <strong>Advantage</strong>: Simple to implement. <strong>Disadvantage</strong>: Can lead to fragmentation and may not efficiently utilize memory space, potentially leaving larger free blocks unused at the end.</p>
<p data-number="2"><strong>Best-Fit</strong>: This technique allocates the smallest available memory partition that is large enough to hold the process. The operating system searches the entire list of free partitions and chooses the one that is closest in size to the process's requirement. <strong>Advantage</strong>: Tends to minimize memory wastage and external fragmentation compared to first-fit. <strong>Disadvantage</strong>: Can be slower than first-fit due to the need to search the entire list and may lead to many small, unusable free blocks.</p>
<p data-number="3"><strong>Worst-Fit</strong>: This technique allocates the largest available memory partition to the process. The operating system searches through all free partitions and selects the largest one. <strong>Advantage</strong>: Aims to leave larger free blocks after allocation, potentially accommodating larger future processes. <strong>Disadvantage</strong>: Can quickly deplete larger free blocks, leading to fragmentation and potentially making it difficult to allocate memory for large processes in the long run.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two parts of a directory structure in an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Directory Entry</strong>: Each directory contains entries that represent files and subdirectories within it. A directory entry typically includes the <strong>name</strong> of the file or subdirectory and a pointer to its <strong>inode or file descriptor</strong>, which holds metadata about the file or directory.</p>
<p data-number="2"><strong>Inode (Index Node) or File Descriptor</strong>: This part stores the <strong>metadata</strong> associated with each file or directory. Metadata includes information such as file permissions, ownership, timestamps (creation, modification, access), file size, and pointers to the data blocks on disk where the file content is stored.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>I. access right;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>I. Access Right</strong>:</p>
<p><strong>Access rights</strong>, also known as permissions, define the level of access that users or processes have to specific files or directories in an operating system. They determine what operations are allowed, such as <strong>read</strong>, <strong>write</strong>, and <strong>execute</strong>. Access rights are a crucial part of security and protection, ensuring that only authorized entities can perform operations on system resources. They are typically associated with user accounts and groups.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>II. flags.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>II. Flags</strong>:</p>
<p>In operating systems, <strong>flags</strong> are single-bit indicators used to represent the status or attributes of a file, process, or system component. They act as <strong>boolean</strong> values (true or false, set or unset) to indicate specific conditions or properties. For example, file flags can indicate if a file is <strong>read-only</strong>, <strong>hidden</strong>, or <strong>system file</strong>. Process flags can indicate the process's <strong>priority</strong> or <strong>state</strong> (running, waiting, etc.). Flags are an efficient way to store and manage binary attributes.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (4 marks)</h3>
<div class="question-content">
<p>Figure I shows layers in computer memory hierarchy. Use it to answer the question that follows.</p>
<p><img src="Screenshot_2025-03-12_at_13-05-57_2014july.pdf.png" alt="" width="750" height="380" /></p>
<img src="figure1.png" alt="Figure 1 Memory Hierarchy Diagram" />
<p>Describe each of the layers labeled (i) and (ii).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on Figure 1, which depicts a typical memory hierarchy pyramid:</p>
<p><strong>(i) Cache</strong>:</p>
<p>Layer (i) is labeled as <strong>Cache</strong>. Cache memory is the <strong>fastest and most expensive</strong> type of memory in the hierarchy. It is a small, high-speed memory that stores frequently accessed data and instructions to speed up access times for the CPU. Caches operate on the principle of locality, predicting that data recently accessed or near recently accessed data is likely to be needed again soon. There are typically multiple levels of cache (L1, L2, L3), with L1 being the fastest and smallest, closest to the CPU.</p>
<p><strong>(ii) Random Access Memory</strong>:</p>
<p>Layer (ii) is labeled as <strong>Random Access Memory (RAM)</strong>. RAM is the <strong>main memory</strong> of the computer system. It is faster than secondary storage (like hard drives) but slower and less expensive than cache. RAM is <strong>volatile</strong> memory, meaning it loses its data when power is turned off. It stores the currently running programs and data that the CPU is actively using. RAM allows for random access, meaning any memory location can be accessed in the same amount of time, making it efficient for general-purpose computing.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (4 marks)</h3>
<div class="question-content">
<p>Petro was investigating advantages of memory segmentation in operating systems. Explain two advantages that he is likely to have identified.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Logical Address Space</strong>: Memory segmentation allows for a <strong>logical view</strong> of memory, where the address space is divided into logical units called segments (code, data, stack). This simplifies program organization and management, as each segment can grow or shrink independently. It also facilitates modular programming and data sharing between segments.</p>
<p data-number="2"><strong>Protection and Sharing</strong>: Segmentation enables <strong>protection</strong> at the segment level. Each segment can have its own access rights (read, write, execute), allowing the operating system to enforce memory protection between different segments and processes. It also facilitates <strong>sharing</strong> of specific segments between processes, such as code segments for libraries, while maintaining protection for other segments. This enhances system security and resource utilization.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two types of files that could be found in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Data Files</strong>: These files contain <strong>user-created data</strong>, such as documents, images, audio, video, and databases. They are typically organized and interpreted by application programs. Data files can be further categorized by their format (e.g., text files, binary files, image files).</p>
<p data-number="2"><strong>Executable Files</strong>: These files contain <strong>program instructions</strong> that can be executed by the CPU. They are the compiled form of source code and represent applications or system utilities. Executable files are typically loaded into memory and run by the operating system. They often have specific formats depending on the operating system (e.g., .exe on Windows, ELF on Linux).</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Brian intends to backup files. Explain two backup strategies he could use.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Full Backup</strong>: A <strong>full backup</strong> strategy involves copying <strong>all selected files and directories</strong> every time a backup is performed. This creates a complete copy of the data set. <strong>Advantage</strong>: Simplest to restore from, as all data is in one backup set. <strong>Disadvantage</strong>: Time-consuming and requires significant storage space, especially for frequent backups, as it duplicates all data each time.</p>
<p data-number="2"><strong>Incremental Backup</strong>: An <strong>incremental backup</strong> strategy only copies the files that have been <strong>changed or created since the last backup</strong> (which could be a full or incremental backup). This significantly reduces backup time and storage space. <strong>Advantage</strong>: Faster backups and less storage space required compared to full backups. <strong>Disadvantage</strong>: Restoration is more complex and time-consuming, as it requires the last full backup and all subsequent incremental backups to be restored in sequence.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>(i) bootstrap;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Bootstrap</strong>:</p>
<p><strong>Bootstrap</strong> refers to the initial startup process of a computer system when it is powered on or rebooted. It is a <strong>self-starting process</strong> where a small program, the <strong>bootstrap loader</strong>, is loaded from non-volatile memory (like ROM or firmware). This loader then initializes the system hardware, loads the operating system kernel from storage into memory, and starts the OS execution. The bootstrap process is essential to bring the system from a powered-off state to a running state.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>(ii) firmware.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Firmware</strong>:</p>
<p><strong>Firmware</strong> is a type of software that is <strong>embedded in hardware devices</strong>. It is stored in non-volatile memory (like ROM, EPROM, or Flash memory) and provides low-level control and instructions for the hardware. Firmware is essential for the basic operation of hardware components, such as BIOS/UEFI in motherboards, firmware in disk drives, network cards, and embedded systems. It is "firm" because it is neither purely hardware nor purely software, residing in between.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (5 marks)</h3>
<div class="question-content">
<p>Figure 2 shows a typical process model used in operating systems. Use it to answer the question that follows.</p>
<p><img src="Screenshot_2025-03-12_at_13-07-33_2014july.pdf.png" alt="" width="731" height="462" /></p>
<img src="figure2.png" alt="Figure 2 Process State Diagram" />
<p>Identify the parts labeled (i), (ii), (iii), (iv) and (v).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on Figure 2, which depicts a typical process state diagram:</p>
<p><strong>(i) Ready</strong>: This state represents processes that are <strong>ready to run</strong> but are waiting for the CPU to be allocated to them. They are in memory and are waiting to be scheduled by the dispatcher.</p>
<p><strong>(ii) Running</strong>: This state represents the process that is <strong>currently being executed</strong> by the CPU. Instructions of the process are being actively processed.</p>
<p><strong>(iii) Waiting (or Blocked)</strong>: This state represents processes that are <strong>waiting for some event to occur</strong>, such as the completion of an I/O operation or receiving a signal. They are not ready to run and are waiting for an external event to become ready again.</p>
<p><strong>(iv) Scheduler Dispatch</strong>: This label represents the action of the <strong>scheduler dispatching</strong> a process from the ready queue to the running state. It's the transition from Ready to Running state.</p>
<p><strong>(v) New</strong>: This state represents a process that is being <strong>created</strong>. The operating system is in the process of setting up the necessary data structures and resources for the new process. Before being admitted to the Ready queue, a process is in the New state.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (4 marks)</h3>
<div class="question-content">
<p>Dorothy intends to design an operating system that uses swapping in memory management. Explain two constraints that are likely to be realized.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Performance Overhead (Swapping Time)</strong>: Swapping processes between main memory and secondary storage (disk) is a <strong>time-consuming operation</strong>. The time taken to swap a process out and swap another process in, known as swap time, introduces significant overhead. Frequent swapping can lead to reduced system throughput and slower response times, especially if the swap space is slow or if processes are frequently swapped in and out.</p>
<p data-number="2"><strong>Increased I/O Traffic</strong>: Swapping generates considerable <strong>disk I/O traffic</strong> as processes are moved to and from secondary storage. This increased I/O load can become a bottleneck, especially if there are many processes being swapped or if disk I/O is already heavily utilized by other system activities. High I/O traffic can degrade overall system performance and reduce the efficiency of other disk-related operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (i) (3 marks)</h3>
<div class="question-content">
<p>Outline three goals of I/O module.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Device Independence</strong>: One goal is to provide a <strong>uniform interface</strong> to the operating system and user processes, regardless of the specific characteristics of different I/O devices. This allows programs to interact with devices in a generic way without needing to know the details of each device's operation. Device drivers handle the device-specific operations, providing an abstraction layer.</p>
<p data-number="2"><strong>Buffering and Caching</strong>: I/O modules aim to improve performance by using <strong>buffering and caching techniques</strong>. Buffering helps to smooth out data transfer rates between devices and memory, while caching stores frequently accessed data in memory to reduce the need for slow I/O operations. These techniques improve efficiency and responsiveness.</p>
<p data-number="3"><strong>Error Handling</strong>: A crucial goal is to manage <strong>error detection and handling</strong> for I/O operations. The I/O module should detect errors during data transfer, device operations, or device failures. It should implement mechanisms to handle these errors, such as retries, error reporting, or device recovery, to ensure data integrity and system reliability.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>A group of module II students were carrying out an assignment on I/O protection strategies in operating systems. Explain two strategies that they could identify.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Privileged Instructions</strong>: Restricting direct access to I/O hardware by making I/O instructions <strong>privileged</strong>. Only the operating system kernel, running in privileged mode, can execute these instructions. User-level processes must request I/O operations through system calls, which are then handled by the kernel. This prevents unauthorized user programs from directly manipulating I/O devices and causing system instability or security breaches.</p>
<p data-number="2"><strong>Memory Protection for I/O Buffers</strong>: Implementing <strong>memory protection mechanisms</strong> to safeguard the memory regions used for I/O buffers. This ensures that user processes cannot directly access or modify the I/O buffers used by the kernel for device communication. Memory protection can be achieved using techniques like memory segmentation or paging with access control bits. This prevents malicious or erroneous user programs from corrupting kernel I/O operations or accessing sensitive data in I/O buffers.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between SCAN and C-SCAN disk scheduling algorithms.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>SCAN Algorithm</strong>:</p>
<p>The <strong>SCAN algorithm</strong>, also known as the elevator algorithm, moves the disk head in one direction (e.g., from the innermost track to the outermost track), servicing all requests in its path. When it reaches one end of the disk, it reverses direction and continues servicing requests in the opposite direction. It's like an elevator moving up and down a building, servicing floors in its current direction of travel. SCAN provides <strong>moderate throughput</strong> and <strong>fairness</strong>, but waiting time can be high for requests arriving just after the head has passed them.</p>
<p><strong>C-SCAN Algorithm</strong>:</p>
<p>The <strong>C-SCAN (Circular SCAN) algorithm</strong> is a variation of SCAN that attempts to provide more uniform wait times. It moves the disk head in one direction (e.g., from the innermost to the outermost track), servicing requests along the way, just like SCAN. However, when it reaches the end of the disk, it <strong>quickly returns to the beginning</strong> of the disk without servicing any requests on the return trip. Then, it starts scanning again from the beginning in the same direction. C-SCAN offers <strong>more uniform wait times</strong> compared to SCAN, as it limits the maximum wait time for any request, but it may have slightly <strong>lower throughput</strong> because of the head repositioning overhead on the return trip.</p>
<p><strong>Key Distinction</strong>:</p>
<p>The primary difference is in the head movement after reaching the end of the disk. SCAN reverses direction, while C-SCAN returns to the beginning without servicing requests, aiming for more uniform service times at the cost of potentially slightly reduced throughput.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (4 marks)</h3>
<div class="question-content">
<p>Hope intends to develop a file management module for an operating system. Explain two file access methods that she should consider.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Sequential Access</strong>: In <strong>sequential access</strong>, files are accessed in a <strong>linear order</strong>, from the beginning to the end. To access a specific record, one must read through all preceding records. This method is simple to implement and efficient for applications that process data in a fixed sequence, like batch processing or tape-based systems. <strong>Example</strong>: Reading a log file from start to finish.</p>
<p data-number="2"><strong>Direct (Random) Access</strong>: In <strong>direct access</strong>, also known as random access, any record in a file can be accessed <strong>directly without needing to read through preceding records</strong>. This is achieved by using a record number or a key to calculate the physical location of the desired record. Direct access is essential for applications that require fast access to specific data records, like databases, indexed file systems, and interactive applications. <strong>Example</strong>: Accessing a specific record in a database using an index.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram in each case, describe each of the following file system:</p>
<p>(i) single-level directory;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Single-Level Directory</strong>:</p>
<p>In a <strong>single-level directory</strong> structure, there is only <strong>one directory</strong> for all files in the system. All files are placed in this single directory. <strong>Conceptual Diagram</strong>: Imagine a single box where all files are placed directly inside. <strong>Description</strong>: This is the simplest directory structure. It is easy to implement but suffers from significant limitations, especially for systems with many files or multiple users. <strong>Limitation</strong>: Naming conflicts are a major issue, as all file names must be unique system-wide. It also lacks organizational structure and is not suitable for large file systems or multi-user environments.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram in each case, describe each of the following file system:</p>
<p>(ii) two-level directory.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Two-Level Directory</strong>:</p>
<p>In a <strong>two-level directory</strong> structure, there is a <strong>root directory</strong>, and under it, each user has their own <strong>user directory</strong>. Each user directory contains all the files belonging to that user. <strong>Conceptual Diagram</strong>: Imagine a main box (root directory) containing smaller boxes (user directories), and each smaller box holds files for a specific user. <strong>Description</strong>: This structure improves upon the single-level directory by providing a level of organization and resolving naming conflicts between users. Each user can have files with the same name as long as they are in different user directories. <strong>Limitation</strong>: It still lacks flexibility for users to create their own subdirectories within their user directory for better organization of their files.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following tables as used in memory management:</p>
<p>(i) hashed;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Hashed Page Table</strong>:</p>
<p>A <strong>hashed page table</strong> is a page table structure used in virtual memory management, especially for large address spaces. Instead of a linear array, it uses a <strong>hash table</strong> to map virtual page numbers to page table entries. The virtual page number is hashed to get an index into the hash table. Each entry in the hash table is a linked list of page table entries that hash to the same index, resolving collisions. <strong>Advantage</strong>: Effective in reducing the size of the page table, especially for sparse address spaces. <strong>Disadvantage</strong>: Lookups can be slightly slower due to hash function computation and linked list traversal in case of collisions.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following tables as used in memory management:</p>
<p>(ii) clustered page.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Clustered Page Table</strong>:</p>
<p>A <strong>clustered page table</strong> is a variation used in memory management to handle large page tables efficiently, particularly in systems with large physical memory. Instead of a single large page table, it is divided into <strong>clusters or groups</strong>. Each cluster is a smaller page table that manages a portion of the virtual address space. A top-level index or directory is used to locate the appropriate cluster for a given virtual address. <strong>Advantage</strong>: Reduces the memory footprint of the page table by only keeping necessary clusters in memory. <strong>Disadvantage</strong>: Adds a level of indirection for address translation, potentially slightly increasing lookup time.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between long-term and short-term schedulers as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Long-Term Scheduler (Job Scheduler)</strong>:</p>
<p>The <strong>long-term scheduler</strong>, also known as the job scheduler, controls the <strong>degree of multiprogramming</strong> by selecting processes from a job pool and loading them into memory for execution. It operates relatively infrequently, typically when a process finishes or when system load changes significantly. Its primary goal is to balance the mix of processes in memory, ensuring a good balance between CPU-bound and I/O-bound processes. It influences system stability and resource utilization over a longer time scale.</p>
<p><strong>Short-Term Scheduler (CPU Scheduler)</strong>:</p>
<p>The <strong>short-term scheduler</strong>, also known as the CPU scheduler, selects one of the ready processes in memory and allocates the CPU to it. It operates very frequently, typically whenever an event occurs that may lead to process switching (e.g., time slice expiration, I/O request, interrupt). Its primary goal is to maximize CPU utilization and minimize response time by quickly switching between ready processes. It makes fine-grained decisions about which process runs next, impacting system responsiveness and throughput in the short term.</p>
<p><strong>Key Distinction</strong>:</p>
<p>The main difference is in their frequency and scope. The <strong>long-term scheduler</strong> controls the overall number of processes in memory over longer periods, while the <strong>short-term scheduler</strong> makes rapid, moment-to-moment decisions about CPU allocation among ready processes.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Bev was carrying out a study on benefits of multiprocessor systems. Explain two benefits that she could have established.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Increased Throughput</strong>: Multiprocessor systems can achieve significantly <strong>higher throughput</strong> than single-processor systems. By having multiple CPUs, they can execute multiple processes or threads concurrently, leading to more work being completed in a given time period. This is especially beneficial for CPU-intensive workloads and applications that can be parallelized. Increased throughput improves overall system efficiency and performance.</p>
<p data-number="2"><strong>Enhanced Reliability and Fault Tolerance</strong>: Multiprocessor systems can offer <strong>improved reliability and fault tolerance</strong>. If one processor fails, the system can continue to operate, albeit with reduced performance, using the remaining processors. This redundancy makes the system more resilient to hardware failures and reduces the risk of complete system downtime. Fault tolerance is crucial for critical applications where continuous operation is essential.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Angie was required to investigate factors that affect performance of a storage disk Outline four factors that she could have considered.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Seek Time</strong>: <strong>Seek time</strong> is the time it takes for the disk head to move to the correct cylinder or track where the desired data is located. A lower seek time means faster access to data. Seek time is influenced by the physical characteristics of the disk drive, such as the speed and inertia of the actuator arm.</p>
<p data-number="2"><strong>Rotational Latency</strong>: <strong>Rotational latency</strong> is the time it takes for the desired sector on the disk to rotate under the read/write head once the head is positioned over the correct track. Lower rotational latency results in quicker data access. Rotational speed (RPM) of the disk directly affects rotational latency; higher RPM reduces latency.</p>
<p data-number="3"><strong>Transfer Rate</strong>: <strong>Transfer rate</strong> is the speed at which data can be transferred between the disk and the system memory, once the head is correctly positioned and the sector is under the head. Higher transfer rates lead to faster data read and write operations. Transfer rate is influenced by the disk interface (e.g., SATA, NVMe), disk technology, and controller capabilities.</p>
<p data-number="4"><strong>Disk Controller Overhead</strong>: The <strong>disk controller</strong>, which manages the disk drive, introduces some overhead. This includes the time for command processing, data buffering, error checking, and protocol handling. Lower controller overhead contributes to better disk performance. Efficient controller design and faster interfaces can minimize this overhead.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in disk operations:</p>
<p>(i) seek time;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Seek Time</strong>:</p>
<p><strong>Seek time</strong> is the time taken for a disk drive's read/write head to move from its current position to the cylinder or track where the requested data is located. It is a major component of disk access time, representing the mechanical movement of the head assembly. Lower seek times contribute to faster disk performance. Seek time is typically measured in milliseconds (ms).</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in disk operations:</p>
<p>(ii) transfer rate;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Transfer Rate</strong>:</p>
<p><strong>Transfer rate</strong>, also known as data rate or bandwidth, is the speed at which data can be transferred between the disk drive and the computer's memory once the read/write head is positioned correctly over the data sector. It is usually measured in megabytes per second (MB/s) or gigabytes per second (GB/s). A higher transfer rate indicates faster data read and write operations, contributing to better disk performance. Transfer rate is influenced by factors like disk interface type, disk speed, and data encoding scheme.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (iii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in disk operations:</p>
<p>(ii) rotational latency.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(iii) Rotational Latency</strong>:</p>
<p><strong>Rotational latency</strong> is the time it takes for the desired sector on a disk platter to rotate under the read/write head once the head has reached the correct track (after seek time). On average, it is half of the time for a full disk rotation. Rotational latency is a component of disk access time, representing the delay due to the disk's rotation speed. It is inversely related to the disk's RPM (revolutions per minute). Higher RPM disks have lower rotational latency, leading to faster data access.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (4 marks)</h3>
<div class="question-content">
<p>Stano listed several examples of I/O buses that could be used in a disk drive. Outline four examples that he could have listed.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>SATA (Serial ATA)</strong>: <strong>SATA</strong> is a common interface for connecting disk drives (HDDs and SSDs) to the motherboard. It is a serial interface, offering good performance for general-purpose storage and is widely used in desktop and laptop computers.</p>
<p data-number="2"><strong>NVMe (Non-Volatile Memory Express)</strong>: <strong>NVMe</strong> is a high-performance interface designed specifically for SSDs. It uses the PCI Express (PCIe) bus to provide significantly higher transfer rates and lower latency compared to SATA. NVMe is ideal for demanding applications requiring fast storage access, such as servers, workstations, and high-end gaming PCs.</p>
<p data-number="3"><strong>SAS (Serial Attached SCSI)</strong>: <strong>SAS</strong> is another serial interface, primarily used in enterprise environments for server and workstation storage. It offers higher reliability, performance, and scalability compared to SATA. SAS drives often have higher rotational speeds and are designed for demanding workloads and data centers.</p>
<p data-number="4"><strong>IDE/ATA (Integrated Drive Electronics/Advanced Technology Attachment)</strong>: <strong>IDE/ATA</strong> is an older parallel interface for disk drives. While less common in modern systems, it was widely used in the past. Compared to SATA, IDE/ATA is slower and has limitations in cable length and device support. Modern systems primarily use SATA and NVMe interfaces.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (5 marks)</h3>
<div class="question-content">
<p>File attributes varies from one operating system to another. Outline five examples of these attributes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Name</strong>: The <strong>name</strong> of the file, which is used to identify and access the file within a directory structure. File naming conventions and restrictions can vary between operating systems (e.g., case sensitivity, allowed characters, maximum length).</p>
<p data-number="2"><strong>Size</strong>: The <strong>size</strong> of the file, indicating the amount of storage space it occupies, usually measured in bytes, kilobytes, megabytes, etc. File size is crucial for storage management and resource allocation.</p>
<p data-number="3"><strong>Type</strong>: The <strong>type</strong> of file, which indicates the file format and purpose (e.g., text file, executable file, image file, directory). File type is often indicated by a file extension or metadata and determines how the file is handled by the operating system and applications.</p>
<p data-number="4"><strong>Permissions/Access Rights</strong>: <strong>Permissions</strong> or access rights control who can access the file and what operations they can perform (e.g., read, write, execute). Permission models vary across operating systems (e.g., ACLs, POSIX permissions) and are essential for security and data protection.</p>
<p data-number="5"><strong>Timestamps</strong>: <strong>Timestamps</strong> record various times associated with the file, such as creation time, last modification time, and last access time. Timestamps are used for file management, tracking changes, and backup purposes. The precision and types of timestamps can differ between operating systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (5 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, outline a typical process control block (PCB) diagram as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>Process Control Block (PCB)</strong> is a data structure used by the operating system to manage and track information about each process. While a true "diagram" isn't textual, conceptually, a PCB can be visualized as a structured record containing various fields.</p>
<p><strong>Conceptual PCB Structure</strong>:</p>
<pre>                    +-----------------------+
                    |  Process Identifier (PID) |
                    +-----------------------+
                    |  Process State        |
                    +-----------------------+
                    |  Program Counter (PC)  |
                    +-----------------------+
                    |  CPU Registers        |
                    +-----------------------+
                    |  Memory Management Info|
                    +-----------------------+
                    |  CPU Scheduling Info   |
                    +-----------------------+
                    |  I/O Status Info       |
                    +-----------------------+
                    |  Accounting Info       |
                    +-----------------------+
                    </pre>
<p><strong>Description of Key Fields</strong>:</p>
<p><strong>Process Identifier (PID)</strong>: A unique numeric identifier assigned to each process for system-level tracking and management.</p>
<p><strong>Process State</strong>: Indicates the current state of the process (e.g., running, ready, waiting, new, terminated).</p>
<p><strong>Program Counter (PC)</strong>: Stores the address of the next instruction to be executed for this process.</p>
<p><strong>CPU Registers</strong>: Saves the values of CPU registers when the process is switched out, allowing the process to resume execution from the same point later.</p>
<p><strong>Memory Management Information</strong>: Includes details about memory allocated to the process, such as page table pointers or segment table information.</p>
<p><strong>CPU Scheduling Information</strong>: Contains process priority, scheduling queue pointers, and other parameters used by the scheduler to determine process execution order.</p>
<p><strong>I/O Status Information</strong>: Records details of I/O devices allocated to the process, open files, and pending I/O requests.</p>
<p><strong>Accounting Information</strong>: Tracks resource usage by the process, such as CPU time used, elapsed time, and account limits.</p>
<p>The PCB is crucial for context switching, process scheduling, resource management, and inter-process communication. The OS maintains a PCB for each active process in the system.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define the term livelock as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Livelock</strong>:</p>
<p><strong>Livelock</strong> is a concurrency control issue similar to deadlock, where processes are continuously changing their state in response to other processes, but <strong>none of them make progress</strong>. Unlike deadlock, processes in a livelock are not blocked; they are actively engaged in attempting to resolve a conflict, but their actions prevent any progress from being made. They are in a loop of repeated state changes, effectively wasting CPU cycles without performing useful work. It's like two people trying to pass each other in a narrow corridor, each stepping aside to let the other pass, but they both step aside in the same direction, continuing to block each other.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between overlaying and partitioning as used memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Overlaying</strong>:</p>
<p><strong>Overlaying</strong> is a memory management technique used in older systems with limited memory. It allows a program larger than the available physical memory to run by dividing it into <strong>overlays</strong>. Only the overlay currently needed is loaded into memory, while others are kept on disk. When a different overlay is required, the current one is replaced (overlaid) with the new one. Overlaying is a programmer-managed technique, requiring careful program design to divide it into appropriate overlays. <strong>Limitation</strong>: Complex to implement and manage, requires programmer intervention, and is not efficient for modern systems.</p>
<p><strong>Partitioning</strong>:</p>
<p><strong>Partitioning</strong> is a memory management technique that divides main memory into <strong>fixed-size or variable-size partitions</strong>. Each partition can hold one process. <strong>Fixed partitioning</strong> divides memory into equal-sized partitions, while <strong>variable partitioning</strong> creates partitions of different sizes dynamically based on process requirements. Partitioning allows for multiprogramming by running multiple processes concurrently in different partitions. <strong>Limitation</strong>: Can suffer from internal fragmentation (in fixed partitioning) or external fragmentation (in variable partitioning), and memory utilization might not be optimal.</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Overlaying</strong> is a technique to run programs larger than physical memory by loading segments on demand, managed by the programmer, while <strong>partitioning</strong> divides memory into sections to run multiple programs concurrently, managed by the OS, and limited by total memory size.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (4 marks)</h3>
<div class="question-content">
<p>Mercy, an intern student was required to discuss examples of file operations during a job interview. Outline four examples that she could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Create</strong>: The <strong>create</strong> operation is used to <strong>make a new file</strong> in the file system. It involves allocating storage space for the file, creating a directory entry with the file name, and setting initial file attributes (e.g., permissions, timestamps). Creating a file is the first step to store data in the file system.</p>
<p data-number="2"><strong>Read</strong>: The <strong>read</strong> operation is used to <strong>retrieve data from an existing file</strong>. It involves accessing the file's data blocks from storage and transferring the data to memory for processing. Read operations are fundamental for accessing and using the information stored in files.</p>
<p data-number="3"><strong>Write</strong>: The <strong>write</strong> operation is used to <strong>store data into a file</strong>. It involves transferring data from memory to the file's data blocks on storage. Write operations are essential for creating, modifying, and updating file content.</p>
<p data-number="4"><strong>Delete</strong>: The <strong>delete</strong> operation is used to <strong>remove a file</strong> from the file system. It involves freeing up the storage space occupied by the file and removing the directory entry associated with the file. Deleting files is necessary for managing storage space and removing outdated or unnecessary files.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (4 marks)</h3>
<div class="question-content">
<p>Sayd Company Ltd. intends to replace its single-processor operating system. Outline four limitations of the existing operating system that could have influenced the decision.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Limited Performance Scaling</strong>: Single-processor operating systems are inherently limited in their ability to scale performance with increasing workloads. As demand grows, a single CPU can become a bottleneck, restricting overall system throughput and responsiveness. This limitation is significant for companies with growing computational needs.</p>
<p data-number="2"><strong>Lack of True Concurrency</strong>: Single-processor systems achieve concurrency through time-sharing, rapidly switching between processes. However, they cannot execute multiple processes truly simultaneously. For applications requiring parallel processing or real-time responsiveness, this lack of true concurrency can be a major limitation.</p>
<p data-number="3"><strong>Single Point of Failure for CPU</strong>: In a single-processor system, the CPU is a single point of failure. If the CPU fails, the entire system becomes inoperable. This lack of redundancy can be a critical concern for business continuity and system reliability, especially for critical operations.</p>
<p data-number="4"><strong>Inefficient Resource Utilization for Multitasking</strong>: While single-processor systems can multitask, they might not efficiently utilize resources when running multiple demanding applications concurrently. Context switching overhead and contention for the single CPU can lead to performance degradation and inefficient resource utilization compared to multiprocessor systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (6 marks)</h3>
<div class="question-content">
<p>Claudius was required to list advantages of dynamic linking in memory management. Explain three advantages that he is likely to have listed.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Reduced Memory Footprint</strong>: <strong>Dynamic linking</strong> allows multiple programs to <strong>share a single copy of library code</strong> in memory. When programs use shared libraries, only one instance of the library needs to be loaded into memory, regardless of how many programs use it. This significantly reduces the overall memory footprint, especially when many programs utilize common libraries. Reduced memory usage can lead to better system performance and increased process capacity.</p>
<p data-number="2"><strong>Easier Library Updates and Maintenance</strong>: Dynamic linking simplifies <strong>library updates and maintenance</strong>. When a shared library is updated (e.g., for bug fixes or feature enhancements), the updated library can be replaced without needing to recompile or relink applications that use it. Applications will automatically use the updated library the next time they are run. This simplifies software distribution, patching, and maintenance, reducing administrative overhead.</p>
<p data-number="3"><strong>Smaller Executable Size</strong>: Executables that use dynamic linking are <strong>smaller in size</strong> compared to statically linked executables. This is because they do not include the library code within themselves. Instead, they only contain references or links to the shared libraries. Smaller executables save disk space, reduce download times, and improve program loading speed. This is beneficial for storage efficiency and faster application launch times.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define the term programmable interval timer as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Programmable Interval Timer (PIT)</strong>:</p>
<p>A <strong>programmable interval timer (PIT)</strong> is a hardware component in a computer system that generates <strong>periodic interrupts</strong> at programmable intervals. The operating system can program the timer to trigger interrupts after a specified duration. PITs are crucial for time-keeping, process scheduling, and implementing time-based functionalities in operating systems. They provide a reliable and precise source of timing signals for system operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Outline four services that could be provided by I/O subsystem kernel.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Device Management</strong>: The I/O subsystem kernel manages <strong>device drivers</strong>, which are software modules that control specific hardware devices. This includes loading and unloading drivers, configuring devices, and handling device initialization and shutdown. Device management ensures that the operating system can communicate with and control various I/O devices.</p>
<p data-number="2"><strong>Buffering and Caching</strong>: The kernel provides <strong>buffering and caching services</strong> for I/O operations. Buffering temporarily stores data being transferred between devices and memory to handle speed mismatches and improve efficiency. Caching stores frequently accessed data in memory to reduce the need for repeated slow I/O operations. These techniques enhance I/O performance and system responsiveness.</p>
<p data-number="3"><strong>Spooling (Simultaneous Peripheral Operations On-Line)</strong>: The I/O subsystem kernel often provides <strong>spooling services</strong>, particularly for output devices like printers. Spooling queues output requests and manages the printing process in the background, allowing applications to continue execution without waiting for I/O completion. Spooling improves system concurrency and user productivity.</p>
<p data-number="4"><strong>Error Handling and Recovery</strong>: The kernel's I/O subsystem is responsible for <strong>detecting and handling errors</strong> during I/O operations. This includes error detection, error reporting, and implementing recovery mechanisms, such as retries or device reset. Robust error handling is crucial for data integrity and system reliability in I/O operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (8 marks)</h3>
<div class="question-content">
<p>Explain four circumstances that would necessitate premature termination of a process execution in an operating system</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Error Condition/Exception</strong>: If a process encounters a <strong>fatal error</strong> or an unrecoverable exception during execution, the operating system may terminate it prematurely. Examples include <strong>division by zero</strong>, <strong>illegal memory access</strong> (segmentation fault), or <strong>invalid instruction</strong>. These errors indicate that the process cannot continue execution safely or correctly, and termination is necessary to prevent system instability or data corruption. The OS typically logs the error and may provide diagnostic information.</p>
<p data-number="2"><strong>Resource Unavailability</strong>: If a process requests a <strong>resource that is not available</strong> and cannot be granted, and if the process cannot proceed without that resource, the operating system might terminate it. This can occur in situations of <strong>resource deadlock</strong> or when system resources are exhausted. For instance, if a process requests more memory than is available, or if it is waiting indefinitely for a resource held by another deadlocked process, termination might be the only way to resolve the situation and free up resources.</p>
<p data-number="3"><strong>Time Limit Exceeded</strong>: Operating systems often impose <strong>time limits</strong> on process execution, especially in time-sharing or real-time systems. If a process exceeds its allocated CPU time or runtime limit, the operating system may terminate it to enforce fairness, prevent monopolization of resources, or meet real-time deadlines. This is common in batch processing systems or when implementing quality of service (QoS) policies. The time limit is typically set by the system administrator or process scheduler.</p>
<p data-number="4"><strong>Parent Process Termination</strong>: In a hierarchical process model, if a <strong>parent process terminates</strong>, the operating system may also terminate its child processes. This is to prevent orphaned processes from running without a parent to manage them or reclaim their resources. This ensures proper process lifecycle management and resource cleanup. The termination of child processes upon parent termination can be a default behavior or configurable based on system policies.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (6 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the parts of a magnetic disk</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A magnetic disk is composed of several key parts working together to store and retrieve data. While a true "diagram" cannot be rendered here, we can describe the conceptual layout and components.</p>
<p><strong>Conceptual Diagram of Magnetic Disk Parts</strong>:</p>
<pre>                    +-----------------------+     +-----------------------+     +-----------------------+
                    | Platter(s)             | --&gt; | Track(s)              | --&gt; | Sector(s)             |
                    +-----------------------+     +-----------------------+     +-----------------------+
                         ^                             ^                             ^
                         |                             |                             |
                         +-----------------------+     +-----------------------+     +-----------------------+
                         | Read/Write Head(s)     |     | Cylinder(s)           |     | Inter-sector Gap      |
                         +-----------------------+     +-----------------------+     +-----------------------+
                               ^
                               |
                         +-----------------------+
                         | Actuator Arm          |
                         +-----------------------+
                    </pre>
<p><strong>Description of Parts</strong>:</p>
<p><strong>Platter(s)</strong>: Magnetic disks consist of one or more <strong>platters</strong>, which are circular disks coated with a magnetic material. Data is stored magnetically on the surfaces of these platters. Platters spin at a constant speed, enabling read/write operations.</p>
<p><strong>Read/Write Head(s)</strong>: Each platter surface has a corresponding <strong>read/write head</strong>, which is used to write data to and read data from the disk surface. Heads are positioned very close to the platter surface but do not touch it during normal operation. Heads are attached to an actuator arm.</p>
<p><strong>Actuator Arm</strong>: The <strong>actuator arm</strong> moves the read/write heads across the platters to position them over the desired track or cylinder. The actuator arm is controlled by the disk controller and is responsible for seek operations.</p>
<p><strong>Track(s)</strong>: Each platter surface is divided into concentric circles called <strong>tracks</strong>. Data is recorded serially along these tracks. Tracks are numbered starting from the outer edge of the platter (track 0) inwards.</p>
<p><strong>Cylinder(s)</strong>: A <strong>cylinder</strong> is a set of tracks that are in the same vertical position across all platters. If a disk has multiple platters, tracks at the same radial distance from the center on each platter form a cylinder. Cylinders are a logical grouping of tracks used for addressing and data organization.</p>
<p><strong>Sector(s)</strong>: Each track is further divided into <strong>sectors</strong>, which are the smallest units of data storage on a disk, typically 512 bytes or 4KB in size. Sectors are where actual data is stored. Sectors are addressed by track and sector number.</p>
<p><strong>Inter-sector Gap</strong>: <strong>Inter-sector gaps</strong> are small spaces between sectors on a track. These gaps are used for synchronization, error correction codes, and sector identification information. They separate sectors and help the disk controller in reading and writing data reliably.</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer>© 2023 [Your University/College Name]</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="novemeber_2014.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2013.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>