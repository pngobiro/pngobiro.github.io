<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>July 2013 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-15"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li id="active"><a href="july_2013.html" class="active no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="november_2013.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2012.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">July 2013</h1></header>
<article class="iDevice_wrapper textIdevice" id="id15">
<div class="iDevice emphasis0" >
<div id="ta15_137_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: July 2013</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain cach of the following terms as used in memory management:</p>
<p>(i) caching:</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Caching</strong> in memory management is a technique used to improve system performance by storing frequently accessed data in a <strong>smaller, faster memory</strong> called a <strong>cache</strong>. When the CPU needs to access data, it first checks the cache. If the data is present (a <strong>cache hit</strong>), it is accessed from the cache, which is much faster than accessing main memory. If the data is not in the cache (a <strong>cache miss</strong>), it is retrieved from main memory and also copied into the cache for future accesses. Caching leverages the principle of locality to reduce average memory access time.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain cach of the following terms as used in memory management:</p>
<p>(ii) trashing.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Thrashing</strong> in memory management is a state where the system spends most of its time <strong>swapping pages</strong> between main memory and secondary storage (disk), with very little productive work being done. This occurs when the degree of multiprogramming is too high, and processes do not have enough physical memory to hold their working sets. As a result, excessive page faults occur, leading to high disk I/O activity and a significant decrease in system performance and CPU utilization. The system becomes inefficient as it is constantly busy swapping pages rather than executing processes.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (i) (3 marks)</h3>
<div class="question-content">
<p>Two processes A and B are to be executed in a uni-processor computer. When one of the processes is being executed the other cannot proceed because of common set of data.</p>
<p>(i) Describe the section of memory depicted in the scenario.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The section of memory depicted in the scenario is the <strong>critical section</strong>. This is a segment of code that accesses <strong>shared resources</strong>, in this case, a "common set of data". When one process (A or B) is executing within its critical section, accessing and potentially modifying the shared data, the other process is prevented from entering its own critical section that operates on the same data. This mutual exclusion ensures that <strong>data consistency is maintained</strong> and race conditions are avoided. Only one process can be active in the critical section at any given time.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (ii) (3 marks)</h3>
<div class="question-content">
<p>Two processes A and B are to be executed in a uni-processor computer. When one of the processes is being executed the other cannot proceed because of common set of data.</p>
<p>(ii) A student observed that each time the processes were executed, different results were produced. Describe the condition that could lead to this observation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The condition that could lead to different results each time the processes are executed is a <strong>race condition</strong>. This occurs when the <strong>outcome of the execution depends on the specific order</strong> in which the instructions from processes A and B are interleaved when accessing and manipulating the shared data in the critical section. If the processes are not properly synchronized, the final value of the shared data can vary depending on which process completes its operations first or which process's instructions are executed at a particular moment. This <strong>unpredictability</strong> in execution order results in <strong>inconsistent and variable outputs</strong> across different runs.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (4 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the two-level directory logical structure.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The <strong>two-level directory structure</strong> is a file system organization method that introduces a hierarchy to manage files, overcoming limitations of a single-level directory. It consists of a <strong>root directory</strong> and <strong>user directories</strong>.</p>
<p><strong>Diagram of Two-Level Directory Structure:</strong></p>
<pre>                    +-------------------+
                    |    Root Directory   |
                    +-------------------+
                    |       / \         |
                    |        |          |
                    +--------+----------+
                    | User Directory 1 |  User Directory 2  |  User Directory 3 ...
                    +-------------------+-------------------+-------------------
                    | File 1.1 | File 1.2 |  File 2.1 | File 2.2 |  File 3.1 ...
                    +----------+----------+----------+----------+----------+
                    </pre>
<p><strong>Description:</strong></p>
<p>At the top is the <strong>root directory</strong>, which is the main directory. Underneath the root directory, each user has their own <strong>user directory</strong>. Each user directory acts as a private directory for that specific user, containing all of their files. Users can create, delete, and manage their files within their own user directories. File names only need to be unique within each user directory, resolving naming conflicts that occur in single-level directories. To access a file, a <strong>two-part path name</strong> is used, specifying the user directory and the file name (e.g., /UserDir/FileName). This structure provides better organization and isolation compared to a single flat directory.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>(i) Outline two functions of the clock software as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Timekeeping</strong>: The clock software is responsible for maintaining the <strong>current time and date</strong> of the system. It updates the system clock at regular intervals based on hardware timer interrupts. This function is crucial for providing timestamps for files, scheduling events, and tracking system uptime.</p>
<p data-number="2"><strong>Process Scheduling</strong>: The clock software is used for <strong>time-slicing in preemptive scheduling algorithms</strong> like Round Robin. It generates timer interrupts that signal the operating system to switch between processes, ensuring fair CPU allocation and enabling multitasking. The timer interrupts trigger the scheduler to regain control and allocate the CPU to another process, preventing any single process from monopolizing the CPU.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between dumb and intelligent terminal as used in computer hardware.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Dumb Terminal</strong>:</p>
<p>A <strong>dumb terminal</strong> is a basic type of terminal that primarily functions as an <strong>input/output device</strong>. It has very limited processing capabilities and relies entirely on a host computer for processing. Dumb terminals can send user input (keyboard strokes) to the host and display output (text and simple graphics) received from the host. They lack local processing power, memory, and storage. Examples include older text-based terminals used with mainframe computers. <strong>Key features</strong>: Low cost, simple functionality, no local processing, relies on host for all operations.</p>
<p><strong>Intelligent Terminal</strong>:</p>
<p>An <strong>intelligent terminal</strong>, also known as a smart terminal, has its own <strong>processing capabilities</strong>, memory, and can perform some processing tasks independently of the host computer. Unlike dumb terminals, intelligent terminals can execute some applications locally, perform data validation, or format data before sending it to the host. They can also store data and run simple programs. Modern personal computers can act as intelligent terminals when connected to a server. <strong>Key features</strong>: Higher cost, local processing power, memory, can run applications independently, reduces load on host, more functionality compared to dumb terminals.</p>
<p><strong>Key Difference</strong>:</p>
<p>The main difference is in their <strong>processing capability</strong>. Dumb terminals are essentially just display and input devices with no local processing, while intelligent terminals have their own processing power and can perform tasks independently, reducing the workload on the central host computer.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (1 mark)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>(i) time sharing;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Time sharing</strong> is an operating system technique that allows <strong>multiple users to simultaneously share a computer system</strong>. It achieves this by rapidly switching the CPU between different processes, giving each user a small time slice of CPU time. This creates the illusion that each user has exclusive use of the computer, even though they are all using the same system concurrently.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (1 mark)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>(ii) system call;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>system call</strong> is a <strong>request from a user-level process to the operating system kernel</strong> to perform a privileged operation. It is the interface through which processes can request services from the kernel, such as I/O operations, process management, and memory allocation. System calls are essential for user programs to interact with the operating system and access system resources in a controlled and secure manner.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (iii) (1 mark)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems:</p>
<p>(iii) thread.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>thread</strong> is a <strong>lightweight unit of execution within a process</strong>. It is a single sequential flow of control within a program. Multiple threads can exist within the same process and share the process's resources such as memory space, code, and data segments. Threads enable concurrency within a process, allowing for parallel execution of different parts of a program and improving responsiveness and efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (i) (4 marks)</h3>
<div class="question-content">
<p>A hard disk with 255 tracks received requests from the disk controller for data in tracks 40, 67, 11, 240 and 87 in that order respectively. Assuming the head is currently located at track 45.</p>
<p>(i) Sketch the order in which C-SCAN scheduling algorithm will service the requests.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The <strong>C-SCAN (Circular SCAN)</strong> algorithm services requests by moving the disk head in one direction (e.g., from lower to higher track numbers), servicing requests along the path. When it reaches the highest track, it quickly returns to the lowest track without servicing any requests and starts scanning again in the same direction.</p>
<p><strong>Initial Head Position:</strong> 45</p>
<p><strong>Requests:</strong> 40, 67, 11, 240, 87</p>
<p><strong>Tracks in order (ascending):</strong> 11, 40, 67, 87, 240</p>
<p><strong>C-SCAN Service Order Sketch:</strong></p>
<pre>                    Head movement direction: Ascending track numbers

                    1. Start at 45. Move upwards servicing requests in order:
                       - Service 67 (Track 67)
                       - Service 87 (Track 87)
                       - Service 240 (Track 240)

                    2. Reach highest track (255). Rapidly return to lowest track (0) without servicing.

                    3. Start scanning upwards again from lowest track (0), servicing remaining requests:
                       - Service 11 (Track 11)
                       - Service 40 (Track 40)

                    C-SCAN Service Order: 67 -&gt; 87 -&gt; 240 -&gt; (Return to 0) -&gt; 11 -&gt; 40
                    </pre>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>A hard disk with 255 tracks received requests from the disk controller for data in tracks 40, 67, 11, 240 and 87 in that order respectively. Assuming the head is currently located at track 45.</p>
<p>(ii) Determine the total seek distance in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on the C-SCAN service order determined in (i): 67 -&gt; 87 -&gt; 240 -&gt; (Return to 0) -&gt; 11 -&gt; 40</p>
<p><strong>Seek Distances Calculation:</strong></p>
<p>1. From 45 to 67: |67 - 45| = 22 tracks</p>
<p>2. From 67 to 87: |87 - 67| = 20 tracks</p>
<p>3. From 87 to 240: |240 - 87| = 153 tracks</p>
<p>4. From 240 to 0 (Return to track 0): |0 - 240| = 240 tracks</p>
<p>5. From 0 to 11: |11 - 0| = 11 tracks</p>
<p>6. From 11 to 40: |40 - 11| = 29 tracks</p>
<p><strong>Total Seek Distance:</strong> 22 + 20 + 153 + 240 + 11 + 29 = <strong>475 tracks</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (i) (4 marks)</h3>
<div class="question-content">
<p>Two processes Pl and P2 are running in a CPU as outlined:</p>
<p>- P1 requests for a resource R1 and P2 requests for a resource R2. Both the resources are available and they are allocated to the requesting process.</p>
<p>- Later process P1 requests for R2 held by P2 and P2 requests for R1 held by P1.</p>
<p>(i) Draw a resource allocation graph to represent this scenario.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Resource Allocation Graph:</strong></p>
<pre>                    Processes: P1, P2
                    Resources: R1, R2

                    Nodes:
                    - Circles represent processes (P1, P2)
                    - Squares represent resources (R1, R2)

                    Edges:
                    - Request edge: Process -&gt; Resource (e.g., P1 -&gt; R2 means P1 is requesting R2)
                    - Allocation edge: Resource -&gt; Process (e.g., R1 -&gt; P1 means R1 is allocated to P1)

                    Graph:

                    +-----+      +-----+
                    |  R1 |-----&gt;|  P1 |-------&gt;|  R2 |
                    +-----+      +-----+      +-----+
                                    ^            |
                                    |            |
                                    +------------+
                                    Request Edge (P2 requesting R1)

                    Legend:
                    -----&gt; Allocation Edge
                    -------&gt; Request Edge
                    </pre>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (ii) (1 mark)</h3>
<div class="question-content">
<p>Two processes Pl and P2 are running in a CPU as outlined:</p>
<p>- P1 requests for a resource R1 and P2 requests for a resource R2. Both the resources are available and they are allocated to the requesting process.</p>
<p>- Later process P1 requests for R2 held by P2 and P2 requests for R1 held by P1.</p>
<p>(ii) State the condition depicted by the graph in (1).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The condition depicted by the graph in (i) is <strong>deadlock</strong>. The graph shows a <strong>circular wait</strong> condition: P1 is waiting for R2 which is held by P2, and P2 is waiting for R1 which is held by P1. This creates a cycle of dependencies where neither process can proceed, resulting in a deadlock situation.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>A student created a file in her new computer to store project work.</p>
<p>(i) Outline four file attributes that could be incorporated in the file.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Name</strong>: A <strong>name</strong> for the file to identify and access it, e.g., "ProjectReport.docx".</p>
<p data-number="2"><strong>Size</strong>: The <strong>size</strong> of the file, indicating the amount of storage space it occupies, e.g., 50KB.</p>
<p data-number="3"><strong>Type</strong>: The <strong>type or extension</strong> of the file, indicating the file format, e.g., ".docx" for a Word document.</p>
<p data-number="4"><strong>Permissions</strong>: <strong>Access permissions</strong> to control who can read, write, or execute the file, e.g., read/write for owner, read-only for others.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (ii) (2 marks)</h3>
<div class="question-content">
<p>A student created a file in her new computer to store project work.</p>
<p>(ii) State two mechanisms that she could use to protect the file against unauthorized access.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Access Control Lists (ACLs) or File Permissions</strong>: Set appropriate <strong>file permissions</strong> to restrict access to the file. The student can configure permissions so that only her user account has read and write access, while other users have no access or read-only access. This prevents unauthorized users from modifying or deleting the file.</p>
<p data-number="2"><strong>Password Protection or Encryption</strong>: <strong>Password protect</strong> the file using software features (e.g., password protection in document editing software) or <strong>encrypt</strong> the file using encryption tools. Password protection requires a password to open the file, while encryption scrambles the file content, making it unreadable without the decryption key. Both mechanisms add a layer of security to prevent unauthorized access, even if someone gains physical access to the computer.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (iii) (2 marks)</h3>
<div class="question-content">
<p>A student shares the computer with two of her colleagues. Explain a tool that could be used to monitor the computer usage.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A tool that could be used to monitor computer usage is an <strong>activity monitor or system monitor</strong>. Operating systems typically include built-in tools like <strong>Task Manager (Windows)</strong> or <strong>Activity Monitor (macOS)</strong>. These utilities display real-time information about system resource usage, including CPU usage, memory usage, disk I/O, and network activity, broken down by process. By checking these monitors, the student can track which applications are running, how much resources each user or process is consuming, and identify potential performance bottlenecks or unusual activity.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four technical factors that should be considered when choosing I/O devices.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Data Transfer Rate/Speed</strong>: The <strong>speed at which the I/O device can transfer data</strong> is a critical factor. Different devices offer varying data transfer rates (e.g., Mbps, Gbps for network cards, MB/s, GB/s for storage devices). The required data transfer rate depends on the application's needs. For example, high-performance applications like video editing or databases require fast storage devices, while basic text editing needs less demanding I/O.</p>
<p data-number="2"><strong>Latency</strong>: <strong>Latency</strong> refers to the delay between initiating an I/O request and the start of the actual data transfer. Lower latency is crucial for interactive applications and real-time systems where quick response is essential. Devices like SSDs have significantly lower latency compared to HDDs, making them suitable for applications requiring rapid access. For devices like network interfaces, latency affects network responsiveness.</p>
<p data-number="3"><strong>Throughput</strong>: <strong>Throughput</strong> measures the amount of data an I/O device can transfer per unit of time. Higher throughput is desirable for applications that involve bulk data transfer, such as file copying, backups, or video streaming. Device throughput is limited by factors like interface bandwidth, device speed, and controller efficiency. For storage devices, throughput affects file read/write speeds; for network devices, it dictates network bandwidth.</p>
<p data-number="4"><strong>Interface and Compatibility</strong>: The <strong>interface type</strong> (e.g., USB, SATA, PCIe, Ethernet) and <strong>compatibility</strong> of the I/O device with the computer system are crucial. The interface must be supported by the motherboard and system bus. Compatibility ensures that the device can physically connect, communicate, and function correctly with the system. Interface standards dictate data transfer protocols, connectors, and power requirements. Choosing a device with a compatible and appropriate interface is essential for proper operation.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the effect of buffering on the performance of each of the following devices:</p>
<p>(i) mouse;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>For a <strong>mouse</strong>, buffering has a minimal direct effect on performance noticeable to the user. Mouse input events (movements, clicks) are typically generated at a relatively slow rate compared to the CPU and memory speeds. Buffering might be used at a low level to collect mouse events before they are processed, but the buffering <strong>does not significantly impact the perceived responsiveness or performance</strong> of the mouse from a user perspective. The primary focus for mouse performance is low latency and accurate tracking, not buffering.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain the effect of buffering on the performance of each of the following devices:</p>
<p>(ii) graphic card.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>For a <strong>graphic card</strong>, buffering plays a significant role in performance. Graphic cards use <strong>frame buffers</strong> to store rendered frames before displaying them on the screen. <strong>Double buffering or triple buffering</strong> techniques, which involve using multiple frame buffers, are employed to prevent screen tearing and improve visual smoothness. Buffering allows the graphics card to prepare the next frame while the current frame is being displayed, leading to smoother animations and video playback. <strong>Buffering helps to decouple the rendering rate from the display refresh rate</strong>, resulting in a more consistent and visually appealing output. It enhances the perceived performance by reducing visual artifacts and improving frame delivery.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following following file organization techniques.</p>
<p>(i) sequential;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Sequential file organization</strong> stores records in a <strong>linear sequence</strong>, one after another, in the order they were entered. Records are accessed in the same sequential order, starting from the beginning of the file. To access a specific record, one must read through all preceding records. This method is simple to implement and efficient for applications that process data in a fixed order, such as batch processing or reading log files. However, it is <strong>inefficient for random access</strong>, as it requires sequential searching to find a specific record.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following following file organization techniques.</p>
<p>(ii) random.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Random file organization</strong>, also known as <strong>direct file organization</strong>, allows records to be accessed in <strong>any order, directly</strong>, without needing to read through preceding records. This is achieved by using a <strong>key or record number</strong> to directly calculate the physical location of a record on disk. Techniques like hashing or indexing are used to map keys to disk addresses. Random file organization is efficient for applications that require frequent random access to records, such as databases, indexed file systems, and interactive applications. It provides fast access to specific records but is more complex to implement than sequential organization.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between layered and client/server Operating System structures.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Layered Operating System Structure</strong>:</p>
<p>A <strong>layered operating system structure</strong> organizes the OS into a <strong>hierarchy of layers</strong>, where each layer provides services to the layer above it and uses services from the layer below it. Layer 0 is the hardware, and the highest layer is the user interface. Each layer is relatively independent and performs a well-defined set of functions. Communication between layers occurs through defined interfaces. <strong>Advantages</strong> include modularity, simplified design and debugging, and ease of maintenance. <strong>Disadvantages</strong> can include performance overhead due to layer interactions and difficulty in strictly defining layer boundaries. Example: Traditional Unix-like systems, though modern OSes often blend layered and modular approaches.</p>
<p><strong>Client-Server Operating System Structure</strong>:</p>
<p>A <strong>client-server operating system structure</strong> distinguishes between <strong>servers</strong>, which provide services, and <strong>clients</strong>, which request and use those services. The kernel is often reduced to a <strong>microkernel</strong>, providing only essential core functionalities like process management and IPC. Most OS services (file system, networking, device drivers) are implemented as user-level servers running on top of the microkernel. Clients and servers communicate via message passing. <strong>Advantages</strong> include modularity, extensibility, fault isolation (server failure less likely to crash the kernel), and adaptability to distributed systems. <strong>Disadvantages</strong> can include performance overhead due to message passing between clients and servers and complexity in designing microkernel and server interactions. Example: Mach, MINIX 3, and modern macOS and Windows kernels (hybrid microkernels).</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Layered structure</strong> is based on hierarchical levels of abstraction and service provision within a monolithic kernel, while <strong>client-server structure</strong> separates services into independent user-level servers communicating with clients through a minimal microkernel. Layered is more monolithic, client-server is more modular and distributed.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Most multiprogrammed systems are designed such that user programs access memory through virtual addresses and the operating system through physical addresses. Explain two implications of this design on the initiation of I/O operations by the user program.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Need for Address Translation for I/O Buffers</strong>: When a user program initiates an I/O operation (e.g., reading from a file), it typically specifies <strong>virtual addresses for I/O buffers</strong> where data will be read into or written from. Since I/O devices and the kernel operate with physical addresses, the operating system must perform <strong>address translation</strong> to convert these virtual buffer addresses to corresponding physical addresses. This translation is necessary for the kernel to correctly access the user program's buffers in physical memory and transfer data between the I/O device and the program's memory space. Address translation adds an extra step in the I/O path but is essential for memory protection and virtual memory management.</p>
<p data-number="2"><strong>Kernel Involvement in I/O Operations</strong>: The separation of virtual and physical addresses reinforces the operating system's <strong>role as an intermediary for I/O operations</strong>. User programs cannot directly access physical memory or I/O devices using virtual addresses. Instead, they must make <strong>system calls</strong> to request I/O operations. The kernel, running in privileged mode and using physical addresses, handles the actual interaction with I/O devices on behalf of the user program. This design ensures <strong>system security and resource management</strong>, as the kernel controls and validates all I/O requests, preventing unauthorized or direct hardware access by user-level programs. It enforces protection and abstraction in I/O operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four file operations used in file management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Create</strong>: The <strong>create</strong> operation is used to <strong>make a new file</strong>. It involves allocating storage space, creating a directory entry with the file's name, and setting initial file attributes.</p>
<p data-number="2"><strong>Read</strong>: The <strong>read</strong> operation retrieves <strong>data from a file</strong>. It involves accessing the file's content from storage and transferring it to memory.</p>
<p data-number="3"><strong>Write</strong>: The <strong>write</strong> operation <strong>stores data into a file</strong>. It involves transferring data from memory to the file's storage space, potentially creating or modifying the file's content.</p>
<p data-number="4"><strong>Delete</strong>: The <strong>delete</strong> operation <strong>removes a file</strong>. It involves freeing up the storage space occupied by the file and removing its directory entry, making the file no longer accessible.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in memory management</p>
<p>(i) swapping:</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Swapping</strong> is a memory management technique used to increase the degree of multiprogramming by moving processes between main memory (RAM) and secondary storage (disk). When memory becomes full, the operating system <strong>swaps out</strong> a process that is not currently active from RAM to disk (swap space). Later, when that process needs to be executed again, it is <strong>swapped in</strong> back into RAM from the disk. Swapping allows more processes to be ready to run than can fit in RAM at once, but it introduces overhead due to disk I/O operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in memory management</p>
<p>(ii) overlaying;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Overlaying</strong> is a memory management technique used in older systems to run programs larger than the available physical memory. It involves dividing a program into <strong>overlays</strong>, where only the overlay currently needed is loaded into memory. When a different overlay is required, the current one is replaced (overlaid) with the new one. Overlaying is programmer-managed, requiring careful program design to fit within limited memory. It is less common in modern systems with virtual memory.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (iii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in memory management</p>
<p>(iii) paging.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Paging</strong> is a memory management technique that divides both physical memory (RAM) and logical memory (process address space) into <strong>fixed-size blocks called pages and frames</strong>, respectively. Processes are divided into pages, and these pages are loaded into available frames in RAM. Pages of a process can be non-contiguous in RAM. A <strong>page table</strong> maps virtual page numbers to physical frame numbers. Paging allows for efficient memory utilization and eliminates external fragmentation, enabling virtual memory implementation.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (6 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the structure of I/O software.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The <strong>structure of I/O software</strong> in an operating system is typically layered to provide abstraction, modularity, and device independence. It can be visualized in terms of layers, from user applications down to the hardware devices.</p>
<p><strong>Diagram of I/O Software Structure:</strong></p>
<pre>                    +-----------------------+  Layer 4: User-Level I/O
                    | User Applications     |  (e.g., Standard Library I/O functions)
                    +-----------------------+
                    | System Call Interface |  (e.g., read(), write(), open())
                    +-----------------------+  Layer 3: Device-Independent OS I/O
                    | Device-Independent    |  (Common I/O services, buffering, caching, naming)
                    | I/O Subsystem         |
                    +-----------------------+
                    | Device Driver Interface|  (Standard interface for device drivers)
                    +-----------------------+  Layer 2: Device Drivers
                    | Device Drivers        |  (Device-specific control, interrupt handling)
                    | (per device type)     |
                    +-----------------------+
                    | Hardware Interface    |  (Registers, command queues)
                    +-----------------------+  Layer 1: Hardware Controllers
                    | I/O Controllers       |  (Disk controller, network adapter, etc.)
                    +-----------------------+
                    | Physical I/O Device   |  Layer 0: I/O Hardware
                    +-----------------------+
                    </pre>
<p><strong>Description of Layers:</strong></p>
<p><strong>Layer 4: User-Level I/O</strong>: This is the <strong>highest layer</strong>, consisting of user applications that perform I/O operations through standard library functions (e.g., `stdio` in C). These functions provide a high-level, device-independent interface to applications.</p>
<p><strong>Layer 3: Device-Independent OS I/O</strong>: This layer provides a <strong>device-independent interface</strong> to the layers above and manages common I/O functionalities. It includes the <strong>system call interface</strong> that user programs use to request I/O operations. It also handles buffering, caching, spooling, device naming, and protection, providing a uniform view of I/O to user programs regardless of the specific hardware.</p>
<p><strong>Layer 2: Device Drivers</strong>: <strong>Device drivers</strong> are <strong>device-specific software modules</strong> that control and manage particular types of I/O devices. Each type of device (e.g., disk, printer, network card) has its own driver. Drivers translate device-independent requests from the OS I/O subsystem into device-specific commands that the hardware controller understands. They handle hardware-level operations, interrupt handling, and data transfer for their respective devices.</p>
<p><strong>Layer 1: Hardware Controllers</strong>: <strong>I/O controllers</strong> are hardware components that interface between the CPU and the actual I/O devices. Examples are disk controllers, network interface cards, and USB controllers. They execute commands from device drivers, manage data transfer between devices and memory, and handle low-level device control.</p>
<p><strong>Layer 0: I/O Hardware</strong>: This is the <strong>physical I/O device</strong> itself, such as a hard disk, printer, keyboard, network card, etc. It performs the actual input or output operations.</p>
<p>This layered structure allows for modularity, portability, and device independence. Changes in hardware or device drivers can be made without affecting user applications or higher layers of the OS I/O system.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (i) (3 marks)</h3>
<div class="question-content">
<p>Two processses enter the ready queue of a system with the following properties:</p>
<p>Process 1 needs 8 units of CPU time but after every 2 units, it must perform an I/O. Assume that there is no work to be done following the last I/O operation.</p>
<p>Process 2 needs 20 units of CPU time and it process arrives just after Process1.</p>
<p>Using Round Robin scheduling algorithm with a time slice of 4 units;</p>
<p>(i) Draw a Gantt chart showing the execution of the two processes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Process Properties:</strong></p>
<p>Process 1 (P1): 8 CPU units, I/O after every 2 units.</p>
<p>Process 2 (P2): 20 CPU units, arrives after P1.</p>
<p>Time Slice: 4 units.</p>
<p><strong>Gantt Chart:</strong></p>
<pre>                    Time: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15| 16| 17| 18| 19| 20| 21| 22| 23| 24| 25| 26| 27| 28|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
                    CPU: | P1| P1| I/O|Idle| P1| P1| I/O|Idle| P1| P1| I/O|Idle| P1| P1| I/O|Idle| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
                    Time: 29| 30| 31| 32| 33| 34| 35| 36| 37| 38| 39| 40| 41| 42| 43| 44| 45| 46| 47| 48|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
                    CPU: | P2| P2| P2| P2| P2| P2| P2| P2|      Idle
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---

                    Explanation:
                    0-2: P1 runs for 2 units.
                    2-3: P1 performs I/O (1 unit). CPU Idle.
                    3-5: P1 runs for next 2 units.
                    5-6: P1 performs I/O (1 unit). CPU Idle.
                    6-8: P1 runs for next 2 units.
                    8-9: P1 performs I/O (1 unit). CPU Idle.
                    9-11: P1 runs for last 2 units. P1 finishes after 8 CPU units and 3 I/O units.
                    11-15: P2 runs for time slice of 4 units.
                    15-19: P2 runs for next time slice of 4 units.
                    19-23: P2 runs for next time slice of 4 units.
                    23-27: P2 runs for next time slice of 4 units.
                    27-31: P2 runs for last 4 units. P2 finishes after 20 CPU units.
                    31-48: CPU Idle.
                    </pre>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (ii) (1 mark)</h3>
<div class="question-content">
<p>Two processses enter the ready queue of a system with the following properties:</p>
<p>Process 1 needs 8 units of CPU time but after every 2 units, it must perform an I/O. Assume that there is no work to be done following the last I/O operation.</p>
<p>Process 2 needs 20 units of CPU time and it process arrives just after Process1.</p>
<p>Using Round Robin scheduling algorithm with a time slice of 4 units;</p>
<p>(ii) Determine the completion time for each process.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on the Gantt chart:</p>
<p><strong>Completion Time for Process 1 (P1): 11 units</strong></p>
<p><strong>Completion Time for Process 2 (P2): 31 units</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following memory allocation techniques:</p>
<p>(i) dynamic partitioning;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Dynamic partitioning</strong> is a memory allocation technique where memory partitions are created <strong>dynamically at runtime</strong>, based on the actual memory requirements of processes. When a process arrives, the operating system allocates a partition of exactly the size needed by the process from the available free memory. Partitions are not fixed in size and are created and sized as needed. This reduces internal fragmentation, but can lead to external fragmentation as memory becomes fragmented into smaller, non-contiguous blocks over time.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following memory allocation techniques:</p>
<p>(ii) segmentation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Segmentation</strong> is a memory management technique that divides a process's logical address space into <strong>variable-sized segments</strong>. Each segment corresponds to a logical unit of the program, such as code, data, or stack. Segments are allocated in physical memory as contiguous blocks, but segments of a process may not be contiguous with each other. A <strong>segment table</strong> is used to map segments to their physical memory locations. Segmentation supports logical program structure, facilitates sharing and protection at the segment level, but can suffer from external fragmentation due to variable segment sizes.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (i) (1 mark)</h3>
<div class="question-content">
<p>Joseph would like to replace his computer card reader with a newer version.</p>
<p>(i) Identify a principle in I/O device management that could enable him carry out this task without the programs using it.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The principle in I/O device management that could enable Joseph to replace his card reader without affecting programs is <strong>device independence</strong>.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (ii) (3 marks)</h3>
<div class="question-content">
<p>Joseph would like to replace his computer card reader with a newer version.</p>
<p>(ii) Explain the implementation of the principle identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Implementation of <strong>device independence</strong> involves using <strong>device drivers</strong> and <strong>abstract I/O interfaces</strong> provided by the operating system. When Joseph replaces the card reader, he only needs to <strong>install a new device driver</strong> for the newer card reader. The operating system's I/O subsystem is designed to interact with devices through these drivers, using a standard interface. As long as the new driver correctly implements this interface, user programs, which interact with the OS through device-independent system calls, will continue to work without needing any modifications. The OS handles the device-specific details through the driver, abstracting away the hardware differences from applications.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the effect of each of the following on CPU utilization:</p>
<p>(i) increase main memory capacity;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Increasing main memory capacity</strong> generally leads to <strong>increased CPU utilization</strong>. With more RAM, the operating system can load and keep more processes in memory simultaneously (higher degree of multiprogramming). This reduces the frequency of swapping and paging, as more processes can reside in RAM, reducing disk I/O for virtual memory management. With less time spent on swapping and paging, the CPU spends more time executing process instructions, thus increasing overall CPU utilization and system throughput.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain the effect of each of the following on CPU utilization:</p>
<p>(ii) spooling.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Spooling (Simultaneous Peripheral Operations On-Line)</strong> typically leads to <strong>increased CPU utilization</strong>, especially for I/O-bound operations like printing. Spooling involves buffering output data to a secondary storage device (e.g., disk) instead of directly sending it to a slow output device (e.g., printer). This allows processes to complete their output operations quickly and continue execution without waiting for the slow I/O device. The actual output to the slow device is handled asynchronously in the background by a spooler process, which is typically less CPU-intensive. By offloading and deferring the slow I/O operations, spooling frees up the CPU to perform other computations, thereby increasing overall CPU utilization and system throughput.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Recently, John has realized that his personal computer keeps displaying the message 'your system is getting low on virtual memory'. Describe two ways that he could use to rectify the problem.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Increase RAM (Physical Memory)</strong>: The most effective way to rectify low virtual memory issues is to <strong>increase the amount of physical RAM</strong> installed in the computer. More RAM reduces the reliance on virtual memory by allowing more data and programs to reside in fast RAM, decreasing the need for paging to disk. This directly addresses the root cause of virtual memory exhaustion by providing more actual memory for the system to use. Upgrading RAM is often the best long-term solution for improving performance and resolving low virtual memory warnings.</p>
<p data-number="2"><strong>Increase Paging File Size or Relocate Paging File to a Faster Drive</strong>: John can <strong>increase the size of the paging file</strong> (swap file) on his hard drive. A larger paging file provides more space for virtual memory, allowing the system to swap more data to disk before running out of virtual memory. Alternatively, if possible, <strong>relocating the paging file to a faster storage drive</strong>, such as an SSD, can improve the performance of virtual memory operations. While not as effective as increasing RAM, these adjustments can provide some relief from low virtual memory issues, especially in the short term or on systems where RAM upgrades are not immediately feasible.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (i) (3 marks)</h3>
<div class="question-content">
<p>Outline three advantages of coding operating system programs in a high-level language.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Improved Programmer Productivity and Development Speed</strong>: High-level languages (HLLs) are <strong>easier to learn, write, and debug</strong> compared to low-level languages like assembly language. They provide higher levels of abstraction, allowing programmers to focus on logic rather than low-level hardware details. This leads to <strong>faster development times</strong>, increased programmer productivity, and reduced development costs for operating system components. HLLs simplify complex tasks and allow for quicker prototyping and iteration.</p>
<p data-number="2"><strong>Enhanced Portability and Maintainability</strong>: Operating systems written in HLLs are <strong>more portable</strong> across different hardware architectures. HLL code is less dependent on specific hardware details, making it easier to adapt and port the OS to new platforms. HLL code is also <strong>easier to read, understand, and maintain</strong> compared to assembly code. This simplifies bug fixing, updates, and long-term maintenance of the operating system. Portability and maintainability are crucial for the longevity and adaptability of operating systems.</p>
<p data-number="3"><strong>Access to Advanced Programming Features and Tools</strong>: HLLs offer advanced programming features like <strong>structured programming constructs, data abstraction, object-oriented programming, and automatic memory management</strong>. These features simplify the development of complex operating system functionalities and promote code reusability and modularity. HLLs are also supported by a wide range of <strong>development tools</strong>, such as compilers, debuggers, and IDEs, which further enhance the development process and improve code quality. Using HLLs allows OS developers to leverage modern software engineering practices.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (ii) (3 marks)</h3>
<div class="question-content">
<p>State three types of fifth generation operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>AI-Based Operating Systems</strong>: These operating systems integrate <strong>artificial intelligence (AI) and machine learning (ML)</strong> to enhance system performance, security, and user experience. They can dynamically adapt to user behavior, optimize resource allocation, automate tasks, and provide intelligent assistance. Examples include research OS prototypes incorporating AI scheduling or security mechanisms.</p>
<p data-number="2"><strong>Mobile Operating Systems (Advanced Versions)</strong>: Fifth-generation mobile OSes are characterized by <strong>advanced AI capabilities, enhanced security, and seamless integration</strong> with cloud services and IoT devices. They feature sophisticated voice assistants, predictive functionalities, and context-aware computing. Examples include latest versions of Android and iOS with advanced AI features and ecosystem integrations.</p>
<p data-number="3"><strong>Quantum Operating Systems</strong>: These are emerging operating systems designed to manage and control <strong>quantum computers</strong>. They are fundamentally different from classical OSes, needing to handle quantum bits (qubits), quantum algorithms, and unique quantum computing architectures. Quantum OSes are in early stages of development but are crucial for harnessing the power of quantum computing. Examples are research prototypes and early quantum OS frameworks.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (4 marks)</h3>
<div class="question-content">
<p>Describe two performance overhead associated with servicing an interrupt.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Context Switching Overhead</strong>: Servicing an interrupt requires the operating system to perform a <strong>context switch</strong>. When an interrupt occurs, the CPU must <strong>suspend the currently running process</strong>, save its current state (CPU registers, program counter, etc.), and load the context of the <strong>interrupt handler</strong>. After the interrupt handler finishes, the original process's context needs to be restored to resume its execution. This context switching process takes time and consumes CPU cycles, adding overhead to the system. Frequent interrupts lead to more context switches, increasing this overhead and potentially reducing overall system performance.</p>
<p data-number="2"><strong>Interrupt Handling Latency and Processing Time</strong>: There is <strong>latency</strong> between the occurrence of an interrupt and the start of the interrupt handler execution. This includes the time for the CPU to recognize the interrupt, save the current state, and dispatch the interrupt handler. Additionally, the <strong>interrupt handler itself takes time to execute</strong>. The handler needs to identify the source of the interrupt, perform the necessary actions (e.g., service I/O request, handle error), and acknowledge the interrupt. The total time spent in interrupt handling, including latency and processing time, is overhead. If interrupt handlers are complex or lengthy, they can consume a significant portion of CPU time, impacting system performance and responsiveness, especially if interrupts occur frequently.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Assume a memory management technique of fixed partitions in order of 100K, 500K, 300K and 200K. Four processes of 417K, 195K, 112K and 96K need to be loaded to the memory. Allocate the processes using each of the following placement policies:</p>
<p>(i) Best Fit;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Fixed Partitions:</strong> 100K, 500K, 300K, 200K</p>
<p><strong>Processes:</strong> P1=417K, P2=195K, P3=112K, P4=96K</p>
<p><strong>Best Fit Allocation:</strong></p>
<p>- P1 (417K): Best fit is 500K partition.</p>
<p>- P2 (195K): Best fit among remaining is 200K partition.</p>
<p>- P3 (112K): Best fit among remaining is 300K partition.</p>
<p>- P4 (96K): Cannot fit into the 100K partition.</p>
<p><strong>Allocation:</strong></p>
<p>500K partition: P1 (417K)</p>
<p>200K partition: P2 (195K)</p>
<p>300K partition: P3 (112K)</p>
<p>100K partition: Not used (P4 cannot fit)</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>Assume a memory management technique of fixed partitions in order of 100K, 500K, 300K and 200K. Four processes of 417K, 195K, 112K and 96K need to be loaded to the memory. Allocate the processes using each of the following placement policies:</p>
<p>(ii) First Fit.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Fixed Partitions:</strong> 100K, 500K, 300K, 200K (in order)</p>
<p><strong>Processes:</strong> P1=417K, P2=195K, P3=112K, P4=96K</p>
<p><strong>First Fit Allocation:</strong></p>
<p>- P1 (417K): First fit is 500K partition.</p>
<p>- P2 (195K): First fit among remaining partitions (100K, 300K, 200K) is 300K partition.</p>
<p>- P3 (112K): First fit among remaining partitions (100K, 200K) is 200K partition.</p>
<p>- P4 (96K): First fit among remaining partition (100K) is 100K partition.</p>
<p><strong>Allocation:</strong></p>
<p>500K partition: P1 (417K)</p>
<p>300K partition: P2 (195K)</p>
<p>200K partition: P3 (112K)</p>
<p>100K partition: P4 (96K)</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between logical and physical file systems. (4 marks)</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Logical File System</strong>:</p>
<p>The <strong>logical file system</strong> is the <strong>user's view</strong> of the file system. It defines how files and directories are organized and presented to users and applications. It deals with <strong>logical file and directory structures</strong>, naming conventions, file types, and access methods. The logical file system provides an abstract interface to file operations, hiding the underlying physical storage details from users and programs. Examples include directory hierarchies, file pathnames, and file access permissions as seen by users. The logical file system is concerned with <strong>what data is accessed and how it is logically structured</strong>.</p>
<p><strong>Physical File System</strong>:</p>
<p>The <strong>physical file system</strong> is concerned with the <strong>actual storage and organization of files on physical storage devices</strong> (e.g., hard disks, SSDs). It deals with <strong>physical storage structures</strong> like disk blocks, sectors, clusters, inodes, and file allocation tables. The physical file system manages the allocation and deallocation of storage space, data block management, and physical data access mechanisms. It is responsible for <strong>how data is physically stored and retrieved</strong> from storage devices. Examples include disk formatting, block allocation strategies, and physical addressing of data on disk. The physical file system implements the storage mechanisms that support the logical file system.</p>
<p><strong>Key Distinction</strong>:</p>
<p>The key difference is in their <strong>perspective and level of abstraction</strong>. The <strong>logical file system</strong> is the user-centric, abstract view of files and directories, focusing on organization and access. The <strong>physical file system</strong> is the system-centric, low-level view focusing on the actual physical storage and management of data on storage devices. The logical file system builds upon the physical file system to provide a user-friendly interface for file management.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define the term Direct Memory Access as used in Operating Systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Direct Memory Access (DMA)</strong> is a hardware mechanism that allows certain hardware subsystems (e.g., disk controllers, graphics cards, network cards) to <strong>access system memory (RAM) independently of the CPU</strong>. DMA enables high-speed data transfer between I/O devices and memory without constant CPU intervention. Once a DMA transfer is initiated by the CPU, the DMA controller takes over and transfers data directly, freeing up the CPU to perform other tasks concurrently. DMA is crucial for improving I/O performance and reducing CPU overhead in data transfer operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) Explain one advantage of using memory mapped I/O as opposed to device controller registers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>One advantage of using <strong>memory-mapped I/O</strong> over device controller registers is <strong>simpler programming and unified address space</strong>. In memory-mapped I/O, device registers are mapped into the same address space as system memory. This allows device control and data transfer to be performed using the <strong>same memory access instructions</strong> (load and store) that are used for regular memory access. Programmers do not need to use special I/O instructions; they can interact with devices using standard memory operations, simplifying programming and making device control more integrated with memory operations. This unified address space simplifies hardware and software interaction.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between semaphore and monitor as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Semaphore</strong>:</p>
<p>A <strong>semaphore</strong> is a <strong>lower-level synchronization primitive</strong> used for controlling access to shared resources and process synchronization. It is an integer variable with two atomic operations: <strong>wait (P)</strong> and <strong>signal (V)</strong>. Semaphores can be used to implement mutual exclusion (binary semaphore) or to control access to a limited number of resources (counting semaphore). Semaphores are flexible and can be used to solve a wide range of synchronization problems, but they can be <strong>error-prone</strong> if not used carefully, leading to issues like deadlocks and race conditions. Semaphores manage synchronization at a more basic level, requiring programmers to handle locking and unlocking explicitly.</p>
<p><strong>Monitor</strong>:</p>
<p>A <strong>monitor</strong> is a <strong>higher-level synchronization construct</strong> that provides a structured approach to mutual exclusion and condition synchronization. It is a programming language construct (e.g., in Java, C#) that encapsulates shared data and the operations that can access that data. Only one process can be active within a monitor at any given time, providing <strong>automatic mutual exclusion</strong>. Monitors also provide <strong>condition variables</strong> for processes to wait and signal each other based on specific conditions. Monitors simplify synchronization by encapsulating locking and condition management within a single construct, reducing the chances of synchronization errors compared to raw semaphores. They offer a more structured and safer way to manage concurrent access to shared resources.</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Semaphores</strong> are a more basic, flexible but error-prone synchronization primitive, requiring explicit lock management. <strong>Monitors</strong> are a higher-level, structured, and safer construct that provides automatic mutual exclusion and condition variables, simplifying concurrent programming and reducing synchronization errors.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (i) (4 marks)</h3>
<div class="question-content">
<p>Citing an example in each case, distinguish between reusable and consumable resources as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Reusable Resources</strong>:</p>
<p><strong>Reusable resources</strong> are resources that can be used by <strong>only one process at a time</strong> and can be reused by other processes after the current process releases them. These resources are not depleted or destroyed by their use. <strong>Example: CPU time.</strong> CPU time is a reusable resource because only one process can use the CPU at any given instant, but after a process's time slice is over, or it voluntarily releases the CPU, the CPU resource becomes available and can be reused by another process. The CPU itself is not consumed or altered by the processes using it; it is reused repeatedly by different processes over time.</p>
<p><strong>Consumable Resources</strong>:</p>
<p><strong>Consumable resources</strong> are resources that are <strong>created by one process and consumed by another process</strong>. Once a consumable resource is used, it is no longer available. <strong>Example: Messages in a message queue.</strong> When a process sends a message to another process using message passing, the message is a consumable resource. The sending process creates the message, and the receiving process consumes it by receiving and processing it. Once the message is received, it is no longer available for further consumption. Consumable resources are typically used for communication and synchronization between processes.</p>
<p><strong>Key Distinction</strong>:</p>
<p>The key difference lies in their <strong>lifecycle and reusability</strong>. <strong>Reusable resources</strong> are persistent and can be reused by multiple processes over time, while <strong>consumable resources</strong> are transient, created and then used up, serving as a means of communication or signaling between processes.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>ABC Ltd Company has recently installed Internet in its premises. Explain two methods it could use to protect computer systems from computer worms.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Install and Maintain Antivirus Software</strong>: Deploying <strong>reputable antivirus software</strong> on all computer systems within the company is crucial. Antivirus software can <strong>detect, quarantine, and remove</strong> known computer worms and other malware. It should be regularly updated with the latest virus definitions to recognize and protect against newly emerging worms. Real-time scanning, scheduled scans, and proactive detection features of antivirus software are essential for preventing worm infections and mitigating their spread within the network.</p>
<p data-number="2"><strong>Implement a Firewall and Network Security Measures</strong>: Employing a <strong>firewall</strong> to control network traffic entering and leaving the company's network is a vital protection method. Firewalls can <strong>block unauthorized network connections</strong> and filter out malicious traffic that worms might use to propagate. Additionally, implementing other network security measures such as <strong>intrusion detection/prevention systems (IDS/IPS), network segmentation, and regularly updating router and firewall firmware</strong> can further strengthen defenses against worm attacks. Network security measures limit the entry points and spread of worms within the company's infrastructure.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>Employees in a certain company using personal computers connected to a central server have realized that the response time of the server reduces with the increase of the number of users.</p>
<p>(1) Identify two techniques that could be used to solve this problem.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Upgrade Server Hardware</strong>: <strong>Upgrading the server hardware</strong>, particularly the CPU, RAM, and network interface card, can significantly improve server performance and response time. A more powerful CPU can handle increased processing load from more users, more RAM can reduce disk swapping and improve data access speed, and a faster network interface can handle higher network traffic. Hardware upgrades directly address server capacity limitations and improve overall server responsiveness under increased user load.</p>
<p data-number="2"><strong>Implement Load Balancing</strong>: <strong>Implementing load balancing</strong> distributes user requests across multiple servers instead of overloading a single server. Load balancing techniques can distribute incoming traffic based on various algorithms (e.g., round robin, least connections, etc.) to ensure that no single server is overwhelmed. By distributing the load, load balancing prevents performance degradation due to increased user connections and maintains consistent response times, even with a larger number of users accessing the services.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (ii) (2 marks)</h3>
<div class="question-content">
<p>Employees in a certain company using personal computers connected to a central server have realized that the response time of the server reduces with the increase of the number of users.</p>
<p>(ii) The company has enforced security mechanisms to protect the shared data. Differentiate between the term security and protection.(2 marks)</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Security</strong>:</p>
<p><strong>Security</strong>, in a broad sense, encompasses the <strong>overall measures and strategies taken to safeguard information and resources from unauthorized access, use, disclosure, disruption, modification, or destruction</strong>. Security is a comprehensive concept that includes policies, procedures, technologies, and practices aimed at ensuring confidentiality, integrity, and availability of data and systems. It involves assessing risks, implementing controls, and continuously monitoring and adapting to evolving threats. Security is the overarching goal of maintaining a safe and trustworthy computing environment.</p>
<p><strong>Protection</strong>:</p>
<p><strong>Protection</strong> is a <strong>specific mechanism or set of mechanisms implemented within an operating system or system architecture to enforce security policies and control access to resources</strong>. Protection mechanisms are the tools and techniques used to implement security. Examples of protection mechanisms include access control lists (ACLs), firewalls, encryption, authentication systems, and authorization protocols. Protection is the <strong>implementation aspect of security</strong>, focusing on the specific technical controls and safeguards that are put in place to achieve security goals. Protection mechanisms are the concrete means to enforce security policies and prevent unauthorized actions.</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Security</strong> is the <strong>broader goal</strong> of safeguarding information and resources, encompassing policies and strategies. <strong>Protection</strong> refers to the <strong>specific mechanisms and technical implementations</strong> used to enforce security policies and control access to resources. Protection is the means to achieve security.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define the term disk sector sparing as used in computer hard disk.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Disk sector sparing</strong>, also known as sector remapping, is a technique used in hard disk drives to <strong>handle bad sectors</strong>. When a sector on a disk is detected as faulty or unreliable (e.g., due to media errors), sector sparing involves <strong>replacing the bad sector with a spare sector</strong> from a reserved area of the disk. The disk controller automatically remaps logical addresses pointing to the bad sector to the spare sector, effectively hiding the bad sector from the operating system and maintaining data integrity and disk reliability. Sector sparing is a form of error management and fault tolerance in hard drives.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (1 mark)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in computer magnetic disk:</p>
<p>(1) platter;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(1) Platter:</strong></p>
<p>A <strong>platter</strong> is a <strong>circular disk</strong> made of a rigid material (like aluminum or glass) coated with a magnetic material. Hard disk drives consist of one or more platters stacked on a spindle. Data is stored magnetically on both surfaces of each platter in concentric tracks and sectors. Platters rotate at high speeds, enabling read/write heads to access data stored on their surfaces.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (1 mark)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in computer magnetic disk:</p>
<p>(II) rotational delay;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(II) Rotational Delay:</strong></p>
<p><strong>Rotational delay</strong>, also known as rotational latency, is the time it takes for the desired sector on a disk platter to <strong>rotate under the read/write head</strong> once the head has been positioned over the correct track (after seek time). It is the delay caused by the disk's rotation. On average, rotational latency is half the time for a full disk rotation. It contributes to disk access time and is inversely related to the disk's RPM (revolutions per minute).</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (1 mark)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in computer magnetic disk:</p>
<p>(III) transfer time.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(III) Transfer Time:</strong></p>
<p><strong>Transfer time</strong>, also known as data transfer time, is the time taken to <strong>transfer data between the disk surface and the computer's memory</strong> once the read/write head is positioned over the correct sector. It depends on the disk's data transfer rate and the amount of data being transferred. Higher transfer rates result in lower transfer times. Transfer time is a component of the total disk access time, following seek time and rotational latency.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (i) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between internal and external fragmentation as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Internal Fragmentation</strong>:</p>
<p><strong>Internal fragmentation</strong> occurs in fixed-size partitioning memory allocation schemes. It is the <strong>wasted memory within a partition</strong> that is allocated to a process because the partition size is larger than the process's memory requirement. When a process is loaded into a fixed-size partition, if the process size is smaller than the partition size, the unused space within that partition is internal fragmentation. This memory is allocated to the process but cannot be used by any other process. Internal fragmentation is a result of allocating memory in fixed-size blocks and can lead to inefficient memory utilization, especially when many processes are smaller than the partition size.</p>
<p><strong>External Fragmentation</strong>:</p>
<p><strong>External fragmentation</strong> occurs in dynamic memory allocation schemes (e.g., variable partitioning, segmentation). It is the condition where there is <strong>enough total free memory space to satisfy a process's memory request, but the free memory is non-contiguous</strong>, scattered in small blocks between allocated partitions. Because the free memory is fragmented into smaller, non-adjacent chunks, a large process requiring a contiguous block of memory may not be able to be allocated, even if the total free memory is sufficient. External fragmentation arises from the allocation and deallocation of variable-sized memory blocks over time, leading to fragmentation of the memory space. Compaction techniques can be used to reduce external fragmentation.</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Internal fragmentation</strong> is wasted memory *within* an allocated partition because the partition is larger than needed. <strong>External fragmentation</strong> is wasted memory *outside* allocated partitions, where total free memory is sufficient but fragmented into non-contiguous blocks too small to satisfy a process request. Internal fragmentation is associated with fixed partitioning, while external fragmentation is associated with dynamic allocation schemes.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Consider each of the following process scheduling algorithms:</p>
<p>First come First Served, Last In First Out, Shortest Job First, and Shortest Job First</p>
<p>Classify each of the algorithms as either preemptive or non-preemptive.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Non-Preemptive Algorithms:</strong></p>
<p>- <strong>First Come First Served (FCFS)</strong>: Non-preemptive. Once a process starts running, it continues until it completes or blocks for I/O.</p>
<p>- <strong>Last In First Out (LIFO)</strong>: Non-preemptive in its basic form. Once a process starts running, it continues until completion.</p>
<p>- <strong>Shortest Job First (SJF)</strong>: Non-preemptive in its traditional form. Once a process with the shortest estimated burst time starts, it runs to completion.</p>
<p><strong>Preemptive Algorithms:</strong></p>
<p>- <strong>Shortest Job First (SJF) (Preemptive version, also known as Shortest Remaining Time First - SRTF)</strong>: Preemptive. A running process can be preempted if a new process arrives with a shorter remaining burst time.</p>
<p><strong>Note:</strong> The question lists "Shortest Job First" twice. It is important to note that while traditional SJF is non-preemptive, there is also a preemptive version of SJF, often called Shortest Remaining Time First (SRTF).</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (i) (1 mark)</h3>
<div class="question-content">
<p>A certain college has campuses in several towns. Each campus meets its own computational needs but submits a report to the main campus on a daily basis.</p>
<p>(i) Identify the appropriate Operating System to be used at the main campus.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The appropriate Operating System to be used at the main campus would be a <strong>Network Operating System (NOS)</strong> or a <strong>Server Operating System</strong>.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>A certain college has campuses in several towns. Each campus meets its own computational needs but submits a report to the main campus on a daily basis.</p>
<p>(ii) Explain two characteristics of the Operating System identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Centralized Management and Administration</strong>: A Network Operating System provides <strong>centralized management and administration capabilities</strong>. This is crucial for the main campus to manage resources, user accounts, security policies, and data backups across all campuses. Centralized administration simplifies IT management, ensures consistency in policies, and facilitates monitoring and control over the entire college network. The NOS enables administrators at the main campus to efficiently manage the distributed computing environment.</p>
<p data-number="2"><strong>Network Services and Resource Sharing</strong>: A Server Operating System or NOS is designed to provide <strong>network services and resource sharing</strong>. It allows the main campus to act as a central server providing services like file sharing, database access, web services, and print services to all campuses. Furthermore, it supports communication protocols and networking functionalities necessary for each campus to submit reports and exchange data with the main campus. Resource sharing and network services are essential for enabling collaboration and data consolidation across the distributed college environment.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (4 marks)</h3>
<div class="question-content">
<p>Figure 2 shows functions of a file management system. Use it to answer the question that follows.</p>
<p><img src="Screenshot_2025-03-12_at_13-21-48_2013j.pdf.png" alt="" width="932" height="548" /></p>
<img src="figure2_q8d.png" alt="Figure 2 File Management System Functions Diagram" />
<p>Explain each of the process labeled (I) and (II).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on Figure 2, which depicts the functions of a file management system:</p>
<p><strong>(I) Directory management</strong>:</p>
<p>Process (I), labeled "Directory Management," refers to the <strong>functions related to managing the directory structure</strong> of the file system. This includes operations such as <strong>creating directories, deleting directories, renaming directories, listing directory contents, and navigating the directory hierarchy</strong>. Directory management is essential for organizing files logically, providing a structured namespace, and allowing users and programs to efficiently locate and access files. It deals with the hierarchical organization of files and directories within the file system.</p>
<p><strong>(II) Physical Blocks in Secondary Storage</strong>:</p>
<p>Process (II), labeled "Physical Blocks in Secondary Storage," refers to the <strong>low-level operations of managing the physical storage space</strong> on secondary storage devices (like hard disks or SSDs) where file data is actually stored. This includes functions such as <strong>allocating disk blocks to files, deallocating blocks when files are deleted, managing free space, and handling the physical layout of data on disk</strong>. It is concerned with the physical organization and management of data blocks on storage devices to ensure efficient storage and retrieval of file data. This process is hidden from users and applications, being handled by the file system at a lower level.</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer>© 2023 [Your University/College Name]</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="november_2013.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2012.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>