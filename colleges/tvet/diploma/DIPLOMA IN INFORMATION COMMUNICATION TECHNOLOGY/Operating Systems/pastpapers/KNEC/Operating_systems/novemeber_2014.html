<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>Novemeber 2014 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-12"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li id="active"><a href="novemeber_2014.html" class="active no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="july_2015.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2014.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">Novemeber 2014</h1></header>
<article class="iDevice_wrapper textIdevice" id="id12">
<div class="iDevice emphasis0" >
<div id="ta12_134_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: November 2014</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (i) (4 marks)</h3>
<div class="question-content">
<p>(a) (i) Outline four resources required in a process execution.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>CPU Time</strong>: The process requires <strong>CPU time</strong> to execute its instructions and perform computations.</p>
<p data-number="2"><strong>Memory</strong>: <strong>Memory</strong> is needed to store the process's code, data, and stack during execution.</p>
<p data-number="3"><strong>I/O Devices</strong>: The process may require access to <strong>I/O devices</strong> such as disks, network interfaces, or input devices for data transfer.</p>
<p data-number="4"><strong>Files</strong>: Access to <strong>files</strong> may be necessary for reading input or writing output during process execution.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between interrupt and system call as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Interrupt</strong>:</p>
<p>An <strong>interrupt</strong> is a <strong>hardware-generated signal</strong> that causes the CPU to <strong>suspend its current execution</strong> and transfer control to an interrupt handler. Interrupts are <strong>asynchronous events</strong> typically triggered by external devices or hardware components needing attention, such as I/O devices completing an operation or a timer expiring.</p>
<p><strong>System Call</strong>:</p>
<p>A <strong>system call</strong> is a <strong>software-generated request</strong> by a process to the operating system kernel to perform a <strong>privileged operation</strong>. System calls are <strong>synchronous events</strong> initiated by a process to request services from the kernel, such as file access, memory allocation, or process creation. They are the interface between user-level processes and the OS kernel.</p>
<p><strong>Key Difference</strong>: Interrupts are hardware-initiated asynchronous signals for external events; system calls are software-initiated synchronous requests by processes for OS services.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) (i) Explain the term context switch as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Context Switch</strong>:</p>
<p>A <strong>context switch</strong> is the <strong>process of saving the state of a currently running process and restoring the state of another process to allow the latter to run</strong>. This operation enables multitasking by allowing the CPU to quickly switch between processes, giving the illusion of concurrent execution. It involves saving and restoring CPU registers, program counter, and memory management information.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) A lecturer described objectives of process scheduling to an operating systems' class. Explain two objectives that he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Maximize CPU Utilization</strong>: One key objective of process scheduling is to <strong>keep the CPU as busy as possible</strong>. By efficiently managing and switching between processes, the scheduler aims to minimize CPU idle time and ensure that the CPU is always executing some process, thereby maximizing overall system throughput.</p>
<p data-number="2"><strong>Minimize Turnaround Time</strong>: Another important objective is to <strong>minimize the turnaround time for processes</strong>. Turnaround time is the total time taken from the submission of a process to its completion. Reducing turnaround time improves system responsiveness and user satisfaction by ensuring that processes complete in a timely manner.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) Bruce was required to identify the appropriate memory placement techniques for a proposed operating system. Explain three techniques that he could have considered.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>First-Fit</strong>: <strong>First-Fit</strong> is a memory placement algorithm where the allocator <strong>scans memory from the beginning and selects the first available partition large enough to satisfy the request</strong>. It's simple and fast for allocation but can lead to fragmentation as it may not always choose the best available block.</p>
<p data-number="2"><strong>Best-Fit</strong>: <strong>Best-Fit</strong> is a strategy where the allocator <strong>searches the entire memory and chooses the smallest available partition that is large enough to satisfy the request</strong>. It aims to minimize wasted space and internal fragmentation, but the search for the best fit can be time-consuming.</p>
<p data-number="3"><strong>Worst-Fit</strong>: <strong>Worst-Fit</strong> is a technique where the allocator <strong>selects the largest available partition to allocate memory</strong>. The idea is to leave larger chunks of free memory available for future, potentially larger allocations. However, it can lead to smaller, less useful fragments over time, increasing external fragmentation.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>2. (a) (i) Outline two parts of a directory structure in an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Directory Entry</strong>: This part stores metadata about each file or subdirectory, including name, attributes, and location information.</p>
<p data-number="2"><strong>Directory File (or Data Block)</strong>: This part contains the actual list of directory entries, effectively mapping names to inodes or file descriptors.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) Explain each of the following terms as used in operating systems:</p>
<p>I. access right;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>I. Access Right</strong>:</p>
<p><strong>Access rights</strong> are <strong>permissions granted to users or groups to perform specific operations on files or directories</strong>. They define what actions a user can perform, such as reading, writing, or executing a file. Access rights are a key component of file system security, controlling who can access and manipulate files.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>II. flags.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>II. Flags</strong>:</p>
<p>In the context of file systems, <strong>flags</strong> are <strong>indicators or markers associated with files or directories that represent specific attributes or states</strong>. Flags can denote various properties, such as whether a file is hidden, read-only, system file, archived, or modified. Flags are used to manage file behavior and characteristics beyond basic access permissions.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Figure I shows layers in computer memory hierarchy. Use it to answer the question that follows.</p>
<p><img src="Screenshot_2025-03-12_at_12-58-44_2014nov.pdf.png" alt="" width="516" height="267" /></p>
<p>Describe each of the layers labeled (i) and (ii).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on a typical memory hierarchy pyramid, assuming (i) is the top layer and (ii) is the bottom layer:</p>
<p><strong>(i) Cache</strong>:</p>
<p>Layer labeled <strong>(i)</strong> represents <strong>Cache Memory</strong>. Cache is the <strong>fastest and smallest memory level</strong> in the hierarchy, located closest to the CPU. It is used to store <strong>frequently accessed data and instructions</strong> to reduce average memory access time. Caches are typically implemented using SRAM and are significantly faster but more expensive than main memory.</p>
<p><strong>(ii) Random Access Memory</strong>:</p>
<p>Layer labeled <strong>(ii)</strong> represents <strong>Random Access Memory (RAM)</strong>, also known as main memory. RAM is the <strong>primary working memory</strong> of the computer, located below cache in the hierarchy. It is <strong>slower and larger than cache</strong> and is used to hold the programs and data that are currently being used by the CPU. RAM is volatile memory, meaning data is lost when power is turned off.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Petro was investigating advantages of memory segmentation in operating systems. Explain two advantages that he is likely to have identified.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Simplified Memory Management for Programmers</strong>: Memory segmentation <strong>simplifies memory management from a programmer's perspective</strong>. Programmers can organize memory into logical segments (like code, data, stack) and deal with memory in terms of these segments, rather than a single linear address space. This modular view simplifies program structure and memory allocation.</p>
<p data-number="2"><strong>Enhanced Protection and Sharing</strong>: Segmentation provides <strong>memory protection and sharing at the segment level</strong>. Each segment can have different access rights (read, write, execute), allowing the OS to protect segments from unauthorized access. Segments can also be shared between processes, enabling efficient data sharing and code reuse among different programs.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>(d) (i) Outline two types of files that could be found in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Data Files</strong>: These files contain user-created or application-generated data, such as documents, images, videos, and databases.</p>
<p data-number="2"><strong>Executable Files</strong>: These files contain programs or applications that can be executed by the operating system.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Brian intends to backup files. Explain two backup strategies he could use.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Full Backup</strong>: In a <strong>full backup</strong>, all selected files and directories are <strong>copied to the backup medium every time a backup is performed</strong>. This strategy provides a complete copy of the data and simplifies restoration, as all data is in one backup set. However, it is time-consuming and requires significant storage space as it duplicates all data in each backup.</p>
<p data-number="2"><strong>Incremental Backup</strong>: In an <strong>incremental backup</strong>, only the <strong>data that has changed since the last backup (full or incremental) is copied</strong>. This strategy saves backup time and storage space compared to full backups, as it only backs up changes. Restoration from incremental backups may require restoring the last full backup and then all subsequent incremental backups in sequence.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>3. (a) Explain each of the following terms as used in operating systems:</p>
<p>(i) bootstrap;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Bootstrap</strong>:</p>
<p><strong>Bootstrap</strong> refers to the <strong>initial process of starting or booting a computer system</strong>. It is a sequence of operations that begins when the computer is powered on, loading and initializing the operating system kernel so that the computer can become operational. The bootstrap process typically involves loading a small initial program (bootstrap loader) from ROM or firmware, which then loads the OS kernel from storage into memory and starts its execution.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) firmware.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Firmware</strong>:</p>
<p><strong>Firmware</strong> is a type of <strong>software that is embedded in hardware devices</strong>. It is typically stored in non-volatile memory such as ROM, EPROM, or flash memory. Firmware provides low-level control and instructions for the hardware device to function. It is often used for boot programs, device controllers, and embedded systems to provide basic operational instructions that are persistent and do not change frequently. Examples include BIOS in PCs and embedded software in devices like routers and printers.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (5 marks)</h3>
<div class="question-content">
<p>(b) Figure 2 shows a typical process model used in operating systems. Use it to answer the question that follows.</p>
<p><img src="Screenshot_2025-03-12_at_12-59-46_2014nov.pdf.png" alt="" width="526" height="310" /></p>
<p>Identify the parts labeled (i), (ii), (iii), (iv) and (v).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on a typical process state diagram, the labels likely represent:</p>
<p><strong>(i) Ready State</strong>:</p>
<p>Label <strong>(i)</strong> represents the <strong>Ready State</strong>. Processes in the ready state are <strong>waiting to be assigned to the CPU and are ready to run</strong>. They are in memory and are waiting for their turn to be scheduled by the dispatcher.</p>
<p><strong>(ii) Running State</strong>:</p>
<p>Label <strong>(ii)</strong> represents the <strong>Running State</strong>. A process in the running state is <strong>currently being executed by the CPU</strong>. Instructions of the process are being actively processed by the processor.</p>
<p><strong>(iii) Waiting/Blocked State (I/O Wait)</strong>:</p>
<p>Label <strong>(iii)</strong> represents the <strong>Waiting or Blocked State</strong>, specifically due to <strong>I/O Wait</strong>. Processes enter this state when they <strong>initiate an I/O operation and must wait for it to complete</strong>. They are blocked and cannot proceed until the I/O operation finishes.</p>
<p><strong>(iv) Dispatch</strong>:</p>
<p>Label <strong>(iv)</strong> represents the <strong>Dispatch</strong> transition. This is the action of the <strong>dispatcher component of the scheduler that moves a process from the ready state to the running state</strong>, allocating the CPU to the selected process.</p>
<p><strong>(v) Exit (Terminated State)</strong>:</p>
<p>Label <strong>(v)</strong> represents the <strong>Exit or Terminated State</strong>. This is the <strong>final state of a process after it has completed its execution</strong>. Once a process terminates, it releases its resources and is no longer active in the system.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Dorothy intends to design an operating system that uses swapping in memory management. Explain two constraints that are likely to be realized.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Performance Overhead of Swapping</strong>: <strong>Swapping introduces significant performance overhead</strong>. The process of swapping processes between RAM and disk is <strong>time-consuming</strong>, especially when swap space is on a traditional HDD. Disk I/O operations are much slower than RAM access, leading to increased latency and reduced system performance. Frequent swapping, known as thrashing, can severely degrade system responsiveness.</p>
<p data-number="2"><strong>Limited Scalability with Memory Size</strong>: Swapping effectiveness is <strong>limited by the size and speed of secondary storage</strong> used for swap space. While swapping allows running programs larger than RAM, performance degrades significantly as the system relies more heavily on swapping. If the swap space is too small or slow, the system may still experience memory limitations and performance bottlenecks, especially with increasing application memory demands.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (i) (3 marks)</h3>
<div class="question-content">
<p>(d) (i) Outline three goals of I/O module.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Efficiency</strong>: The I/O module aims to perform I/O operations <strong>efficiently</strong>, maximizing throughput and minimizing latency to ensure fast data transfer and responsiveness.</p>
<p data-number="2"><strong>Device Independence</strong>: To provide <strong>device independence</strong>, the I/O module abstracts device-specific details, offering a uniform interface to higher layers, so applications can work with diverse devices without device-specific code.</p>
<p data-number="3"><strong>Uniform Interface</strong>: The I/O module should present a <strong>uniform and consistent interface</strong> to the rest of the OS and applications, simplifying I/O operations and making them easier to use and manage.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) A group of module II students were carrying out an assignment on I/O protection strategies in operating systems. Explain two strategies that they could identify.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Access Control Lists (ACLs) for I/O Devices</strong>: <strong>Access Control Lists (ACLs)</strong> can be used to control which processes or users can access specific I/O devices. ACLs define permissions for operations like read, write, and control for each device, allowing fine-grained control over device access and enhancing security.</p>
<p data-number="2"><strong>Privileged Instructions and Kernel-Level I/O</strong>: <strong>Restricting direct I/O hardware access to the kernel and using privileged instructions for I/O operations</strong> is a key strategy. Only the OS kernel, running in a privileged mode, is allowed to directly access I/O hardware. User-level processes must use system calls to request I/O operations, which are then validated and executed by the kernel, enforcing security and preventing unauthorized device access.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (4 marks)</h3>
<div class="question-content">
<p>4. (a) Distinguish between SCAN and C-SCAN disk scheduling algorithms.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>SCAN Algorithm (Elevator Algorithm)</strong>:</p>
<p><strong>SCAN</strong>, also known as the Elevator algorithm, moves the disk head <strong>in one direction across the disk, servicing all requests in its path</strong>. When the head reaches one end of the disk, it reverses direction and continues servicing requests in the opposite direction. SCAN behaves like an elevator, moving up and down, servicing requests along its path in both directions. It provides better performance than FCFS and SSTF, especially under heavy load, and offers relatively fair service.</p>
<p><strong>C-SCAN Algorithm (Circular SCAN)</strong>:</p>
<p><strong>C-SCAN (Circular SCAN)</strong> is a variation of SCAN that is designed to provide more uniform wait times. C-SCAN moves the disk head <strong>in one direction only, from one end of the disk to the other, servicing requests along the way</strong>. When the head reaches the end of the disk, it <strong>quickly returns to the beginning of the disk without servicing any requests during the return trip</strong>. C-SCAN provides more equitable service compared to SCAN by limiting head movement to one direction during service and then quickly returning to the start.</p>
<p><strong>Key Difference:</strong> SCAN services requests in both directions of head movement; C-SCAN services requests only in one direction and quickly returns to the start without servicing on the return trip, leading to more uniform wait times.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Hope intends to develop a file management module for an operating system. Explain two file access methods that she should consider.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Sequential Access</strong>: <strong>Sequential access</strong> is a method where files are accessed in a <strong>linear order, from the beginning to the end</strong>. Data is read and written sequentially, one record after another. It's efficient for applications that process files in a linear fashion, like batch processing or streaming data. Sequential access is simple to implement and efficient for ordered data processing.</p>
<p data-number="2"><strong>Direct Access (Random Access)</strong>: <strong>Direct access</strong>, also known as random access, allows <strong>accessing any record in a file directly, without needing to read through preceding records</strong>. Records are accessed based on their position or a key. Direct access is efficient for applications that require frequent random data access, such as databases or index-based file retrieval. It provides flexibility in accessing specific data records quickly.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>(c) With the aid of a diagram in each case, describe each of the following file system:</p>
<p>(i) single-level directory;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Single-Level Directory</strong>:</p>
<p>A <strong>single-level directory structure</strong> is the simplest file organization where <strong>all files are placed in a single directory</strong>. There is no hierarchy or subdirectories. All files reside directly under the root directory.</p>
<p><strong>Diagram:</strong></p>
<pre>+---------------------+
| Root Directory      |
+---------------------+
| File A              |
| File B              |
| File C              |
| ...                 |
| File N              |
+---------------------+
</pre>
<p><strong>Description:</strong> All files are located in one directory. Easy to implement but leads to naming conflicts and poor organization for large numbers of files.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) two-level directory.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Two-Level Directory</strong>:</p>
<p>A <strong>two-level directory structure</strong> introduces a hierarchy with a <strong>root directory and user directories under it</strong>. Each user has their own directory, and files are organized within user directories.</p>
<p><strong>Diagram:</strong></p>
<pre>+---------------------+
| Root Directory      |
+---------------------+
| User Directory 1    | --&gt; [File 1A, File 1B, ...]
| User Directory 2    | --&gt; [File 2A, File 2B, ...]
| ...                 |
| User Directory N    | --&gt; [File NA, File NB, ...]
+---------------------+
</pre>
<p><strong>Description:</strong> Each user has a separate directory under the root. Resolves naming conflicts between users but limited in organizational depth.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>(d) (i) Bev was carrying out a study on benefits of multiprocessor systems. Explain two benefits that she could have established.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Increased Throughput</strong>: <strong>Multiprocessor systems</strong> significantly <strong>increase throughput</strong>. By having multiple CPUs, they can execute multiple processes or threads in parallel, completing more tasks in a given time frame. This leads to higher overall system efficiency and productivity.</p>
<p data-number="2"><strong>Enhanced Reliability and Fault Tolerance</strong>: Multiprocessor systems offer <strong>enhanced reliability and fault tolerance</strong>. If one processor fails, the system can continue to operate, albeit at a reduced performance level, using the remaining processors. This redundancy makes the system more resilient to hardware failures and improves overall system availability.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Angie was required to investigate factors that affect performance of a storage disk Outline four factors that she could have considered.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Seek Time</strong>: <strong>Seek time</strong> is the time it takes for the disk head to move to the correct track. Lower seek times result in faster data access, significantly impacting disk performance. Algorithms and disk mechanics influence seek time.</p>
<p data-number="2"><strong>Rotational Latency</strong>: <strong>Rotational latency</strong> is the time it takes for the desired sector to rotate under the read/write head. Disks with higher RPM (rotations per minute) have lower rotational latency, improving data access speed.</p>
<p data-number="3"><strong>Data Transfer Rate</strong>: <strong>Data transfer rate</strong> is the speed at which data can be transferred between the disk and the system. Higher transfer rates mean faster read and write operations, directly affecting disk performance. Interface type (SATA, NVMe) and disk technology influence transfer rates.</p>
<p data-number="4"><strong>Caching</strong>: <strong>Disk caching</strong> significantly affects performance. The presence and effectiveness of disk cache (buffer in RAM) can dramatically reduce access times for frequently accessed data. Cache hit ratio and cache size are important factors.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>5. (a) Explain each of the following tables as used in memory management:</p>
<p>(i) hashed;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Hashed Page Table</strong>:</p>
<p>A <strong>hashed page table</strong> is a page table structure used in virtual memory management to handle large address spaces efficiently. In a hashed page table, the <strong>virtual page number is hashed into a hash table</strong>. Each entry in the hash table contains a linked list of elements that hash to the same location, and each element contains the virtual page number, the corresponding page frame number, and control bits. Hashed page tables are used to reduce the size of page tables, especially for large address spaces, by providing a more compact representation compared to traditional multi-level page tables.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) clustered page.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Clustered Page Table</strong>:</p>
<p>A <strong>clustered page table</strong> is a variation of multi-level page tables where <strong>page table entries are grouped into clusters</strong>. Instead of a single large page table, the page table is divided into smaller, fixed-size clusters or chunks. This approach is used to <strong>improve the locality of reference for page table entries and reduce the memory overhead of page tables</strong>, especially in systems with very large address spaces. Clustering page table entries can improve cache performance for page table accesses and reduce the overall memory footprint of page tables.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Distinguish between long-term and short-term schedulers as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Long-Term Scheduler (Job Scheduler)</strong>:</p>
<p>The <strong>long-term scheduler</strong>, or job scheduler, controls the <strong>degree of multiprogramming</strong> by selecting processes from a job pool and loading them into memory for execution. It is invoked <strong>less frequently</strong> and makes decisions about which programs are admitted to the ready queue. The long-term scheduler focuses on balancing the mix of jobs in the system and controlling the number of active processes in memory.</p>
<p><strong>Short-Term Scheduler (CPU Scheduler)</strong>:</p>
<p>The <strong>short-term scheduler</strong>, or CPU scheduler, selects from the ready queue and decides <strong>which process should be executed by the CPU next</strong>. It is invoked <strong>very frequently</strong>, typically every few milliseconds, and makes fine-grained decisions about CPU allocation. The short-term scheduler aims to maximize CPU utilization, minimize response times, and improve overall system performance by efficiently switching between ready processes.</p>
<p><strong>Key Difference:</strong> Long-term scheduler controls the degree of multiprogramming and job admission (less frequent); short-term scheduler controls CPU allocation to ready processes (very frequent).</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) Loise was required to run disk management utilities during computer maintenance. Explain three examples of utilities that she could use.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Disk Defragmentation Utility</strong>: A <strong>disk defragmentation utility</strong> is used to <strong>reorganize files on a disk to reduce fragmentation</strong>. Over time, files can become fragmented, meaning their parts are scattered across non-contiguous blocks on the disk. Defragmentation utilities rearrange file blocks to make them contiguous, improving disk access speed, especially for frequently accessed files, and enhancing overall system performance.</p>
<p data-number="2"><strong>Disk Check Utility (e.g., CHKDSK, fsck)</strong>: A <strong>disk check utility</strong> is used to <strong>scan the file system for errors and repair them</strong>. It checks the file system metadata, file structures, and disk surface for inconsistencies, bad sectors, or other errors. Disk check utilities can detect and fix file system corruption, logical errors, and physical disk problems, ensuring data integrity and system stability.</p>
<p data-number="3"><strong>Disk Cleanup Utility</strong>: A <strong>disk cleanup utility</strong> is used to <strong>free up disk space by removing unnecessary files</strong>. It can identify and delete temporary files, internet cache files, old system files, and other unnecessary data that accumulates over time. Disk cleanup utilities help to reclaim storage space, improve disk performance, and reduce clutter, optimizing disk usage and system efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>(d) Figure 3 shows a memory allocation technique. Use it to answer questions that follow.</p>
<p><img src="Screenshot_2025-03-12_at_13-00-28_2014nov.pdf.png" alt="" width="585" height="281" /></p>
<p>(i) Explain the memory management techniques depicted in the figure.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Paging</strong>:</p>
<p>The memory management technique depicted in Figure 3 is <strong>Paging</strong>. The diagram illustrates a <strong>non-contiguous memory allocation</strong>, where a process's logical address space is divided into fixed-size blocks called <strong>pages</strong> (P), and these pages are mapped to non-contiguous, fixed-size blocks of physical memory called <strong>frames</strong> (d) in RAM. The use of pages and frames and the non-contiguous nature of allocation are key indicators of paging.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Explain two advantages of the memory management technique identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Eliminates External Fragmentation</strong>: <strong>Paging eliminates external fragmentation</strong>. Since memory is allocated in fixed-size pages and frames, any free frame can be used to store any page of a process. There is no issue of fragmented free space between variable-sized blocks, as in segmentation or dynamic partitioning. This leads to more efficient use of physical memory.</p>
<p data-number="2"><strong>Efficient Memory Utilization and Flexible Allocation</strong>: Paging allows for more <strong>efficient memory utilization and flexible allocation</strong>. Only the necessary pages of a process need to be loaded into memory, and pages can be placed in any available frame, which can be non-contiguous. This fine-grained allocation and efficient use of frames improves memory utilization and supports a higher degree of multiprogramming.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>6. (a) Explain each of the following terms as used in disk operations:</p>
<p>(i) seek time;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Seek Time</strong>:</p>
<p><strong>Seek time</strong> is the <strong>time taken for the disk arm and read/write head to move to the specific track (cylinder) on the disk platter</strong> where the desired data is located. It is the time required to position the head over the correct track before data can be read or written. Seek time is a major factor contributing to disk access latency.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) transfer rate;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Transfer Rate</strong>:</p>
<p><strong>Transfer rate</strong>, also known as data transfer rate or bandwidth, is the <strong>speed at which data can be transferred between the disk and the computer system</strong> (typically memory or CPU). It is usually measured in megabytes per second (MB/s) or gigabytes per second (GB/s). Transfer rate indicates how quickly data can be read from or written to the disk once the read/write head is positioned correctly and rotational latency is accounted for.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) rotational latency.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(iii) Rotational Latency</strong>:</p>
<p><strong>Rotational latency</strong>, also known as rotational delay, is the <strong>time it takes for the desired sector on the disk to rotate under the read/write head once the head is positioned over the correct track</strong>. After the seek operation is complete, rotational latency is the time spent waiting for the disk to rotate to the correct sector position before data transfer can begin. Rotational latency is dependent on the disk's rotational speed (RPM).</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Stano listed several examples of I/O buses that could be used in a disk drive. Outline four examples that he could have listed.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>SATA (Serial ATA)</strong>: <strong>SATA</strong> is a common interface bus used for connecting storage devices like HDDs and SSDs to the motherboard. It provides high-speed serial data transfer and is widely used for internal disk drives in desktop and laptop computers.</p>
<p data-number="2"><strong>NVMe (Non-Volatile Memory Express)</strong>: <strong>NVMe</strong> is a high-performance interface bus designed specifically for SSDs. It utilizes the PCIe bus for significantly faster data transfer rates and lower latency compared to SATA, making it ideal for high-speed SSDs used in demanding applications.</p>
<p data-number="3"><strong>SAS (Serial Attached SCSI)</strong>: <strong>SAS</strong> is a bus interface used primarily for enterprise-level storage devices, such as high-performance HDDs and tape drives. SAS offers high data transfer rates, reliability, and scalability, often used in servers and storage arrays.</p>
<p data-number="4"><strong>IDE/ATA (Integrated Drive Electronics/Advanced Technology Attachment)</strong>: <strong>IDE/ATA</strong>, also known as Parallel ATA (PATA), is an older bus interface for connecting storage devices. While largely replaced by SATA, IDE/ATA was widely used in older systems and is still relevant in understanding legacy systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (5 marks)</h3>
<div class="question-content">
<p>(c) File attributes varies from one operating system to another. Outline five examples of these attributes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>File Name</strong>: The <strong>name</strong> of the file, used to identify and access the file within a directory.</p>
<p data-number="2"><strong>File Size</strong>: The <strong>size</strong> of the file, indicating the amount of storage space it occupies, typically in bytes or kilobytes.</p>
<p data-number="3"><strong>File Type</strong>: The <strong>type</strong> of file, indicating the format and intended use of the file (e.g., text file, executable file, directory).</p>
<p data-number="4"><strong>Timestamps</strong>: <strong>Timestamps</strong> such as creation time, last modification time, and last access time, recording when the file was created, last modified, and last accessed.</p>
<p data-number="5"><strong>Access Permissions/Attributes</strong>: <strong>Access permissions</strong> controlling who can access the file and what operations they can perform (read, write, execute); attributes like read-only, hidden, system file, archive.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (5 marks)</h3>
<div class="question-content">
<p>(d) With the aid of a diagram, outline a typical process control block (PCB) diagram as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Process Control Block (PCB) Diagram</strong>:</p>
<p>The <strong>Process Control Block (PCB)</strong> is a data structure used by the OS to manage and track each process. It contains all the necessary information about a process.</p>
<p><strong>Diagram of a Process Control Block (PCB):</strong></p>
<pre>+-------------------------------------+
| Process Identification              |
| ----------------------------------- |
| Process ID (PID)                    |
| User ID (UID)                       |
+-------------------------------------+
| Process State                       |
| ----------------------------------- |
| Current State (Running, Ready, ...) |
+-------------------------------------+
| Program Counter (PC)                |
| ----------------------------------- |
| Address of next instruction         |
+-------------------------------------+
| CPU Registers                       |
| ----------------------------------- |
| General Purpose Registers          |
| Stack Pointer                       |
| ...                                 |
+-------------------------------------+
| Memory Management Info              |
| ----------------------------------- |
| Page Table Base Address             |
| Segment Table Base Address          |
| ...                                 |
+-------------------------------------+
| CPU Scheduling Info                 |
| ----------------------------------- |
| Priority                            |
| Scheduling Queue Pointers           |
| ...                                 |
+-------------------------------------+
| I/O and File Management             |
| ----------------------------------- |
| List of Open Files                  |
| Allocated I/O Devices             |
| ...                                 |
+-------------------------------------+
| Accounting Information              |
| ----------------------------------- |
| CPU Time Used                       |
| Execution Time                      |
| ...                                 |
+-------------------------------------+
</pre>
<p><strong>Description:</strong> The PCB typically includes sections for:</p>
<p data-number="1"><strong>Process Identification</strong>: Contains unique identifiers like Process ID (PID) and User ID (UID).</p>
<p data-number="2"><strong>Process State</strong>: Indicates the current state of the process (e.g., Running, Ready, Blocked).</p>
<p data-number="3"><strong>Program Counter (PC)</strong>: Stores the address of the next instruction to be executed.</p>
<p data-number="4"><strong>CPU Registers</strong>: Saves the state of CPU registers to allow process resumption after interruption.</p>
<p data-number="5"><strong>Memory Management Info</strong>: Holds pointers to page tables or segment tables for memory management.</p>
<p data-number="6"><strong>CPU Scheduling Info</strong>: Includes scheduling priority and queue pointers for process scheduling.</p>
<p data-number="7"><strong>I/O and File Management</strong>: Lists open files and allocated I/O devices.</p>
<p data-number="8"><strong>Accounting Information</strong>: Tracks resource usage like CPU time and execution time.</p>
<p>The PCB is essential for the OS to manage and control each process effectively.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>7. (a) (i) Define the term livelock as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Livelock</strong>:</p>
<p><strong>Livelock</strong> is a concurrency control issue similar to deadlock, but in livelock, processes are <strong>not blocked; instead, they continuously change their state in response to each other, without making progress</strong>. Processes in a livelock are actively engaged in resolving a conflict but are unable to make forward progress, effectively stuck in a loop of unproductive activity. Unlike deadlock, processes in livelock are not waiting for each other to release resources but are constantly reacting to each other's actions.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Distinguish between overlaying and partitioning as used memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Overlaying</strong>:</p>
<p><strong>Overlaying</strong> is a memory management technique where a process is <strong>divided into segments (overlays)</strong>, and only the <strong>currently needed segments are loaded into memory</strong>. Segments are loaded into a <strong>fixed memory area</strong>, overwriting previously loaded segments as needed. Overlaying is a manual technique requiring programmers to divide programs into overlays and manage their loading and unloading. It was used in early systems with limited memory to run programs larger than physical memory.</p>
<p><strong>Partitioning</strong>:</p>
<p><strong>Partitioning</strong> is a memory management technique that <strong>divides main memory into fixed or variable-sized partitions</strong>. Each partition can hold one process. <strong>Fixed partitioning</strong> divides memory into static partitions at system startup, while <strong>dynamic partitioning</strong> allocates partitions of variable size based on process needs at runtime. Partitioning is used to enable multiprogramming by allocating separate memory regions to different processes.</p>
<p><strong>Key Difference:</strong> Overlaying is a program-centric technique where program segments are swapped in and out of a fixed memory area, managed by programmers. Partitioning is an OS-centric technique that divides memory into partitions to hold different processes, enabling multiprogramming.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Mercy, an intern student was required to discuss examples of file operations during a job interview. Outline four examples that she could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Create</strong>: <strong>Create</strong> is a file operation used to <strong>make a new file</strong> in the file system. It allocates storage space and sets up metadata for the new file, preparing it for data storage.</p>
<p data-number="2"><strong>Read</strong>: <strong>Read</strong> is an operation to <strong>retrieve data from a file</strong>. It involves accessing the file's contents and transferring data from the storage device to memory for processing or display.</p>
<p data-number="3"><strong>Write</strong>: <strong>Write</strong> is a file operation used to <strong>store data into a file</strong>. It involves transferring data from memory to the file on the storage device, modifying or adding to the file's contents.</p>
<p data-number="4"><strong>Delete</strong>: <strong>Delete</strong> is an operation to <strong>remove a file from the file system</strong>. It deallocates storage space occupied by the file and removes the file's directory entry, making the file no longer accessible.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Sayd Company Ltd. intends to replace its single-processor operating system. Outline four limitations of the existing operating system that could have influenced the decision.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Limited Performance and Throughput</strong>: A single-processor OS <strong>limits performance and throughput</strong>, especially under heavy workloads or when running multiple applications concurrently. It can only execute one process at a time, leading to bottlenecks when handling multiple tasks or user requests. Performance may degrade significantly as workload increases.</p>
<p data-number="2"><strong>Poor Responsiveness in Multitasking Environments</strong>: In multitasking environments, a single-processor OS can exhibit <strong>poor responsiveness</strong>. When running multiple applications, users may experience delays and sluggishness as the single CPU has to time-share its resources among all processes. Responsiveness for interactive tasks may suffer, especially if CPU-intensive processes are running.</p>
<p data-number="3"><strong>Inefficient Resource Utilization</strong>: Single-processor systems can lead to <strong>inefficient utilization of system resources</strong>. While one process is using the CPU, other system components, such as memory or I/O devices, may be underutilized. The system cannot fully leverage parallelism or concurrency to maximize resource usage, limiting overall efficiency.</p>
<p data-number="4"><strong>Lack of Scalability for Demanding Applications</strong>: A single-processor OS is <strong>not scalable for demanding applications or growing workloads</strong>. As the company's processing needs increase, a single-processor system cannot easily scale to handle the increased load. Upgrading to a multiprocessor system and OS becomes necessary to achieve better scalability and performance for demanding applications and future growth.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (6 marks)</h3>
<div class="question-content">
<p>(d) Claudius was required to list advantages of dynamic linking in memory management. Explain three advantages that he is likely to have listed.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Reduced Memory Footprint</strong>: <strong>Dynamic linking reduces the memory footprint of applications</strong>. With dynamic linking, shared libraries are loaded into memory only once and are shared among multiple processes that use them. This avoids redundant copies of libraries in memory for each application, saving significant memory space, especially when many applications use the same libraries.</p>
<p data-number="2"><strong>Disk Space Savings</strong>: <strong>Dynamic linking saves disk space</strong>. Shared libraries are stored only once on disk, and multiple executables link to the same shared library file. This reduces the overall disk space occupied by applications and libraries, as shared code is not duplicated across multiple executables. Disk space savings are particularly beneficial in systems with limited storage capacity or when distributing software.</p>
<p data-number="3"><strong>Simplified Software Updates and Patches</strong>: <strong>Dynamic linking simplifies software updates and patching</strong>. When a shared library is updated or patched (e.g., for security fixes or bug fixes), the update only needs to be applied to the shared library file. All applications that dynamically link to this library automatically benefit from the update the next time they are executed, without needing to be re-linked or recompiled. This simplifies software maintenance and deployment of updates and patches.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>8. (a) (i) Define the term programmable interval timer as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Programmable Interval Timer</strong>:</p>
<p>A <strong>programmable interval timer (PIT)</strong> is a <strong>hardware timer component</strong> in a computer system that can be <strong>programmed to generate interrupts at regular intervals</strong>. The interval between interrupts is programmable, allowing the OS to configure the timer to generate interrupts at desired frequencies. PITs are used by the operating system for timekeeping, scheduling, and managing time-dependent operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Outline four services that could be provided by I/O subsystem kernel.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Device Driver Management</strong>: The I/O subsystem kernel manages <strong>device drivers</strong>, loading, initializing, and unloading them as needed. It provides an interface for device drivers to interact with the kernel and handle device-specific operations, abstracting hardware details from the rest of the OS.</p>
<p data-number="2"><strong>I/O Scheduling and Queue Management</strong>: The kernel's I/O subsystem performs <strong>I/O scheduling</strong>, managing the order and priority of I/O requests to optimize disk performance and fairness. It maintains I/O queues for different devices and uses scheduling algorithms to determine which I/O request to service next, improving overall I/O throughput and response times.</p>
<p data-number="3"><strong>Buffering and Caching</strong>: The I/O subsystem implements <strong>buffering and caching mechanisms</strong> to improve I/O performance. It manages buffers in memory to temporarily store data during I/O transfers, handling speed mismatches and data size adaptation. Disk caching is used to cache frequently accessed disk blocks in RAM to reduce disk access latency.</p>
<p data-number="4"><strong>Error Handling and Device Management</strong>: The I/O subsystem kernel is responsible for <strong>handling I/O errors and managing I/O devices</strong>. It detects and handles device errors, implements error recovery procedures, and reports errors to the OS and applications. Device management includes device initialization, configuration, allocation, and deallocation of I/O resources to processes.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (8 marks)</h3>
<div class="question-content">
<p>(b) Explain four circumstances that would necessitate premature termination of a process execution in an operating system</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Error Conditions and Exceptions</strong>: <strong>Fatal errors or exceptions</strong> during process execution can necessitate premature termination. If a process encounters an error it cannot handle, such as a segmentation fault, illegal instruction, division by zero, or unrecoverable system error, the OS may terminate the process to prevent further damage or instability to the system.</p>
<p data-number="2"><strong>Resource Limits Exceeded</strong>: If a process <strong>exceeds its allocated resource limits</strong>, the OS may terminate it prematurely. Resource limits can include CPU time limits, memory limits, file size limits, or I/O limits. Exceeding these limits may indicate a runaway process, resource exhaustion, or policy enforcement, leading to termination to protect system resources and other processes.</p>
<p data-number="3"><strong>User Intervention or Termination Request</strong>: A user or administrator may <strong>explicitly request to terminate a process</strong>. Users can use commands like 'kill' or task managers to terminate processes that are unresponsive, malfunctioning, or no longer needed. User intervention allows for manual control over process execution and termination.</p>
<p data-number="4"><strong>Deadlock or System Hang Situations</strong>: In <strong>deadlock or system hang situations</strong>, where processes are blocked indefinitely, the OS may need to <strong>terminate one or more processes to break the deadlock and recover system functionality</strong>. Deadlock resolution strategies may involve process abortion as a means to release resources and allow other processes to proceed. Termination is a drastic measure to resolve critical system issues like deadlocks.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) With the aid of a diagram, describe the parts of a magnetic disk</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Parts of a Magnetic Disk with Diagram</strong>:</p>
<p>A magnetic disk, such as a Hard Disk Drive (HDD), consists of several key components that work together to store and retrieve data.</p>
<p><strong>Diagram of Magnetic Disk Parts:</strong></p>
<pre>                 _________________________
                |                         |
                |     Platter(s)          | &lt;-- (1) Circular Platters coated with magnetic material
                |       _______           |
                |      /       \          |
                |     |  Spindle  |         | &lt;-- (2) Spindle - Central axis for platter rotation
                |      \_______/          |
                |                         |
                +-------------------------+
                      /   |   \
                     /    |    \
    Read/Write Heads ----+-----+---- Actuator Arm  &lt;-- (3) Actuator Arm &amp; Read/Write Heads
      (per platter surface)         (Moves heads across platters)
           |
           V
      +-------------+
      |  Controller | &lt;-- (4) Disk Controller - Interface to system bus
      +-------------+
</pre>
<p><strong>Description of Parts:</strong></p>
<p data-number="1"><strong>Platters</strong>: <strong>Platters</strong> are the <strong>circular disks made of aluminum or glass, coated with a magnetic material</strong>. Data is stored magnetically on both surfaces of each platter. A hard disk typically contains multiple platters stacked on a spindle to increase storage capacity. Platters rotate at high speeds, enabling data access.</p>
<p data-number="2"><strong>Spindle</strong>: The <strong>Spindle</strong> is the <strong>central axis around which the platters rotate</strong>. It is driven by a motor that spins the platters at a constant speed (e.g., 5400 RPM, 7200 RPM). The spindle ensures consistent and high-speed rotation of the platters, enabling the read/write heads to access data sectors.</p>
<p data-number="3"><strong>Read/Write Heads and Actuator Arm</strong>: <strong>Read/Write Heads</strong> are electromagnetic components that <strong>read and write data on the platter surfaces</strong>. Each platter surface has its own read/write head, mounted on an <strong>Actuator Arm</strong>. The actuator arm moves the heads radially across the platters to position them over different tracks or cylinders. The heads float very close to the platter surface but do not touch it during normal operation.</p>
<p data-number="4"><strong>Disk Controller</strong>: The <strong>Disk Controller</strong> is an <strong>electronic circuit board</strong> that controls the operation of the hard disk and provides an <strong>interface between the disk drive and the computer system bus</strong> (e.g., SATA, NVMe). The controller manages data transfer, error correction, disk formatting, and communication with the host system. It translates high-level commands from the OS into low-level signals for the disk drive components.</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer>easytvet.com</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="july_2015.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2014.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>