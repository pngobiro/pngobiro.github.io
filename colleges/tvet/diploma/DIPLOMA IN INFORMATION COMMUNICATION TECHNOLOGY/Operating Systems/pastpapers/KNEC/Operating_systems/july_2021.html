<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>July 2021 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-3"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li id="active"><a href="july_2021.html" class="active no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="november_2021.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2019.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">July 2021</h1></header>
<article class="iDevice_wrapper textIdevice" id="id3">
<div class="iDevice emphasis0" >
<div id="ta3_130_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: July 2021</p>
</div>
</header>
<p></p>
<p></p>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1 (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four objectives of memory management as a function of the operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">To efficiently utilize available memory space.</p>
<p data-number="2">To allow multiprogramming by accommodating multiple processes in memory.</p>
<p data-number="3">To provide memory protection to prevent processes from interfering with each other.</p>
<p data-number="4">To enable virtual memory, allowing processes to exceed physical memory size.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (b) (4 marks)</h3>
<div class="question-content">
<p>Explain two functions of shell as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Command Interpretation: The shell interprets commands entered by the user, parsing and executing them. It acts as a command-line interpreter, translating user requests into system calls.</p>
<p data-number="2">Scripting and Automation: Shells allow users to write scripts (shell scripts) to automate tasks. These scripts can combine multiple commands, control flow, and perform complex operations, enhancing system automation and efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (c) (6 marks)</h3>
<div class="question-content">
<p>In an operating system a process may go through several states. Outline six such process states.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">New: The process is being created and has not yet been admitted to the pool of executable processes by the operating system.</p>
<p data-number="2">Ready: The process is waiting to be assigned to a processor. Ready processes are waiting to have processor time allocated to them.</p>
<p data-number="3">Running: The process is being executed by a processor. Instructions of the process are being carried out.</p>
<p data-number="4">Waiting/Blocked: The process is waiting for some event to occur, such as completion of an I/O operation or receipt of a signal.</p>
<p data-number="5">Suspended Ready: A ready process that has been moved out of main memory to secondary memory (e.g., disk) to free up main memory.</p>
<p data-number="6">Suspended Blocked/Waiting: A blocked process that has been moved out of main memory to secondary memory to free up main memory.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (d) (6 marks)</h3>
<div class="question-content">
<p>Paging is a significant technique used in memory management. Explain three advantages that paging could provide when implemented.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Virtual Memory Implementation: Paging is essential for implementing virtual memory, allowing processes to run even if they are larger than physical memory. It enables the system to bring only necessary pages into RAM, keeping the rest on disk.</p>
<p data-number="2">Reduced External Fragmentation: Paging eliminates external fragmentation as memory allocation is done in fixed-size pages. Free pages can be allocated to any process, regardless of their physical location, making memory utilization more efficient.</p>
<p data-number="3">Efficient Memory Sharing: Paging facilitates sharing of code and data among processes. If multiple processes use the same code or libraries, the corresponding pages can be shared in physical memory, reducing memory footprint and improving system efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four types of Direct Memory Access (DMA) transfer mode.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Burst Mode DMA: In burst mode, DMA controller transfers a block of data in a continuous sequence. It gains control of the system bus and retains it until the entire block transfer is complete, leading to high-speed data transfer.</p>
<p data-number="2">Cycle Stealing DMA: In cycle stealing mode, DMA controller transfers data one byte or word at a time, relinquishing bus control after each transfer. CPU can interleave its operations with DMA transfers, allowing concurrent CPU and I/O activity, though at a reduced DMA transfer rate.</p>
<p data-number="3">Transparent DMA: In transparent DMA, DMA transfers occur when the CPU is not using the system bus, typically during CPU idle cycles or memory refresh cycles. DMA operations are transparent to the CPU, having minimal impact on CPU performance.</p>
<p data-number="4">Fly-by DMA: In fly-by DMA, data is transferred directly between two peripherals without going through main memory. DMA controller manages data flow directly from source device to destination device, reducing memory bandwidth usage and latency.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (b) (4 marks)</h3>
<div class="question-content">
<p>Explain two features of the 3rd generation computer operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Multiprogramming: Third-generation operating systems introduced multiprogramming, allowing multiple programs to reside in memory simultaneously. This enabled the CPU to switch between programs, increasing CPU utilization and system throughput by overlapping CPU and I/O operations.</p>
<p data-number="2">Time-Sharing: Time-sharing systems emerged, a logical extension of multiprogramming. They allowed multiple users to interact with the computer system concurrently. CPU time is divided and allocated to each user's process in time slices, providing interactive computing experience and responsiveness.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (c) (4 marks)</h3>
<div class="question-content">
<p>Explain two circumstances under which memory overlay could be implemented in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Limited Memory Size: When the size of a program exceeds the available physical memory, memory overlay can be used to run the program. It divides the program into smaller segments (overlays), loading only necessary segments into memory at any given time, swapping segments in and out as needed.</p>
<p data-number="2">Simple Program Structure: Memory overlay is more feasible when programs have a relatively simple and modular structure. Programs that can be naturally divided into independent modules or phases that do not need to reside in memory simultaneously are suitable for overlay implementation.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (d) (8 marks)</h3>
<div class="question-content">
<p>When a user program processes a malicious task it causes a threat to the operating system. Explain four such threats.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Malware Installation: Malicious programs can install malware (viruses, worms, Trojans) onto the system. Malware can compromise system integrity, steal data, disrupt operations, or grant unauthorized access to attackers.</p>
<p data-number="2">Data Breach and Exfiltration: Malicious tasks can lead to data breaches, where sensitive information is accessed and exfiltrated without authorization. This can compromise confidential data, intellectual property, or personal information.</p>
<p data-number="3">Denial of Service (DoS): Malicious programs can launch denial-of-service attacks, overwhelming system resources (CPU, memory, network) to make the system or services unavailable to legitimate users. DoS attacks can disrupt critical operations and services.</p>
<p data-number="4">Privilege Escalation: Malicious tasks may attempt to exploit vulnerabilities to escalate privileges, gaining administrative or root access to the system. With elevated privileges, malicious programs can bypass security controls, modify system settings, or perform unauthorized actions, causing severe damage.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (a) (i) (1 mark)</h3>
<div class="question-content">
<p>Outline the functions of each of the following drivers: kernel device;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Kernel device drivers operate within the kernel space, directly interacting with hardware. Their function is to provide low-level control and management of hardware devices, enabling the operating system to communicate with and utilize hardware resources efficiently.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (a) (ii) (1 mark)</h3>
<div class="question-content">
<p>use mode device;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>User mode device drivers operate outside the kernel in user space. They provide a higher-level interface to hardware devices, often utilizing kernel drivers for low-level operations. User mode drivers enhance system stability by isolating driver failures from the kernel and can simplify driver development for certain devices.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (a) (iii) (1 mark)</h3>
<div class="question-content">
<p>block;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Block device drivers manage block-oriented devices like hard disks and SSDs. Their primary function is to handle block-level I/O operations, such as reading and writing data in fixed-size blocks, managing disk access, and implementing storage protocols.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (a) (iv) (1 mark)</h3>
<div class="question-content">
<p>character.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Character device drivers manage character-oriented devices like keyboards and serial ports. Their function is to handle byte-stream data transfer, managing input and output of individual characters or bytes, and providing interfaces for character-based communication.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following multiprocessor operating system models: master-slave;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Master-Slave Multiprocessor Model: In this model, one processor is designated as the master, and the others are slaves. The master processor handles operating system functions, scheduling, and system management, while slave processors execute user processes under the master's direction. It is simpler to implement but can create a bottleneck at the master processor and is less fault-tolerant.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>symmetric.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Symmetric Multiprocessor (SMP) Model: In SMP, all processors are treated equally and can perform all tasks, including operating system functions and user processes. Processors share memory and I/O resources and communicate through a shared bus or interconnect. SMP provides better load balancing and fault tolerance compared to master-slave but requires more complex OS design to manage concurrency and synchronization.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (c) (6 marks)</h3>
<div class="question-content">
<p>Computer operating systems access files using specific mechanism. Explain three file access mechanisms that could be used.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Sequential Access: In sequential access, files are accessed in a linear, ordered manner, from the beginning to the end. Operations like read and write proceed in sequence. This method is efficient for processing files in order, such as log files or batch processing, but inefficient for random access or frequent seeking.</p>
<p data-number="2">Direct/Random Access: Direct access allows accessing any file record directly without traversing from the beginning. Records are accessed based on their address or position. This method is suitable for applications requiring random data retrieval and updates, such as databases or indexed file systems, providing fast access to specific data records.</p>
<p data-number="3">Indexed Sequential Access: Indexed sequential access combines sequential and direct access methods. It uses an index to enable direct access to records based on key values, while also supporting sequential processing. Files are stored sequentially, and an index is maintained to locate records quickly. This method balances the advantages of both sequential and direct access, suitable for applications needing both ordered processing and indexed retrieval.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (d) (6 marks)</h3>
<div class="question-content">
<p>RAID storage techniques were introduced to manage the challenges of computer storage. Explain three benefits that could be realised from these techniques.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Improved Performance: RAID techniques like striping (RAID 0) can significantly improve data access and transfer rates by distributing data across multiple disks. This parallel access enhances read and write performance, reducing I/O latency and increasing throughput, beneficial for high-performance applications.</p>
<p data-number="2">Enhanced Reliability and Fault Tolerance: RAID levels like mirroring (RAID 1) and parity-based RAID (RAID 5, RAID 6) provide data redundancy. In case of a disk failure, data can be recovered or accessed from redundant copies or parity information, ensuring data availability and system resilience. This fault tolerance minimizes downtime and data loss.</p>
<p data-number="3">Increased Storage Capacity: RAID configurations like spanning (RAID 0) and concatenation can combine multiple physical disks into a single logical volume, increasing total storage capacity. RAID can aggregate storage space from multiple drives, providing larger volumes to accommodate growing data needs. While some RAID levels trade capacity for redundancy, others maximize usable storage.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (a) (2 marks)</h3>
<div class="question-content">
<p>Outline two types of job control language statements used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Command Statements: These JCL statements instruct the operating system to execute specific commands or programs. They initiate program execution, specify program parameters, and control the flow of job processing.</p>
<p data-number="2">Data Definition (DD) Statements: DD statements describe and allocate data resources required by a job. They define input and output datasets, specify file attributes, and associate datasets with programs, enabling data management within jobs.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (b) (4 marks)</h3>
<div class="question-content">
<p>Explain two divisions of addresses generated by the CPU.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Logical Address (Virtual Address): Logical addresses are generated by the CPU and are addresses within the process's virtual address space. They are independent of the physical memory layout and are translated to physical addresses by the Memory Management Unit (MMU). Logical addresses provide processes with a private and contiguous address space.</p>
<p>Physical Address: Physical addresses are the actual memory addresses in physical RAM. They are used to access physical memory locations. Logical addresses are mapped to physical addresses by the MMU, using techniques like paging or segmentation, to enable virtual memory and memory protection.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (c) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between record and file as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Record: A record is a structured unit of data within a file, representing a collection of related data items or fields. Records are logical entities that organize data within a file, e.g., a row in a database table or a line in a text file. Records are the basic units of data manipulation within a file.</p>
<p>File: A file is a named collection of related records or data, stored and managed by the operating system as a single unit. Files are containers for data and metadata, organized in a file system hierarchy (directories). Files are persistent storage units, providing a way to store and retrieve data persistently on storage devices.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Explain two circumstances under which deadlocks could occur in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Mutual Exclusion and Hold and Wait: Deadlock can occur when processes require exclusive access to resources (mutual exclusion) and hold allocated resources while waiting to acquire additional resources (hold and wait). If multiple processes hold resources and request resources held by others, a circular wait condition can arise, leading to deadlock.</p>
<p data-number="2">No Preemption and Circular Wait: Deadlock can occur when resources cannot be forcibly taken away from a process (no preemption) and a circular wait condition exists. Circular wait happens when two or more processes are waiting for each other to release resources in a circular chain, preventing any process from proceeding and resulting in a deadlock.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (d) (ii) (6 marks)</h3>
<div class="question-content">
<p>In order to achieve device independence, the computer organizes the I/O software in layers. Describe three such layers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">User-Level I/O Libraries: This is the highest layer, consisting of user-level libraries and APIs that provide a device-independent interface for applications to perform I/O operations. Libraries abstract device-specific details, offering high-level functions like file I/O, network communication, and device access. Applications interact with these libraries without needing to know device-specific details.</p>
<p data-number="2">Device-Independent OS Core: This layer in the OS kernel provides a device-independent abstraction for I/O operations. It includes generic I/O functions, buffering, caching, and error handling mechanisms that are common across different device types. This layer translates device-independent requests from user-level libraries into device-specific requests for lower layers.</p>
<p data-number="3">Device Drivers: Device drivers are the lowest layer, directly interacting with hardware devices. Each device driver is specific to a particular type of device or device controller. Drivers implement device-specific I/O operations, handle hardware interrupts, and translate generic I/O requests from the OS core into device-specific commands. Device drivers encapsulate hardware-specific details, ensuring device independence for higher layers.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in I/O devices: external interrupt;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>External Interrupt: An external interrupt is a hardware interrupt generated by an I/O device or external hardware component to signal an event requiring CPU attention. External interrupts are asynchronous signals from peripherals indicating completion of I/O operations, device status changes, or external events, prompting the CPU to handle the interrupt request.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>software interrupt.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Software Interrupt (Trap): A software interrupt, also known as a trap or exception, is an interrupt generated by software, typically by a program executing an instruction that requires OS intervention. Software interrupts are synchronous events caused by program execution, such as system calls, illegal instructions, or page faults, invoking OS services to handle the event.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (b) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between deterministic scheduling and non-feministic scheduling algorithms for processes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Deterministic Scheduling Algorithms:</p>
<p>Deterministic scheduling algorithms make scheduling decisions based on predictable process characteristics, such as known burst times or arrival times. These algorithms aim to optimize performance metrics based on this prior knowledge. Examples include First-Come, First-Served (FCFS) and Shortest Job Next (SJN). Deterministic algorithms are predictable and can provide guarantees on performance metrics under known conditions.</p>
<p>Non-Deterministic Scheduling Algorithms:</p>
<p>Non-deterministic scheduling algorithms make scheduling decisions without complete prior knowledge of process characteristics. They adapt to dynamic system conditions and process behaviors. Examples include Priority Scheduling, Round Robin, and Multilevel Queue Scheduling. Non-deterministic algorithms are more flexible and adaptable to real-world scenarios with varying process demands but may offer less predictability compared to deterministic algorithms.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (c) (4 marks)</h3>
<div class="question-content">
<p>The Manager of ABC Company Ltd. intends to learn about the functions of virtual devices. Explain two functions of the device giving an example.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Device Emulation: Virtual devices emulate the functionality of physical hardware devices in a virtualized environment. They provide a software-based abstraction of hardware, allowing virtual machines or applications to interact with devices without direct physical hardware access. Example: Virtual network interface card (vNIC) emulates a physical NIC, enabling network connectivity for virtual machines.</p>
<p data-number="2">Resource Sharing and Abstraction: Virtual devices enable sharing and abstraction of physical hardware resources among multiple virtual machines or processes. They decouple hardware from software, allowing efficient resource utilization and device management in virtualized or containerized environments. Example: Virtual disk (vDisk) abstracts physical storage, allowing multiple VMs to share underlying storage resources without direct hardware contention.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Figure 1 represents the structure of a computer disk.</p>
<p><img src="Screenshot_2025-03-11_at_14-32-30_2021j.pdf.png" alt="" width="443" height="494" /></p>
<p>Use it to answer the questions that follow. Identify the parts labelled (i), (ii), (iii) and (iv).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">(i) Platter: The circular magnetic disk on which data is stored.</p>
<p data-number="2">(ii) Track: A concentric circular path on the platter surface where data is recorded.</p>
<p data-number="3">(iii) Cylinder: A set of tracks at the same radial position across all platters.</p>
<p data-number="4">(iv) Sector: A segment of a track, representing the smallest unit of data storage.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Explain two uses of the R/W head of the computer disk.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Reading Data: The Read/Write (R/W) head is used to detect and sense magnetic patterns on the disk platter surface, converting them into electrical signals representing digital data. During read operations, the head senses the magnetic flux reversals on the disk, retrieving stored data.</p>
<p data-number="2">Writing Data: The R/W head is used to magnetize areas on the disk platter surface to store digital data. During write operations, the head generates magnetic fields to alter the magnetic orientation of particles on the disk, encoding data onto the storage medium.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (a) (4 marks)</h3>
<div class="question-content">
<p>Explain two ways of enforcing mutual exclusion in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Semaphores: Semaphores are synchronization primitives used to control access to shared resources and enforce mutual exclusion. A semaphore is an integer variable with atomic operations (P and V). Processes use P operation to request access and V operation to release access, ensuring only one process can access a critical section at a time. Semaphores can be binary (mutex) or counting.</p>
<p data-number="2">Mutex Locks (Mutual Exclusion Locks): Mutex locks are binary semaphores that provide mutual exclusion. A mutex lock has two states: locked and unlocked. A process acquires the lock before entering a critical section, making it locked. Only the process holding the lock can unlock it after exiting the critical section. Mutex locks ensure that only one process can execute a critical section at any given time, preventing race conditions.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (b) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between multiple-partition allocation and single-partition allocation as applied in computer memory.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Single-Partition Allocation:</p>
<p>In single-partition allocation, main memory is divided into only two partitions: one for the operating system and one for a single user process. The entire user partition is allocated to a single process at a time. It is simple to implement but inefficient as it supports only one user process at a time and leads to memory wastage if the process is smaller than the partition.</p>
<p>Multiple-Partition Allocation:</p>
<p>In multiple-partition allocation, main memory is divided into several partitions, each capable of holding a process. Multiple processes can reside in memory concurrently. Partitions can be fixed-sized (static partitioning) or variable-sized (dynamic partitioning). Multiple partitioning improves memory utilization and allows multiprogramming by accommodating several processes simultaneously.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (c) (6 marks)</h3>
<div class="question-content">
<p>A student intends to study the functions of the dispatcher in process management. Explain three such functions.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Context Switching: The dispatcher is responsible for performing context switching, which involves saving the state of the current process (CPU registers, program counter, etc.) and loading the saved state of a new process to be executed. Context switching enables the CPU to switch between processes, supporting multitasking and time-sharing.</p>
<p data-number="2">Process Selection: The dispatcher selects the next process to be executed by the CPU from the ready queue, based on the scheduling algorithm implemented by the operating system. It determines which process gets CPU time allocation based on factors like priority, waiting time, or burst time, ensuring fair or prioritized process execution.</p>
<p data-number="3">CPU Allocation: The dispatcher allocates CPU time to the selected process, giving it control of the processor to execute its instructions. It sets up the execution environment for the process and starts its execution. CPU allocation is a core function of the dispatcher in enabling process execution and concurrency.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (d) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two types of queues that could be used in process scheduling.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Ready Queue: The ready queue holds processes that are in the ready state, waiting to be executed by the CPU. Processes in the ready queue are eligible for CPU allocation and are selected by the scheduler based on scheduling algorithms.</p>
<p data-number="2">Wait/Blocked Queue: Wait queues or blocked queues hold processes that are blocked or waiting for a specific event to occur, such as I/O completion or resource availability. Processes in wait queues are not eligible for CPU allocation until the event they are waiting for occurs, after which they may move to the ready queue.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Explain two circumstance that would lead to external fragmentation in computer memory.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Dynamic Partitioning with Variable Size Allocation: External fragmentation is common in dynamic partitioning where memory is allocated in variable-sized blocks. Over time, as processes are allocated and deallocated, memory becomes fragmented into small, non-contiguous holes. Even if total free memory is sufficient, a large process may not be allocated memory if no single contiguous block is large enough.</p>
<p data-number="2">First-Fit or Best-Fit Allocation Algorithms: Using allocation algorithms like first-fit or best-fit in dynamic partitioning can exacerbate external fragmentation. First-fit tends to allocate memory from the first available large enough block, potentially leaving larger holes fragmented later. Best-fit, while trying to minimize internal fragmentation, can also contribute to external fragmentation by creating many small, unusable free blocks scattered across memory.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four factors to consider when choosing computer file organization methods.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Access Pattern: Consider the primary way files will be accessed: sequential, random, or indexed. Sequential access favors sequential file organization, while random access suits direct or indexed organization.</p>
<p data-number="2">File Size and Volume: Evaluate the size and number of files. For large files, contiguous or indexed sequential methods might be efficient. For numerous small files, indexed or linked methods may be more appropriate.</p>
<p data-number="3">Performance Requirements: Analyze performance needs for file operations like read, write, search, and update. High-performance applications may require indexed or direct access for faster retrieval, while batch processing might benefit from sequential organization.</p>
<p data-number="4">Data Volatility and Update Frequency: Consider how often files are updated or modified. For frequently updated files, indexed or direct access methods may be more efficient for in-place updates. For relatively static files, sequential or indexed sequential organization might suffice.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (b) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between static loading and dynamic loading in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Static Loading:</p>
<p>In static loading, the entire program and all its required libraries are loaded into memory before program execution begins. All necessary code and data are loaded at load time. Static loading results in faster program startup as all components are in memory but increases memory usage during the entire execution, even if some parts of the code are not immediately needed.</p>
<p>Dynamic Loading:</p>
<p>In dynamic loading, program modules or libraries are loaded into memory only when they are first needed during runtime. Modules are loaded on demand. Dynamic loading reduces initial memory footprint and startup time as only essential parts are loaded initially. It conserves memory by loading modules only when required but may introduce overhead during runtime when loading modules for the first time.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (c) (6 marks)</h3>
<div class="question-content">
<p>A computer technician intends to list the good qualities of a computer clock to employees in a company. Outline six such qualities.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Accuracy: A good computer clock should provide accurate timekeeping, minimizing deviations from real-time. Accuracy ensures precise time measurements and synchronization, critical for time-sensitive applications and system operations.</p>
<p data-number="2">Reliability: A reliable computer clock should maintain consistent and dependable timekeeping over extended periods. Reliability ensures continuous time availability without interruptions or failures, vital for system stability and uptime.</p>
<p data-number="3">Stability: A stable computer clock should exhibit minimal drift or fluctuations in its timekeeping rate. Stability ensures consistent time progression and prevents time skew or distortions, important for long-term time accuracy and synchronization.</p>
<p data-number="4">Resolution: High resolution clocks offer fine-grained time measurements, allowing for precise timing and event ordering. Higher resolution clocks enable capturing short-duration events and accurate time-stamping, beneficial for performance analysis and real-time applications.</p>
<p data-number="5">Synchronization Capability: A good computer clock should support synchronization with external time sources, such as NTP servers or GPS, to maintain accurate and consistent time across systems. Synchronization ensures time alignment and coordination in distributed environments and networks.</p>
<p data-number="6">Low Overhead: An efficient computer clock should impose minimal overhead on system resources, consuming minimal CPU cycles and power. Low overhead clocks ensure timekeeping operations do not significantly impact system performance or energy consumption, important for resource-constrained systems and energy efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (d) (6 marks)</h3>
<div class="question-content">
<p>Most computer systems provide directories to aid users in different areas. Explain three advantages that users would realize from using these directories.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">File Organization and Management: Directories enable users to organize files hierarchically, grouping related files together. This structured organization simplifies file management, making it easier to locate, access, and maintain files. Directories provide a logical structure for organizing and categorizing files, improving file system usability.</p>
<p data-number="2">Efficient File Searching and Retrieval: Directories facilitate efficient file searching and retrieval. Users can navigate through directory hierarchies to locate specific files quickly. Directory structures, often implemented as trees or graphs, enable fast path traversal and file lookup, reducing file access time and improving user productivity.</p>
<p data-number="3">Namespace Management and Conflict Resolution: Directories provide namespaces, allowing users to create files with the same name in different directories without naming conflicts. Directories partition the file system namespace, enabling users to manage and organize files within distinct contexts. Namespace management prevents naming collisions and ensures file uniqueness within directories.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four causes of thrashing in computer memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Insufficient Physical Memory: Thrashing primarily occurs when the amount of physical RAM is insufficient to accommodate the working sets of active processes. When the total memory required by running processes exceeds available RAM, excessive page swapping occurs, leading to thrashing.</p>
<p data-number="2">High Degree of Multiprogramming: Increasing the number of processes in memory (degree of multiprogramming) beyond the system's memory capacity can lead to thrashing. With more processes competing for limited memory, working sets overlap, causing increased page faults and swapping.</p>
<p data-number="3">Global Page Replacement Algorithms: Using global page replacement algorithms, where a page fault in one process can cause page replacement from another process's frame, can contribute to thrashing. Global replacement may lead to processes continuously faulting on pages needed by other processes, increasing overall page fault rate.</p>
<p data-number="4">Small Page Size: Very small page sizes can exacerbate thrashing. Smaller pages increase the number of pages required to hold a process's working set. With more pages, page fault frequency may increase, especially if locality of reference is not strong, leading to higher swapping overhead and thrashing.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (b) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between synchronous I/O and asynchronous I/O in computer devices.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Synchronous I/O (Blocking I/O):</p>
<p>In synchronous I/O, when a process initiates an I/O operation, it blocks or waits until the I/O operation is complete before proceeding with further execution. The process is suspended and remains idle while waiting for I/O completion. Synchronous I/O is simpler to program but can lead to CPU underutilization as processes wait for I/O.</p>
<p>Asynchronous I/O (Non-blocking I/O):</p>
<p>In asynchronous I/O, when a process initiates an I/O operation, it does not block. The process can continue with other tasks while the I/O operation is performed in the background. The process is notified upon I/O completion, typically through interrupts or callbacks. Asynchronous I/O allows for concurrent processing and better CPU utilization as processes can perform other tasks while waiting for I/O operations to complete.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (c) (4 marks)</h3>
<div class="question-content">
<p>A lecturer repaired a faulty computer RAM disk. Explain two types of the disks he could have repaired.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">DRAM-based RAM Disk: A DRAM-based RAM disk is created using dynamic random-access memory (DRAM). It uses system RAM to simulate a disk drive, providing very fast read and write access. DRAM-based RAM disks are volatile, meaning data is lost when power is turned off. They are typically repaired by replacing faulty DRAM modules or addressing memory errors through error correction mechanisms.</p>
<p data-number="2">Flash-based RAM Disk (Solid State Drive - SSD): Although technically flash memory, SSDs are sometimes referred to as RAM disks due to their solid-state nature and fast access times compared to traditional HDDs. SSDs use non-volatile flash memory for data storage. Repairing a faulty SSD involves diagnosing and addressing issues with flash memory chips, controllers, or firmware. Repair may include firmware updates, bad block management, or component replacement.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Table 1 shows processes in a queue awaiting execution by the scheduler in a round robin scheduling algorithm.</p>
<p><img src="Screenshot_2025-03-11_at_15-14-03_2021j.pdf.png" alt="" width="406" height="212" /></p>
<p>Use the information provided to answer the questions that follow.</p>
<p>Draw a Gantt chart to represent the data in table 1, given quantum time as 20.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Gantt Chart for Round Robin Scheduling (Quantum = 20):</p>
<p>| P1(20) | P2(20) | P3(20) | P4(20) | P1(20) | P2(7) | P3(20) | P1(23) | P3(18) |</p>
<p>0 20 40 60 80 100 107 127 147 165</p>
<p>Explanation:</p>
<p>P1 runs for 20ms (0-20ms), remaining burst time = 43ms.</p>
<p>P2 runs for 20ms (20-40ms), remaining burst time = 7ms.</p>
<p>P3 runs for 20ms (40-60ms), remaining burst time = 38ms.</p>
<p>P4 runs for 20ms (60-80ms), remaining burst time = 14ms (Process finishes within quantum in the next round, but for chart consistency we show full quantum).</p>
<p>P1 runs for 20ms (80-100ms), remaining burst time = 23ms.</p>
<p>P2 runs for remaining 7ms (100-107ms), P2 finishes.</p>
<p>P3 runs for 20ms (107-127ms), remaining burst time = 18ms.</p>
<p>P1 runs for remaining 23ms (127-147ms), P1 finishes.</p>
<p>P3 runs for remaining 18ms (147-165ms), P3 finishes.</p>
<p>P4 finishes within its first time quantum.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Determine the average waiting time.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Waiting Time Calculation:</p>
<p>Completion Times: P1: 147, P2: 107, P3: 165, P4: 80</p>
<p>Burst Times: P1: 63, P2: 27, P3: 58, P4: 34</p>
<p>Turnaround Times: P1: 147, P2: 107, P3: 165, P4: 80 (Arrival time is assumed 0 for all processes)</p>
<p>Waiting Times = Turnaround Time - Burst Time:</p>
<p>P1 Waiting Time: 147 - 63 = 84</p>
<p>P2 Waiting Time: 107 - 27 = 80</p>
<p>P3 Waiting Time: 165 - 58 = 107</p>
<p>P4 Waiting Time: 80 - 34 = 46</p>
<p>Average Waiting Time = (84 + 80 + 107 + 46) / 4 = 317 / 4 = 79.25</p>
<p>Average Waiting Time: 79.25 ms</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<p></p>
<p></p>
<footer> 2021 The Kenya National Examinations Council</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="november_2021.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2019.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>