<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>November 2018 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-5"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li id="active"><a href="november_2018.html" class="active no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="july_2019.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2017.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">November 2018</h1></header>
<article class="iDevice_wrapper textIdevice" id="id5">
<div class="iDevice emphasis0" >
<div id="ta5_127_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: November 2018</p>
</div>
</header>
<p></p>
<p></p>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain one function of a memory-management unit (MMU)</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>One function of a <strong>memory-management unit (MMU)</strong> is <strong>address translation</strong>. The MMU translates logical or virtual addresses used by the CPU into physical addresses in main memory, enabling memory protection and virtual memory management.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between logical and physical memory addresses.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Logical Memory Address (Virtual Address):</strong></p>
<p><strong>Definition:</strong> A <strong>logical address</strong> is generated by the CPU during program execution. It is a virtual address that does not directly correspond to a physical location in memory. It is part of the virtual address space.</p>
<p><strong>Characteristics:</strong></p>
<p data-number="1"><strong>Program View:</strong> Logical addresses are viewed by the program; processes operate in logical address space.</p>
<p data-number="2"><strong>Abstraction:</strong> They provide an abstraction of the actual physical memory, allowing for memory protection and management.</p>
<p><strong>Physical Memory Address:</strong></p>
<p><strong>Definition:</strong> A <strong>physical address</strong> is the actual location in the main memory (RAM). It is the address used by the memory controller to access physical memory locations.</p>
<p><strong>Characteristics:</strong></p>
<p data-number="1"><strong>Hardware View:</strong> Physical addresses are seen by the memory hardware; the memory controller works with physical addresses.</p>
<p data-number="2"><strong>Real Location:</strong> They directly represent a physical storage location in RAM.</p>
<p><strong>Key Difference:</strong> The main difference is that <strong>logical addresses are virtual and process-specific</strong>, while <strong>physical addresses are real and hardware-specific</strong>. The <strong>MMU translates logical addresses to physical addresses</strong> during memory access.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (4 marks)</h3>
<div class="question-content">
<p>A typical operating system is bound to be upgraded over time for a number of reasons. Outline four reasons that could influence the upgrade.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Security Enhancements:</strong> Upgrades are often necessary to patch <strong>security vulnerabilities</strong> discovered in the operating system. These patches protect the system from malware, viruses, and unauthorized access, ensuring system integrity and user data safety.</p>
<p data-number="2"><strong>Performance Improvements:</strong> Upgrades can include optimizations that enhance the <strong>performance and efficiency</strong> of the operating system. This can involve improving resource management, reducing overhead, and speeding up system processes, leading to a better user experience.</p>
<p data-number="3"><strong>New Hardware Support:</strong> As new hardware technologies emerge (e.g., faster processors, new peripherals), operating system upgrades are required to provide <strong>compatibility and support</strong> for these devices. This ensures that users can utilize the latest hardware with their existing systems.</p>
<p data-number="4"><strong>Feature Additions and Improvements:</strong> Upgrades often introduce <strong>new features and functionalities</strong>, or improve existing ones, to meet evolving user needs and industry trends. These updates can enhance usability, provide new tools, and keep the operating system competitive and relevant.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (6 marks)</h3>
<div class="question-content">
<p>Judy was required to design a job scheduling algorithm for a proposed operating system. Explain three features she should consider in the design.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Fairness:</strong> The scheduling algorithm should aim to provide <strong>fair allocation of CPU time</strong> to all processes. This means that no single process should be perpetually starved of CPU resources while others dominate. Fairness ensures that all processes get a reasonable share of processing time, preventing undue delays and improving overall system responsiveness.</p>
<p data-number="2"><strong>Throughput:</strong> <strong>Throughput</strong> is a measure of the number of processes completed per unit of time. Judy should consider designing an algorithm that maximizes throughput. A high throughput indicates that the system is efficiently processing jobs, making effective use of the CPU and system resources, which is crucial for productivity.</p>
<p data-number="3"><strong>Turnaround Time:</strong> <strong>Turnaround time</strong> is the total time taken from the submission of a process to its completion. The algorithm should aim to minimize the average turnaround time for processes. A lower turnaround time means that jobs are completed quicker, enhancing user satisfaction and system efficiency. This involves minimizing waiting time and execution time.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (4 marks)</h3>
<div class="question-content">
<p>Operating systems should make several types of scheduling decisions with respect to process execution, Describe two of these processor scheduling decisions.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Process Admission Scheduling:</strong> This decision involves determining <strong>which processes are allowed to enter the ready queue</strong> and compete for CPU time. The operating system must decide whether to admit a new process into the system, based on factors such as system load, resource availability, and process priority. Admission control helps to prevent system overload and maintain performance by limiting the number of processes competing for resources at any given time.</p>
<p data-number="2"><strong>Process Selection for Execution (CPU Scheduling):</strong> Once processes are in the ready queue, the operating system must decide <strong>which process to execute next</strong>. This decision is made by the CPU scheduler, using algorithms like FIFO, SJF, Priority Scheduling, Round Robin, etc. The choice of algorithm and the decision criteria (e.g., priority, remaining time, arrival time) directly impact system performance metrics such as response time, throughput, and fairness.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (3 marks)</h3>
<div class="question-content">
<p>Outline three process states as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Running:</strong> The process is currently being <strong>executed by the CPU</strong>. Instructions of the process are being processed.</p>
<p data-number="2"><strong>Ready:</strong> The process is <strong>waiting to be assigned to the CPU</strong>. It is ready to run but is waiting for the scheduler to select it.</p>
<p data-number="3"><strong>Blocked/Waiting:</strong> The process is <strong>waiting for some event to occur</strong>, such as I/O completion or resource availability. It cannot proceed until the event happens.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Modern operating system uses dynamic link memory technology. Explain two advantages of this technology.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Reduced Memory Footprint:</strong> Dynamic linking allows multiple programs to <strong>share a single copy of a library</strong> in memory. Instead of each program loading its own copy of common libraries, they all link to a shared library at runtime. This significantly reduces memory usage, especially when many programs are using the same libraries, leading to more efficient memory utilization and allowing more programs to run concurrently.</p>
<p data-number="2"><strong>Easier Updates and Maintenance:</strong> When a library is dynamically linked, updates or bug fixes to that library only need to be applied once to the shared library file. All programs that use this library will automatically benefit from the update the next time they are run, without needing to be recompiled or relinked. This simplifies software maintenance and deployment, ensuring consistency and reducing the effort required for software updates across the system.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (5 marks)</h3>
<div class="question-content">
<p>Peter was required to design a file system for a client. Outline five factors that he should consider in the design.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Data Organization and Structure:</strong> Peter needs to decide how files and directories will be <strong>organized and structured</strong> within the file system. This includes choosing a directory structure (e.g., hierarchical, flat), metadata management, and file naming conventions. Efficient organization is crucial for easy file access and management.</p>
<p data-number="2"><strong>Storage Efficiency:</strong> <strong>Efficient use of storage space</strong> is vital. Peter should consider techniques like block size optimization, compression, and sparse file support to minimize wasted space and maximize the amount of data that can be stored. Efficient storage directly impacts cost and capacity.</p>
<p data-number="3"><strong>Reliability and Fault Tolerance:</strong> The file system must be <strong>reliable and resilient to failures</strong>. Peter should consider implementing features like data redundancy (e.g., RAID), journaling, and checksums to protect against data loss due to hardware failures or system crashes. Data integrity and availability are paramount.</p>
<p data-number="4"><strong>Security:</strong> <strong>Security</strong> is a critical factor. Peter must consider access control mechanisms (e.g., permissions, ACLs), encryption options, and security policies to protect data from unauthorized access, modification, or deletion. Security measures safeguard sensitive information.</p>
<p data-number="5"><strong>Performance:</strong> <strong>Performance</strong> in terms of file access speed (read and write operations) is important for user experience. Peter should consider techniques like caching, disk scheduling algorithms, and file system layout optimization to enhance performance. Fast file access improves application responsiveness and overall system efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (4 marks)</h3>
<div class="question-content">
<p>Passwords are normally used to enhance security of a file system. Outline four guidelines that should be observed when using passwords.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Use Strong and Complex Passwords:</strong> Passwords should be <strong>long and complex</strong>, incorporating a mix of uppercase and lowercase letters, numbers, and special characters. Complexity makes it harder for attackers to guess or crack passwords using brute-force methods. Avoid using easily guessable information like names or dates.</p>
<p data-number="2"><strong>Keep Passwords Confidential:</strong> Passwords should be treated as <strong>highly confidential</strong> and never shared with anyone. Avoid writing down passwords in insecure places or disclosing them in emails or messages. Password secrecy is crucial to prevent unauthorized access.</p>
<p data-number="3"><strong>Change Passwords Regularly:</strong> Passwords should be <strong>changed periodically</strong> (e.g., every few months) to minimize the risk of compromised accounts. Regular password changes limit the window of opportunity for attackers if a password is ever compromised. Consider using password rotation policies.</p>
<p data-number="4"><strong>Avoid Reusing Passwords:</strong> <strong>Do not reuse the same password</strong> across multiple accounts or systems. If one password is compromised, using unique passwords for each account prevents attackers from gaining access to other systems. Password diversification is a key security practice.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (4 marks)</h3>
<div class="question-content">
<p>Preemptive process scheduling policies incur greater overheads than non-preemptive policies. Explain two strategies that could be used to mitigate these overheads.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Reduce Context Switching Frequency:</strong> While preemption requires context switching, <strong>optimizing the frequency of context switches</strong> can help reduce overhead. This can be achieved by adjusting the time quantum in algorithms like Round Robin. A larger time quantum reduces the number of preemptions and context switches, but it might impact responsiveness for short processes. Balancing the time quantum is key to minimizing overhead without sacrificing fairness.</p>
<p data-number="2"><strong>Efficient Context Switching Implementation:</strong> <strong>Optimizing the context switching mechanism itself</strong> is crucial. This involves minimizing the time it takes to save and restore the context of a process. Techniques include streamlining the process state saving and restoring routines, using faster memory for storing process context, and reducing the amount of data that needs to be saved and restored during a context switch. Efficient context switching reduces the time spent on scheduling overhead, improving overall system performance.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems: kernel;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Kernel:</strong> The <strong>kernel</strong> is the core component of an operating system. It is the <strong>lowest level of software</strong> that has complete control over the hardware. It manages system resources, including the CPU, memory, and I/O devices, and provides essential services to other parts of the OS and applications.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following terms as used in operating systems: interrupt.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Interrupt:</strong> An <strong>interrupt</strong> is a signal to the processor that requires immediate attention and temporarily suspends the current execution. It can be triggered by hardware (e.g., I/O device completion) or software (e.g., system call). Interrupts are essential for <strong>handling asynchronous events</strong> and enabling efficient system operation by allowing the OS to respond to events in real-time.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Purity was required to design an operating system that would provide necessary operating system's services but only mechanisms needed to implement such services. Identify the most appropriate category of operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The most appropriate category of operating system for Purity's requirements is a <strong>Microkernel Operating System</strong>.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>Outline four benefits that could realize when using the operating system identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Increased Reliability:</strong> In a microkernel architecture, most OS services run as user-level processes, separate from the kernel. If a service fails, it is <strong>isolated and less likely to crash the entire system</strong>. Only the microkernel, which is kept small and simple, runs in kernel mode, reducing the attack surface and improving overall system stability.</p>
<p data-number="2"><strong>Enhanced Security:</strong> The <strong>small kernel size</strong> and separation of services into user space enhance security. Fewer functions in kernel mode mean fewer potential vulnerabilities in the most critical part of the system. Service isolation also limits the impact of security breaches in one service on other parts of the OS.</p>
<p data-number="3"><strong>Flexibility and Extensibility:</strong> Microkernels are designed to be <strong>flexible and extensible</strong>. New services can be added and existing ones modified or replaced without requiring changes to the kernel itself. This modularity simplifies development, customization, and adaptation to different needs and environments.</p>
<p data-number="4"><strong>Simplified Kernel Design and Maintenance:</strong> By keeping the kernel small and focused on essential functions, microkernels are <strong>easier to design, implement, and maintain</strong>. The reduced complexity of the kernel makes it less prone to bugs and easier to debug and update, leading to more robust and manageable operating systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the term dispatcher as used in inter-process communication.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The term <strong>dispatcher</strong>, in the context of inter-process communication, is more accurately referred to as the <strong>scheduler or process scheduler</strong>. The dispatcher is the module that gives control of the CPU to the process selected by the short-term scheduler. It's involved in context switching, which is crucial for managing and switching between processes, including those communicating with each other.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between human and machine readable I/O devices.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Human-Readable I/O Devices:</strong></p>
<p><strong>Purpose:</strong> Designed for <strong>interaction with human users</strong>. They facilitate communication and data exchange between humans and the computer system.</p>
<p><strong>Examples:</strong></p>
<p data-number="1"><strong>Keyboard:</strong> Input device for text and commands.</p>
<p data-number="2"><strong>Monitor:</strong> Output device for displaying visual information.</p>
<p data-number="3"><strong>Mouse:</strong> Input device for pointing and selection.</p>
<p><strong>Characteristics:</strong></p>
<p data-number="1"><strong>Slow Speed:</strong> Operate at speeds limited by human interaction rate.</p>
<p data-number="2"><strong>Formatted Data:</strong> Data is often formatted for human comprehension (e.g., text, images).</p>
<p><strong>Machine-Readable I/O Devices:</strong></p>
<p><strong>Purpose:</strong> Designed for <strong>communication with other machines or for data storage</strong> that is primarily processed by machines.</p>
<p><strong>Examples:</strong></p>
<p data-number="1"><strong>Disk Drives (HDD, SSD):</strong> Storage devices for machine-processed data.</p>
<p data-number="2"><strong>Network Interface Cards (NICs):</strong> For machine-to-machine network communication.</p>
<p data-number="3"><strong>Sensors:</strong> Input devices providing data for automated systems.</p>
<p><strong>Characteristics:</strong></p>
<p data-number="1"><strong>High Speed:</strong> Operate at much higher speeds for efficient data transfer.</p>
<p data-number="2"><strong>Raw Data:</strong> Data is often in raw or machine-optimized formats (e.g., binary, structured data).</p>
<p><strong>Key Difference:</strong> <strong>Human-readable devices</strong> focus on user interaction and are slower, while <strong>machine-readable devices</strong> prioritize speed and efficiency for inter-machine communication and data processing.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (4 marks)</h3>
<div class="question-content">
<p>A lecturer described single buffering scheme to an OS class. Outline two techniques used with this scheme that he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Simple Buffer Management:</strong> In single buffering, a <strong>single buffer is used in system memory</strong> to transfer data between an I/O device and the process. The lecturer might have mentioned the simplicity of management as a key aspect. Only one buffer needs to be allocated and managed, which reduces the complexity of buffer control and resource allocation. Data is transferred to the buffer, then processed; this is straightforward to implement.</p>
<p data-number="2"><strong>Synchronous Operation:</strong> Single buffering typically involves <strong>synchronous I/O operations</strong>. The process must wait until the data transfer to the buffer is complete before it can process the data. Similarly, the I/O device has to wait until the buffer is emptied by the process before the next transfer can begin. This synchronous nature simplifies the control flow and data handling but can lead to performance bottlenecks if I/O operations are slow, as the CPU remains idle during I/O transfer.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (3 marks)</h3>
<div class="question-content">
<p>Outline three file access methods in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Sequential Access:</strong> Files are accessed in a <strong>linear, ordered manner</strong>, from the beginning to the end. To access a specific record, all preceding records must be read. This method is efficient for processing files in order but inefficient for random access.</p>
<p data-number="2"><strong>Direct (Random) Access:</strong> Files can be accessed in <strong>any order, directly accessing any record</strong> without needing to read through preceding records. This is achieved using record numbers or keys to determine the exact location of the data. It is efficient for applications needing to access specific parts of a file quickly.</p>
<p data-number="3"><strong>Indexed Sequential Access:</strong> This method combines sequential and direct access. An <strong>index is created for the file</strong>, containing keys and pointers to records. Sequential access is still possible, but direct access is also supported through the index, allowing for efficient retrieval based on keys while maintaining sequential processing capability.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Define the term disk cache as used in I/O communication.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Disk cache</strong> is a portion of <strong>main memory (RAM)</strong> that is used to store frequently accessed data blocks from the disk. It acts as a <strong>buffer between the disk and the CPU</strong>, aiming to reduce the average time to access data by serving requests from the faster RAM cache instead of the slower disk.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (ii) (5 marks)</h3>
<div class="question-content">
<p>There are several file directories systems but all support similar file operations. Outline five examples of these file operations.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Create:</strong> This operation allows users to <strong>create a new file</strong> within the file system. It involves allocating storage space for the file and adding an entry for it in the directory structure, including metadata such as name, permissions, and timestamps.</p>
<p data-number="2"><strong>Read:</strong> The <strong>read</strong> operation enables users to <strong>access and retrieve data</strong> from an existing file. It involves locating the file, checking access permissions, and transferring the file's content from storage to memory for processing.</p>
<p data-number="3"><strong>Write:</strong> The <strong>write</strong> operation allows users to <strong>modify or add data to a file</strong>. It involves locating the file, checking write permissions, and transferring data from memory to the file's storage location, updating the file's content.</p>
<p data-number="4"><strong>Delete:</strong> The <strong>delete</strong> operation is used to <strong>remove a file</strong> from the file system. It involves removing the file's directory entry, deallocating the storage space occupied by the file, and updating relevant metadata. Permission checks are typically performed before deletion.</p>
<p data-number="5"><strong>Rename:</strong> The <strong>rename</strong> operation allows users to <strong>change the name of a file</strong>. It involves updating the file's entry in the directory structure with the new name, while preserving the file's content and other metadata. This operation is primarily a metadata update.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two objectives of memory management in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Efficient Memory Utilization:</strong> One key objective is to <strong>maximize the use of available memory</strong>. Memory management aims to allocate memory to processes in a way that minimizes wasted space (e.g., through techniques like dynamic allocation and compaction) and allows as many processes as possible to reside in memory concurrently, improving system throughput.</p>
<p data-number="2"><strong>Memory Protection:</strong> <strong>Protecting the memory space of one process from unauthorized access by other processes</strong> is crucial. Memory management ensures that each process operates within its allocated memory region, preventing interference and data corruption caused by errant or malicious processes. This isolation enhances system stability and security.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between a CD recordable (CD-R) and a CD Rewritable (CD-RW).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>CD-R (CD Recordable):</strong></p>
<p><strong>Write Capability:</strong> CD-R media can be <strong>written to only once</strong>. Once data is written, it becomes permanent and cannot be erased or overwritten.</p>
<p><strong>Technology:</strong> Uses a dye layer that is permanently altered (burned) by the laser during the writing process to represent data.</p>
<p><strong>Usage:</strong> Suitable for <strong>archiving data</strong>, distributing software or music, and creating permanent backups where data immutability is desired.</p>
<p><strong>CD-RW (CD Rewritable):</strong></p>
<p><strong>Write Capability:</strong> CD-RW media can be <strong>written to, erased, and rewritten multiple times</strong>. Data can be modified or updated as needed.</p>
<p><strong>Technology:</strong> Uses a phase-change material that can switch between crystalline and amorphous states when heated by the laser, allowing for data to be written, erased, and rewritten.</p>
<p><strong>Usage:</strong> Suitable for <strong>temporary data storage</strong>, data backup where updates are needed, and as a reusable storage medium. They are more versatile but typically more expensive than CD-Rs.</p>
<p><strong>Key Difference:</strong> The primary difference is that <strong>CD-Rs are write-once media</strong>, while <strong>CD-RWs are rewritable media</strong>. CD-Rs are for permanent storage, and CD-RWs are for reusable storage.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (4 marks)</h3>
<div class="question-content">
<p>Modern operating system does not use fixed memory partitioning. Explain two limitations of this memory management technique that could be influence this trend.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Internal Fragmentation:</strong> Fixed partitioning leads to <strong>internal fragmentation</strong>. Partitions are allocated in fixed sizes, and if a process requires less memory than the partition size, the unused space within the partition is wasted. This wasted space within allocated partitions accumulates and reduces overall memory utilization. For example, if a 10MB partition is allocated to a 2MB process, 8MB is internally fragmented and unusable.</p>
<p data-number="2"><strong>Inefficient Memory Utilization and Program Size Limitation:</strong> Fixed partitioning is <strong>inefficient in utilizing memory</strong> because partition sizes are predetermined and static. If a process size exceeds the largest available partition, it cannot be loaded, even if there is enough total free memory, just not in a contiguous block of the required size. This limits the size of programs that can be run and can lead to situations where memory is available in total but not in usable fixed-size chunks, resulting in poor resource utilization and inflexibility.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (2 marks)</h3>
<div class="question-content">
<p>Explain the term segment as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>In memory management, a <strong>segment</strong> is a logical unit of memory organization that is visible to the programmer. It is a <strong>variable-sized block of memory</strong> that can represent a logical entity such as a code segment, data segment, or stack segment. Segmentation allows for logical division of a program's address space, providing structure and protection.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (4 marks)</h3>
<div class="question-content">
<p>List four requirements for a memory management technique.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Relocation:</strong> The memory management technique must support <strong>relocation</strong>, allowing processes to be loaded into different physical memory locations. This is necessary because the available memory may not always be at a fixed starting address, and processes might need to be moved during execution (e.g., in swapping or paging systems). Relocation provides flexibility in memory allocation.</p>
<p data-number="2"><strong>Protection:</strong> <strong>Memory protection</strong> is a crucial requirement. The technique should ensure that processes are protected from each other, preventing unauthorized access to memory regions belonging to other processes or the operating system. Protection is essential for system stability and security, preventing one process from corrupting or interfering with others.</p>
<p data-number="3"><strong>Sharing:</strong> The memory management scheme should facilitate <strong>sharing of memory</strong> among processes when needed. This can be useful for sharing code or data between processes, reducing memory usage and enabling inter-process communication. Shared memory segments need to be managed and protected appropriately.</p>
<p data-number="4"><strong>Logical Organization:</strong> Memory management should support a <strong>logical organization of memory</strong> that aligns with the programmer's view of memory (e.g., segments, pages). This logical structure simplifies program development and memory management by providing a structured and understandable memory model, abstracting away the physical memory details.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (6 marks)</h3>
<div class="question-content">
<p>Deadlock in resource allocation exists only if several conditions hold. Explain three conditions that are likely to trigger deadlock.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Mutual Exclusion:</strong> <strong>Mutual exclusion</strong> condition states that at least one resource must be held in a non-sharable mode. This means that only one process at a time can use the resource. If another process requests that resource, it must wait until the resource is released. This condition is necessary for deadlock because if all resources were sharable, deadlock would not occur.</p>
<p data-number="2"><strong>Hold and Wait:</strong> The <strong>hold and wait</strong> condition occurs when a process is holding onto at least one resource and is waiting to acquire additional resources that are currently being held by other processes. For deadlock to happen, a process must hold resources it has already been allocated while requesting new ones. If a process had to request all its resources at once and not hold any while waiting, deadlock could be avoided.</p>
<p data-number="3"><strong>No Preemption:</strong> The <strong>no preemption</strong> condition means that resources cannot be forcibly taken away from a process holding them. A resource can only be released voluntarily by the process holding it after that process has completed its task. If resources could be preempted from processes, deadlock could be resolved by taking resources away from a holding process and giving them to a waiting process.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>Distributed Deadlock Detection algorithms are more commonly used in distributed operating systems. Explain two strengths that could be influencing their application.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Detection of System-Wide Deadlocks:</strong> Distributed deadlock detection algorithms are designed to <strong>detect deadlocks that span across multiple nodes</strong> in a distributed system. In distributed systems, processes on different machines may hold and request resources from other machines, leading to deadlocks that are not confined to a single system. These algorithms can gather information from various nodes to construct a global wait-for graph and identify cycles, indicating deadlocks that would be impossible to detect with local deadlock detection mechanisms.</p>
<p data-number="2"><strong>Autonomous Node Operation:</strong> Distributed deadlock detection allows each node in the system to operate <strong>autonomously while still participating in deadlock detection</strong>. Nodes can independently manage their local resources and processes. The distributed algorithm then coordinates across nodes to detect deadlocks without requiring centralized control. This decentralized approach aligns with the nature of distributed systems, enhancing scalability and fault tolerance by avoiding single points of failure and allowing nodes to function even if communication is temporarily disrupted.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (ii) (4marks)</h3>
<div class="question-content">
<p>An authentication process consists of two steps. Explain two of these steps that could be incorporated in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>User Identification:</strong> The first step in authentication is <strong>user identification</strong>. This involves the system requesting the user to provide a unique identifier, typically a username or login ID. The operating system needs to know who is attempting to access the system before it can verify their identity. This step sets the stage for subsequent verification.</p>
<p data-number="2"><strong>Password Verification:</strong> Following identification, the system performs <strong>password verification</strong>. The user is prompted to enter a password, which is then compared against a stored (typically hashed) version associated with the provided username. If the entered password matches the stored hash, the user is authenticated. This step confirms that the user is who they claim to be based on secret knowledge (the password).</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (4 marks)</h3>
<div class="question-content">
<p>Figure 1 shows a cross section of a hard disk platter.</p>
<p><img src="Screenshot_2025-03-12_at_11-34-33_2018nov.pdf.png" alt="" width="402" height="294" /></p>
<p>Describe the function of the parts labeled (i) and (ii).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Referring to Figure 1:</p>
<p><strong>(i) Magnetic Coating (Magnetic Layer):</strong> This layer is the <strong>magnetic medium</strong> where data is actually stored on the hard disk platter. It is made of a ferromagnetic material that can be magnetized in different directions to represent binary data (0s and 1s). The read/write head interacts with this layer to write data by magnetizing areas and read data by detecting the magnetization direction.</p>
<p><strong>(ii) Substrate (Platter Substrate):</strong> This is the <strong>base material</strong> of the platter, typically made of aluminum alloy or glass. The substrate provides a rigid and non-magnetic foundation for the magnetic coating. It is crucial for the platter's structural integrity, ensuring it can spin at high speeds without warping or bending, and provides a smooth surface for the magnetic layer to be deposited on.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (4 marks)</h3>
<div class="question-content">
<p>Mary would like to implement shortest remaining time (SRT) processor scheduling algorithm. State four characteristics expected of the operating system with respect to the process control.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Preemptive Scheduling:</strong> SRT is a <strong>preemptive algorithm</strong>. The operating system must support preemption, meaning it can interrupt a running process if a new process arrives with a shorter remaining execution time, or if the remaining time of a running process becomes longer than that of another ready process. Preemption is essential for SRT to dynamically prioritize processes based on remaining time.</p>
<p data-number="2"><strong>Tracking Remaining Execution Time:</strong> The OS needs to <strong>accurately track or estimate the remaining execution time</strong> for each process. This is crucial for SRT to make scheduling decisions. The scheduler must have a mechanism to know (or predict) how much CPU time each process still needs to complete, which is often done through estimations based on past behavior or process specifications.</p>
<p data-number="3"><strong>Context Switching Overhead:</strong> Since SRT is preemptive and can lead to frequent context switches (especially if many short processes arrive), the operating system must be able to handle <strong>context switching efficiently</strong>. Minimizing the overhead of saving and restoring process states is important to prevent excessive performance degradation due to frequent scheduling decisions.</p>
<p data-number="4"><strong>Dynamic Priority Management:</strong> SRT effectively uses <strong>dynamic priority</strong>. Process priorities are not fixed but change based on the remaining execution time. The OS must support dynamic priority management, allowing the scheduler to adjust process priorities in real-time as processes execute and their remaining times decrease. The process with the shortest remaining time always gets the highest priority.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (4 marks)</h3>
<div class="question-content">
<p>Paul was advised to enable I/O buffering in his computer. Explain two conditions that could have informed his friend's advice.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Speed Mismatch between CPU and I/O Devices:</strong> If Paul's computer frequently performs operations involving <strong>slow I/O devices</strong> (like hard drives, network connections), enabling I/O buffering can help bridge the speed gap between the fast CPU and slow I/O. Buffering allows the CPU to continue processing other tasks while data is being transferred to or from the slower I/O device in the background, improving overall system throughput and responsiveness.</p>
<p data-number="2"><strong>Data Transfer Size Discrepancies:</strong> If applications on Paul's computer often deal with <strong>data transfers in chunks that are not optimally sized for I/O devices</strong>, buffering can be beneficial. Buffers can accumulate smaller data chunks into larger, more efficient transfer units for I/O operations, or break down large data into manageable segments. This optimization reduces the overhead of frequent small I/O requests and improves the efficiency of data transfer operations, especially for disk and network I/O.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, outline a process control block.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>Process Control Block (PCB)</strong> is a data structure used by the operating system to manage and store information about each process. It contains all the necessary details for managing a process's execution and state.</p>
<p><strong>Diagrammatic Outline:</strong></p>
<pre style="background-color: #f0f0f0; padding: 10px; border-radius: 5px; font-family: monospace; overflow-x: auto;">+-----------------------+
| Process Identifier (PID)|
+-----------------------+
| Process State         | (e.g., Running, Ready, Blocked)
+-----------------------+
| Program Counter (PC)  | (Address of next instruction)
+-----------------------+
| CPU Registers         | (Accumulators, index registers, etc.)
+-----------------------+
| Memory Management Info| (e.g., Page table base, segment table)
+-----------------------+
| CPU Scheduling Info   | (e.g., Priority, scheduling queue pointers)
+-----------------------+
| I/O Status Info       | (List of open files, I/O devices allocated)
+-----------------------+
| Accounting Info       | (CPU time used, time limits, etc.)
+-----------------------+
| Context Data          | (Saved context when process is not running)
+-----------------------+
                    </pre>
<p><strong>Components of a PCB:</strong></p>
<p data-number="1"><strong>Process Identifier (PID):</strong> A <strong>unique number</strong> to identify the process.</p>
<p data-number="2"><strong>Process State:</strong> Indicates the <strong>current state</strong> of the process (e.g., running, ready, waiting).</p>
<p data-number="3"><strong>Program Counter (PC):</strong> Stores the <strong>address of the next instruction</strong> to be executed.</p>
<p data-number="4"><strong>CPU Registers:</strong> Saves the <strong>state of CPU registers</strong> when the process is interrupted.</p>
<p data-number="5"><strong>Memory Management Information:</strong> Includes details for <strong>memory management</strong>, like page tables or segment tables.</p>
<p data-number="6"><strong>CPU Scheduling Information:</strong> Contains <strong>scheduling priorities</strong> and pointers to scheduling queues.</p>
<p data-number="7"><strong>I/O Status Information:</strong> Lists <strong>open files and I/O devices</strong> allocated to the process.</p>
<p data-number="8"><strong>Accounting Information:</strong> Tracks <strong>resource usage</strong>, such as CPU time and limits.</p>
<p data-number="9"><strong>Context Data:</strong> General <strong>context information</strong> needed to resume the process execution.</p>
<p>The PCB is essential for the OS to manage processes, enabling context switching, scheduling, and resource management.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>Disk mirroring is a feature of Redundant Array of Independent Disks 1(RAID 1). Explain two limitations that could be realized while using it.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Reduced Storage Capacity:</strong> In RAID 1 (disk mirroring), <strong>half of the total disk capacity is used for redundancy</strong>. For every byte of data stored, another byte is duplicated on a mirror disk. This means if you have two 1TB drives in a RAID 1 configuration, you only get 1TB of usable storage space, as the other 1TB is used for mirroring. This effectively reduces the available storage capacity by 50%, making it less storage-efficient compared to RAID levels that utilize capacity more fully.</p>
<p data-number="2"><strong>Increased Write Overhead:</strong> <strong>Write operations in RAID 1 are slower</strong> compared to single-disk systems or RAID levels like RAID 0. Every write operation must be performed twice – once to the primary disk and again to the mirror disk to maintain data redundancy. This doubles the write I/O workload, potentially reducing write performance. While read performance can be improved (by reading from either disk), write performance is inherently limited by the need to duplicate every write operation.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two examples of resources needed for process execution.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>CPU Time:</strong> Processes need <strong>CPU time</strong> to execute their instructions. The CPU is the primary resource for computation, and processes require slices of CPU time to perform operations, calculations, and execute program code. CPU time is allocated by the operating system's scheduler.</p>
<p data-number="2"><strong>Memory:</strong> Processes require <strong>memory (RAM)</strong> to store their code, data, and stack during execution. Memory is essential for holding the process's working set, including program instructions, variables, and runtime data. Memory must be allocated and managed by the operating system for each process.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Outline four factors that may affect performance of a storage disk.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Seek Time:</strong> <strong>Seek time</strong> is the time taken for the disk's read/write head to move to the correct track (cylinder) on the platter. Longer seek times result in slower data access, especially for random access patterns. Seek time is a significant factor in hard disk drive (HDD) performance, less so in solid-state drives (SSDs).</p>
<p data-number="2"><strong>Rotational Latency:</strong> For HDDs, <strong>rotational latency</strong> is the time it takes for the desired sector on the track to rotate under the read/write head once the head is positioned over the correct track. Higher rotational speeds (RPM) reduce rotational latency. This is another HDD-specific factor affecting access speed.</p>
<p data-number="3"><strong>Transfer Rate:</strong> <strong>Transfer rate</strong> is the speed at which data can be transferred between the disk and the system's memory once the head is in the correct position and the sector is under the head. Higher transfer rates mean faster read and write operations. This is influenced by the disk interface (e.g., SATA, NVMe) and the disk's internal data processing capabilities.</p>
<p data-number="4"><strong>Disk Interface and Bus Bandwidth:</strong> The <strong>type of disk interface</strong> (e.g., SATA, NVMe, SAS) and the <strong>bandwidth of the system bus</strong> (e.g., PCIe) connecting the disk to the motherboard significantly impact performance. A faster interface and bus allow for higher data transfer rates. For example, NVMe over PCIe offers much higher bandwidth and lower latency compared to SATA, resulting in significantly better performance for SSDs.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between rename and modify as used in file operations.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Rename (File Operation):</strong></p>
<p><strong>Function:</strong> <strong>Rename</strong> operation changes the <strong>name of a file or directory</strong>. It alters the filename within the file system's directory structure but <strong>does not change the content of the file itself</strong>.</p>
<p><strong>Scope:</strong> Primarily affects <strong>metadata</strong> associated with the file, specifically the filename in the directory entry. The file's data, location on disk, and other attributes (except filename) remain unchanged.</p>
<p><strong>Impact:</strong> A relatively <strong>lightweight operation</strong> as it mainly involves updating directory entries. It's fast because it does not involve reading or writing the file's data content.</p>
<p><strong>Modify (File Operation):</strong></p>
<p><strong>Function:</strong> <strong>Modify</strong> operation changes the <strong>content of a file</strong>. It alters the data stored within the file, potentially adding, deleting, or changing the existing data.</p>
<p><strong>Scope:</strong> Directly affects the <strong>data blocks</strong> on the storage medium where the file's content is stored. Metadata like timestamps (modification time) are also updated.</p>
<p><strong>Impact:</strong> Can be a <strong>resource-intensive operation</strong>, especially for large files or significant changes, as it involves reading from and writing to the storage device. Performance depends on file size, changes made, and storage device speed.</p>
<p><strong>Key Difference:</strong> <strong>Rename</strong> changes the filename (metadata), while <strong>modify</strong> changes the file's content (data). Rename is metadata-focused and fast; modify is data-focused and can be slower depending on the extent of changes.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (4 marks)</h3>
<div class="question-content">
<p>Figure 2 shows a typical memory hierarchical map used in computers.</p>
<p><img src="Screenshot_2025-03-12_at_11-41-42_2018nov.pdf.png" alt="" width="634" height="517" /></p>
<p>Describe each of the layers labelled (i) and (ii).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Referring to Figure 2, depicting a memory hierarchy:</p>
<p><strong>(i) Cache:</strong> <strong>Cache memory</strong> is a <strong>small, fast memory</strong> located closer to the CPU than main memory (RAM). It stores frequently accessed data and instructions to speed up access times. When the CPU needs to read or write data, it first checks the cache. If the data is found in the cache (a cache hit), it is accessed quickly. If not (a cache miss), it's retrieved from RAM and then placed in the cache for future faster access. Cache is crucial for reducing average memory access time.</p>
<p><strong>(ii) RAM (Random Access Memory):</strong> <strong>RAM</strong> is the <strong>main memory</strong> of the computer system. It is larger and slower than cache but much faster than secondary storage (like hard drives). RAM is used to <strong>hold the operating system, currently running applications, and data being actively used</strong> by the CPU. It provides volatile storage, meaning data is lost when power is turned off. RAM is the primary working memory for active processes.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (6 marks)</h3>
<div class="question-content">
<p>Describe three circumstances under which a new process could be generated in an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>System Initialization (Booting):</strong> When the operating system <strong>starts up (boots)</strong>, it initiates several processes. The first process, often called 'init' or 'systemd', is created directly by the kernel. This initial process then starts other system daemons and services that are essential for the OS to function, such as process managers, memory managers, device drivers, and user login services. System boot is a fundamental circumstance for process creation.</p>
<p data-number="2"><strong>User Request (Command Execution or Application Launch):</strong> When a user <strong>executes a command or launches an application</strong>, the operating system creates a new process to run that program. For example, typing a command in the terminal or clicking an application icon triggers the OS to create a new process and load the program's code and data into memory, starting its execution. User interactions are a common trigger for process generation.</p>
<p data-number="3"><strong>Process Spawning (Parent Process Creating Child Process):</strong> An <strong>existing process</strong> can create one or more new processes, known as <strong>child processes</strong>. This is often done when an application needs to perform concurrent tasks or divide work into smaller, manageable units. For instance, a web server process might spawn new child processes to handle incoming client requests concurrently. Process spawning allows for modularity and parallelism in software execution.</p>
</div>
</div>
</section>
<section class="question">
<h3>9. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two reasons that could be influencing the use of cache memory in computers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Speed Gap between CPU and Main Memory:</strong> Cache memory is used to address the <strong>significant speed difference</strong> between the fast CPU and slower main memory (RAM). CPUs operate much faster than RAM can provide data. Cache acts as a high-speed buffer, storing frequently accessed data closer to the CPU, reducing the CPU's wait time for memory access and improving overall processing speed. This speed gap is a primary driver for cache use.</p>
<p data-number="2"><strong>Locality of Reference:</strong> Computer programs exhibit <strong>locality of reference</strong>, meaning they tend to access data and instructions in clusters, both temporally (repeated access to the same data in a short period) and spatially (access to data located near each other in memory). Cache memory leverages this principle by storing recently accessed data (temporal locality) and data adjacent to recently accessed data (spatial locality). This increases the probability of cache hits, making data access faster and more efficient due to program behavior.</p>
</div>
</div>
</section>
<section class="question">
<h3>9. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between asynchronous and synchronous as applied in windows I/O communication.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Synchronous I/O (Blocking I/O):</strong></p>
<p><strong>Operation:</strong> In <strong>synchronous I/O</strong>, when a process initiates an I/O operation, it <strong>blocks or waits</strong> until the operation is fully completed. The process is suspended and cannot continue execution until the I/O request is served, and the data is transferred.</p>
<p><strong>Characteristics:</strong></p>
<p data-number="1"><strong>Blocking:</strong> Process is blocked during I/O operation.</p>
<p data-number="2"><strong>Simpler Programming:</strong> Easier to program and understand for simple I/O tasks.</p>
<p data-number="3"><strong>Inefficient Resource Usage:</strong> CPU remains idle while waiting for I/O, potentially wasting resources.</p>
<p><strong>Asynchronous I/O (Non-blocking I/O):</strong></p>
<p><strong>Operation:</strong> In <strong>asynchronous I/O</strong>, when a process starts an I/O operation, it <strong>does not wait</strong> for completion. The process continues to execute other tasks. The OS handles the I/O operation in the background and notifies the process when the operation is complete, typically through signals or callbacks.</p>
<p><strong>Characteristics:</strong></p>
<p data-number="1"><strong>Non-blocking:</strong> Process does not block and can perform other tasks.</p>
<p data-number="2"><strong>Complex Programming:</strong> More complex to program, requires handling of callbacks or event notifications.</p>
<p data-number="3"><strong>Efficient Resource Usage:</strong> CPU can perform other tasks while I/O operations are in progress, improving resource utilization and system responsiveness.</p>
<p><strong>Key Difference:</strong> <strong>Synchronous I/O blocks</strong> the process until completion, while <strong>asynchronous I/O is non-blocking</strong>, allowing the process to continue execution while I/O operations are performed in the background, leading to better resource utilization and responsiveness in many scenarios.</p>
</div>
</div>
</section>
<section class="question">
<h3>9. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Define the term spatial locality as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Spatial Locality</strong>, in operating systems, refers to the tendency of a processor to <strong>access memory locations that are physically close to each other in memory</strong>. If a process accesses a particular memory location, it is likely to access nearby memory locations in the near future. This principle is exploited by cache memory systems to improve performance by fetching blocks of data around the requested location.</p>
</div>
</div>
</section>
<section class="question">
<h3>9. (b) (ii) (6 marks)</h3>
<div class="question-content">
<p>Explain three types of information that should be found in a memory table.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Allocation Status of Memory Blocks:</strong> Memory tables should track the <strong>allocation status</strong> of each block of memory (e.g., page, segment, partition). This includes indicating whether a block is currently <strong>allocated (in use) or free (available)</strong>. For allocated blocks, it should specify which process or entity is using the block. This information is crucial for memory management functions like allocation, deallocation, and preventing memory conflicts.</p>
<p data-number="2"><strong>Physical Address Mapping:</strong> In virtual memory systems, memory tables (like page tables or segment tables) must store the <strong>mapping between virtual addresses and physical addresses</strong>. For each virtual page or segment, the table should contain the corresponding physical frame number where the data is actually stored in RAM. This mapping is essential for the MMU to translate virtual addresses generated by the CPU into physical addresses for memory access. If a virtual page is not in RAM, the table entry will indicate its location on secondary storage (e.g., disk).</p>
<p data-number="3"><strong>Protection and Access Control Information:</strong> Memory tables should include <strong>protection bits or access control information</strong> for each memory block. This information specifies the <strong>access rights</strong> (e.g., read, write, execute) granted to processes or users for each memory region. Protection bits ensure memory security by preventing unauthorized access and modifications, enforcing memory protection policies and isolating processes from each other's memory spaces. Examples include read-only, read-write, supervisor mode access, etc.</p>
</div>
</div>
</section>
<section class="question">
<h3>10. (6 marks)</h3>
<div class="question-content">
<p>Typically, users or groups of users are granted certain access rights to a file in a computer system. Describe three examples of these access rights that could be found in computer systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Read Access:</strong> <strong>Read access</strong> right allows a user or group to <strong>view or copy the contents of a file</strong>. With read permission, users can open and read the file's data but cannot make any changes to it. This right is essential for allowing users to access information without the risk of accidental or malicious modification. It is a fundamental access right for data sharing and information retrieval.</p>
<p data-number="2"><strong>Write Access:</strong> <strong>Write access</strong> right grants a user or group the ability to <strong>modify or delete a file</strong>. With write permission, users can change the file's content, add new data, or remove existing data. It often implies read access as well, as users typically need to read a file before modifying it. Write access is critical for users who need to update or manage files, but it must be controlled to prevent unauthorized alteration of important data.</p>
<p data-number="3"><strong>Execute Access:</strong> <strong>Execute access</strong> right allows a user or group to <strong>run a file as a program or script</strong>. This right is primarily relevant for executable files (e.g., .exe files on Windows, scripts on Linux/Unix). With execute permission, users can launch and execute the code contained in the file. For non-executable files, execute permission may have no effect or may be interpreted differently depending on the operating system. Controlling execute access is vital for system security, preventing the execution of unauthorized or malicious software.</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<p></p>
<p></p>
<footer>©2018 The Kenya National Examinations Council</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="july_2019.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="november_2017.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>