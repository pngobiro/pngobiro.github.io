<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>July 2015 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-11"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li id="active"><a href="july_2015.html" class="active no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="november_2015.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="novemeber_2014.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">July 2015</h1></header>
<article class="iDevice_wrapper textIdevice" id="id11">
<div class="iDevice emphasis0" >
<div id="ta11_133_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: July 2015</p>
</div>
</header>
<p><main>
<section class="question">
<h3>1. (a) (3 marks)</h3>
<div class="question-content">
<p>(a) Outline three types of file sharing technologies that could be implemented in an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Network File System (NFS)</strong>: <strong>NFS</strong> allows file sharing across a network, primarily used in Unix and Linux environments.</p>
<p data-number="2"><strong>Server Message Block (SMB/CIFS)</strong>: <strong>SMB/CIFS</strong> enables file sharing in Windows environments and is also compatible with other operating systems through Samba.</p>
<p data-number="3"><strong>Distributed File System (DFS)</strong>: <strong>DFS</strong> aggregates file shares across multiple servers into a single namespace, providing a unified view of distributed files.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) (i) Define the term cluster as used in file management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Cluster</strong>:</p>
<p>A <strong>cluster</strong> is the <strong>smallest unit of disk space allocation</strong> in a file system, comprising one or more contiguous sectors. It's the minimum amount of storage that can be allocated to a file, with file systems managing disk space in clusters rather than individual sectors.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (ii) (5 marks)</h3>
<div class="question-content">
<p>(ii) Operating system uses file allocation table to position files on a disk. Outline five desirable features of a good file allocation table.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Efficiency in Disk Space Management</strong>: A good FAT should efficiently manage disk space by <strong>minimizing fragmentation</strong> and optimizing the allocation of clusters to files. Efficient space management ensures that disk space is utilized effectively, reducing wastage and maximizing storage capacity.</p>
<p data-number="2"><strong>Fast File Access and Retrieval</strong>: The FAT should facilitate <strong>fast file access and retrieval</strong>. It should enable quick lookups of file locations and efficient traversal of file clusters to minimize access time and improve file system performance. Fast file access is crucial for application responsiveness and overall system performance.</p>
<p data-number="3"><strong>Robustness and Reliability</strong>: A desirable FAT should be <strong>robust and reliable</strong>, ensuring data integrity and preventing file system corruption. Features like redundancy, error checking, and recovery mechanisms are important to protect the FAT structure and file metadata from failures, maintaining data integrity and system stability.</p>
<p data-number="4"><strong>Scalability to Handle Large Disks and Files</strong>: The FAT structure should be <strong>scalable to handle large disk volumes and a large number of files</strong>. It should efficiently manage increasing storage capacities and file counts without performance degradation. Scalability ensures that the file system can accommodate future data growth and remain efficient over time.</p>
<p data-number="5"><strong>Simplicity and Ease of Implementation</strong>: While being efficient and robust, a good FAT should also be <strong>relatively simple to implement and maintain</strong>. Simplicity reduces the complexity of file system design and development, making it easier to implement, debug, and manage. A simpler FAT structure can also reduce overhead and improve overall file system efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>(c) (i) Outline two disadvantages of memory fragmentation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Inefficient Memory Utilization</strong>: Memory fragmentation leads to <strong>inefficient utilization of memory</strong>. External fragmentation results in usable memory being scattered in small chunks, while internal fragmentation wastes space within allocated partitions. In both cases, memory is not used optimally, reducing the system's capacity to run more processes or handle larger datasets.</p>
<p data-number="2"><strong>Reduced System Performance</strong>: Fragmentation can <strong>degrade system performance</strong>. External fragmentation may lead to failure to allocate memory for new processes or require memory compaction, which is time-consuming. Internal fragmentation wastes allocated memory, reducing the effective memory available and potentially causing more swapping or paging, thus slowing down system operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between device controller and device driver as used in computer systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Device Controller</strong>:</p>
<p>A <strong>device controller</strong> is a <strong>hardware component</strong> (chip or circuit board) that <strong>manages and controls the physical operations of an I/O device</strong>. It acts as an interface between the I/O device and the system bus. The device controller handles low-level operations such as data transfer, device signaling, error detection, and device-specific protocols. It is responsible for the physical control of the hardware device and interacts directly with the device hardware.</p>
<p><strong>Device Driver</strong>:</p>
<p>A <strong>device driver</strong> is a <strong>software component</strong> that <strong>enables the operating system to communicate with and control a specific hardware device</strong>. It acts as a software interface between the OS kernel and the device controller. The device driver translates generic OS commands into device-specific instructions that the device controller can understand. It handles device initialization, I/O request processing, interrupt handling, and device management functions. Device drivers abstract the hardware details and provide a uniform interface for the OS to interact with diverse hardware devices.</p>
<p><strong>Key Difference:</strong> The device controller is hardware that physically controls the I/O device, while the device driver is software that allows the OS to communicate with and manage the device controller and, thus, the I/O device.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Disk caching increases performance of a computer. Explain two ways used in disk caching to justify this statement.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Reduced Disk Access Time</strong>: <strong>Disk caching reduces disk access time</strong> by storing frequently accessed data in a cache memory (RAM), which has much faster access speeds than hard disks or SSDs. When data is requested, the system first checks the disk cache. If the data is found in the cache (cache hit), it is served directly from the cache, avoiding the slower disk access. Serving more requests from the cache significantly lowers the average access time, improving overall system responsiveness and speed of data retrieval.</p>
<p data-number="2"><strong>Increased I/O Throughput</strong>: Disk caching <strong>increases I/O throughput</strong> by reducing the number of actual disk I/O operations. By serving read requests from the cache and buffering write operations in the cache (write-back caching), disk caching reduces the load on the disk subsystem. Higher cache hit rates mean fewer disk accesses are needed to satisfy I/O requests, allowing the disk subsystem to handle more I/O operations in a given time, thus increasing overall I/O throughput and system efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (3 marks)</h3>
<div class="question-content">
<p>2. (a) (i) Outline three groups of I/O instructions used in computers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Control Instructions</strong>: <strong>Control instructions</strong> are used to <strong>control the operation of I/O devices</strong>. These instructions send commands to devices to initiate actions, set modes, or manage device functions. Examples include commands to start or stop a device, rewind a tape, or seek a specific track on a disk. They manage the behavior and state of I/O devices.</p>
<p data-number="2"><strong>Status Instructions</strong>: <strong>Status instructions</strong> are used to <strong>query the status of I/O devices</strong>. These instructions allow the CPU or operating system to check the current state of a device, such as its readiness, error status, or completion status. Status instructions are essential for device monitoring and error handling, enabling the system to check if a device is ready for data transfer or if any errors have occurred.</p>
<p data-number="3"><strong>Data Transfer Instructions</strong>: <strong>Data transfer instructions</strong> are used to <strong>transfer actual data between the CPU/memory and I/O devices</strong>. These instructions handle the movement of data for input and output operations. Examples include instructions to read data from an I/O port to memory or write data from memory to an I/O port. Data transfer instructions are the core of I/O operations, facilitating the exchange of data between the system and external devices.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Most computer systems have implemented dynamic memory access. Describe the procedure used to transfer data from I/O devices in these systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Procedure for Data Transfer from I/O Devices using Dynamic Memory Access (DMA)</strong>:</p>
<p data-number="1"><strong>DMA Request</strong>: The I/O device initiates a data transfer by sending a <strong>DMA request signal</strong> to the DMA controller. This request indicates that the device has data to transfer to memory or is ready to receive data from memory.</p>
<p data-number="2"><strong>DMA Controller Setup</strong>: Upon receiving the DMA request, the DMA controller <strong>requests control of the system bus</strong> from the CPU. The CPU may grant the bus to the DMA controller after completing the current bus cycle.</p>
<p data-number="3"><strong>Data Transfer by DMA Controller</strong>: Once the DMA controller gains control of the bus, it directly <strong>transfers data between the I/O device and main memory</strong> without involving the CPU for each byte transferred. The DMA controller acts as the bus master, managing the data transfer process independently.</p>
<p data-number="4"><strong>DMA Completion and Notification</strong>: After the data transfer is complete, the DMA controller <strong>notifies the CPU via an interrupt signal</strong>. The CPU is then informed that the DMA transfer is finished and can resume processing or initiate further operations. This process offloads data transfer tasks from the CPU, allowing it to perform other computations concurrently.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (5 marks)</h3>
<div class="question-content">
<p>(b) Rosalina would like to design a file management system. Outline five objectives of the system that she should consider in the design.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Meeting User Needs and Requirements</strong>: The primary objective is to design a file management system that <strong>effectively meets the needs and requirements of users</strong>. This includes providing functionalities for file creation, deletion, organization, sharing, and access in a manner that is user-friendly and efficient. User needs should drive the design and features of the file system.</p>
<p data-number="2"><strong>Efficient Data Storage and Retrieval</strong>: The file system should ensure <strong>efficient storage of data on storage devices and fast retrieval of files</strong> when needed. This involves optimizing disk space utilization, minimizing fragmentation, and implementing efficient algorithms for file access, directory operations, and metadata management. Performance in data storage and retrieval is crucial for system responsiveness.</p>
<p data-number="3"><strong>Data Integrity and Reliability</strong>: Maintaining <strong>data integrity and reliability</strong> is a critical objective. The file system must protect data from corruption, loss, and unauthorized modifications. Features like error detection and correction, data journaling, backup and recovery mechanisms, and robust metadata management are essential to ensure data integrity and system reliability.</p>
<p data-number="4"><strong>Security and Access Control</strong>: Implementing <strong>strong security and access control mechanisms</strong> is vital. The file system should provide features to control access to files and directories, ensuring data confidentiality and preventing unauthorized access. Access control should be flexible, allowing for permissions based on users, groups, and roles, and should protect against both internal and external security threats.</p>
<p data-number="5"><strong>Scalability and Adaptability</strong>: The file management system should be <strong>scalable to handle increasing data volumes and file counts</strong> as the system grows. It should also be <strong>adaptable to different storage technologies and evolving user needs</strong>. Scalability and adaptability ensure that the file system can meet current and future storage requirements and remain efficient and functional over time.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (4 marks)</h3>
<div class="question-content">
<p>3. (a) Explain the semaphore as used in operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Semaphore Explanation</strong>:</p>
<p>A <strong>semaphore</strong> is a <strong>synchronization primitive</strong> used in operating systems for controlling access to shared resources and coordinating process execution. It is an <strong>integer variable</strong> that can be accessed and manipulated through two atomic operations: <strong>wait (P)</strong> and <strong>signal (V)</strong>. Semaphores help solve critical section problems and manage concurrency by controlling process access to shared resources, preventing race conditions and ensuring synchronized operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (i) (3 marks)</h3>
<div class="question-content">
<p>(b) (i) Describe the term swapping as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Swapping Description</strong>:</p>
<p><strong>Swapping</strong> is a memory management technique where processes are <strong>moved between main memory (RAM) and secondary storage (disk)</strong> to manage memory and enable multiprogramming. When main memory becomes full or when a process is idle, the operating system swaps out inactive processes from RAM to disk (swap space) to free up memory. When a swapped-out process needs to run again, it is swapped back into RAM. Swapping allows more processes to be loaded and executed than physical memory can hold simultaneously, increasing the degree of multiprogramming.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Outline four major storage levels that could be found in a memory hierarchy diagram.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Registers</strong>: <strong>Registers</strong> are the <strong>fastest and most expensive level</strong>, located within the CPU. They hold data and instructions that the CPU is currently processing. Registers have very small capacity but offer the quickest access times.</p>
<p data-number="2"><strong>Cache Memory</strong>: <strong>Cache memory</strong> is a <strong>fast, relatively small memory</strong> located closer to the CPU than main memory. It stores frequently accessed data and instructions from RAM to reduce average memory access time. Cache memory is typically multi-level (L1, L2, L3), with increasing size and decreasing speed at each level.</p>
<p data-number="3"><strong>Main Memory (RAM)</strong>: <strong>Main Memory (RAM - Random Access Memory)</strong> is the <strong>primary working memory</strong> of a computer system. It is faster and more expensive than secondary storage but slower and cheaper than cache. RAM holds the programs and data currently in use by the CPU and provides a balance between speed, cost, and capacity.</p>
<p data-number="4"><strong>Secondary Storage (e.g., SSD, HDD)</strong>: <strong>Secondary Storage</strong>, such as Solid State Drives (SSDs) or Hard Disk Drives (HDDs), is the <strong>slowest and cheapest level</strong>, but offers the <strong>largest capacity</strong>. It is non-volatile and used for long-term storage of data, including the operating system, applications, and user files. Access times are significantly slower compared to RAM and cache.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) Explain three ways in which a new process is created in an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Process Creation by Parent Process (Forking)</strong>: A new process can be created by an <strong>existing process, known as the parent process, using the fork system call</strong>. When a parent process forks, the operating system creates a nearly identical copy of the parent process, which becomes the child process. The child process inherits many attributes from the parent, but has a new process ID and starts executing independently. Forking is a common method for process creation in Unix-like systems.</p>
<p data-number="2"><strong>Process Creation by System Initialization (Bootstrapping)</strong>: Some processes are created during <strong>system initialization or boot-up</strong>. When the operating system starts, it launches essential system processes that are needed for system functionality. These processes are typically created directly by the kernel as part of the boot sequence and are crucial for managing system resources and services. Examples include init process (in Unix-like systems) or system daemons.</p>
<p data-number="3"><strong>Process Creation by User Request (Command Execution)</strong>: New processes are often created in response to <strong>user requests, such as when a user executes a command or starts an application</strong>. When a user types a command in a shell or clicks on an application icon, the operating system creates a new process to run the requested program. The shell or GUI acts as a parent process that spawns new processes based on user actions. This is the primary way user applications are launched.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Derrick was required to investigate several elements of a process control block. Outline four elements that he could have established.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Process State</strong>: The PCB contains the <strong>current state of the process</strong>. This state indicates whether the process is currently running, ready to run, waiting (blocked), new, or terminated. The process state is dynamic and changes as the process executes and interacts with the system.</p>
<p data-number="2"><strong>Program Counter (PC)</strong>: The PCB stores the <strong>Program Counter (PC) value</strong> for the process. The PC holds the address of the next instruction that the process is to execute. When a process is interrupted or switched out, the PC value is saved in its PCB so that execution can resume from the correct point later.</p>
<p data-number="3"><strong>CPU Registers</strong>: The PCB includes <strong>CPU registers</strong>. This section saves the <strong>current values of all CPU registers</strong> when the process is switched out. Registers hold temporary data and intermediate results that the process is actively using. Saving and restoring registers are essential for context switching to ensure correct process resumption.</p>
<p data-number="4"><strong>Memory Management Information</strong>: The PCB contains <strong>memory management information</strong> for the process. This includes details about the process's memory allocation, such as <strong>pointers to page tables or segment tables</strong>. This information is crucial for virtual address translation and memory protection, enabling the OS to manage the process's memory space effectively.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>4. (a) Explain each of the following terms as used in operating system:</p>
<p>(i) shell;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Shell</strong>:</p>
<p>In operating systems, a <strong>shell</strong> is a <strong>command-line interpreter</strong>. It acts as an <strong>interface between the user and the operating system kernel</strong>. The shell takes user commands as input, interprets them, and executes them by making system calls to the kernel. It provides a command-line user interface (CLI) for users to interact with the OS, launch programs, manage files, and control system operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) thread.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Thread</strong>:</p>
<p>A <strong>thread</strong> is a <strong>lightweight unit of execution within a process</strong>. It is a single sequential flow of control within a program. Multiple threads can coexist within a process and share the same process resources, such as memory space and files. Threads enable concurrency within a process, allowing for parallel execution of different parts of a program and improving performance and responsiveness.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) AXB Company Ltd. intends to install an operating system with a friendly user interface.</p>
<p>(i) Identify the most appropriate type of operating system for the company justifying your answer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Graphical User Interface (GUI) Based Operating System</strong>:</p>
<p>The most appropriate type of operating system for AXB Company Ltd., focusing on a friendly user interface, is a <strong>Graphical User Interface (GUI) based operating system</strong>. GUI-based OSs like Windows, macOS, or Linux distributions with GUI environments (GNOME, KDE) are designed to be user-friendly and intuitive, providing visual interfaces with icons, menus, and windows. GUIs make computers accessible and easier to use for a broad range of users, especially those who are not technically expert.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Outline four drawbacks that the company could realize while using the operating system identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Higher Resource Consumption</strong>: <strong>GUI-based operating systems</strong> typically consume <strong>more system resources</strong> (CPU, memory, disk space) compared to command-line or text-based OSs. GUIs require resources to render graphical elements, manage windows, and handle user interactions. This higher resource consumption can lead to reduced performance, especially on systems with limited hardware resources.</p>
<p data-number="2"><strong>Increased Complexity and Overhead</strong>: GUI-based OSs are <strong>more complex and have higher overhead</strong>. The GUI layer adds complexity to the OS kernel and system architecture. Managing graphical interfaces, windowing systems, and event handling introduces additional overhead, which can impact system performance and responsiveness, especially for low-end hardware.</p>
<p data-number="3"><strong>Security Vulnerabilities due to Complexity</strong>: The <strong>increased complexity of GUI-based OSs can introduce more security vulnerabilities</strong>. A larger codebase and more complex system architecture can increase the potential for bugs and security flaws. GUI components, windowing systems, and graphics drivers can be targets for security exploits, potentially increasing the system's attack surface.</p>
<p data-number="4"><strong>Less Efficient for Server Environments and Automation</strong>: GUI-based OSs are generally <strong>less efficient for server environments and automation tasks</strong>. Server environments often benefit more from lightweight, command-line oriented OSs that minimize resource overhead and are optimized for server functionalities. Automation and scripting tasks are typically more efficiently performed using command-line interfaces rather than graphical interfaces, which are designed for interactive user sessions.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>(c) (i) Explain the term dispatcher as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Dispatcher</strong>:</p>
<p>The <strong>dispatcher</strong> is the <strong>module of the operating system's scheduler</strong> that <strong>gives control of the CPU to the process selected by the short-term scheduler</strong>. It is responsible for the actual context switch, which involves saving the state of the previously running process and loading the saved state of the process to be executed. The dispatcher is invoked every time a process needs to be switched in or out of the CPU.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between block-oriented and stream-oriented I/O devices.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Block-Oriented Devices</strong>:</p>
<p><strong>Block-oriented devices</strong> transfer data in <strong>fixed-size blocks or chunks</strong>. Data is accessed and transferred in blocks, and each block has a unique address. These devices typically support random access, allowing access to any block directly without needing to read through preceding data. Examples include <strong>disk drives (HDDs, SSDs)</strong> and tapes (in block mode). Block-oriented devices are suitable for storage and retrieval of structured data.</p>
<p><strong>Stream-Oriented Devices</strong>:</p>
<p><strong>Stream-oriented devices</strong> transfer data as a <strong>continuous stream of bytes or characters</strong>, without fixed block sizes. Data is accessed sequentially in a stream, and random access is generally not supported or efficient. Examples include <strong>keyboards</strong>, <strong>mice</strong>, <strong>printers</strong>, and <strong>network interfaces</strong>. Stream-oriented devices are used for character-based or byte-based data flow, typically for communication or sequential data processing.</p>
<p><strong>Key Difference:</strong> Block-oriented devices handle data in fixed blocks and support random access, while stream-oriented devices handle continuous streams of data and are primarily sequential access.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) A lecturer described goals of I/O module during an operating system class. Outline four goals he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Efficiency</strong>: A primary goal of an I/O module is to achieve <strong>efficiency in I/O operations</strong>. The module should aim to <strong>maximize I/O throughput and minimize I/O latency</strong>, ensuring that data transfer between the system and external devices is performed quickly and with minimal overhead. Efficient I/O operations are crucial for overall system performance and responsiveness.</p>
<p data-number="2"><strong>Device Independence</strong>: <strong>Device independence</strong> is a key goal. The I/O module should provide a <strong>uniform interface to higher-level software layers</strong> (OS and applications), abstracting away the device-specific details of different I/O devices. This allows applications to work with I/O devices in a generic manner, without needing to be rewritten or modified for each specific device type. Device drivers handle device-specific operations, providing abstraction.</p>
<p data-number="3"><strong>Error Handling</strong>: <strong>Robust error handling</strong> is an essential goal. The I/O module should be able to <strong>detect and handle errors that occur during I/O operations</strong>, such as device failures, data corruption, or transmission errors. Error handling mechanisms should include error detection, error recovery, and error reporting to ensure data integrity and system reliability in the presence of I/O faults.</p>
<p data-number="4"><strong>Uniform Interface</strong>: Providing a <strong>uniform interface</strong> is a goal for simplifying I/O programming. The I/O module should offer a <strong>consistent and standardized set of system calls and APIs</strong> for applications to perform I/O operations. This uniform interface hides the complexities of device-specific control and allows programmers to interact with I/O devices in a simple, predictable, and device-independent way, improving programmer productivity and code portability.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>5. (a) (1) Outline two memory placement algorithms.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>First-Fit</strong></p>
<p data-number="2"><strong>Best-Fit</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between short term and long term process scheduling.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Short-Term Scheduling (CPU Scheduling)</strong>:</p>
<p><strong>Short-term scheduling</strong>, also known as CPU scheduling, is the process of <strong>selecting one of the ready processes in memory to be executed by the CPU</strong>. It is invoked very frequently (milliseconds) whenever an event occurs that may lead to process switching, such as timer interrupts, I/O completion, or system calls. The main objective of short-term scheduling is to <strong>maximize CPU utilization and system throughput while minimizing response time and turnaround time</strong>. Short-term schedulers make fine-grained decisions about CPU allocation on a short time scale.</p>
<p><strong>Long-Term Scheduling (Job Scheduling)</strong>:</p>
<p><strong>Long-term scheduling</strong>, also known as job scheduling, is the process of <strong>selecting processes from a job pool and loading them into memory for execution</strong>. It controls the <strong>degree of multiprogramming</strong> â€“ the number of processes in memory. Long-term scheduling is invoked less frequently compared to short-term scheduling, typically when a process finishes or when system load changes significantly. Its primary objective is to <strong>control the number of processes in memory and balance the mix of processes</strong> (e.g., CPU-bound vs. I/O-bound) to optimize resource utilization and system performance over longer time scales.</p>
<p><strong>Key Difference:</strong> Short-term scheduling is for CPU allocation and is frequent, focusing on responsiveness and throughput. Long-term scheduling is for controlling the degree of multiprogramming and is less frequent, focusing on balancing process mix and resource utilization.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) (i) Define the term spatial locality as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Spatial Locality</strong>:</p>
<p><strong>Spatial locality</strong> is a principle of locality of reference in memory management that refers to the tendency of a processor to <strong>access memory locations that are physically close to each other in memory</strong>. If a program accesses a particular memory location, it is likely to access nearby memory locations in the near future. Spatial locality is often exploited by cache memory and block-based data transfer mechanisms to improve memory access performance.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Describe two limitations of dynamic memory partitioning schemes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>External Fragmentation</strong>: <strong>External fragmentation</strong> is a primary limitation of dynamic memory partitioning. As memory is allocated and deallocated over time in variable-sized chunks, free memory becomes fragmented into <strong>small, non-contiguous blocks</strong>. Even if the total amount of free memory is sufficient to satisfy a memory request, it may not be possible to allocate a contiguous block of the required size due to fragmentation. External fragmentation leads to wasted memory space and reduced efficiency in memory utilization.</p>
<p data-number="2"><strong>Complexity of Memory Management</strong>: <strong>Dynamic memory partitioning schemes are more complex to manage</strong> compared to fixed partitioning. They require more sophisticated algorithms for allocation, deallocation, and tracking free memory blocks. Managing variable-sized partitions, searching for suitable free blocks, and handling fragmentation add overhead to the memory management system, increasing the complexity of OS implementation and potentially impacting performance.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>(c) Figure 1 shows a directory structure in a typical operating system.</p>
<p>Use it to answer the questions that follow.</p>
<p><img src="Screenshot_2025-03-12_at_12-50-56_2015j.pdf.png" alt="" width="919" height="367" /></p>
<p>(i) Identify the directory structure depicted in the diagram justifying your answer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Hierarchical (Tree-Structured) Directory Structure</strong>:</p>
<p>The directory structure depicted in Figure 1 is a <strong>Hierarchical or Tree-Structured Directory Structure</strong>. This is justified by the presence of a <strong>master file directory</strong> (root-like directory) branching out into <strong>user directories</strong> (user 1, user 2, user 3, user 4), and further branching into <strong>user file directories</strong> (cat, bo, test, data, etc.) forming a tree-like hierarchy. This structure allows for nested directories, providing a clear and organized way to manage files and directories in a hierarchical manner, typical of modern file systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) Outline two advantages of the directory structure identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Improved Organization and Navigation</strong>: A hierarchical directory structure provides <strong>improved organization of files and directories</strong>. It allows users to group related files and directories logically under parent directories, creating a well-structured and easy-to-navigate file system. This hierarchical organization simplifies file management and makes it easier for users to locate and access files.</p>
<p data-number="2"><strong>Scalability and Manageability</strong>: Hierarchical directory structures are <strong>scalable and manage large numbers of files efficiently</strong>. The tree-like structure allows for creating subdirectories within directories, enabling the file system to handle a large volume of files and directories without becoming disorganized or unwieldy. Scalability and manageability are crucial for large-scale file systems and multi-user environments.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (iii) (4 marks)</h3>
<div class="question-content">
<p>(iii) Outline four typical directory operations that could be carried out in the directory structure identified in (c) (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Create Directory</strong>: <strong>Creating a directory</strong> is a fundamental operation. Users can create new directories within existing directories to organize files and create a hierarchical structure. This operation allows users to structure their files and directories logically, improving organization and manageability.</p>
<p data-number="2"><strong>Delete Directory</strong>: <strong>Deleting a directory</strong> is used to remove a directory and its contents (files and subdirectories). This operation allows users to clean up and remove directories that are no longer needed. Deletion operations typically require appropriate permissions and may involve checks to ensure the directory is empty or to recursively delete contents.</p>
<p data-number="3"><strong>List Directory Contents</strong>: <strong>Listing directory contents</strong> is a common operation to view the files and subdirectories within a directory. This operation allows users to see what files and directories are present in a given location, aiding in navigation and file management. The listing typically displays file and directory names, attributes, and sizes.</p>
<p data-number="4"><strong>Rename Directory</strong>: <strong>Renaming a directory</strong> allows users to change the name of a directory. This operation is used to reorganize or update directory names for better clarity or consistency. Renaming a directory typically preserves its contents and structure but changes its identifier within the file system hierarchy.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (4 marks)</h3>
<div class="question-content">
<p>6. (a) Figure 2 shows a NTFS volume layout diagram.</p>
<p>Outline the function of the parts labeled (i) and (ii).</p>
<p><img src="Screenshot_2025-03-12_at_12-52-38_2015j.pdf.png" alt="" width="778" height="318" /></p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on a typical NTFS volume layout, assuming (i) points to the Master File Table and (ii) points to the File Area:</p>
<p><strong>(i) Master File Table (MFT)</strong>:</p>
<p>Part labeled <strong>(i)</strong> represents the <strong>Master File Table (MFT)</strong>. The MFT is a <strong>core component of the NTFS file system</strong>. It is a <strong>database that contains metadata about every file and directory on the NTFS volume</strong>. For each file and directory, the MFT stores information such as file name, size, timestamps, permissions, data block locations, and attributes. The MFT is crucial for organizing and managing the entire file system structure and for locating and accessing files and directories. It acts as the central index and metadata repository for the NTFS volume.</p>
<p><strong>(ii) File Area</strong>:</p>
<p>Part labeled <strong>(ii)</strong> represents the <strong>File Area</strong>. The File Area is the <strong>region on the NTFS volume where the actual data content of files and directories is stored</strong>. It is the <strong>largest part of the volume</strong> and occupies the majority of the disk space. When files are created and data is written, the actual file data is stored in clusters within the File Area. The MFT contains pointers (metadata) that map filenames and directories to the locations of their data within the File Area. The File Area is where the user and application data resides.</p>
<p><strong>Relationship:</strong> The MFT (i) stores metadata and indexing information, while the File Area (ii) stores the actual file data. The MFT provides the structure and pointers to locate and manage files within the File Area.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Most CPUs have interrupt requests for operating system's operations. Explain two types of such interrupt requests.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Hardware Interrupts</strong>: <strong>Hardware interrupts</strong> are <strong>generated by hardware devices or peripherals to signal the CPU about an event that requires immediate attention</strong>. These interrupts are asynchronous events triggered by hardware components outside the CPU. Examples include interrupts from I/O devices (disk, network, keyboard), timers, and hardware failures. Hardware interrupts are used for timely handling of external events and device interactions.</p>
<p data-number="2"><strong>Software Interrupts (Traps)</strong>: <strong>Software interrupts</strong>, also known as traps or system calls, are <strong>generated by software, typically by a running program, to request services from the operating system kernel</strong>. Software interrupts are synchronous events triggered by specific instructions within a program. They are used to invoke kernel-level functionalities, such as I/O operations, process creation, memory allocation, or inter-process communication. System calls are the primary way user-level programs request OS services.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) With the aid of a diagram, describe contiguous file allocation method.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Contiguous File Allocation Method Description with Diagram</strong>:</p>
<p>In <strong>contiguous file allocation</strong>, each file occupies a set of <strong>contiguous blocks</strong> on the disk. This means that all disk blocks allocated to a file are physically adjacent to each other on the disk. The file system needs to know only the starting block address and the length (number of blocks) of the file to access it. Contiguous allocation is simple to implement and provides good performance for sequential file access.</p>
<p><strong>Diagram of Contiguous File Allocation:</strong></p>
<pre>Disk Blocks:
[ Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 | Block 8 | Block 9 | Block 10 | ... ]
+---------+---------+---------+---------+---------+---------+---------+---------+---------+----------+-----+
| File A  | File A  | File A  | File B  | File B  | File B  | File B  | File C  | File C  |   Free   | ... |
+---------+---------+---------+---------+---------+---------+---------+---------+---------+----------+-----+
  File A: Starts at Block 1, Length 3 Blocks (Blocks 1-3)
  File B: Starts at Block 4, Length 4 Blocks (Blocks 4-7)
  File C: Starts at Block 8, Length 2 Blocks (Blocks 8-9)
</pre>
<p><strong>Description:</strong></p>
<p data-number="1"><strong>Contiguous Blocks</strong>: Each file is allocated a <strong>contiguous set of disk blocks</strong>. For example, File A occupies blocks 1, 2, and 3, which are adjacent to each other.</p>
<p data-number="2"><strong>Directory Entry Information</strong>: The directory entry for each file stores the <strong>starting block address and the length (number of blocks)</strong> allocated to the file. For File A, the directory entry would store 'Start Block: 1, Length: 3'.</p>
<p data-number="3"><strong>Sequential Access Efficiency</strong>: Contiguous allocation is very <strong>efficient for sequential file access</strong>. Reading a file sequentially is fast because the disk head only needs to move from the starting block to the end block of the contiguous range. There is minimal seek time or fragmentation overhead for sequential reads.</p>
<p data-number="4"><strong>Direct Access Support</strong>: Direct (random) access is also relatively straightforward. To access block 'n' of a file, the system can calculate the physical block address by adding 'n-1' to the starting block address. However, direct access is still less efficient than sequential access as it may involve disk head movement to a specific block within the contiguous range.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>(d) (i) Juliet intends to procure an I/O device for her computer. Other than cost, outline four factors that she should consider when selecting the device.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Performance (Speed and Throughput)</strong>: <strong>Performance</strong> is a crucial factor. Juliet should consider the <strong>speed and throughput</strong> of the I/O device. For storage devices, this is measured in data transfer rates (MB/s or GB/s) and access times. For network devices, it's bandwidth. Higher performance devices improve system responsiveness and reduce bottlenecks.</p>
<p data-number="2"><strong>Compatibility</strong>: <strong>Compatibility</strong> with her computer system is essential. Juliet needs to ensure that the I/O device is <strong>compatible with her computer's interfaces</strong> (e.g., USB, PCIe, SATA), operating system, and drivers. Check for interface compatibility, OS support, and driver availability to avoid integration issues.</p>
<p data-number="3"><strong>Reliability and Durability</strong>: <strong>Reliability and durability</strong> are important for long-term use. Consider the device's <strong>build quality, Mean Time Between Failures (MTBF), and warranty</strong>. Reliable devices reduce the risk of device failures, data loss, and system downtime.</p>
<p data-number="4"><strong>Form Factor and Interface Type</strong>: Consider the <strong>form factor and interface type</strong> of the device. Ensure that the device <strong>physically fits into her computer</strong> (e.g., expansion slot, drive bay) and that the <strong>interface (e.g., USB, SATA, PCIe) is compatible</strong> with her system's ports and slots. Form factor and interface compatibility are essential for physical installation and connectivity.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Solomon, a programmer with a certain company was required to explain the roles of clock software to a client. Outline four functions that he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Timekeeping and System Clock Management</strong>: Clock software is responsible for <strong>maintaining the system's time and date</strong>. It updates the system clock based on hardware clock ticks and provides functions to set and retrieve the current date and time. Accurate timekeeping is crucial for many system operations and applications.</p>
<p data-number="2"><strong>Scheduling and Time Slicing</strong>: Clock software, through timer interrupts, is used to <strong>drive process scheduling and time-slicing mechanisms</strong>. Timer interrupts at regular intervals allow the OS scheduler to preempt running processes and allocate CPU time to other processes, enabling fair CPU sharing and multitasking.</p>
<p data-number="3"><strong>Timer Services for Applications</strong>: Clock software provides <strong>timer services to applications</strong>. Applications can use timer APIs to set timers for specific events, schedule tasks at certain times, or implement delays and timeouts. Timer services enable applications to perform time-dependent operations and manage time-based events.</p>
<p data-number="4"><strong>Performance Monitoring and Profiling</strong>: Clock software is used for <strong>performance monitoring and profiling</strong>. High-resolution timers provided by clock software allow the OS and performance analysis tools to measure execution times of code segments, system calls, or processes. This timing information is essential for performance tuning, debugging, and identifying performance bottlenecks.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>7. (a) (i) Explain the term linking as applied in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Linking in Memory Management</strong>:</p>
<p><strong>Linking</strong> in memory management is the process of <strong>combining different pieces of code and data together to form a single executable program</strong> that can be loaded into memory and run. It typically involves resolving symbolic references between different modules or object files, assigning memory addresses to code and data segments, and creating an executable file that the OS loader can load and execute. Linking is a crucial step in software compilation and execution.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between logical address and physical address as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Logical Address (Virtual Address)</strong>:</p>
<p><strong>Logical address</strong>, also known as a virtual address, is the <strong>address generated by the CPU</strong> during program execution. It is the address as seen by the process or program. Logical addresses are part of the process's virtual address space and are independent of the physical layout of memory. Programs use logical addresses to access memory locations, and these addresses are then translated to physical addresses by the MMU.</p>
<p><strong>Physical Address</strong>:</p>
<p><strong>Physical address</strong> is the <strong>actual address in physical RAM (main memory)</strong>. It is the address that is used by the memory controller to access specific locations in physical memory chips. Physical addresses represent the real locations in RAM where data is stored. Logical addresses are mapped to physical addresses by the Memory Management Unit (MMU) using page tables or segment tables to enable virtual memory management.</p>
<p><strong>Key Difference:</strong> Logical addresses are program-view addresses that are virtual and translated, while physical addresses are hardware addresses in RAM and are real locations in memory.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Table 1 shows details of FCFS scheduling algorithm. Use it to answer the questions that follow.</p>
<p><strong>Table 1</strong></p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Arrival time</th>
<th>Execution time</th>
<th>Service time</th>
</tr>
</thead>
<tbody>
<tr>
<td data-label="Process">P0</td>
<td data-label="Arrival time">0</td>
<td data-label="Execution time">5</td>
<td data-label="Service time">0</td>
</tr>
<tr>
<td data-label="Process">P1</td>
<td data-label="Arrival time">1</td>
<td data-label="Execution time">3</td>
<td data-label="Service time">5</td>
</tr>
<tr>
<td data-label="Process">P2</td>
<td data-label="Arrival time">2</td>
<td data-label="Execution time">8</td>
<td data-label="Service time">8</td>
</tr>
<tr>
<td data-label="Process">P3</td>
<td data-label="Arrival time">3</td>
<td data-label="Execution time">6</td>
<td data-label="Service time">16</td>
</tr>
</tbody>
</table>
<p>(1) Calculate the wait time for each process labeled P0, P1, P2 and P3.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Wait Time Calculation for Each Process (FCFS):</strong></p>
<p><strong>Completion Time Calculation (FCFS - First Come First Served):</strong></p>
<p>P0 completes at: Arrival Time + Service Time + Execution Time = 0 + 0 + 5 = 5</p>
<p>P1 completes at: Completion Time of P0 + Execution Time of P1 = 5 + 3 = 8</p>
<p>P2 completes at: Completion Time of P1 + Execution Time of P2 = 8 + 8 = 16</p>
<p>P3 completes at: Completion Time of P2 + Execution Time of P3 = 16 + 6 = 22</p>
<p><strong>Wait Time Calculation: Wait Time = Turnaround Time - Execution Time</strong></p>
<p>Turnaround Time = Completion Time - Arrival Time</p>
<p>Wait Time = (Completion Time - Arrival Time) - Execution Time = Completion Time - (Arrival Time + Execution Time)</p>
<p>Wait Time for P0: 5 - (0 + 5) = 0</p>
<p>Wait Time for P1: 8 - (1 + 3) = 4</p>
<p>Wait Time for P2: 16 - (2 + 8) = 6</p>
<p>Wait Time for P3: 22 - (3 + 6) = 13</p>
<p><strong>Wait Times:</strong></p>
<p>P0: 0 ms</p>
<p>P1: 4 ms</p>
<p>P2: 6 ms</p>
<p>P3: 13 ms</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) Calculate the average wait time for all the processes.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Average Wait Time Calculation:</strong></p>
<p>Average Wait Time = (Wait Time P0 + Wait Time P1 + Wait Time P2 + Wait Time P3) / Number of Processes</p>
<p>Average Wait Time = (0 + 4 + 6 + 13) / 4 = 23 / 4 = 5.75 ms</p>
<p><strong>Average Wait Time for all processes is 5.75 ms.</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (iii) (2 marks)</h3>
<div class="question-content">
<p>(iii) Outline two advantages of FCFS scheduling algorithm.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Simplicity</strong>: <strong>FCFS is simple to understand and implement</strong>. The algorithm is straightforward and easy to program, requiring minimal overhead for scheduling decisions.</p>
<p data-number="2"><strong>Fairness</strong>: FCFS is inherently <strong>fair</strong> as it processes jobs in the order of their arrival. Every process gets a chance to run, and there is no starvation. Processes are served based on their arrival sequence, ensuring equal opportunity for CPU access based on arrival order.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Risper was required to identify two types of memory fragmentations in operating systems. Explain two types that she was likely to have identified.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>External Fragmentation</strong>: <strong>External fragmentation</strong> occurs when <strong>total free memory space is sufficient to satisfy a memory request, but it is not contiguous</strong>. Free memory is scattered in small, non-adjacent blocks, making it unusable for allocating larger contiguous blocks, even when total free memory is adequate. This type of fragmentation is common in dynamic partitioning schemes.</p>
<p data-number="2"><strong>Internal Fragmentation</strong>: <strong>Internal fragmentation</strong> occurs when memory is allocated in fixed-size partitions or pages. If a process is allocated a partition or page that is larger than its actual memory requirement, the <strong>unused space within the allocated block is wasted</strong>. This wasted space inside the allocated block is internal fragmentation. It's common in fixed partitioning and paging systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Javesh Company Ltd. would like to implement a client-server operating system. Outline four benefits the company will derive from this decision.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Centralized Resource Management</strong>: A client-server OS allows for <strong>centralized management of resources</strong>. Servers can manage shared resources like files, printers, databases, and applications, making them accessible to multiple clients. Centralized management simplifies administration, reduces redundancy, and improves resource utilization.</p>
<p data-number="2"><strong>Enhanced Security</strong>: Client-server architecture offers <strong>enhanced security</strong> through centralized security management. Security policies, authentication, and access controls can be implemented and enforced centrally on servers, providing better protection for sensitive data and resources compared to decentralized systems.</p>
<p data-number="3"><strong>Improved Scalability</strong>: Client-server systems are <strong>scalable</strong>. As the company grows, it's easier to scale server resources (e.g., upgrade servers, add more servers) to meet increasing demands. Client machines can be added without requiring significant changes to the overall system architecture, providing scalability for growing user bases and workloads.</p>
<p data-number="4"><strong>Facilitated Data Sharing and Collaboration</strong>: Client-server OSs <strong>facilitate data sharing and collaboration</strong>. Servers act as central repositories for data and applications, enabling users to easily access and share information, collaborate on projects, and access common resources. Centralized data storage and sharing improve teamwork and data consistency across the organization.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (4 marks)</h3>
<div class="question-content">
<p>8. (a) Outline four reasons for implementing audit trail on a file system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Security Monitoring and Intrusion Detection</strong>: Audit trails enable <strong>security monitoring and intrusion detection</strong>. By logging file access attempts, modifications, permission changes, and other file system events, audit trails provide a record of activities that can be analyzed to detect suspicious or unauthorized actions. Security personnel can use audit logs to identify potential security breaches, intrusions, or policy violations.</p>
<p data-number="2"><strong>Compliance and Regulatory Requirements</strong>: Many industries and regulations require organizations to maintain <strong>audit trails for compliance purposes</strong>. Audit logs provide evidence of adherence to security policies, data protection regulations (e.g., GDPR, HIPAA), and industry standards. Compliance audits often rely on audit trails to verify that access controls and security measures are in place and effective.</p>
<p data-number="3"><strong>Accountability and User Activity Tracking</strong>: Audit trails enhance <strong>accountability and user activity tracking</strong>. By logging user actions on files and directories, audit trails provide a record of who accessed, modified, or deleted specific files and when. This improves accountability by allowing administrators to trace actions back to specific users, investigate incidents, and enforce user responsibility for file system activities.</p>
<p data-number="4"><strong>Troubleshooting and Forensic Analysis</strong>: Audit trails are valuable for <strong>troubleshooting system issues and conducting forensic analysis</strong>. In case of system errors, data corruption, or security incidents, audit logs provide a detailed history of file system events. This information can be used to diagnose problems, identify the causes of errors, and perform forensic investigations to understand the sequence of events leading to an incident or data loss.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Differentiate between kernel and user spaces as applied in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Kernel Space</strong>:</p>
<p><strong>Kernel space</strong> is the <strong>privileged memory area where the operating system kernel executes</strong>. It has direct access to system hardware and all memory. Code running in kernel space can execute privileged instructions and manage system resources. Kernel space is protected from user-level processes to ensure system stability and security. The kernel, device drivers, and core OS services reside and run in kernel space.</p>
<p><strong>User Space</strong>:</p>
<p><strong>User space</strong> is the <strong>non-privileged memory area where user applications and processes execute</strong>. Processes in user space have restricted access to system hardware and kernel memory. User-level code cannot directly execute privileged instructions or access protected memory regions. User space provides isolation and protection for user processes, preventing them from interfering with the OS or each other. Applications and user programs run in user space and interact with the kernel through system calls.</p>
<p><strong>Key Difference:</strong> Kernel space is privileged and for OS kernel execution with full hardware access, while user space is non-privileged and for user application execution with restricted hardware access, providing system security and stability.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>(c) (i) Outline two examples of resources required in process execution.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>CPU Time</strong></p>
<p data-number="2"><strong>Memory</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Figure 3 shows memory registers in an operating system.</p>
<p>Outline the memory register labeled (i) and (ii).</p>
<p><img src="Screenshot_2025-03-12_at_12-53-40_2015j.pdf.png" alt="" width="534" height="351" /></p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on Figure 3, and assuming typical memory register usage in an OS context, where (i) is associated with a lower memory address and (ii) with a higher memory address relative to "Process" label:</p>
<p><strong>(i) Base Register</strong>:</p>
<p>Memory register labeled <strong>(i)</strong> is likely representing a <strong>Base Register</strong>. In memory management with segmentation or base-limit registers, the base register <strong>holds the starting physical address of a process's memory segment</strong>. It defines the beginning address of the memory region allocated to the process. In Figure 3, if (i) is at a lower address (30004) relative to the "Process" block, it could indicate the base address for that process's memory segment.</p>
<p><strong>(ii) Limit Register</strong>:</p>
<p>Memory register labeled <strong>(ii)</strong> is likely representing a <strong>Limit Register</strong>. A limit register, used with a base register, <strong>specifies the size or limit of the memory segment</strong> allocated to a process. It defines the range of valid addresses that a process can access, starting from the base address. In Figure 3, if (ii) is at a higher address (42094) relative to the "Process" block and the base register (i), it could indicate the upper bound or limit of the memory segment allocated to that process. The range between the base and limit registers defines the process's valid memory space.</p>
<p><strong>Context:</strong> Together, base and limit registers are used for memory protection and segmentation, defining and enforcing the memory boundaries for each process.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (6 marks)</h3>
<div class="question-content">
<p>(d) Patricia was required to categorize computer I/O hardware. Describe three categories that she could have indicated.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Human-Readable Devices</strong>: <strong>Human-readable devices</strong> are designed for <strong>interaction with human users</strong>. They facilitate input from and output to humans. Examples include <strong>keyboards</strong> and <strong>pointing devices (mice, touchscreens)</strong> for input, and <strong>monitors</strong>, <strong>printers</strong>, and <strong>speakers</strong> for output. These devices are characterized by their user-friendly interfaces and formats suitable for human perception and interaction.</p>
<p data-number="2"><strong>Communication Devices</strong>: <strong>Communication devices</strong> are used for <strong>communication between computer systems or networks</strong>. They enable data exchange over communication channels. Examples include <strong>network interface cards (NICs)</strong>, <strong>modems</strong>, and <strong>wireless adapters</strong>. These devices facilitate networking, remote communication, and data transmission between computers, enabling distributed systems and network services.</p>
<p data-number="3"><strong>Storage Devices</strong>: <strong>Storage devices</strong> are used for <strong>persistent data storage</strong>. They provide non-volatile storage for data that needs to be retained even when the system is powered off. Examples include <strong>hard disk drives (HDDs)</strong>, <strong>solid-state drives (SSDs)</strong>, <strong>optical drives (CD/DVD/Blu-ray)</strong>, and <strong>tape drives</strong>. Storage devices are used to store files, applications, operating systems, and user data for long-term retention and retrieval.</p>
</div>
</div>
</section>
</main></p>
<footer>THIS IS THE LAST PRINTED PAGE.</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="november_2015.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="novemeber_2014.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>