<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>November 2015 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-10"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li id="active"><a href="november_2015.html" class="active no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="july_2016.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2015.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">November 2015</h1></header>
<article class="iDevice_wrapper textIdevice" id="id10">
<div class="iDevice emphasis0" >
<div id="ta10_132_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: November 2015</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>(a) (i) Explain the term page table as applied in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>page table</strong> is a <strong>data structure used by the operating system to implement virtual memory</strong>. It is used to <strong>translate virtual addresses to physical addresses</strong> for each process. Each process has its own page table which maps virtual pages to physical frames in memory or to secondary storage if the page is not currently in RAM.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Outline four advantages of First Come First Served (FCFS) scheduling algorithms.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Simplicity</strong>: <strong>FCFS is simple to understand and implement</strong>. It is straightforward to program and requires minimal overhead in terms of algorithm complexity.</p>
<p data-number="2"><strong>Fairness</strong>: FCFS is inherently <strong>fair</strong> in that it processes jobs in the order of their arrival. Every process gets a chance to run, and there is no starvation.</p>
<p data-number="3"><strong>No Starvation</strong>: Due to its fair nature, <strong>FCFS prevents starvation</strong>. Every process will eventually get its turn to be executed based on its arrival time.</p>
<p data-number="4"><strong>Easy to Predict</strong>: The behavior of FCFS is <strong>predictable</strong>. The order of execution is determined solely by the arrival time of the processes, making it easy to estimate turnaround and waiting times in simple scenarios.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Paul was investigating the challenges that his company might be experiencing as a result of using monolithic operating system. Explain two challenges he could have identified.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Lack of Modularity and Maintainability</strong>: <strong>Monolithic operating systems lack modularity</strong>. All system services run within the kernel, making it complex and tightly coupled. This leads to difficulties in maintenance, debugging, and implementing changes or updates. Any modification can have unintended side effects across the system, increasing instability.</p>
<p data-number="2"><strong>System Instability</strong>: In a monolithic kernel, a <strong>failure in one component can crash the entire system</strong>. Because all services are integrated into a single kernel space, there is no fault isolation. A bug in a device driver or any other part of the kernel can lead to system-wide crashes, reducing reliability and uptime.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Explain two circumstances that could necessitate implementation of a client server operating system in an organization.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Resource Sharing and Centralized Management</strong>: When an organization needs to <strong>share resources such as files, printers, and applications among multiple users</strong>, a client-server OS becomes necessary. It allows for centralized management of these resources on a server, making them accessible to clients. Centralizing resources simplifies administration, enhances security, and reduces redundancy.</p>
<p data-number="2"><strong>Need for Centralized Services and Scalability</strong>: If an organization requires <strong>centralized services like email, web hosting, databases, or application servers</strong> and needs to <strong>scale its IT infrastructure</strong>, a client-server OS is essential. Server operating systems are designed to handle high loads, manage numerous client requests, and provide robust services. The client-server model allows for scalability by adding more servers or upgrading server hardware to meet increasing demands.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>2. (a) (i) Outline two file allocation methods that could be used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Contiguous Allocation</strong></p>
<p data-number="2"><strong>Linked Allocation</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Explain two reasons for adapting buffering technique in I/O communication.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Speed Mismatch Handling</strong>: Buffering is used to handle <strong>speed mismatches between I/O devices and the CPU or memory</strong>. I/O devices often operate at speeds much slower than the CPU and memory. Buffers act as a temporary holding area, allowing the faster component to transfer data to the buffer quickly and proceed with other tasks, while the slower device can access data from the buffer at its own pace. This prevents the faster component from being stalled waiting for the slower one.</p>
<p data-number="2"><strong>Data Size Adaptation</strong>: Buffers help in <strong>adapting data sizes between producers and consumers</strong>. I/O devices and processes may produce or consume data in different sized chunks. Buffers can accumulate data until a block of the required size is formed before passing it to the consumer, or they can break down large blocks of data into smaller units suitable for the producer. This simplifies data handling and processing for both sides of the communication.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (6 marks)</h3>
<div class="question-content">
<p>(b) Figure 1 shows inbound memory hierarchy diagram.</p>
<p><img src="Screenshot_2025-03-12_at_12-43-42_2015nov.pdf.png" alt="" width="345" height="333" /></p>
<p>Describe each of the layers labeled A, B and C.</p>
<p><img src="paperpaper-007.png" alt="Figure 1" /></p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on a typical memory hierarchy, and assuming Figure 1 represents levels of memory from slowest/lowest to fastest/highest:</p>
<p><strong>Layer A: Secondary Storage (e.g., Hard Disk, SSD)</strong>:</p>
<p><strong>Layer A</strong> represents <strong>Secondary Storage</strong>. This is the <strong>slowest and cheapest level of memory</strong> in the hierarchy, but it has the <strong>largest capacity</strong>. It is non-volatile, meaning data is retained even when power is off. Secondary storage is used for long-term storage of data, including the operating system, applications, and user files. Access times are slow compared to RAM and cache, but it provides persistent storage.</p>
<p><strong>Layer B: Main Memory (RAM)</strong>:</p>
<p><strong>Layer B</strong> represents <strong>Main Memory (RAM - Random Access Memory)</strong>. This level is <strong>faster and more expensive than secondary storage but has less capacity</strong>. RAM is volatile, meaning data is lost when power is off. Main memory is used to hold the programs and data that are currently being used by the CPU. It provides faster access compared to secondary storage, enabling efficient program execution.</p>
<p><strong>Layer C: Cache Memory (CPU Cache)</strong>:</p>
<p><strong>Layer C</strong> represents <strong>Cache Memory</strong>. This is the <strong>fastest and most expensive level of memory</strong>, with the <strong>smallest capacity</strong>. Cache memory is used to store frequently accessed data and instructions from main memory to reduce average memory access time. It acts as a buffer between the CPU and RAM. Cache memory is typically implemented in multiple levels (L1, L2, L3), with each level being faster and smaller than the level below it. It significantly improves CPU performance by providing very fast access to frequently used data.</p>
<p><strong>Inbound Memory Hierarchy</strong>: The diagram depicts an inbound memory hierarchy, suggesting data moves "inward" towards the CPU as it becomes more frequently used or actively processed, transitioning from slower, larger storage (Layer A) to faster, smaller caches (Layer C).</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Several design issues are of concern in disk cache implementation. Explain two typical considerations that should be observed.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Cache Size and Block Size</strong>: <strong>Cache size</strong> is a critical consideration. A <strong>larger cache can store more data</strong>, potentially increasing the cache hit rate and improving performance. However, larger caches are more expensive and consume more memory. <strong>Block size</strong> (or cache line size) also matters. It determines the unit of data transfer between cache and main memory. Choosing an appropriate cache size and block size involves balancing cost, performance, and memory usage to optimize cache effectiveness for the expected workload.</p>
<p data-number="2"><strong>Cache Replacement Policy</strong>: The <strong>cache replacement policy</strong> determines which block to evict from the cache when new data needs to be loaded and the cache is full. Common policies include <strong>Least Recently Used (LRU), First-In, First-Out (FIFO), and Least Frequently Used (LFU)</strong>. The choice of replacement policy significantly impacts cache hit rate and overall performance. LRU is generally effective but complex to implement, while FIFO is simple but may not be as efficient. Selecting a suitable replacement policy depends on the access patterns of the data being cached.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Beth intends to adopt a full backup scheme for her company's file system. Explain two disadvantages that she could likely realize while using this backup scheme.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Time-Consuming Backup Process</strong>: A <strong>full backup</strong> scheme is <strong>very time-consuming</strong>, especially for large file systems. It involves backing up all files and directories, regardless of whether they have changed since the last backup. The entire backup process can take a significant amount of time, potentially disrupting normal operations, especially if backups are performed during peak hours. Long backup windows can impact system availability and user productivity.</p>
<p data-number="2"><strong>Large Storage Space Requirement</strong>: Full backups require a <strong>large amount of storage space</strong>. Each backup operation duplicates the entire file system, leading to high storage consumption. Storing multiple full backups over time can quickly fill up backup storage media, increasing storage costs and management complexity. The large storage footprint of full backups can be inefficient and costly, especially for organizations with rapidly growing data.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (4 marks)</h3>
<div class="question-content">
<p>(a) Distinguish between human-readable and machine-readable I/O devices.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Human-Readable I/O Devices</strong>:</p>
<p><strong>Human-readable I/O devices</strong> are designed to <strong>interact directly with human users</strong>. They are used for input from and output to humans. Examples include <strong>keyboards</strong>, <strong>mice</strong>, <strong>monitors</strong>, and <strong>printers</strong>. These devices are characterized by their orientation towards human communication, involving formats and interfaces that humans can easily understand and use. They are often slower in terms of data transfer rates compared to machine-readable devices, as human interaction speed is the limiting factor.</p>
<p><strong>Machine-Readable I/O Devices</strong>:</p>
<p><strong>Machine-readable I/O devices</strong> are designed for <strong>communication between computer systems or for data storage that is primarily processed by machines</strong>. They are used for high-speed data transfer and storage operations. Examples include <strong>disk drives (HDDs, SSDs)</strong>, <strong>network interface cards (NICs)</strong>, and <strong>sensors</strong>. These devices are optimized for efficiency, speed, and data throughput in machine-to-machine communication and data handling. They typically use formats and protocols designed for machine processing, not direct human interpretation.</p>
<p><strong>Key Difference:</strong> Human-readable devices are for human interaction, focusing on user-friendly interfaces, while machine-readable devices are for machine-to-machine communication and data storage, emphasizing speed and efficiency.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Sarah intends to select a file system for her company. Outline four factors that she should consider other than cost.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Performance and Efficiency</strong>: <strong>Performance</strong> is a key factor. Sarah should consider the file system's <strong>speed and efficiency in file operations</strong> such as read, write, create, delete, and search. Performance metrics include throughput, latency, and I/O operations per second (IOPS). An efficient file system will ensure fast data access and overall system responsiveness.</p>
<p data-number="2"><strong>Scalability and Capacity</strong>: <strong>Scalability</strong> is important for future growth. Sarah needs to consider if the file system can <strong>handle increasing data volumes and file counts</strong> as the company's data grows. The maximum file size, maximum volume size, and overall scalability of the file system should be evaluated to ensure it can meet long-term storage needs.</p>
<p data-number="3"><strong>Reliability and Data Integrity</strong>: <strong>Reliability and data integrity</strong> are crucial for protecting valuable company data. The file system should offer features like <strong>data journaling, error detection and correction, and fault tolerance</strong> to prevent data loss and ensure data consistency, even in case of system failures or crashes. Reliability is paramount for business continuity.</p>
<p data-number="4"><strong>Security Features</strong>: <strong>Security features</strong> are vital for protecting sensitive company data from unauthorized access. Sarah should consider the file system's <strong>access control mechanisms, permissions management, encryption capabilities, and security auditing features</strong>. Robust security features are necessary to maintain data confidentiality, integrity, and compliance with security policies.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>(c) Define each of the following terms as used in file system:</p>
<p>(i) field;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Field</strong>:</p>
<p>In a file system context, particularly when discussing record-based file organization, a <strong>field</strong> is a <strong>basic unit of data within a record</strong>. It represents a <strong>single piece of information or attribute</strong> about an entity. For example, in a file containing employee records, fields could be 'Employee ID', 'Name', 'Department', etc. Fields are the smallest named data components within a record.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) record.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Record</strong>:</p>
<p>In a file system context, a <strong>record</strong> is a <strong>collection of related fields that are treated as a single unit</strong>. It represents a <strong>complete entry or instance of an entity</strong>. For example, an employee record might consist of fields like 'Employee ID', 'Name', 'Department', and 'Salary'. Records are organized into files, forming structured data sets in file systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (i) (4 marks)</h3>
<div class="question-content">
<p>(d) (i) The short-term scheduler is invoked whenever an event occurs that may lead to the blocking of the current process in an operating system. Outline four examples of such events that could be invoked.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>I/O Request</strong>: When a running process <strong>initiates an I/O operation</strong>, such as reading from a disk, network, or keyboard, it typically needs to wait for the I/O operation to complete. This waiting period blocks the process, and the short-term scheduler is invoked to select another process to run while the current process is blocked waiting for I/O.</p>
<p data-number="2"><strong>Semaphore Wait Operation</strong>: If a process <strong>performs a wait operation on a semaphore</strong> and the semaphore value is not positive (resource not available), the process gets blocked. It enters a waiting queue associated with the semaphore, and the short-term scheduler is invoked to choose another process to execute.</p>
<p data-number="3"><strong>Page Fault</strong>: In a virtual memory system, when a process <strong>accesses a memory page that is not currently in RAM (page fault)</strong>, the process is blocked. The OS needs to load the required page from secondary storage into memory, which is a time-consuming I/O operation. During this page fault handling, the short-term scheduler is invoked to schedule another process.</p>
<p data-number="4"><strong>Process Suspension (e.g., due to User Request)</strong>: If a process is <strong>explicitly suspended</strong>, either by a user command or by another process, it transitions to a blocked or suspended state. The short-term scheduler is invoked to select a different process to run, as the suspended process is no longer ready for execution until it is resumed.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Explain two circumstances under which an operating system would prompt a user to rename a file.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Filename Conflict</strong>: If a user attempts to <strong>create a new file or directory with a name that already exists</strong> in the same directory, the operating system would prompt the user to rename the new file or resolve the naming conflict. Filename conflicts occur because within a single directory, filenames must be unique. The OS prompts for renaming to maintain file system integrity and prevent overwriting existing files unintentionally.</p>
<p data-number="2"><strong>Invalid Filename Characters</strong>: If a user tries to <strong>rename a file or create a file with a name that contains characters not allowed by the file system's naming conventions</strong>, the operating system would prompt the user to rename the file with a valid name. Filename conventions vary across OSs, and using invalid characters can cause errors or prevent the file from being created or accessed correctly. The OS prompts for renaming to ensure filenames adhere to valid syntax and file system rules.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>4. (a) Explain each of the following terms as used in operating systems:</p>
<p>(i) port;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Port</strong>:</p>
<p>In operating systems and networking, a <strong>port</strong> is a <strong>virtual endpoint for communication</strong>. It is a <strong>numbered connection point</strong> used by processes or applications to send and receive data over a network or within a system. Ports allow multiple applications or services to share a single network interface or system IP address by distinguishing traffic based on port numbers. They are essential for multiplexing network connections and directing data to the correct application or service.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) message.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Message</strong>:</p>
<p>A <strong>message</strong> in operating systems and inter-process communication (IPC) is a <strong>unit of data or information exchanged between processes or components</strong>. Messages are used for communication, synchronization, and data transfer between different parts of a system. They can be used in various IPC mechanisms like message queues, message passing systems, and network communication to enable processes to interact and coordinate their activities.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (i) (4 marks)</h3>
<div class="question-content">
<p>(b) (i) Figure 2 shows a cross section of a disk platter.</p>
<p><img src="Screenshot_2025-03-12_at_12-44-38_2015nov.pdf.png" alt="" width="453" height="356" /></p>
<p>Outline each of the parts label (i) and (ii).</p>
<p><img src="paperpaper-009.png" alt="Figure 2" /></p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Based on a typical cross-section of a disk platter diagram, assuming (i) points to a track and (ii) points to a sector:</p>
<p><strong>(i) Track</strong>:</p>
<p>Part labeled <strong>(i)</strong> represents a <strong>Track</strong>. A track is a <strong>concentric circular path on the surface of a disk platter</strong> where data is recorded magnetically. Platters are divided into numerous concentric tracks, each serving as a storage path for data. Tracks are further divided into smaller units called sectors. The read/write heads move radially across the platter surface to access different tracks. Data is recorded and read along these circular tracks.</p>
<p><strong>(ii) Sector</strong>:</p>
<p>Part labeled <strong>(ii)</strong> represents a <strong>Sector</strong>. A sector is a <strong>segment or division of a track on a disk platter</strong>. It is the <strong>smallest addressable unit on a disk</strong>, typically storing a fixed amount of data (e.g., 512 bytes or 4KB). Each track is divided into multiple sectors. Sectors are used to organize data on the disk surface and are the basic units for reading and writing data to the disk. Disk addresses are often given in terms of sector numbers or logical block addresses (LBAs) that map to sectors.</p>
<p><strong>Relationship:</strong> Tracks are circular paths on the platter, and sectors are segments within these tracks. Sectors are subdivisions of tracks and are the smallest units of data storage and access.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Kate was investigating conditions necessary for deadlocks in operating systems. Outline four conditions that she was likely to identify.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Mutual Exclusion</strong>: <strong>Mutual exclusion</strong> is a condition where <strong>resources are non-sharable</strong>. At least one resource must be held in a non-sharable mode, meaning only one process can use it at a time. If multiple processes request exclusive access to a non-sharable resource, mutual exclusion may lead to deadlocks.</p>
<p data-number="2"><strong>Hold and Wait</strong>: <strong>Hold and wait</strong> condition occurs when a process is <strong>holding at least one resource and is waiting to acquire additional resources</strong> that are currently held by other processes. The process holds onto resources it has already acquired while waiting for new resources, potentially leading to deadlocks.</p>
<p data-number="3"><strong>No Preemption</strong>: <strong>No preemption</strong> condition means that <strong>resources cannot be forcibly taken away from a process holding them</strong>. Resources can only be released voluntarily by the process holding them after it has completed its task. Lack of preemption allows processes to hold onto resources indefinitely, contributing to deadlock situations.</p>
<p data-number="4"><strong>Circular Wait</strong>: <strong>Circular wait</strong> condition is a situation where there is a <strong>circular chain of two or more processes</strong>, each waiting for a resource held by the next process in the chain. For example, process A waits for a resource held by process B, and process B waits for a resource held by process A, creating a cycle of dependencies and leading to deadlock.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Julie intends to use fixed memory partitioning in an operating system that she was designing for a client. Explain two difficulties that she could experience while using this memory technique.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Internal Fragmentation</strong>: <strong>Internal fragmentation</strong> is a significant difficulty. In fixed partitioning, partitions are pre-sized, and if a process is smaller than the partition it is allocated, the unused space within the partition is wasted. This wasted space, known as internal fragmentation, reduces memory utilization efficiency. For example, if a 10KB process is placed in a 20KB partition, 10KB is internally fragmented and lost.</p>
<p data-number="2"><strong>Inefficient Memory Utilization and Limited Multiprogramming</strong>: Fixed partitioning can lead to <strong>inefficient memory utilization and limits the degree of multiprogramming</strong>. If partition sizes are not well-matched to process sizes, memory can be wasted due to internal fragmentation. Also, the total number of processes that can be in memory at once is limited by the fixed number of partitions. If all partitions are in use, even if there is sufficient total free memory (but not in appropriately sized partitions), new processes cannot be loaded, restricting multiprogramming and system throughput.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (4 marks)</h3>
<div class="question-content">
<p>(d) Load sharing is one of un-processor scheduling technique. Explain two versions of this technique that could be implemented in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Load Sharing with Thresholds</strong>: In this version of load sharing, <strong>thresholds are set for CPU utilization or queue lengths</strong>. When a processor's load exceeds a certain threshold, it attempts to <strong>transfer some of its workload to a less loaded processor</strong>. This can be implemented by migrating processes or tasks to processors with lower utilization. Thresholds help to trigger load sharing actions only when necessary, avoiding excessive migration overhead when the load is already balanced or within acceptable limits. Thresholds can be static or dynamically adjusted.</p>
<p data-number="2"><strong>Load Sharing with Periodic Polling/Sampling</strong>: In this approach, each processor <strong>periodically polls or samples the load of other processors</strong> in the system. Based on the sampled load information, processors can make decisions about load sharing. If a processor detects that it is heavily loaded compared to others, it may initiate load sharing by migrating tasks to less loaded processors. Periodic polling/sampling allows for dynamic load assessment and adjustment, enabling the system to adapt to changing workloads over time. The polling interval needs to be carefully chosen to balance responsiveness and overhead.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>5. (a) Explain each of the following types of I/O operations:</p>
<p>(i) control;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Control I/O Operations</strong>:</p>
<p><strong>Control I/O operations</strong> involve <strong>sending commands to I/O devices to control their functions or modes of operation</strong>. These operations do not typically involve transferring large amounts of data but rather sending control signals or commands. Examples include commands to start or stop a device, set device parameters, rewind a tape drive, or position a disk head. Control operations are essential for managing and configuring I/O devices.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) status;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Status I/O Operations</strong>:</p>
<p><strong>Status I/O operations</strong> involve <strong>querying I/O devices to obtain information about their current state or condition</strong>. These operations are used to check the device's status, such as whether it is ready, busy, idle, or if any errors have occurred. Status operations do not transfer large amounts of data but retrieve status information. Examples include checking if a printer is online, if a disk drive is ready, or if there are any pending errors from a device.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (iii) (2 marks)</h3>
<div class="question-content">
<p>(iii) transfer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(iii) Transfer I/O Operations</strong>:</p>
<p><strong>Transfer I/O operations</strong> involve the <strong>actual movement of data between the main memory and an I/O device</strong>. These operations are used to read data from an input device into memory or to write data from memory to an output device. Transfer operations typically involve transferring blocks of data and are the primary operations for data input and output. Examples include reading data from a disk file, sending data to a network interface, or displaying data on a monitor.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Explain two circumstances that could render use of context switching in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Time Slice Expiry in Time-Sharing Systems</strong>: In time-sharing operating systems using scheduling algorithms like Round Robin, <strong>context switching is triggered when a process's allocated time slice (time quantum) expires</strong>. After a process has run for its time slice, the scheduler preempts the process, saves its current state, and performs a context switch to load the state of another ready process, allowing it to run for its time slice. This time-slicing mechanism ensures fair CPU sharing and responsiveness.</p>
<p data-number="2"><strong>I/O Wait</strong>: When a running process <strong>initiates an I/O operation</strong> (e.g., disk read, network request), it typically needs to wait for the I/O operation to complete. During this waiting period, the process becomes blocked or enters a waiting state. The operating system performs a <strong>context switch to another ready process</strong>, allowing the CPU to be utilized by other processes while the original process is waiting for I/O. Context switching in I/O wait scenarios improves CPU utilization by overlapping CPU processing with I/O operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (5 marks)</h3>
<div class="question-content">
<p>(c) Hillary was required to identify disadvantages of sequential file access method during a job interview. Outline five disadvantages that he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Inefficient for Random Access</strong>: <strong>Sequential access is inefficient for applications requiring random or direct access to specific records</strong>. To access a record in the middle or end of a sequential file, one must read through all preceding records. This results in slow access times for random access patterns, making it unsuitable for applications that frequently need to jump to arbitrary positions in the file.</p>
<p data-number="2"><strong>Difficult to Update or Insert Records in the Middle</strong>: <strong>Updating or inserting records in the middle of a sequential file is cumbersome and inefficient</strong>. To insert a record, one typically needs to rewrite the file from the point of insertion onwards. Similarly, updating a record often requires rewriting the entire record or even subsequent parts of the file to maintain sequence and structure. These update and insertion operations are time-consuming and resource-intensive.</p>
<p data-number="3"><strong>Limited Flexibility in File Organization</strong>: Sequential file organization offers <strong>limited flexibility in how data can be organized and accessed</strong>. Records are strictly ordered, typically based on a key, and access is primarily limited to sequential traversal. It is not well-suited for complex data structures or applications that require more flexible or indexed access patterns.</p>
<p data-number="4"><strong>Slower for Searching Specific Records</strong>: <strong>Searching for a specific record in a sequential file can be slow</strong>, especially for large files. A linear search from the beginning of the file is required to find a record based on a specific criterion or key value. This linear search time increases proportionally with file size, making sequential search inefficient for large datasets.</p>
<p data-number="5"><strong>Data Redundancy and Inconsistency Potential</strong>: In some sequential file implementations, <strong>managing relationships between data can be challenging</strong>, potentially leading to data redundancy and inconsistency. Lack of indexing or direct access mechanisms can make it harder to maintain data integrity and enforce relationships between records, especially in complex data management scenarios.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (5 marks)</h3>
<div class="question-content">
<p>(d) With the aid of a diagram, describe a process control block PCB as applied in operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Process Control Block (PCB) Description with Diagram</strong>:</p>
<p>A <strong>Process Control Block (PCB)</strong> is a <strong>data structure used by the operating system to store all the information needed to manage a particular process</strong>. It contains process-specific information that the OS needs to control and track the execution of each process. The PCB is created when a process is created and is updated and used throughout the process's lifecycle.</p>
<p><strong>Diagram of a Process Control Block (PCB):</strong></p>
<pre>+-----------------------------------+
| Process ID (PID)                  |  &lt;-- Unique identifier for the process
+-----------------------------------+
| Process State                     |  &lt;-- Running, Ready, Blocked, etc.
+-----------------------------------+
| Program Counter (PC)              |  &lt;-- Address of the next instruction to execute
+-----------------------------------+
| CPU Registers                     |  &lt;-- Contents of CPU registers (Accumulator, etc.)
+-----------------------------------+
| Memory Management Information     |  &lt;-- Page table base, segment table base, etc.
+-----------------------------------+
| CPU Scheduling Information        |  &lt;-- Priority, scheduling queue pointers
+-----------------------------------+
| Accounting Information            |  &lt;-- CPU time used, time limits, etc.
+-----------------------------------+
| I/O Status Information            |  &lt;-- List of open files, I/O devices allocated
+-----------------------------------+
| Context Data                      |  &lt;-- Other context-specific data for process state
+-----------------------------------+
| Pointer to Parent PCB             |  &lt;-- Pointer to PCB of parent process
+-----------------------------------+
| Pointers to Child PCBs            |  &lt;-- List of pointers to PCBs of child processes
+-----------------------------------+
</pre>
<p><strong>Description of PCB Components:</strong></p>
<p data-number="1"><strong>Process ID (PID)</strong>: A <strong>unique identifier</strong> that distinguishes each process from others.</p>
<p data-number="2"><strong>Process State</strong>: Indicates the <strong>current state of the process</strong> (e.g., running, ready, blocked, new, terminated).</p>
<p data-number="3"><strong>Program Counter (PC)</strong>: Stores the <strong>address of the next instruction</strong> that the process will execute.</p>
<p data-number="4"><strong>CPU Registers</strong>: Saves the <strong>contents of CPU registers</strong> when the process is switched out, so the process can resume execution correctly later.</p>
<p data-number="5"><strong>Memory Management Information</strong>: Includes details for memory management, such as <strong>page table base address or segment table information</strong>, used for virtual address translation.</p>
<p data-number="6"><strong>CPU Scheduling Information</strong>: Contains data used for process scheduling, like <strong>priority level and pointers to scheduling queues</strong>.</p>
<p data-number="7"><strong>Accounting Information</strong>: Tracks <strong>resource usage</strong> by the process, such as CPU time used, real time elapsed, account numbers, etc.</p>
<p data-number="8"><strong>I/O Status Information</strong>: Keeps track of <strong>I/O devices allocated to the process and lists of open files</strong>.</p>
<p data-number="9"><strong>Pointers</strong>: Includes <strong>pointers to parent and child PCBs</strong> to establish process hierarchy.</p>
<p><strong>Function:</strong> The PCB is the central repository of information that the operating system uses to manage and control processes. It is essential for context switching, process scheduling, resource management, and inter-process communication.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>6. (a) Explain each of the following terms as used in memory management:</p>
<p>(i) address space;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Address Space</strong>:</p>
<p><strong>Address space</strong> is the <strong>range of memory addresses available to a process</strong>. It is the set of addresses that a process can logically access. In virtual memory systems, this is typically a virtual address space, which is separate from the physical memory addresses. Each process has its own address space, providing isolation and protection from other processes. The address space defines the memory view of a process.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>(ii) user space.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) User Space</strong>:</p>
<p><strong>User space</strong> is the <strong>memory area where user-level processes execute</strong>. It is a part of the virtual address space that is accessible to user applications. User space is typically protected, meaning user processes have restricted access to system hardware and kernel memory. Code and data of user applications reside in user space, and they interact with the operating system kernel through system calls to request privileged operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Distinguish between a ready-state and blocked-state of a process.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Ready State</strong>:</p>
<p>A process is in the <strong>ready state</strong> when it is <strong>prepared and waiting to be executed by the CPU</strong>. The process has all the necessary resources it needs to run, except for the CPU itself. Processes in the ready state are waiting in a ready queue for their turn to be scheduled on the CPU by the short-term scheduler. They are runnable and will transition to the running state when the scheduler selects them.</p>
<p><strong>Blocked State (Waiting State)</strong>:</p>
<p>A process is in the <strong>blocked state</strong>, also known as the waiting state, when it is <strong>waiting for some event to occur before it can proceed</strong>. This event is typically an external event, such as the completion of an I/O operation, release of a resource, or reception of a signal. While in the blocked state, a process cannot use the CPU, even if it is available. Processes in the blocked state are not eligible to run until the event they are waiting for occurs, after which they typically transition to the ready state.</p>
<p><strong>Key Difference:</strong> A process in the ready state is waiting for CPU allocation and is ready to run, while a process in the blocked state is waiting for an external event and cannot run even if the CPU is available.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) Amos was required to implement remote file sharing system for a client. Explain three methods that he could consider for the client.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Network File System (NFS)</strong>: <strong>Network File System (NFS)</strong> is a <strong>distributed file system protocol</strong> that allows users to access files over a network as if they were on their local file system. NFS enables clients to mount file systems located on servers and access files transparently. It is widely used in Unix-like systems and provides file sharing capabilities across heterogeneous environments. NFS is suitable for sharing files among users and applications in a network environment, providing file-level access and sharing.</p>
<p data-number="2"><strong>Server Message Block (SMB/CIFS)</strong>: <strong>Server Message Block (SMB)</strong>, also known as Common Internet File System (CIFS), is a <strong>network file sharing protocol</strong> commonly used in Windows environments (but also available for other OSs like Linux via Samba). SMB allows clients to access files and directories shared on servers over a network. It provides file and printer sharing services and supports features like file locking and authentication. SMB/CIFS is widely used in Windows networks for file sharing among Windows clients and servers.</p>
<p data-number="3"><strong>Distributed File System (DFS)</strong>: <strong>Distributed File System (DFS)</strong> is a <strong>file system that spans multiple servers and locations</strong>, presenting a unified view of shared files to users. DFS can aggregate multiple file shares into a single logical namespace, simplifying access to distributed files. It can also provide features like fault tolerance, load balancing, and data replication. DFS is suitable for large organizations with geographically distributed file servers and users needing access to files across different locations.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>(d) Figure 3 shows a memory allocation technique.</p>
<p><img src="Screenshot_2025-03-12_at_12-45-27_2015nov.pdf.png" alt="" width="740" height="509" /></p>
<p>Use it to answer questions that follow.</p>
<p><img src="paperpaper-009.png" alt="Figure 3" /></p>
<p>(i) Identify the appropriate memory management techniques depicted in the figure.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Swapping</strong>:</p>
<p>The memory management technique depicted in Figure 3 is <strong>swapping</strong>. The diagram illustrates a process (Process P1) being <strong>swapped out</strong> of main memory to secondary storage (store) and another process (Process P2) being <strong>swapped in</strong> from secondary storage into main memory. This exchange of processes between RAM and disk is characteristic of swapping.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Explain two benefits that could be realized when using memory management technique identified in (i).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Increased Degree of Multiprogramming</strong>: <strong>Swapping allows for an increased degree of multiprogramming</strong>. By temporarily moving processes out of main memory to secondary storage, swapping frees up RAM, allowing the operating system to load and execute more processes concurrently than would fit in physical memory at once. This increases CPU utilization and system throughput as more processes can compete for CPU time.</p>
<p data-number="2"><strong>Running Larger Programs than Physical Memory</strong>: Swapping enables the execution of <strong>programs that are larger than the available physical RAM</strong>. By swapping parts of a program (or whole processes) in and out of memory as needed, swapping creates the illusion of a larger memory space than physically present. This allows users to run applications that would otherwise exceed the physical memory capacity of the system.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (4 marks)</h3>
<div class="question-content">
<p>7. (a) (i) Outline four typical resources needed in a process execution.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>CPU Time</strong>: <strong>CPU time</strong> is the fundamental processing resource required for a process to execute its instructions. The process needs to be allocated CPU cycles by the operating system scheduler to perform computations and execute program code.</p>
<p data-number="2"><strong>Memory Space</strong>: <strong>Memory space (RAM)</strong> is needed to store the process's code, data, and stack during execution. The process requires memory to hold its instructions, variables, and runtime data. Sufficient memory allocation is essential for the process to run correctly.</p>
<p data-number="3"><strong>Files</strong>: <strong>File resources</strong> are often required for processes to interact with data stored in files. Processes may need to open, read, write, create, or delete files to perform their tasks. Access to file system resources is essential for many applications.</p>
<p data-number="4"><strong>I/O Devices</strong>: <strong>Input/Output (I/O) devices</strong> are necessary for processes to interact with the external environment or other system components. Processes may require access to devices like keyboards, monitors, network interfaces, or printers to receive input, display output, or communicate with networks.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Differentiate between data and system buses as used in computers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Data Bus</strong>:</p>
<p>The <strong>data bus</strong> is a set of wires or conductors that <strong>carries actual data being transferred between different components of a computer system</strong>, such as the CPU, memory, and I/O devices. It is used to transmit data for processing and storage. The width of the data bus (number of parallel lines) determines the amount of data that can be transferred simultaneously in a single bus cycle. Data buses are bidirectional, allowing data to flow in both directions (to and from components).</p>
<p><strong>System Bus</strong>:</p>
<p>The <strong>system bus</strong> is a <strong>collection of buses that connect major components of a computer system</strong>, including the CPU, memory, and peripherals. It is a higher-level bus that typically includes the data bus, address bus, and control bus. The system bus provides a pathway for communication and data transfer between these major components, facilitating overall system operation. It is responsible for handling all types of system-level communication, including data transfer, address signaling, and control signals.</p>
<p><strong>Key Difference:</strong> The data bus is specifically for transferring data, while the system bus is a broader term encompassing the data bus along with address and control buses, serving as the main communication pathway for major system components.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>(b) (i) Describe the term disk cache as applied in computers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Disk Cache</strong>:</p>
<p><strong>Disk cache</strong> is a <strong>portion of RAM (main memory) used as a cache to store frequently accessed data from a hard disk drive (HDD) or solid-state drive (SSD)</strong>. It acts as a buffer between the slower disk storage and the faster CPU and main memory. The disk cache stores recently accessed disk blocks or frequently used files, allowing the system to retrieve data from the faster RAM cache instead of the slower disk, improving I/O performance and reducing disk access latency.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Anna was required to investigate I/O protection measures that could be implemented in an operating system for her company. Explain two measures that could have identified.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Access Control Lists (ACLs) for I/O Devices</strong>: Implementing <strong>Access Control Lists (ACLs) for I/O devices</strong> can provide fine-grained control over which processes or users can access specific I/O devices. ACLs can define permissions (read, write, control) for different users or groups for each I/O device. This measure helps to prevent unauthorized access to sensitive hardware resources and ensures that only authorized processes can perform I/O operations on specific devices, enhancing system security and device access control.</p>
<p data-number="2"><strong>Memory Protection for I/O Buffers</strong>: Employing <strong>memory protection mechanisms for I/O buffers</strong> is crucial. This involves ensuring that only authorized processes can access I/O buffers used for data transfer between memory and I/O devices. Memory protection techniques like memory segmentation or paging can be used to isolate I/O buffers in protected memory regions, preventing unauthorized processes from reading or writing to these buffers. Protecting I/O buffers helps to maintain data integrity during I/O operations and prevents malicious or accidental data corruption.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (6 marks)</h3>
<div class="question-content">
<p>(c) A number of memory placement techniques exist in an operating system. Explain three of such techniques that could be adapted in a given operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>First-Fit</strong>: <strong>First-Fit</strong> is a dynamic memory allocation algorithm that <strong>allocates the first available free partition (hole) in memory that is large enough to satisfy the request</strong>. When searching for a free partition, First-Fit starts from the beginning of the memory or the list of free partitions and allocates the first suitable one it finds. It is simple and fast for allocation but can lead to fragmentation, especially external fragmentation.</p>
<p data-number="2"><strong>Best-Fit</strong>: <strong>Best-Fit</strong> algorithm allocates the <strong>smallest free partition that is large enough to satisfy the memory request</strong>. It searches the entire list of free partitions and selects the one that is closest in size to the requested memory. Best-Fit aims to minimize wasted space (internal fragmentation) but can be slower than First-Fit due to the need to search all free partitions, and it can still lead to external fragmentation over time.</p>
<p data-number="3"><strong>Worst-Fit</strong>: <strong>Worst-Fit</strong> algorithm allocates the <strong>largest available free partition</strong> to satisfy a memory request. It searches the entire list of free partitions and selects the largest one. The idea behind Worst-Fit is to leave larger free partitions remaining after allocation, hoping to accommodate larger future requests. However, it can actually increase external fragmentation by breaking down large free blocks into smaller, less usable pieces.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>8. (a) (i) Define the term monitor as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Monitor</strong>:</p>
<p>In process management, a <strong>monitor</strong> is a <strong>high-level synchronization construct</strong> used for controlling access to shared resources in concurrent programming. It encapsulates shared data and the procedures (methods) that operate on that data, ensuring <strong>mutual exclusion</strong> and providing <strong>condition variables</strong> for process synchronization. Monitors simplify concurrent programming by providing a structured way to manage shared resources and synchronize process interactions.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>(ii) Distinguish between logical and physical addresses as applied in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Logical Address (Virtual Address)</strong>:</p>
<p><strong>Logical addresses</strong>, also known as virtual addresses, are the <strong>addresses generated by the CPU when a program is executed</strong>. They are part of the process's virtual address space and are independent of the physical memory addresses. Logical addresses are used by programmers and processes to refer to memory locations. They are translated to physical addresses by the Memory Management Unit (MMU) during memory access. Each process has its own logical address space.</p>
<p><strong>Physical Address</strong>:</p>
<p><strong>Physical addresses</strong> are the <strong>actual addresses in physical RAM (main memory)</strong>. They represent the real locations in memory hardware where data is stored. Physical addresses are used by the memory controller to access specific memory locations in RAM chips. Logical addresses are mapped to physical addresses by the MMU using page tables or segment tables. Physical addresses are what the hardware understands and uses to access memory.</p>
<p><strong>Key Difference:</strong> Logical addresses are virtual and process-specific, used by programs. Physical addresses are real hardware addresses in RAM, used by the memory controller. The MMU translates logical to physical addresses.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (4 marks)</h3>
<div class="question-content">
<p>(b) Tom was required to develop a clock module for an operating system for a client. Outline four functions of this module to the proposed operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Timekeeping and System Clock Maintenance</strong>: The clock module is responsible for <strong>maintaining the system clock</strong>, keeping track of the current date and time. It updates the system time based on hardware clock ticks and provides system calls for applications and the OS to query the current time. Accurate timekeeping is essential for various system functions, such as scheduling, timestamps, and logging.</p>
<p data-number="2"><strong>Process Scheduling and Time Slicing</strong>: The clock module generates <strong>timer interrupts</strong> at regular intervals, which are used by the operating system's scheduler for <strong>time-slicing and process scheduling</strong>. Timer interrupts trigger context switches, allowing the scheduler to preempt currently running processes and allocate CPU time to other ready processes in Round Robin or similar scheduling algorithms. This ensures fairness and responsiveness in time-sharing systems.</p>
<p data-number="3"><strong>Timeouts and Delays</strong>: The clock module provides mechanisms for implementing <strong>timeouts and delays</strong>. The OS and applications can use the clock module to set timers for specific events, such as I/O operations, network communication, or alarms. Timeouts are crucial for handling time-dependent operations, detecting failures, and implementing time-based functionalities in various system components.</p>
<p data-number="4"><strong>Profiling and Performance Measurement</strong>: The clock module can be used for <strong>profiling and performance measurement</strong>. By measuring time intervals using the system clock or high-resolution timers provided by the clock module, the OS and performance monitoring tools can measure execution times of processes, system calls, or specific code sections. This information is valuable for performance analysis, debugging, and optimization.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (4 marks)</h3>
<div class="question-content">
<p>(c) Nabat described several objectives for developing an I/O module to his friends. Outline four objectives that he could have mentioned.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Device Independence</strong>: A key objective is to achieve <strong>device independence</strong>. The I/O module should provide a <strong>uniform interface for the rest of the operating system and applications</strong>, regardless of the specific characteristics of the underlying I/O devices. Device independence allows the OS and applications to interact with I/O devices in a generic way, without needing to be rewritten or modified for each different device type. Device drivers handle the device-specific details, abstracting hardware differences.</p>
<p data-number="2"><strong>Efficiency</strong>: <strong>Efficiency</strong> is a critical objective. The I/O module should be designed to <strong>maximize I/O throughput and minimize latency</strong>. Efficient I/O operations are essential for overall system performance. Techniques like buffering, caching, DMA, and optimized I/O scheduling algorithms are employed in the I/O module to improve efficiency and reduce the overhead of I/O operations.</p>
<p data-number="3"><strong>Error Handling and Reliability</strong>: <strong>Error handling and reliability</strong> are important objectives. The I/O module should handle <strong>device errors, I/O errors, and exceptions gracefully</strong>. It should provide mechanisms for error detection, error recovery, and reporting errors to the OS and applications. Robust error handling is necessary to ensure data integrity and system stability in the presence of I/O device issues.</p>
<p data-number="4"><strong>Abstraction and Simplification of I/O Operations</strong>: The I/O module aims to <strong>abstract and simplify I/O operations for higher-level software layers</strong> (OS kernel and applications). It provides a set of <strong>high-level, easy-to-use interfaces (system calls)</strong> for performing common I/O tasks, hiding the complexities of device-specific control and low-level hardware interactions. This abstraction simplifies programming and makes I/O operations more manageable for developers.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (6 marks)</h3>
<div class="question-content">
<p>(d) Nissi Company Ltd. was experiencing security issues with its file system. Explain three logical security measures that it could implement in order to mitigate the issue.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Access Control Lists (ACLs) Implementation</strong>: Implement <strong>Access Control Lists (ACLs)</strong> to provide fine-grained control over file and directory permissions. ACLs allow administrators to define specific access rights (read, write, execute, delete, etc.) for individual users or groups for each file and directory. This measure enhances security by allowing precise permission settings, minimizing unauthorized access beyond basic owner-group-others permissions. ACLs offer more granular and flexible access control.</p>
<p data-number="2"><strong>File System Encryption</strong>: Implement <strong>file system encryption</strong> to protect sensitive data at rest. Encrypting the file system ensures that data stored on disk is unreadable without the correct decryption key, even if unauthorized users gain physical access to the storage media or bypass access controls. Encryption protects data confidentiality and mitigates the risk of data breaches. Both full-disk encryption and file-level encryption can be considered depending on requirements.</p>
<p data-number="3"><strong>Regular Security Audits and Monitoring</strong>: Conduct <strong>regular security audits and monitoring of file system access and activities</strong>. Implement logging and auditing mechanisms to track file access attempts, permission changes, and other relevant events. Regular security audits help identify vulnerabilities, misconfigurations, or suspicious activities. Monitoring file system logs can detect and respond to security incidents promptly. Proactive security monitoring and auditing are essential for maintaining file system security over time.</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer>THIS IS THE LAST PRINTED PAGE.</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="july_2016.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2015.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>