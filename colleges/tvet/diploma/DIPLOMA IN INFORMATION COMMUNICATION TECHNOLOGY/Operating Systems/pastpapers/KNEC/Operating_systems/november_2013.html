<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>November 2013 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-14"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li><a href="november_2021.html" class="no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li id="active"><a href="november_2013.html" class="active no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="july_2014.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2013.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">November 2013</h1></header>
<article class="iDevice_wrapper textIdevice" id="id14">
<div class="iDevice emphasis0" >
<div id="ta14_136_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    </style>
<header>
<h1>Operating Systems</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: November 2013</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in computer operating systems.</p>
<p>(i) shell;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>shell</strong> is a command-line interpreter or user interface in an operating system. It acts as an <strong>intermediary between the user and the operating system kernel</strong>, allowing users to execute commands, manage files, and interact with the system through textual commands. The shell interprets user commands and translates them into system calls that the kernel can understand and execute.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in computer operating systems.</p>
<p>(ii) system call.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>system call</strong> is a request made by a user-level process to the operating system kernel to perform a specific task that requires <strong>privileged operations</strong>. It is the <strong>interface</strong> through which processes can request services from the kernel, such as file I/O, process creation, memory allocation, and network communication. System calls are essential for processes to interact with the operating system and access system resources.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (a) (iii) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in computer operating systems.</p>
<p>(iii) buffer</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>buffer</strong> is a region of memory used for <strong>temporary storage</strong> of data during data transfer operations, especially between different parts of a computer system or between devices. Buffers are used to handle differences in data transfer rates, optimize data flow, and improve efficiency. They are commonly used in I/O operations, network communication, and data processing.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (i) (2marks)</h3>
<div class="question-content">
<p>Explain each of the following Inter Process Communication methods:</p>
<p>(i) semaphore;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>semaphore</strong> is a synchronization primitive used for controlling access to <strong>shared resources</strong> in a concurrent system. It is an integer variable that, apart from initialization, is accessed only through two atomic operations: <strong>wait (P)</strong> and <strong>signal (V)</strong>. Semaphores are used to manage critical sections and prevent race conditions by ensuring that only a limited number of processes can access a resource at any given time.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain each of the following Inter Process Communication methods:</p>
<p>(ii) signal.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A <strong>signal</strong> is a software interrupt used in operating systems to notify a process of the occurrence of a particular <strong>event</strong>. Signals can be sent from the kernel to a process, or from one process to another. They are used for various purposes, such as handling errors, responding to user input (like Ctrl+C), or inter-process <strong>notification</strong>. When a process receives a signal, it can either handle it using a signal handler or perform a default action.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (i) (4 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the NTFS file system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>NTFS (New Technology File System)</strong> is a proprietary file system developed by Microsoft, and is the primary file system for recent versions of Windows. It offers several improvements over older file systems like FAT32, including enhanced reliability, security, and features.</p>
<p><strong>Conceptual Diagram of NTFS Structure</strong>:</p>
<pre>                    +---------------------+
                    |      Boot Sector    |  (Contains boot code and metadata)
                    +---------------------+
                    |      MFT (Master    |  (Main file table, index of all files and directories)
                    |    File Table)       |
                    +---------------------+
                    |      MFT Mirror     |  (Backup of critical MFT entries for redundancy)
                    +---------------------+
                    |    System Files     |  (Metadata files like log files, volume info)
                    +---------------------+
                    |     File Area       |  (Space for file and directory content)
                    +---------------------+
                    </pre>
<p><strong>Description of Key Components</strong>:</p>
<p><strong>Boot Sector</strong>: The first sector of an NTFS volume, containing the <strong>boot code</strong> used to start the operating system and metadata about the file system structure.</p>
<p><strong>Master File Table (MFT)</strong>: The core component of NTFS. It is a <strong>database</strong> that contains metadata about every file and directory on the volume. Each entry in the MFT, called a File Record, stores attributes like file name, size, timestamps, permissions, and data block locations. The MFT is organized as an array of File Records.</p>
<p><strong>MFT Mirror</strong>: A backup copy of the first few entries of the MFT, used for <strong>redundancy</strong> and recovery in case of corruption in the primary MFT.</p>
<p><strong>System Files</strong>: Various metadata files used by NTFS to manage the file system, including log files for <strong>journaling</strong>, volume information, attribute definitions, and security descriptors.</p>
<p><strong>File Area</strong>: The remaining space on the volume, used to store the actual <strong>content of files and directories</strong>. NTFS uses clusters as the unit of allocation, and file data can be stored in contiguous or non-contiguous clusters.</p>
<p><strong>Key Features of NTFS</strong>:</p>
<p><strong>Journaling</strong>: Maintains a log of file system changes to ensure <strong>consistency and recoverability</strong> after system crashes.</p>
<p><strong>Security Descriptors</strong>: Supports detailed <strong>access control lists (ACLs)</strong> for file and directory permissions, enhancing security.</p>
<p><strong>Compression and Encryption</strong>: Provides built-in support for file <strong>compression</strong> and <strong>encryption</strong>.</p>
<p><strong>Large File and Volume Sizes</strong>: Supports very <strong>large files and volumes</strong>, overcoming limitations of older file systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>Describe single streaming batch processing as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Single streaming batch processing</strong> is a simple form of batch processing where jobs are processed <strong>sequentially, one after another</strong>, in a single stream. In this method, jobs are submitted to the system and processed in the order of submission, without any user interaction during processing. Once a job starts, it runs to completion before the next job in the queue is started. It is typically <strong>non-interactive</strong> and suitable for tasks that can be processed in a predefined sequence without manual intervention.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>Lara, a database administrator used each of the following file lock mechanisms in her design. Explain the result from each lock when enforced:</p>
<p>(i) file lock;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) File Lock</strong>:</p>
<p>When a <strong>file lock</strong> is enforced on a file, it typically grants <strong>exclusive access</strong> to the process that holds the lock. Other processes are prevented from accessing the file in any way that could conflict with the lock holder's operations. The exact behavior depends on the type of file lock (e.g., exclusive or shared), but generally, a file lock ensures that only one process (or a controlled group of processes for shared locks) can operate on the file at a time, preventing data corruption and ensuring consistency.</p>
</div>
</div>
</section>
<section class="question">
<h3>1. (d) (ii) (2 marks)</h3>
<div class="question-content">
<p>Lara, a database administrator used each of the following file lock mechanisms in her design. Explain the result from each lock when enforced:</p>
<p>(ii) write lock.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Write Lock</strong>:</p>
<p>When a <strong>write lock</strong> is enforced on a file (or a portion of a file), it prevents other processes from obtaining a write lock on the same file (or overlapping portion). Processes might still be able to obtain read locks, depending on the specific locking mechanism, but <strong>exclusive write access</strong> is granted to the lock holder. This ensures that only one process can modify the file at any given time, preventing write-write conflicts and maintaining data integrity during updates. Other processes attempting to acquire a write lock will typically be blocked until the lock is released.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (a) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between coherency and inclusion as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Cache Coherency</strong>:</p>
<p><strong>Cache coherency</strong> is concerned with maintaining <strong>consistency of data</strong> across multiple caches in a multi-processor system. When multiple processors have caches, and they share a common memory, it is possible for different caches to hold different, potentially outdated, copies of the same data. Cache coherency protocols ensure that when one processor modifies data in its cache, all other caches that hold a copy of that data are updated or invalidated to maintain a consistent view of memory across all processors. This is critical for correct parallel program execution.</p>
<p><strong>Cache Inclusion</strong>:</p>
<p><strong>Cache inclusion</strong> is a property of multi-level cache hierarchies. It dictates that the data stored in a smaller, faster cache (e.g., L1 cache) must also be present in the larger, slower cache that is higher up in the hierarchy (e.g., L2 cache). In other words, the content of the L1 cache is a <strong>subset of the content of the L2 cache</strong>, and so on for deeper cache levels. Cache inclusion simplifies cache management and coherency protocols, as it provides a containment relationship between cache levels. However, it can also lead to some redundancy and potentially reduced cache capacity utilization.</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Coherency</strong> is about data consistency across *multiple caches* in a multiprocessor system, ensuring all processors see the same data. <strong>Inclusion</strong> is about the hierarchical relationship *between levels of cache* within a single processor or system, requiring data in faster caches to also be present in slower, higher-level caches.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (i) (4 marks)</h3>
<div class="question-content">
<p>With the aid of diagrams, describe each of the following memory allocation techniques:</p>
<p>(i) fixed partitioned allocation;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Fixed Partitioned Allocation</strong>:</p>
<p>In <strong>fixed partitioned allocation</strong>, main memory is divided into a <strong>fixed number of partitions</strong> at system initialization. Each partition has a <strong>fixed size</strong>. When a process needs to be loaded into memory, it is allocated to a partition large enough to hold it. If a partition is larger than the process, the unused space within the partition is wasted (internal fragmentation). If no partition is large enough, the process cannot be loaded.</p>
<p><strong>Conceptual Diagram of Fixed Partitioned Allocation</strong>:</p>
<pre>                    +-------------------+-------------------+-------------------+-------------------+
                    | Partition 1 (Size S1)| Partition 2 (Size S2)| Partition 3 (Size S3)| Partition 4 (Size S4)| ...
                    +-------------------+-------------------+-------------------+-------------------+
                    | Process A         | Process B         |  Empty            | Process C         | ...
                    +-------------------+-------------------+-------------------+-------------------+
                    </pre>
<p><strong>Description</strong>:</p>
<p>Memory is divided into <strong>static partitions</strong> of predefined sizes, typically at system boot time. Partitions can be of equal or unequal sizes. Each partition can hold <strong>one process at a time</strong>. When a process arrives, the operating system tries to find an empty partition large enough for it. If found, the process is loaded into that partition. If no suitable partition is available, the process must wait. Once a process finishes, the partition becomes available for another process. <strong>Internal fragmentation</strong> is a key issue, as processes smaller than the partition size waste memory within the partition.</p>
<p><strong>Advantages</strong>: Simple to implement, easy to manage.</p>
<p><strong>Disadvantages</strong>: Internal fragmentation, limits degree of multiprogramming due to fixed partition count, inefficient memory utilization if partition sizes are not well-matched to process sizes.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>With the aid of diagrams, describe each of the following memory allocation techniques:</p>
<p>(ii) paged allocation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Paged Allocation</strong>:</p>
<p>In <strong>paged allocation</strong>, both main memory and processes are divided into <strong>fixed-size blocks</strong> called <strong>pages</strong> (for processes) and <strong>frames</strong> (for main memory). Logical addresses are divided into page numbers and page offsets. A <strong>page table</strong> is used to map pages of a process to frames in main memory. Pages of a process can be non-contiguous in memory, allocated to any available frames. This eliminates external fragmentation.</p>
<p><strong>Conceptual Diagram of Paged Allocation</strong>:</p>
<pre>                    Process Address Space          Main Memory (Physical Address Space)
                    +----------+                  +----------+
                    | Page 0   |                  | Frame 0  |
                    +----------+                  +----------+
                    | Page 1   | ---- Page Table ----&gt; Frame 3
                    +----------+                  +----------+
                    | Page 2   |                  | Frame 1  |
                    +----------+       ...        +----------+
                    | Page 3   | ---- Page Table ----&gt; Frame 5
                    +----------+                  +----------+
                                                  | Frame 2  |
                                                  +----------+
                                                  | Frame 3  | &lt;--- Page 1
                                                  +----------+
                                                  | Frame 4  |
                                                  +----------+
                                                  | Frame 5  | &lt;--- Page 3
                                                  +----------+
                                                     ...
                    </pre>
<p><strong>Description</strong>:</p>
<p>Memory is divided into fixed-size <strong>frames</strong>, and logical address space of each process is divided into fixed-size <strong>pages</strong>. Page and frame sizes are equal (e.g., 4KB). A process's pages can be loaded into any available frames in memory. The <strong>page table</strong>, maintained by the operating system for each process, maps virtual page numbers to physical frame numbers. When the CPU generates a virtual address, it is translated to a physical address using the page table. <strong>No external fragmentation</strong> occurs as memory is allocated in frame units, and pages are of fixed size. <strong>Internal fragmentation</strong> can occur if a process's last page is not fully utilized.</p>
<p><strong>Advantages</strong>: Eliminates external fragmentation, allows non-contiguous allocation, efficient memory utilization compared to partitioning.</p>
<p><strong>Disadvantages</strong>: Page table overhead (memory and management), internal fragmentation within the last page, complexity in address translation.</p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (3 marks)</h3>
<div class="question-content">
<p>June came across the following file name extensions during a lesson. Identify the file type for each extension:</p>
<p>(i) .bmp</p>
<p>(ii) .xlsx</p>
<p>(iii) .rar</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>(i) <strong>.bmp</strong>: <strong>Bitmap Image File</strong></p>
<p>(ii) <strong>.xlsx</strong>: <strong>Microsoft Excel Open XML Spreadsheet File</strong></p>
<p>(iii) <strong>.rar</strong>: <strong>RAR Archive File (Compressed Archive)</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (c) (iv) (1 mark)</h3>
<div class="question-content">
<p>June came across the following file name extensions during a lesson. Identify the file type for each extension:</p>
<p>(iv) .exe</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>(iv) <strong>.exe</strong>: <strong>Executable File</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>2. (d) (4marks)</h3>
<div class="question-content">
<p>Jeremy prefers the online method when storing his company's files. Outline two reasons for his preference.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Accessibility and Remote Access</strong>: Online storage enables <strong>access to files from anywhere with an internet connection</strong>, using various devices (computers, smartphones, tablets). This facilitates remote work, collaboration, and access to company data while traveling or from different locations. It enhances flexibility and accessibility for employees.</p>
<p data-number="2"><strong>Data Backup and Disaster Recovery</strong>: Online storage solutions often include <strong>automatic backup and data redundancy features</strong>. Files are typically stored in geographically distributed data centers, providing protection against data loss due to hardware failures, local disasters (fire, flood), or theft. This ensures business continuity and data security, offering a robust disaster recovery solution.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (a) (4 marks)</h3>
<div class="question-content">
<p>Outline four criteria that could be used when choosing a scheduling algorithm for an operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>CPU Utilization</strong>: Aim to <strong>maximize CPU utilization</strong>, keeping the CPU as busy as possible to execute processes. A good scheduling algorithm should minimize CPU idle time and ensure that the processor is actively working on tasks.</p>
<p data-number="2"><strong>Throughput</strong>: Maximize the <strong>number of processes completed per unit of time</strong>. Higher throughput indicates that the system is efficiently processing tasks. The scheduling algorithm should strive to complete as many jobs as possible in a given timeframe.</p>
<p data-number="3"><strong>Turnaround Time</strong>: Minimize the <strong>total time taken for a process to complete execution</strong>, from submission to completion. Shorter turnaround times improve user experience and system responsiveness. This includes waiting time, execution time, and I/O time.</p>
<p data-number="4"><strong>Response Time</strong>: Minimize the <strong>time it takes for a process to produce its first response</strong>, especially important for interactive systems. Quick response times enhance user satisfaction. This is particularly relevant for time-sharing systems where users expect immediate feedback.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (b) (6 marks)</h3>
<div class="question-content">
<p>Purity prefers the command line user interface over the GUI for her computer. Explain three reasons for this preference.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Efficiency and Speed</strong>: Command Line Interfaces (CLIs) are often <strong>more efficient and faster</strong> for many tasks, especially for experienced users. Commands can be executed quickly with minimal overhead, bypassing the graphical rendering and resource consumption of a GUI. For repetitive tasks or system administration, CLI commands can be significantly faster than navigating through graphical menus and windows.</p>
<p data-number="2"><strong>Scripting and Automation</strong>: CLIs are highly scriptable, allowing users to <strong>automate complex tasks</strong> by writing scripts (e.g., bash scripts, PowerShell scripts). These scripts can combine multiple commands and logic to perform batch operations, system maintenance, or customized workflows. Automation through scripting is much more powerful and flexible in a CLI compared to GUIs.</p>
<p data-number="3"><strong>Lower Resource Consumption</strong>: CLIs generally consume <strong>fewer system resources</strong> (CPU, memory, and disk space) compared to Graphical User Interfaces (GUIs). CLIs are text-based and do not require the overhead of rendering graphics, windows, and visual elements. This makes CLIs ideal for systems with limited resources or for tasks where resource efficiency is critical, such as servers or embedded systems. Using CLI can improve system performance and responsiveness, especially on older or less powerful hardware.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (c) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between reusable and consumable resources as used in inter-process communication.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Reusable Resources</strong>:</p>
<p><strong>Reusable resources</strong> are resources that can be <strong>used by only one process at a time</strong> and can be reused by another process after the current process is finished using it. These resources are not depleted or destroyed by use. Examples include <strong>CPU time</strong>, <strong>memory</strong>, <strong>files</strong>, <strong>printers</strong>, and <strong>database connections</strong>. Processes request and are granted exclusive access to reusable resources, use them, and then release them, making them available for other processes. Improper management of reusable resources can lead to deadlocks if processes hold onto resources and prevent others from accessing them.</p>
<p><strong>Consumable Resources</strong>:</p>
<p><strong>Consumable resources</strong> are resources that are <strong>created by one process and consumed by another process</strong>. Once a consumable resource is used, it is no longer available. Examples include <strong>messages in a message queue</strong>, <strong>signals</strong>, <strong>interrupts</strong>, and <strong>data in a buffer</strong>. A producer process creates consumable resources, and a consumer process uses them up. Consumable resources are typically used for synchronization and communication between processes. Mismanagement of consumable resources can lead to process starvation if producers do not create enough resources for consumers or if resources are lost.</p>
<p><strong>Key Distinction</strong>:</p>
<p>The key difference is in their lifecycle and usage. <strong>Reusable resources</strong> are persistent and shared among processes over time, while <strong>consumable resources</strong> are transient, created by one process and used up by another, serving as a means of communication or signaling between processes.</p>
</div>
</div>
</section>
<section class="question">
<h3>3. (d) (6 marks)</h3>
<div class="question-content">
<p>Explain three reasons that could cause a process to be suspended.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>I/O Wait or Event Wait</strong>: A process may be suspended when it needs to perform an <strong>I/O operation</strong> (e.g., read from disk, receive network data) or <strong>wait for a specific event</strong> to occur (e.g., user input, signal from another process). During these wait states, the process cannot continue executing because it is waiting for an external operation to complete. The operating system suspends the process to free up the CPU for other ready processes and will resume it when the I/O operation is complete or the event has occurred. This is a common reason for process suspension in multitasking systems to improve CPU utilization.</p>
<p data-number="2"><strong>Preemption by Scheduler</strong>: In preemptive scheduling systems, the operating system can <strong>interrupt a running process</strong> and suspend it to allow another process to run. This is typically done based on scheduling algorithms (e.g., round robin, priority scheduling) to ensure fairness, responsiveness, or priority enforcement. Processes may be preempted when their time slice expires, a higher-priority process becomes ready, or to maintain system responsiveness. Suspension due to preemption is a normal part of process scheduling and multitasking.</p>
<p data-number="3"><strong>User Request or System Call</strong>: A process can be suspended due to an <strong>explicit request from the user</strong> or through a <strong>system call</strong>. For example, a user might pause a process using a command (e.g., Ctrl+Z in Unix-like systems), or a process might voluntarily suspend itself by making a system call (e.g., `sleep()` or `wait()`). User-initiated suspension can be for debugging, pausing execution, or managing process flow. System-call based suspension is often used for synchronization or when a process needs to wait for a specific condition before proceeding.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>List four examples of utility programs used in computers.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Antivirus Software</strong></p>
<p data-number="2"><strong>Disk Defragmentation Tool</strong></p>
<p data-number="3"><strong>Backup and Restore Utility</strong></p>
<p data-number="4"><strong>File Manager (e.g., Windows Explorer, Finder)</strong></p>
</div>
</div>
</section>
<section class="question">
<h3>4. (a) (ii) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between spatial locality and sequential locality as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Spatial Locality</strong>:</p>
<p><strong>Spatial locality</strong> refers to the tendency of a processor to access memory locations that are <strong>physically close to each other</strong> in memory. If a program accesses a particular memory location, there is a high probability that it will soon access nearby memory locations. This is often observed when accessing data structures like arrays or sequential blocks of code. Cache memory exploits spatial locality by fetching blocks of data (cache lines) that are larger than the immediate request, anticipating that nearby data will be needed soon.</p>
<p><strong>Sequential Locality (Temporal Locality)</strong>:</p>
<p><strong>Sequential locality</strong>, more accurately termed <strong>temporal locality</strong>, refers to the tendency of a processor to <strong>re-access memory locations that have been recently accessed</strong>. If a program accesses a particular memory location at one point in time, there is a high probability that it will access the same location again in the near future. This is common in loops, function calls, and repeated use of variables. Cache memory leverages temporal locality by keeping recently accessed data in the cache, so that subsequent accesses to the same data are faster.</p>
<p><strong>Key Distinction</strong>:</p>
<p><strong>Spatial locality</strong> is about accessing *nearby* memory locations, while <strong>temporal locality</strong> is about *re-accessing* the *same* memory locations *over time*. Both types of locality are fundamental principles that cache memory and other memory management techniques exploit to improve performance by reducing memory access latency.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following terms as used in file management:</p>
<p>(i) alias file names;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Alias File Names</strong>:</p>
<p><strong>Alias file names</strong>, also known as <strong>shortcuts</strong> or <strong>links</strong>, are alternative names or pointers that refer to an existing file or directory. They provide a way to access a file using a different name or from a different location in the directory structure, without duplicating the file itself. Alias file names are used for <strong>convenience</strong>, organization, and to provide multiple access paths to the same data. Changes made through an alias affect the original file.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following terms as used in file management:</p>
<p>(ii) pathnames.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Pathnames</strong>:</p>
<p><strong>Pathnames</strong> are strings that specify the <strong>location of a file or directory</strong> within a file system's directory hierarchy. A pathname describes the sequence of directories to traverse from a starting point (usually the root directory or the current working directory) to reach the target file or directory. Pathnames can be <strong>absolute</strong> (starting from the root) or <strong>relative</strong> (starting from the current directory) and use delimiters (like '/' in Unix or '\' in Windows) to separate directory names in the path.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (c) (4 marks)</h3>
<div class="question-content">
<p>Joss used the RAID and disk caching to help improve the performance of the disk. Describe each of these techniques as used in file management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>RAID (Redundant Array of Independent Disks)</strong>:</p>
<p><strong>RAID</strong> is a data storage virtualization technology that combines multiple physical disk drives into a single logical unit for <strong>improved performance, redundancy, or both</strong>. Different RAID levels (RAID 0, 1, 5, 10, etc.) offer various combinations of striping (data distribution across disks for performance), mirroring (data duplication for redundancy), and parity (error correction). RAID can enhance disk I/O performance by parallelizing read/write operations across multiple disks and improve data reliability by providing fault tolerance in case of disk failures. RAID is used to boost disk subsystem performance and data availability.</p>
<p><strong>Disk Caching</strong>:</p>
<p><strong>Disk caching</strong> is a technique that uses a portion of <strong>fast memory (cache)</strong>, typically RAM, to store frequently accessed data from the disk. When a read request is made, the system first checks the cache. If the data is found in the cache (cache hit), it is served from the faster cache memory, significantly reducing access time. If not found (cache miss), the data is read from the slower disk and also placed in the cache for future accesses (cache fill). Disk caching exploits temporal locality to improve disk access performance by reducing the number of physical disk I/O operations. It is a key technique for speeding up file system operations and application loading times.</p>
</div>
</div>
</section>
<section class="question">
<h3>4. (d) (6 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the structure of the I/O control system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The <strong>I/O control system</strong> in an operating system is structured in layers to manage communication between applications and hardware devices. It typically involves several layers of software and hardware components working together.</p>
<p><strong>Conceptual Diagram of I/O Control System Structure</strong>:</p>
<pre>                    +-----------------------+     User Applications
                    | User-Level I/O        |     (e.g., File I/O, Network Sockets)
                    +-----------------------+
                               ^ System Calls
                               |
                    +-----------------------+     Operating System Kernel
                    | Kernel I/O Subsystem  |     (e.g., File System, Network Stack)
                    +-----------------------+
                               ^ Device Driver Interface
                               |
                    +-----------------------+     Device Drivers
                    | Device Drivers        |     (Specific to Hardware Devices)
                    +-----------------------+
                               ^ Hardware Commands
                               |
                    +-----------------------+     I/O Hardware Controllers
                    | I/O Controllers       |     (e.g., Disk Controller, Network Interface Card)
                    +-----------------------+
                               ^ Physical Signals
                               |
                    +-----------------------+     I/O Devices
                    | I/O Devices           |     (e.g., Hard Disk, Network Card, Keyboard)
                    +-----------------------+
                    </pre>
<p><strong>Description of Layers</strong>:</p>
<p><strong>User-Level I/O</strong>: This is the <strong>highest layer</strong>, where user applications interact with the I/O system. Applications use <strong>system calls</strong> (e.g., `read()`, `write()`, `open()`) to request I/O operations in a device-independent manner. This layer provides a high-level abstraction of I/O operations.</p>
<p><strong>Kernel I/O Subsystem</strong>: This layer resides within the operating system <strong>kernel</strong> and provides core I/O services. It includes components like the <strong>file system</strong>, <strong>network stack</strong>, and <strong>device management</strong>. It translates user-level I/O requests into device-specific commands and manages buffering, caching, and scheduling of I/O operations. This layer provides device independence and resource management.</p>
<p><strong>Device Drivers</strong>: <strong>Device drivers</strong> are software modules that are <strong>specific to each type of hardware device</strong>. They act as an interface between the kernel I/O subsystem and the hardware controllers. Device drivers translate generic I/O requests from the kernel into device-specific commands that the hardware controller can understand. They handle low-level device control, interrupt handling, and data transfer protocols. Each device type typically requires its own driver.</p>
<p><strong>I/O Controllers</strong>: <strong>I/O controllers</strong> are hardware components that manage the physical I/O devices. Examples include <strong>disk controllers</strong>, <strong>network interface cards (NICs)</strong>, and <strong>USB controllers</strong>. They interpret commands from device drivers and control the operation of the actual I/O devices. Controllers handle data transfer, error detection, and hardware-level device management. They communicate with the CPU and memory via system buses.</p>
<p><strong>I/O Devices</strong>: These are the <strong>physical hardware devices</strong> themselves, such as <strong>hard disks</strong>, <strong>network cards</strong>, <strong>keyboards</strong>, <strong>printers</strong>, etc. They perform the actual I/O operations (data storage, communication, input/output). Devices are controlled by I/O controllers based on commands from the device drivers.</p>
<p>This layered structure provides modularity, device independence, and abstraction, making it easier to manage and extend the I/O system.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in memory management:</p>
<p>(i) thrashing;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Thrashing</strong>:</p>
<p><strong>Thrashing</strong> is a performance problem in virtual memory systems that occurs when a system spends most of its time <strong>paging</strong> data between main memory and secondary storage, rather than performing useful computation. It happens when the degree of multiprogramming is too high, and processes do not have enough frames in memory to meet their working set requirements. This leads to excessive page faults, disk I/O, and a significant decrease in system throughput and CPU utilization. The system becomes bogged down in paging activity.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in memory management:</p>
<p>(ii) starvation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Starvation</strong>:</p>
<p><strong>Starvation</strong> in operating systems, particularly in process scheduling and resource allocation, refers to a situation where a process is <strong>indefinitely denied access to the resources</strong> it needs to make progress, even though the resources are not deadlocked and are potentially available. Starvation can occur in priority scheduling if low-priority processes are continuously preempted by high-priority processes, or in resource allocation if a process is repeatedly passed over in favor of others. It results in <strong>indefinite postponement</strong> of a process's execution.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (b) (6 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the round robin scheduling algorithm as used in computer operating system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Round Robin Scheduling Algorithm</strong>:</p>
<p><strong>Round Robin (RR)</strong> is a preemptive CPU scheduling algorithm designed for time-sharing systems. It gives each process a fixed amount of CPU time, called a <strong>time slice or quantum</strong>. Processes are placed in a <strong>ready queue</strong>. The scheduler selects the first process from the ready queue, allocates the CPU to it for one time quantum. If the process does not complete within the time quantum, it is preempted and moved to the back of the ready queue. The scheduler then picks the next process from the front of the queue. This process repeats, giving each process a fair share of CPU time in a cyclic manner.</p>
<p><strong>Conceptual Diagram of Round Robin Scheduling</strong>:</p>
<pre>                    Ready Queue (FIFO)
                    +---------+   +---------+   +---------+   +---------+
                    | Process A |--&gt;| Process B |--&gt;| Process C |--&gt;| Process D |--&gt; ...
                    +---------+   +---------+   +---------+   +---------+
                        ^                                       |
                        |                                       v
                        +---------------------------------------+
                                       CPU Scheduler
                                         (Time Quantum)
                    </pre>
<p><strong>Description of Operation</strong>:</p>
<p>Processes are maintained in a <strong>ready queue</strong>, typically a FIFO queue. The <strong>scheduler</strong> selects the process at the front of the queue and dispatches it to run on the CPU for a predefined <strong>time quantum</strong> (e.g., 10-100 milliseconds). If the process completes its execution within the time quantum, it voluntarily releases the CPU. If the process is still running when the time quantum expires, it is <strong>preempted</strong> (interrupted), its context is saved, and it is moved to the <strong>back of the ready queue</strong>. Then, the scheduler selects the next process from the front of the queue to run. This cycle repeats continuously. The <strong>time quantum</strong> is a critical parameter. If it's too large, RR approaches FCFS; if too small, context switching overhead becomes significant.</p>
<p><strong>Advantages</strong>: Fair allocation of CPU time to all processes, prevents starvation, relatively easy to implement, good for time-sharing systems, provides reasonable response times.</p>
<p><strong>Disadvantages</strong>: Performance depends heavily on the choice of time quantum, higher context switching overhead compared to FCFS, may have longer average turnaround time compared to algorithms that prioritize shorter jobs.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following terms as used in process management:</p>
<p>(0) race condition;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Race Condition</strong>:</p>
<p>A <strong>race condition</strong> is a situation that occurs when the outcome of a computation depends on the <strong>unpredictable order of execution</strong> of processes or threads, especially when they are accessing <strong>shared resources</strong>. It arises when multiple processes access and manipulate shared data concurrently, and the final result depends on which process finishes its operation first. Race conditions can lead to inconsistent data, errors, and unpredictable behavior in concurrent systems. Synchronization mechanisms are needed to prevent race conditions.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>Describe each of the following terms as used in process management:</p>
<p>(ii) critical section.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Critical Section</strong>:</p>
<p>A <strong>critical section</strong> is a segment of code in a process that <strong>accesses shared resources</strong> (e.g., shared variables, data structures, files, devices) that can be manipulated by other concurrent processes. To ensure data integrity and avoid race conditions, access to critical sections must be <strong>mutually exclusive</strong>, meaning that only one process can execute its critical section at any given time. Synchronization mechanisms like mutexes, semaphores, or monitors are used to protect critical sections and enforce mutual exclusion.</p>
</div>
</div>
</section>
<section class="question">
<h3>5. (d) (6 marks)</h3>
<div class="question-content">
<p>During an operating system lesson the teacher addressed various functions of the software clock. Explain three such functions that the teacher could have discussed.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Timekeeping and System Clock</strong>: The software clock is used to maintain the <strong>system's current time and date</strong>. It keeps track of elapsed time and provides time-related services to the operating system and applications. This includes setting and getting the system time, synchronizing with external time sources (e.g., NTP servers), and providing time-based information for timestamps, logs, and scheduling.</p>
<p data-number="2"><strong>Process Scheduling and Time Slicing</strong>: The software clock is crucial for <strong>time-based process scheduling algorithms</strong>, such as Round Robin. It generates periodic interrupts (timer interrupts) at regular intervals, which trigger the scheduler to preempt the currently running process and switch to another ready process. This time-slicing mechanism enables multitasking and fair CPU sharing among processes. The clock's interrupt frequency determines the granularity of time slices.</p>
<p data-number="3"><strong>Timeouts and Delays</strong>: The software clock is used to implement <strong>timeouts and delays</strong> in various system operations and applications. Timeouts are used to limit the waiting time for events or responses, preventing processes from hanging indefinitely (e.g., network timeouts, I/O timeouts). Delays are used to introduce pauses or timing control in program execution (e.g., `sleep()` function). The clock's timer functions are used to measure elapsed time and trigger actions after a specified duration.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in operating systems:</p>
<p>(i) device independence;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Device Independence</strong>:</p>
<p><strong>Device independence</strong> is a principle in operating system design that aims to allow user programs to interact with I/O devices without needing to know the <strong>specific details of the hardware</strong>. The operating system provides an <strong>abstract interface</strong> for I/O operations, so applications can perform I/O in a generic way, regardless of the type or characteristics of the underlying hardware devices. Device drivers handle the device-specific operations, providing a layer of abstraction.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in operating systems:</p>
<p>(ii) virtual device.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Virtual Device</strong>:</p>
<p>A <strong>virtual device</strong> is an <strong>abstraction</strong> of a physical hardware device, created by the operating system to provide enhanced functionality, sharing, or device independence. It is a <strong>logical device</strong> that may or may not have a direct one-to-one mapping to a physical device. Virtual devices can be used for various purposes, such as printer spooling (virtual printer), disk virtualization (virtual disk), or network virtualization (virtual network interface). They provide a higher-level interface and can manage access to underlying physical resources.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the circumstance under which each of the following disk system algorithms could be applicable:</p>
<p>(i) first come first served;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) First Come First Served (FCFS)</strong>:</p>
<p><strong>FCFS</strong> disk scheduling algorithm is applicable in scenarios where <strong>simplicity and fairness</strong> are prioritized over performance optimization. It is straightforward to implement and ensures that disk requests are processed in the order they arrive. FCFS can be suitable for <strong>lightly loaded systems</strong> or where request arrival patterns are relatively random and not clustered. It is also useful as a baseline algorithm for comparison with more complex scheduling methods. However, FCFS is generally not optimal in terms of minimizing seek time and may lead to inefficient disk head movement.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain the circumstance under which each of the following disk system algorithms could be applicable:</p>
<p>(ii) shortest seek time first;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Shortest Seek Time First (SSTF)</strong>:</p>
<p><strong>SSTF</strong> disk scheduling algorithm is applicable when the primary goal is to <strong>minimize seek time</strong> and improve disk throughput. SSTF selects the disk request that requires the minimum seek distance from the current head position. It is effective in reducing average waiting time and improving overall disk performance, especially in systems with clustered disk requests. SSTF is suitable for <strong>systems where performance is critical</strong> and fairness is less of a concern. However, SSTF can lead to starvation for requests that are far from the current head position.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (b) (iii) (2 marks)</h3>
<div class="question-content">
<p>Explain the circumstance under which each of the following disk system algorithms could be applicable:</p>
<p>(iii) SCAN.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(iii) SCAN Algorithm</strong>:</p>
<p>The <strong>SCAN</strong> disk scheduling algorithm is applicable when a <strong>balance between performance and fairness</strong> is desired. SCAN moves the disk head in one direction, servicing requests along the way, and reverses direction when it reaches the end of the disk. SCAN provides better performance than FCFS and offers more fairness compared to SSTF, as it prevents starvation by servicing all requests in its path in each sweep. SCAN is suitable for <strong>general-purpose systems</strong> where reasonable performance and prevention of starvation are important. It is a good compromise between SSTF and FCFS.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (c) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between software interrupt and trap as used in operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Software Interrupt</strong>:</p>
<p>A <strong>software interrupt</strong>, also known as a <strong>synchronous interrupt</strong> or an <strong>exception</strong>, is an interrupt that is <strong>generated programmatically</strong> by software during the execution of a program. It is typically caused by an instruction within the program itself, such as a <strong>system call instruction</strong> (e.g., `syscall`, `int 0x80`) or a deliberate software instruction to trigger an interrupt. Software interrupts are used by user-level programs to request services from the operating system kernel (via system calls) or to handle specific software-defined events. They are synchronous because they occur at a predictable point in the program's execution flow.</p>
<p><strong>Trap (Exception)</strong>:</p>
<p>A <strong>trap</strong>, also called an <strong>exception</strong>, is a type of synchronous interrupt that is caused by an <strong>error condition or an exceptional event</strong> detected during program execution. Traps are typically generated by the CPU in response to events like <strong>division by zero</strong>, <strong>invalid memory access</strong> (segmentation fault), <strong>illegal instruction</strong>, or <strong>overflow conditions</strong>. Traps signal abnormal or error conditions that require special handling by the operating system. When a trap occurs, the CPU transfers control to an exception handler in the kernel to deal with the error. Traps are also synchronous as they occur as a direct result of executing a specific instruction that triggers the exceptional condition.</p>
<p><strong>Key Distinction</strong>:</p>
<p>Both software interrupts and traps are synchronous interrupts initiated during program execution, but their <strong>purpose and origin differ</strong>. <strong>Software interrupts</strong> are intentionally triggered by programs to request OS services (system calls), while <strong>traps</strong> are triggered by the CPU in response to error or exceptional conditions encountered during program execution. Software interrupts are for normal service requests, whereas traps are for error handling and exception management.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the function of each of the following terms as used in memory management:</p>
<p>(1) relocating loader;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Relocating Loader</strong>:</p>
<p>A <strong>relocating loader</strong> is a type of loader in operating systems that is responsible for loading a program into memory and <strong>adjusting (relocating) the program's addresses</strong> so that it can run correctly at the loaded memory location. When a program is compiled or assembled, it is often generated with starting addresses relative to zero or a fixed address. The relocating loader modifies these addresses to match the actual memory address where the program is loaded, enabling the program to execute correctly regardless of its load address. Relocation is essential for dynamic loading and memory management in multiprogramming environments.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (ii) (2 marks)</h3>
<div class="question-content">
<p>Explain the function of each of the following terms as used in memory management:</p>
<p>(ii) job control language;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Job Control Language (JCL)</strong>:</p>
<p><strong>Job Control Language (JCL)</strong> is a scripting language used in batch processing systems, primarily in mainframe environments, to <strong>control the execution of batch jobs</strong>. JCL scripts specify the sequence of programs to be executed, the resources required for each job step (e.g., input files, output files, memory), and control flow logic. JCL allows users to define and automate complex batch processing workflows. It is used to manage job submission, execution, and resource allocation in batch-oriented operating systems.</p>
</div>
</div>
</section>
<section class="question">
<h3>6. (d) (iii) (2 marks)</h3>
<div class="question-content">
<p>Explain the function of each of the following terms as used in memory management:</p>
<p>(iii) segmentation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(iii) Segmentation</strong>:</p>
<p><strong>Segmentation</strong> is a memory management technique that divides a process's logical address space into <strong>logical units called segments</strong>. Segments typically correspond to logical program units like code, data, and stack. Each segment is of variable size and can be placed anywhere in physical memory. Segmentation provides a structured view of memory, facilitates memory protection and sharing at the segment level, and supports logical organization of programs. However, it can suffer from external fragmentation and requires segment tables for address translation.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in process management:</p>
<p>(i) Dispatch latency;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Dispatch Latency</strong>:</p>
<p><strong>Dispatch latency</strong> is the time it takes for the <strong>scheduler to stop one process and start running another process</strong>. It is the delay between the context switch and the start of execution of the newly scheduled process. Dispatch latency is a critical factor in real-time systems, where minimizing response time and ensuring timely process execution are essential. Lower dispatch latency leads to better system responsiveness and more predictable real-time behavior.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in process management:</p>
<p>(ii) Reschedule latency.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Reschedule Latency</strong>:</p>
<p><strong>Reschedule latency</strong> is the total time taken for the operating system to <strong>respond to an event and begin executing the appropriate handler</strong>. It encompasses the time from the occurrence of an event (e.g., interrupt, system call) to the point when the scheduler starts executing a new process or thread in response to that event. Reschedule latency includes interrupt handling time, context switching time, and scheduler decision time. It is a measure of the overall responsiveness of the operating system to events that require process rescheduling.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (i) (3 marks)</h3>
<div class="question-content">
<p>Joan came across the following DOS commands when revising for her operating systems examination.</p>
<p>CD, DIR, FORMAT, BACKUP, RESTORE, CLS.</p>
<p>Categorize each of them as either external or internal commands.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Internal Commands (Built-in to command processor)</strong>:</p>
<p><strong>CD</strong> (Change Directory)</p>
<p><strong>DIR</strong> (Directory Listing)</p>
<p><strong>CLS</strong> (Clear Screen)</p>
<p><strong>External Commands (Separate executable files)</strong>:</p>
<p><strong>FORMAT</strong> (Disk Formatting)</p>
<p><strong>BACKUP</strong> (File Backup)</p>
<p><strong>RESTORE</strong> (File Restore)</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (b) (ii) (3 marks)</h3>
<div class="question-content">
<p>Differentiate between independent and cooperating process as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Independent Processes</strong>:</p>
<p><strong>Independent processes</strong> are processes that <strong>do not share data or resources</strong> with other processes and do not affect or get affected by the execution of other processes in the system. They operate in isolation, with their own private address space and resources. The execution of an independent process is deterministic and predictable, as it is not influenced by external factors from other processes. Examples include simple command-line utilities or standalone applications that do not communicate with other programs.</p>
<p><strong>Cooperating Processes</strong>:</p>
<p><strong>Cooperating processes</strong> are processes that are designed to <strong>share data or resources</strong> with other processes and can affect or be affected by the execution of other processes. They need to communicate and synchronize their actions to achieve a common task or goal. Cooperating processes can share memory, files, or communicate through inter-process communication (IPC) mechanisms like messages, pipes, or shared memory. Cooperation is essential for complex applications, client-server systems, and parallel processing. However, it introduces challenges related to synchronization, data consistency, and potential race conditions or deadlocks.</p>
<p><strong>Key Distinction</strong>:</p>
<p>The primary difference is in their <strong>interaction and resource sharing</strong>. <strong>Independent processes</strong> operate in isolation and do not interact, while <strong>cooperating processes</strong> share resources and communicate to work together, requiring synchronization and coordination.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Differentiate between each of the following replacement policies as used in memory management:</p>
<p>(i) least recently used;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Least Recently Used (LRU)</strong>:</p>
<p><strong>Least Recently Used (LRU)</strong> is a page replacement policy that replaces the page that has <strong>not been used for the longest period</strong> in the past. LRU assumes that pages that have not been accessed recently are less likely to be accessed in the near future (based on temporal locality). LRU requires keeping track of the access history of pages, typically using counters or a stack. When a page fault occurs, the page with the oldest last access time is evicted. LRU is effective in reducing page faults but can be complex and costly to implement due to the overhead of tracking page access history.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (c) (ii) (2 marks)</h3>
<div class="question-content">
<p>Differentiate between each of the following replacement policies as used in memory management:</p>
<p>(ii) not recently used.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Not Recently Used (NRU)</strong>:</p>
<p><strong>Not Recently Used (NRU)</strong> is a page replacement policy that replaces a page that is <strong>not recently used</strong>. NRU is a simpler approximation of LRU and is easier to implement. NRU classifies pages into categories based on their reference bit and modified bit. Pages are considered "not recently used" if their reference bit is not set (indicating they haven't been referenced recently). When a page fault occurs, NRU selects a page to replace based on a priority order, favoring pages that are both not recently used and not modified. NRU has lower overhead than LRU but may have a higher page fault rate.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (i) (2 marks)</h3>
<div class="question-content">
<p>During an operating systems class, Peter came across the following tile attributes. Explain the function of each of the attributes.</p>
<p>(i) archive;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Archive Attribute</strong>:</p>
<p>The <strong>archive attribute</strong> (often represented as 'A' or 'archive bit') is a file attribute used to indicate whether a file has been <strong>modified since the last backup</strong>. When a file is created or modified, the archive attribute is set (turned on). Backup software typically clears (turns off) the archive attribute after backing up the file. This attribute is used by incremental backup strategies to identify files that need to be backed up because they have been changed since the last backup operation. It helps optimize backup processes by only backing up modified files.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (ii) (2 marks)</h3>
<div class="question-content">
<p>During an operating systems class, Peter came across the following tile attributes. Explain the function of each of the attributes.</p>
<p>(ii) hidden;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Hidden Attribute</strong>:</p>
<p>The <strong>hidden attribute</strong> is a file attribute that makes a file or directory <strong>invisible</strong> or less visible to users in standard file listings and graphical interfaces. Files with the hidden attribute set are typically not displayed by default in file explorers or directory listings, unless the user explicitly enables the option to show hidden files. The hidden attribute is used to <strong>hide system files, configuration files, or files that users are not intended to directly access or modify</strong>, helping to reduce clutter and prevent accidental changes to important files.</p>
</div>
</div>
</section>
<section class="question">
<h3>7. (d) (iii) (2 marks)</h3>
<div class="question-content">
<p>During an operating systems class, Peter came across the following tile attributes. Explain the function of each of the attributes.</p>
<p>(iii) system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(iii) System Attribute</strong>:</p>
<p>The <strong>system attribute</strong> is a file attribute that marks a file as a <strong>critical system file</strong>. Files with the system attribute set are typically essential for the operating system's proper functioning. Like hidden files, system files are usually not displayed by default and are protected from accidental deletion or modification. The system attribute indicates that the file is an <strong>integral part of the operating system</strong> and should not be tampered with by users. Modifying or deleting system files can lead to system instability or failure.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in operating systems:</p>
<p>(i) address translation;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Address Translation</strong>:</p>
<p><strong>Address translation</strong>, also known as address mapping, is the process of <strong>converting a virtual address to a physical address</strong> in memory management systems that use virtual memory. The CPU generates virtual addresses, which are logical addresses used by processes. The memory management unit (MMU) in the hardware, with the help of the operating system, translates these virtual addresses into physical addresses, which correspond to the actual locations in physical RAM. Address translation is essential for virtual memory, memory protection, and address space management.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Define each of the following terms as used in operating systems:</p>
<p>(ii) address exception.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(ii) Address Exception</strong>:</p>
<p>An <strong>address exception</strong>, also known as a <strong>memory access violation</strong> or a <strong>page fault</strong> in virtual memory systems, is an exception that occurs when a process attempts to access a <strong>virtual memory address that is invalid or not currently mapped to physical memory</strong>. This can happen if the virtual address is outside the process's allocated address space, refers to a protected memory region, or corresponds to a page that is not present in physical RAM (and needs to be fetched from disk). Address exceptions are handled by the operating system, which may terminate the process (in case of invalid access) or handle page faults by loading the required page from secondary storage into memory.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (b) (3 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the message passing as used in inter process communication.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>Message Passing for Inter-Process Communication (IPC)</strong>:</p>
<p><strong>Message passing</strong> is an inter-process communication (IPC) mechanism where processes communicate by <strong>sending and receiving messages</strong>. Processes do not share memory directly. Communication is achieved through system calls provided by the operating system kernel. Messages are typically sent through communication channels or queues managed by the kernel. Message passing can be synchronous (blocking send/receive) or asynchronous (non-blocking send/receive).</p>
<p><strong>Conceptual Diagram of Message Passing</strong>:</p>
<pre>                    Process A                 Operating System Kernel                Process B
                    +---------+             +-----------------------+             +---------+
                    |         | Send        |                       | Receive     |         |
                    |         +-----------&gt;| Message Queue/Channel |&lt;-----------+         |
                    |         |             |                       |             |         |
                    +---------+             +-----------------------+             +---------+
                                                 (Manages Messages)
                    </pre>
<p><strong>Description of Operation</strong>:</p>
<p><strong>Send Operation</strong>: A <strong>sender process</strong> (e.g., Process A) prepares a <strong>message</strong> containing data to be communicated and uses a <strong>send system call</strong> to send the message. The message is passed to the operating system kernel, which places it in a <strong>message queue or channel</strong> associated with the destination process (e.g., Process B).</p>
<p><strong>Receive Operation</strong>: A <strong>receiver process</strong> (e.g., Process B) uses a <strong>receive system call</strong> to retrieve messages. The kernel checks the message queue for messages addressed to the receiver process. If a message is available, the kernel retrieves it from the queue, copies the message data to the receiver process's address space, and returns control to the receiver process. If no message is available, the receiver process may be blocked (in synchronous receive) or continue execution (in asynchronous receive).</p>
<p><strong>Key Features</strong>: No shared memory, communication via messages, kernel mediates communication, can be synchronous or asynchronous. Message passing is suitable for both shared-memory and distributed systems and provides a structured and controlled way for processes to exchange information.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (c) (4 marks)</h3>
<div class="question-content">
<p>During revision for an operating systems paper, ken came across the term metaphors. Outline two functions of this facility.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1"><strong>Simplifying User Interaction and Understanding</strong>: Metaphors in operating systems, especially in user interfaces (GUIs), are used to <strong>represent complex concepts and functionalities in a more intuitive and user-friendly way</strong>. By using familiar real-world analogies (like "desktop," "folder," "trash can," "windows"), metaphors make it easier for users to understand and interact with abstract computer concepts. They reduce the cognitive load and learning curve for users, especially for non-technical users, by relating unfamiliar digital entities to recognizable physical objects and actions.</p>
<p data-number="2"><strong>Enhancing Usability and Learnability</strong>: Metaphors contribute to <strong>improved usability and learnability</strong> of operating systems. They provide a consistent and predictable mental model for users to navigate and operate the system. By leveraging existing knowledge and experiences from the real world, metaphors make it easier for users to discover and use system features. They promote intuitive interaction, reduce the need for extensive training, and make the system more accessible to a wider range of users. Metaphors help bridge the gap between the technical complexity of the operating system and the user's conceptual understanding.</p>
</div>
</div>
</section>
<section class="question">
<h3>8. (d) (9 marks)</h3>
<div class="question-content">
<p>Figure I shows a variable memory partition of the sizes in the order as indicated.</p>
<p><img src="Screenshot_2025-03-12_at_13-15-07_2013nov.pdf.png" alt="" width="882" height="144" /></p>
<img src="figure1_q8d.png" alt="Figure 1 Memory Partition Diagram" />
<p>Assume that a new process of size 42KB is to be loaded in the partition, use sketch diagrams to show how the operating system would fit the new process using each of the following placement methods:</p>
<p>(i) best fit method;</p>
<p>(ii) worst fit method;</p>
<p>(iii) first fit method.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p><strong>(i) Best Fit Method</strong>:</p>
<p>The <strong>best fit</strong> method selects the <strong>smallest partition that is large enough</strong> to accommodate the process. In this case, the partitions are 40KB, 25KB, 50KB, 70KB, 25KB. The 42KB process can fit in the 50KB and 70KB partitions. The <strong>50KB partition is the best fit</strong> as it leaves the smallest remaining fragment (8KB).</p>
<p><strong>Diagram for Best Fit</strong>:</p>
<pre>                    Initial Partitions:  [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Free   Free

                    Process Size:        42KB

                    Best Fit Allocation: [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Used   Free   Free
                                                 Process
                                                 [42KB]
                                        Fragment: 50KB - 42KB = 8KB
                    </pre>
<p><strong>(ii) Worst Fit Method</strong>:</p>
<p>The <strong>worst fit</strong> method selects the <strong>largest available partition</strong> to allocate the process. In this case, the largest partition is 70KB. Allocating the 42KB process to the 70KB partition leaves the <strong>largest remaining fragment</strong> (28KB).</p>
<p><strong>Diagram for Worst Fit</strong>:</p>
<pre>                    Initial Partitions:  [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Free   Free

                    Process Size:        42KB

                    Worst Fit Allocation:[40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Used   Free
                                                     Process
                                                     [42KB]
                                        Fragment: 70KB - 42KB = 28KB
                    </pre>
<p><strong>(iii) First Fit Method</strong>:</p>
<p>The <strong>first fit</strong> method selects the <strong>first partition encountered that is large enough</strong> to hold the process. Scanning the partitions in order (40KB, 25KB, 50KB, 70KB, 25KB), the <strong>first partition large enough is the 50KB partition</strong>.</p>
<p><strong>Diagram for First Fit</strong>:</p>
<pre>                    Initial Partitions:  [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Free   Free

                    Process Size:        42KB

                    First Fit Allocation:[40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Used   Free   Free
                                                 Process
                                                 [42KB]
                                        Fragment: 50KB - 42KB = 8KB
                    </pre>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer>© 2023 [Your University/College Name]</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="july_2014.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2013.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>