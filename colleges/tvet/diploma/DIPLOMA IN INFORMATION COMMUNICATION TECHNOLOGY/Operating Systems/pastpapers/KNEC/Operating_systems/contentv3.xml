<?xml version="1.0" encoding="utf-8"?>

<instance xmlns="http://www.exelearning.org/content/v0.3" reference="4" version="0.3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.exelearning.org/content/v0.3 content.xsd" class="exe.engine.package.Package">
 <dictionary>
  <string role="key" value="_title"></string>
  <unicode value=""></unicode>
  <string role="key" value="idevices"></string>
  <list></list>
  <string role="key" value="_addAccessibilityToolbar"></string>
  <bool value="0"></bool>
  <string role="key" value="_addExeLink"></string>
  <bool value="0"></bool>
  <string role="key" value="_addPagination"></string>
  <bool value="0"></bool>
  <string role="key" value="_addSearchBox"></string>
  <bool value="0"></bool>
  <string role="key" value="_author"></string>
  <unicode value=""></unicode>
  <string role="key" value="_backgroundImg"></string>
  <unicode value=""></unicode>
  <string role="key" value="_contextMode"></string>
  <unicode value="presencial"></unicode>
  <string role="key" value="_contextPlace"></string>
  <unicode value="classroom"></unicode>
  <string role="key" value="_description"></string>
  <unicode value=""></unicode>
  <string role="key" value="_docType"></string>
  <unicode value="HTML5"></unicode>
  <string role="key" value="_exportElp"></string>
  <bool value="0"></bool>
  <string role="key" value="_extraHeadContent"></string>
  <unicode value=""></unicode>
  <string role="key" value="_fieldValidationInfo"></string>
  <dictionary>
   <unicode role="key" value="all"></unicode>
   <dictionary>
    <unicode role="key" value="mandatory_fields"></unicode>
    <list>
     <unicode value="pp_title"></unicode>
     <unicode value="pp_lang"></unicode>
     <unicode value="pp_description"></unicode>
     <unicode value="pp_author"></unicode>
     <unicode value="pp_newlicense"></unicode>
    </list>
   </dictionary>
   <unicode role="key" value="procomun"></unicode>
   <dictionary>
    <unicode role="key" value="mandatory_fields"></unicode>
    <list>
     <unicode value="pp_learningResourceType"></unicode>
    </list>
    <unicode role="key" value="values_from_list"></unicode>
    <dictionary>
     <unicode role="key" value="pp_learningResourceType"></unicode>
     <list>
      <unicode value="master class"></unicode>
      <unicode value="closed exercise or problem"></unicode>
      <unicode value="real project"></unicode>
      <unicode value="didactic game"></unicode>
      <unicode value="webquest"></unicode>
      <unicode value="open problem"></unicode>
      <unicode value="simulation"></unicode>
      <unicode value="questionnaire"></unicode>
      <unicode value="conceptual map"></unicode>
     </list>
    </dictionary>
   </dictionary>
  </dictionary>
  <string role="key" value="_intendedEndUserRoleGroup"></string>
  <bool value="0"></bool>
  <string role="key" value="_intendedEndUserRoleTutor"></string>
  <bool value="0"></bool>
  <string role="key" value="_intendedEndUserRoleType"></string>
  <unicode value="learner"></unicode>
  <string role="key" value="_isChanged"></string>
  <bool value="0"></bool>
  <string role="key" value="_isTemplate"></string>
  <bool value="0"></bool>
  <string role="key" value="_lang"></string>
  <unicode value="en"></unicode>
  <string role="key" value="_learningResourceType"></string>
  <unicode value=""></unicode>
  <string role="key" value="_levelNames"></string>
  <list>
   <unicode value="Topic"></unicode>
   <unicode value="Section"></unicode>
   <unicode value="Unit"></unicode>
  </list>
  <string role="key" value="_loadMathEngine"></string>
  <bool value="0"></bool>
  <string role="key" value="_name"></string>
  <unicode value="Operating_systems"></unicode>
  <string role="key" value="_nextIdeviceId"></string>
  <int value="19"></int>
  <string role="key" value="_nextNodeId"></string>
  <int value="19"></int>
  <string role="key" value="_nodeIdDict"></string>
  <dictionary>
   <unicode role="key" value="0"></unicode>
   <instance class="exe.engine.node.Node" reference="3">
    <dictionary>
     <string role="key" value="_title"></string>
     <unicode value="Home"></unicode>
     <string role="key" value="idevices"></string>
     <list>
      <instance class="exe.engine.jsidevice.JsIdevice" reference="1">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value=""></unicode>
        <string role="key" value="_attributes"></string>
        <list>
         <tuple>
          <string value="title"></string>
          <list>
           <string value="Title"></string>
           <int value="0"></int>
           <int value="0"></int>
          </list>
         </tuple>
         <tuple>
          <string value="category"></string>
          <list>
           <string value="Category"></string>
           <int value="0"></int>
           <int value="1"></int>
          </list>
         </tuple>
         <tuple>
          <string value="css-class"></string>
          <list>
           <string value="CSS class"></string>
           <int value="0"></int>
           <int value="2"></int>
          </list>
         </tuple>
         <tuple>
          <string value="icon"></string>
          <list>
           <string value="Icon"></string>
           <int value="0"></int>
           <int value="3"></int>
          </list>
         </tuple>
        </list>
        <string role="key" value="_author"></string>
        <string value=""></string>
        <string role="key" value="_iDeviceDir"></string>
        <string value="text"></string>
        <string role="key" value="_purpose"></string>
        <string value=""></string>
        <string role="key" value="_tip"></string>
        <string value=""></string>
        <string role="key" value="_typeName"></string>
        <unicode value="Text"></unicode>
        <string role="key" value="_valid"></string>
        <bool value="1"></bool>
        <string role="key" value="class_"></string>
        <unicode value="text"></unicode>
        <string role="key" value="edit"></string>
        <bool value="0"></bool>
        <string role="key" value="emphasis"></string>
        <int value="0"></int>
        <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
        <int value="1"></int>
        <string role="key" value="fields"></string>
        <list>
         <instance class="exe.engine.field.TextAreaField" reference="2">
          <dictionary>
           <string role="key" value="_id"></string>
           <unicode value="127_2"></unicode>
           <string role="key" value="_idevice"></string>
           <reference key="1"></reference>
           <string role="key" value="_instruc"></string>
           <string value=""></string>
           <string role="key" value="_name"></string>
           <string value=""></string>
           <string role="key" value="anchor_names"></string>
           <list></list>
           <string role="key" value="anchors_linked_from_fields"></string>
           <dictionary></dictionary>
           <string role="key" value="content_w_resourcePaths"></string>
           <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;July 2023&lt;/p&gt;&lt;/div&gt;"></unicode>
           <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
           <int value="4"></int>
           <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
           <int value="2"></int>
           <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
           <int value="3"></int>
           <string role="key" value="htmlTag"></string>
           <string value="div"></string>
           <string role="key" value="images"></string>
           <instance class="exe.engine.galleryidevice.GalleryImages">
            <dictionary>
             <string role="key" value=".listitems"></string>
             <list></list>
             <string role="key" value="idevice"></string>
             <reference key="2"></reference>
            </dictionary>
           </instance>
           <string role="key" value="intlinks_to_anchors"></string>
           <dictionary></dictionary>
           <string role="key" value="nextImageId"></string>
           <int value="0"></int>
           <string role="key" value="parentNode"></string>
           <reference key="3"></reference>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="icon"></string>
        <unicode value=""></unicode>
        <string role="key" value="id"></string>
        <unicode value="0"></unicode>
        <string role="key" value="ideviceCategory"></string>
        <unicode value="Text and Tasks"></unicode>
        <string role="key" value="lastIdevice"></string>
        <bool value="0"></bool>
        <string role="key" value="nextFieldId"></string>
        <int value="3"></int>
        <string role="key" value="originalicon"></string>
        <string value=""></string>
        <string role="key" value="parentNode"></string>
        <reference key="3"></reference>
        <string role="key" value="systemResources"></string>
        <list></list>
        <string role="key" value="undo"></string>
        <bool value="1"></bool>
        <string role="key" value="userResources"></string>
        <list></list>
        <string role="key" value="version"></string>
        <int value="0"></int>
       </dictionary>
      </instance>
     </list>
     <string role="key" value="_id"></string>
     <unicode value="0"></unicode>
     <string role="key" value="_package"></string>
     <reference key="4"></reference>
     <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
     <int value="2"></int>
     <string role="key" value="exportType"></string>
     <string value="website"></string>
     <string role="key" value="last_full_node_path"></string>
     <string value="exe-node:Home"></string>
     <string role="key" value="parent"></string>
     <none></none>
     <string role="key" value="children"></string>
     <list>
      <instance class="exe.engine.node.Node" reference="7">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2023"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="5">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="6">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="128_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="5"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2023&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four characteristics of a priority scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Priority scheduling assigns a priority level to each process.&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;Processes with higher priorities are executed before processes with lower priorities.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Processes with the same priority are typically executed in FCFS (First-Come, First-Served) order.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Priority scheduling can be preemptive or non-preemptive.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;It may lead to starvation for low-priority processes if high priority process arrive continuously.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between dumb and smart controllers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Dumb Controller:&lt;/p&gt;
&lt;p&gt;A dumb controller is a simple device controller that can only follow explicit instructions from the CPU. It has minimal processing power and relies entirely on the CPU for all decision-making.&lt;/p&gt;
&lt;p&gt;Smart Controller:&lt;/p&gt;
&lt;p&gt;A smart controller has its own processor and can perform some processing independently of the CPU. It can handle more complex tasks and offload some of the processing burden from the main CPU. Smart controller use cache memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (b) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain three circumstances under which an ostrich algorithm would be used to deal with deadlock in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The ostrich algorithm ignores potential deadlocks and pretends they do not exist.&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;When deadlocks are very rare: If the probability of a deadlock occurring is extremely low, the cost of detection or prevention mechanisms may outweigh the impact of a potential deadlock.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;When the cost of deadlock recovery is low: If the system can easily recover from a deadlock (e.g., by rebooting), the overhead of deadlock prevention or detection might not be justified.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;When deadlock detection and prevention are too expensive: In systems where the computational cost of implementing deadlock detection or prevention algorithms is high, the ostrich algorithm might be a pragmatic choice.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two rules that should be followed when implementing a layered operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Higher layers can only access services provided by lower layers; a layer should never invoke a service on higher layer.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Each layer should have well-defined functionality and interfaces.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Mary noted several caching issues while using an operating system. Explain two such issues that she could have noted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Cache Coherency: This issue occurs when multiple caches exist (e.g., in a multi-core processor), and the data in one cache is modified without updating the other caches or main memory. This leads to inconsistencies.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Cache Thrashing: Occurs when the cache is constantly being filled and emptied due to a working set of data that exceeds the cache's capacity. This results in frequent cache misses and significantly degrades performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between seek time and latency as applied is disk drives.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Seek Time:&lt;/p&gt;
&lt;p&gt;Seek time is the time it takes for the disk arm to move the read/write head to the correct track on the disk platter.&lt;/p&gt;
&lt;p&gt;Latency (Rotational Latency):&lt;/p&gt;
&lt;p&gt;Latency is the time it takes for the desired sector of the disk to rotate under the read/write head after the head is positioned on the correct track. It's the delay caused by the rotational speed of the disk.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Contiguous file allocation method is commonly used in operating systems. Outline four advantages of this file allocation method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Contiguous file allocation involves storing file blocks in adjacent disk blocks.&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;Simple Implementation: It's straightforward to implement because the operating system only needs to track the starting block and the length of the file.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Fast Sequential Access: Sequential access is very fast since all blocks are contiguous, requiring minimal head movement.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Good Read Performance: Excellent for read operations, especially for sequential reads.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Minimal Overhead: Low metadata overhead, as only the starting address and length need to be stored.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Audit trail is an important file protection feature in operating systems. Outline four typical content of the audit records captured by this feature.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;User Identification: The user ID or account that performed the action.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Timestamp: The date and time the action occurred.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Type of Event: The specific action performed (e.g., file creation, deletion, modification, access).&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;File/Resource Identifier: The name or ID of the file or resource affected.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distributed Operating System allows applications running on multiple computers to be linked via a communications link. Describe two types of this operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Client-Server: In this type, clients request resources or services, and servers provide those resources or services. Clients do not share resources.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Peer-to-Peer (P2P): In a P2P distributed OS, all computers (nodes) have equal capabilities and responsibilities. Each node can act as both a client and a server, sharing resources and workload among themselves.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A lecturer described the computer clocking system during an operating system lesson. Describe two types of clocks that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Real-Time Clock (RTC): A hardware clock that keeps track of the current time, even when the computer is powered off. It is usually battery-backed.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Programmable Interval Timer (PIT): A hardware timer that can be programmed to generate interrupts at specific intervals. Used by the OS for scheduling tasks, time slicing, and other time-dependent operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four characteristics of round robin scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Round Robin scheduling is a preemptive scheduling algorithm.&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;Time Quantum/Time Slice: Each process is allocated a fixed time slice to execute.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Preemptive: Processes are interrupted after their time slice expires, and the CPU is given to the next process in the ready queue.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Fairness: All processes get an equal share of CPU time, preventing starvation.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Circular Queue: The ready queue is treated as a circular queue, with processes being picked in a round-robin fashion.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between maskable and non-maskable interrupts.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Maskable Interrupt:&lt;/p&gt;
&lt;p&gt;A maskable interrupt is an interrupt that can be temporarily disabled or ignored by the CPU. The operating system can choose to delay the handling of a maskable interrupt if a higher-priority task is being executed.&lt;/p&gt;
&lt;p&gt;Non-maskable Interrupt (NMI):&lt;/p&gt;
&lt;p&gt;A non-maskable interrupt is a high-priority interrupt that cannot be ignored or disabled by the CPU. It signals a critical hardware error or event that requires immediate attention, such as a power failure or memory error.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term process swapping used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Process swapping is the act of temporarily removing a process from main memory (RAM) and placing it on secondary storage (such as a hard disk) to free up memory for other processes. The swapped-out process can be brought back into memory later when needed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Computer terminals are commonly used for input of data in organizations. Describe two types that are likely to be used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Intelligent Terminals: These terminals have built-in processing capabilities, allowing for some local data processing and editing before sending data to the main computer. They can perform tasks like data validation and formatting.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Thin Clients: These are lightweight terminals that rely heavily on a central server for processing and storage. They typically have minimal local processing power and storage, acting primarily as an interface to the server.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;John was required to mention several disadvantages of memory overlay during a job interview. Explain three disadvantages that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Complexity: Designing and implementing overlays is a complex programming task, requiring careful planning and management of memory segments.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Programmer Overhead: The programmer is responsible for managing the overlays, which increases the programming burden and the potential for errors.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Limited Memory Savings: While overlays can save memory, they only allow parts of a program to be in memory at a time, not the entire program. The savings might not be significant for very large programs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between address and address space as applied in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Address:&lt;/p&gt;
&lt;p&gt;Address refers to a specific numerical value that is used to specify a particular memory location in computer where a certain byte or word of data is stored.&lt;/p&gt;
&lt;p&gt;Address space:&lt;/p&gt;
&lt;p&gt;An address space is the set of all possible addresses available to a process or the entire system. It's the range of memory locations that a process or the system can access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two types of semaphores used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Binary Semaphore: A binary semaphore can have only two values: 0 and 1. It is used to control access to a single resource, acting like a lock.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Counting Semaphore: A counting semaphore can have any non-negative integer value. It is used to control access to a resource with multiple instances, where the semaphore's value represents the number of available instances.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two circumstances under which an organization would implement a tree-structured directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Large Number of Files: When the organization has a vast number of files, a tree-structured directory provides a hierarchical organization that makes it easier to manage and locate files.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Hierarchical Data Organization: When the organization's data naturally fits into a hierarchical structure (e.g., departments, projects, subprojects), a tree structure reflects this organization logically.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A kernel is key in operating systems. Outline four roles it plays in operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Process Management: Creating, scheduling, and terminating processes.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Memory Management: Allocating and deallocating memory to processes.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Device Management: Controlling and managing hardware devices.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;File System Management: Organizing and managing files and directories.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Virtual memory does affect the performance of a system. Explain three disadvantages of implementing virtual memory in highly computational environments.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Overhead: Managing virtual memory adds overhead to the system, as the OS needs to translate virtual addresses to physical addresses and handle page faults.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Thrashing: If the system spends more time swapping pages between memory and disk than executing processes, it is said to be thrashing. This drastically reduces performance.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Increased Disk I/O: Virtual memory relies heavily on disk I/O for swapping pages, which is significantly slower than accessing RAM. This can slow down the overall system performance, especially in computationally intensive tasks that require frequent memory access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems: system call;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;System Call: A system call is a request made by a process to the operating system's kernel to perform a privileged operation or access a system resource. It provides an interface between user-level processes and the OS kernel.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;hypervisor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Hypervisor: A hypervisor, also known as a virtual machine monitor (VMM), is a software layer that creates and manages virtual machines (VMs). It allows multiple operating systems to run concurrently on a single physical machine by virtualizing the hardware resources.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (b) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 1 shows a memory management technique. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;Identify the memory management technique depicted in the Figure 1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_13-56-58_2023j.pdf.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;307&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Swapping.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two benefits of the technique in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Allows running more processes than can fit in physical memory simultaneously.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Increases CPU utilization by overlapping I/O of one process with the computation of another.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (b) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two limitations of the technique in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Slower execution: Swapping to disk is much slower than accessing RAM, leading to performance degradation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Increased disk I/O overhead: Frequent swapping increases disk I/O activity.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;The operating system maintains separate types of process scheduling queues throughout the process life cycle. Explain two types of these process scheduling queues.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Ready Queue: This queue holds processes that are in the ready state and are waiting to be assigned to a processor for execution.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Device Queue (or Wait/Blocked Queue): These queues hold processes that are waiting for a particular I/O device or event to complete. There is typically one queue per I/O device.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (d) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three factors that determines the efficiency of an I/O device.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Data Transfer Rate: The speed at which the device can transfer data to and from the computer's memory or CPU.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Access Time: The time it takes for the device to locate and retrieve data, including seek time and latency for disk drives.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Error Rate: The frequency of errors that occur during data transfer. A lower error rate indicates higher efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Ruben intends to implement a disk scheduling algorithm in an operating system that he was designing for a client. Describe two reasons for the inclusion of the algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Minimize Seek Time: A disk scheduling algorithm aims to minimize the movement of the disk arm, reducing the seek time and improving overall disk I/O performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Improve Throughput: By optimizing the order of disk requests, a disk scheduling algorithm can increase the number of requests serviced per unit of time, improving the overall throughput of the disk.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms used in computer memory: dual channel;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Dual Channel: A memory technology that uses two memory channels to increase the data transfer rate between the memory controller and the RAM. It effectively doubles the memory bandwidth compared to single-channel memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Error Correcting Code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Error Correcting Code (ECC): A type of memory that can detect and correct certain types of memory errors. It uses additional bits to store parity or checksum information, allowing it to identify and fix single-bit errors and, in some cases, detect multi-bit errors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between ready and ready suspended process states.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Ready:&lt;/p&gt;
&lt;p&gt;A process in the ready state is loaded in main memory and is waiting to be assigned to a processor for execution. It has all the resources it needs except the CPU.&lt;/p&gt;
&lt;p&gt;Ready Suspended:&lt;/p&gt;
&lt;p&gt;A process in the ready suspended state is not immediately available for execution. It has been swapped out of main memory to secondary storage (e.g., hard disk) but is still ready to run once it is loaded back into memory. This state helps to manage memory usage when there are more processes than can fit in RAM simultaneously.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;RAM disk are commonly used by computer users to temporarily store data. Explain three features that are likely to be exhibited when using it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Very High Speed: RAM disks are extremely fast because they reside in RAM, which offers much faster access times than physical disks (HDDs or SSDs).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Volatility: Data stored on a RAM disk is typically lost when the computer is powered off or loses power, as RAM requires constant power to maintain data.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Limited Capacity: The size of a RAM disk is limited by the amount of available RAM in the system, which is usually much smaller than the capacity of a hard disk or SSD.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows a contiguous memory allocation technique. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_13-59-21_2023j.pdf.png&quot; alt=&quot;&quot; width=&quot;195&quot; height=&quot;424&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Outline the memory technique shown in Figure 2.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Fixed Partitioning (or Static Partitioning).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two advantages of the memory technique identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Simplicity: Fixed partitioning is simple to implement, as the memory is divided into fixed-size partitions at system startup.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Low Overhead: It has low memory management overhead since the OS only needs to track which partitions are free and which are allocated.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (a) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain three design flaws common in I/O throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Inefficient Polling: Continuously checking the status of I/O devices (polling) wastes CPU cycles, especially when devices are slow or infrequent in their data transfer requests. This reduces overall throughput.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Lack of Buffering: Insufficient buffering between the I/O device and memory can create bottlenecks. If data is not buffered effectively, the CPU or device may have to wait, reducing throughput.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Incorrect Interrupt Handling: Inefficient or slow interrupt handling routines can significantly limit I/O throughput. If interrupt service routines are lengthy or poorly optimized, they can delay processing and reduce the overall data transfer rate.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Zack was researching on types of I/O devices that could be used in organizations. Explain two types that he could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Block Devices: These devices transfer data in blocks of fixed sizes. Examples include hard disks, SSDs, and tapes. They are characterized by addressable storage and are suitable for file systems and databases.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Character Devices: These devices transfer data character by character without any block structure. Examples include keyboards, mice, and serial ports. They are typically used for low-speed data input and output.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (c) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;File naming requires careful consideration by the users. Outline five guidelines that should be followed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Be Descriptive and Specific: File names should clearly indicate the content of the file. Use specific and descriptive words that accurately reflect the file's purpose.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Use Consistent Naming Conventions: Establish and follow a consistent naming convention within an organization or project. This makes it easier for users to understand and locate files.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Keep Names Concise but Clear: Aim for a balance between brevity and clarity. File names should be short enough to be easily manageable but long enough to convey sufficient information.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Avoid Special Characters and Spaces: Special characters (e.g., *, ?, /, \, :, &amp;lt;, &amp;gt;, |, &quot;) and spaces can cause compatibility issues across different operating systems and applications. Use underscores (_) or hyphens (-) instead of spaces, and stick to alphanumeric characters.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;Use Date and Versioning: For files that are frequently updated, include dates (YYYYMMDD format is recommended) and version numbers in the filename to track changes and maintain history.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (d) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Andy was required to diagnose the reasons for process termination in an operating system. Outline five reasons that he could find.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Normal Completion: The process has finished its execution and voluntarily terminated. This is a successful and expected termination.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Time Limit Exceeded: The process has run for longer than its allocated time slice or a predefined time limit set by the system or user.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Memory Allocation Failure: The process requested memory that the operating system could not provide. This can happen due to insufficient physical memory or virtual memory limitations.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Protection Fault: The process attempted to access memory or resources that it was not authorized to access. This is often due to programming errors or security violations.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;I/O Failure: The process encountered an error during an input or output operation. This could be due to hardware malfunctions, file access problems, or network issues.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;List four examples of file extensions used in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;.txt&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;.docx&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;.jpg&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;.pdf&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four ways of securing files stored in a computer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Access Control Lists (ACLs): Use ACLs to define permissions for users and groups, specifying who can read, write, or execute files. This ensures that only authorized users can access sensitive files.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Encryption: Encrypt files using encryption software or operating system features like BitLocker (Windows) or FileVault (macOS). Encryption protects file content even if unauthorized access is gained to the storage medium.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Firewall: Implement a firewall to control network access to the computer. This helps prevent unauthorized remote access to files and folders.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Regular Backups: Perform regular backups of important files to a separate storage location. Backups ensure data availability and protect against data loss due to hardware failure, accidental deletion, or security breaches.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 3 shows memory hierarchy in a computer. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_14-03-33_2023j.pdf.png&quot; alt=&quot;&quot; width=&quot;466&quot; height=&quot;352&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Describe the two memory hierarchy levels labelled (i) and (ii).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Level (i):&lt;/p&gt;
&lt;p&gt;Level (i) represents Main Memory (RAM). Main memory is the primary working memory of a computer system. It is faster than secondary storage but slower and more expensive than cache memory. It is volatile, meaning data is lost when power is turned off.&lt;/p&gt;
&lt;p&gt;Level (ii):&lt;/p&gt;
&lt;p&gt;Level (ii) represents Secondary Storage (Hard Disk/SSD). Secondary storage is used for long-term storage of data and programs. It is slower and cheaper than main memory and cache memory, but it is non-volatile, meaning data is retained even when power is off.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Modern operating system uses inverted page tables for memory management. Explain two disadvantages that could be realized from this method of paging.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Increased Complexity: Inverted page tables are more complex to implement and manage compared to traditional forward page tables. They require more sophisticated data structures and algorithms for address translation and page table maintenance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;TLB Inefficiency: Inverted page tables can sometimes lead to Translation Lookaside Buffer (TLB) misses. Since the inverted page table is indexed by physical frame number rather than virtual page number, TLB lookups can be less efficient, potentially increasing address translation overhead in certain access patterns.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;List four system file formats used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Executable files (e.g., .exe, .bin)&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Configuration files (e.g., .ini, .conf)&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Library files (e.g., .dll, .so)&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Device driver files (e.g., .sys, .drv)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two reasons for disk defragmentation in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Improve Access Time: Defragmentation rearranges fragmented files so that their blocks are contiguous on the disk. This reduces seek time and rotational latency, leading to faster file access and improved read/write performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Enhance System Responsiveness: By reducing disk access time, defragmentation can make the overall system more responsive. Applications load faster, file operations are quicker, and the system feels snappier, especially when dealing with frequently accessed files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 The Kenya National Examinations Council.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="249"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="1_128_2.3"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="8">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="5"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_13-59-21_2023j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_13-59-21_2023j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="94405e368980a223a14410c2308288d4"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="6"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="251"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="1_128_2.4"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="9">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="5"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_13-56-58_2023j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_13-56-58_2023j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="ad4825a3b0ad1e5342a3abe53059e827"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="6"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="253"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="1_128_2.5"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="10">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="5"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_14-03-33_2023j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_14-03-33_2023j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="8e96791daffb2fde15586baeabc58e8e"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="6"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="6"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="6"></int>
              <string role="key" value="parentNode"></string>
              <reference key="7"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="1"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="7"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="8"></reference>
            <reference key="9"></reference>
            <reference key="10"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="1"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202023"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="13">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2021"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="11">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="12">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="129_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="11"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2021&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (a) (i) (1) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the role played by operating systems in the following services: program development;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Operating systems provide essential tools and environments that facilitate program development. These include compilers, debuggers, text editors, and integrated development environments (IDEs). They also offer libraries and APIs that programmers can use to build applications, managing system resources and providing a consistent interface to hardware.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (a) (i) (II) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;system access.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Operating systems manage and control system access, ensuring secure and efficient resource utilization. They handle user authentication and authorization, control access to files and directories through permissions, and manage network connections. By mediating access to hardware and software resources, OSs maintain system integrity and prevent unauthorized operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two typical characteristics of microkernel architecture operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Minimal Kernel Size: Microkernels have a very small kernel that only includes essential functionalities like inter-process communication (IPC), basic scheduling, and memory management. Most other OS services are implemented as user-level processes.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Service Modularity: Services in a microkernel architecture, such as file systems, device drivers, and networking stacks, are designed as independent modules running in user space. This modularity enhances system flexibility and makes it easier to modify or extend services without affecting the kernel.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (b) (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;The operating system controls the execution of processes depending on various existing conditions in the system. Explain four reasons that could necessitate termination of a running process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Normal Completion: A process terminates normally when it has completed its intended task and reaches its natural endpoint. The process exits gracefully, releasing all resources it held.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Time Limit Exceeded: If a process runs longer than a predefined time limit set by the system or user, the OS may terminate it to prevent resource monopolization. This is common in time-sharing systems to ensure fair CPU allocation.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Resource Unavailability: A process may be terminated if it requests resources that the system cannot provide, such as memory, files, or I/O devices. This can occur due to system overload or hardware limitations.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Fatal Error: Processes can be terminated due to fatal errors such as division by zero, illegal memory access, or invalid instructions. These errors indicate that the process cannot continue execution safely or correctly and must be terminated to prevent system instability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 1 shows cross-sectional organization of a disk system. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_14-13-32_2021n.pdf.png&quot; alt=&quot;&quot; width=&quot;507&quot; height=&quot;415&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Explain the function of the parts labeled (i), (ii) and (iii).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Part (i) - Track:&lt;/p&gt;
&lt;p&gt;A track is a concentric circular path on the surface of a disk platter where data is recorded. Disks are formatted into tracks, and data is stored sequentially along these tracks. Each track is further divided into sectors.&lt;/p&gt;
&lt;p&gt;Part (ii) - Sector:&lt;/p&gt;
&lt;p&gt;A sector is the smallest unit of data storage on a disk drive, representing a segment of a track. Sectors are typically of a fixed size (e.g., 512 bytes or 4KB) and are used to read and write data. The OS addresses and manages data in units of sectors.&lt;/p&gt;
&lt;p&gt;Part (iii) - Platter:&lt;/p&gt;
&lt;p&gt;A platter is a circular magnetic disk on which data is stored. Hard disk drives usually consist of multiple platters stacked on a spindle. Each platter surface is coated with a magnetic material that can store data. Read/write heads access data on both surfaces of each platter.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two typical attributes associated with computer files.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Name: A file has a name that uniquely identifies it within a directory. The name is used by users and the operating system to access and manage the file.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Type: A file has a type that indicates the kind of data it contains (e.g., text, image, executable). The file type is often indicated by a file extension and helps the OS and applications determine how to handle the file.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between memory paging and memory segmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Memory Paging:&lt;/p&gt;
&lt;p&gt;Memory paging is a memory management technique that divides the computer's memory into fixed-size blocks called pages. Both virtual and physical memory are divided into pages of the same size. Paging provides a way to implement virtual memory, allowing non-contiguous allocation and efficient memory utilization.&lt;/p&gt;
&lt;p&gt;Memory Segmentation:&lt;/p&gt;
&lt;p&gt;Memory segmentation divides memory into logical units called segments, which are of variable size and correspond to logical parts of a program (e.g., code, data, stack). Segmentation supports a user-centric view of memory organization, allowing logical structuring of programs and data, but can lead to external fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Gijo Consultants have advised Youl Technical Institute to consider installing a multiprocessor system for its server room. Describe the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A multiprocessor system is a computer system with two or more central processing units (CPUs) within a single computer. These CPUs share system resources such as memory, I/O devices, and the system bus. Multiprocessor systems are designed to improve processing speed and system throughput by enabling parallel processing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two advantages of the system that could have influenced the advice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Increased Throughput: Multiprocessor systems can execute multiple processes or threads concurrently, significantly increasing the overall throughput and processing speed of the system. This is particularly beneficial for server environments that handle numerous requests simultaneously.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Enhanced Reliability and Fault Tolerance: In a multiprocessor system, if one processor fails, the system can continue to operate, albeit at a reduced performance level. This redundancy enhances system reliability and fault tolerance, making it more robust for critical server applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (d) Evaluate: (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Table 1 shows execution information of four processes in a system using SRTN scheduling algorithm.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_14-14-37_2021n.pdf.png&quot; alt=&quot;&quot; width=&quot;749&quot; height=&quot;337&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Use it to answer the questions that follow. (i) the average waiting time for the processes;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;To evaluate the average waiting time using SRTN, we need to trace the execution:&lt;/p&gt;
&lt;p&gt;At time 0, Process W arrives (Service time 1). W starts.&lt;/p&gt;
&lt;p&gt;At time 1, Process X arrives (Service time 10). Remaining time for W is 0. W finishes. X starts (SRTN).&lt;/p&gt;
&lt;p&gt;At time 2, Process Y arrives (Service time 3). Remaining time for X is 9. Y preempts X (SRTN).&lt;/p&gt;
&lt;p&gt;At time 3, Process Z arrives (Service time 7). Remaining time for Y is 2. Y continues.&lt;/p&gt;
&lt;p&gt;At time 5, Y finishes. Remaining time for X is 9, Remaining time for Z is 7. Z starts (SRTN).&lt;/p&gt;
&lt;p&gt;At time 12, Z finishes. Remaining time for X is 9. X starts.&lt;/p&gt;
&lt;p&gt;At time 21, X finishes.&lt;/p&gt;
&lt;p&gt;Completion Times: W: 1, Y: 5, Z: 12, X: 21&lt;/p&gt;
&lt;p&gt;Turnaround Times: W: 1-0=1, Y: 5-2=3, Z: 12-3=9, X: 21-1=20&lt;/p&gt;
&lt;p&gt;Waiting Times: W: 1-1=0, Y: 3-3=0, Z: 9-7=2, X: 20-10=10&lt;/p&gt;
&lt;p&gt;Average Waiting Time = (0 + 0 + 2 + 10) / 4 = 12 / 4 = 3&lt;/p&gt;
&lt;p&gt;Average Waiting Time: 3&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (d) Evaluate: (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) the average turn-around time for the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Turnaround Times (calculated above): W: 1, Y: 3, Z: 9, X: 20&lt;/p&gt;
&lt;p&gt;Average Turnaround Time = (1 + 3 + 9 + 20) / 4 = 33 / 4 = 8.25&lt;/p&gt;
&lt;p&gt;Average Turnaround Time: 8.25&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the following terms as used in operating systems: multithreading:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Multithreading is a programming and execution technique that allows a single process to have multiple threads of control within the same address space. These threads run concurrently, sharing the process's resources like memory and files, but operate independently in terms of execution flow.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A process is an instance of a computer program that is being executed. It is an independent unit of execution and resource allocation managed by the operating system. A process has its own address space, program code, data, and system resources such as file handles and network connections.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four typical functions of the operating system kernel during process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Process Creation and Termination: The kernel is responsible for creating new processes, allocating necessary resources, and terminating processes when they complete execution or encounter errors. This includes managing process IDs and process control blocks (PCBs).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Process Scheduling: The kernel implements scheduling algorithms to decide which process should be executed by the CPU at any given time. It manages process states (ready, running, waiting) and performs context switching to allocate CPU time among processes efficiently.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Inter-Process Communication (IPC): The kernel provides mechanisms for processes to communicate and synchronize with each other. These mechanisms include pipes, message queues, shared memory, and semaphores, enabling cooperation and data exchange between processes.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Resource Allocation and Management: The kernel manages system resources such as memory, CPU time, and I/O devices. It allocates resources to processes upon creation and reclaims them upon termination, ensuring fair and efficient resource utilization and preventing resource conflicts.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between block-oriented and stream-oriented I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Block-Oriented I/O Devices:&lt;/p&gt;
&lt;p&gt;Block-oriented I/O devices transfer data in fixed-size blocks. Data is accessed in discrete blocks, each with its own address. Examples include hard disks, SSDs, and tapes. Operations on block devices typically involve reading or writing entire blocks of data. They support random access to data blocks.&lt;/p&gt;
&lt;p&gt;Stream-Oriented I/O Devices:&lt;/p&gt;
&lt;p&gt;Stream-oriented I/O devices transfer data as a continuous stream of bytes or characters, without a block structure. Data is accessed sequentially. Examples include keyboards, mice, serial ports, and network interfaces. Operations involve reading or writing a stream of bytes. They are typically used for communication or sequential data flow.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (d) (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Memory management is a key function that should be carefully addressed when designing an operating system. Explain four requirements that the memory management design of an operating system should endeavor to satisfy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Efficiency and Performance: Memory management should aim for efficient utilization of memory resources to maximize system performance. It should minimize overhead associated with memory allocation, deallocation, and address translation, ensuring fast access to memory and reducing latency.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Protection and Security: Memory management must provide memory protection to prevent processes from accessing memory regions that do not belong to them. This is crucial for system stability and security, preventing unauthorized data access and interference between processes. Mechanisms like address space isolation and access control are essential.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Virtual Memory Support: Modern operating systems require virtual memory capabilities to allow processes to access more memory than physically available. Memory management should implement virtual memory techniques like paging or segmentation, enabling efficient use of physical RAM and disk space for memory extension. This includes demand paging and page replacement algorithms.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Fair Allocation and Resource Management: Memory management should ensure fair allocation of memory resources among competing processes, preventing starvation and ensuring that all processes get a reasonable share of memory. It needs to manage memory allocation and deallocation dynamically, adapting to changing process needs and system load. Mechanisms for managing memory fragmentation and compaction may be necessary.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four criteria that should be considered when selecting a file organization method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Access Pattern: The typical way files will be accessed (sequential, random, indexed). If files are mostly accessed sequentially, sequential organization might be efficient. For random access, indexed or direct file organization is better.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Data Volume and File Size: The size and number of files to be stored. For large volumes of data, methods that efficiently manage space and access large files are needed. For many small files, directory structure and overhead become important.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Performance Requirements: The required speed for file operations (read, write, search, update). Performance considerations will dictate whether simpler, faster methods or more complex, feature-rich methods are needed.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Application Needs: The specific requirements of the applications that will use the files. Different applications may have different needs in terms of data structure, access methods, and file operations. For example, database systems have different needs than text editors or multimedia applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (a) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe three types of operations commonly performed on file directories.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Search: Searching a directory involves locating a specific file or subdirectory within the directory structure. This operation is crucial for users and applications to find files by name. Efficient search operations are essential for quick file retrieval, and directory structures are often optimized for fast searching, such as using hash tables or tree-based indices.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Create/Delete: Operations to create new directories or files within a directory and to delete existing directories or files. Creating a directory involves allocating space and updating directory metadata to include the new entry. Deleting a directory involves removing its entry from the parent directory and deallocating space. These operations are fundamental for managing the file system hierarchy.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;List/Enumerate: Listing or enumerating directory contents involves retrieving a list of all files and subdirectories contained within a directory. This operation allows users and applications to view the contents of a directory, often used in file browsers or command-line interfaces. The operation needs to efficiently access and present directory entries in a readable format.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between demand cleaning and precleaning as used in virtual memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Demand Cleaning:&lt;/p&gt;
&lt;p&gt;Demand cleaning is a page cleaning policy in virtual memory management where dirty pages (pages that have been modified and differ from their disk copy) are written back to disk only when a page frame is needed for allocation to a new page. Cleaning is triggered by page faults and memory pressure. It aims to minimize disk I/O by writing pages back only when necessary.&lt;/p&gt;
&lt;p&gt;Precleaning:&lt;/p&gt;
&lt;p&gt;Precleaning, also known as anticipatory cleaning, is a page cleaning policy where dirty pages are written back to disk proactively, before they are needed to be replaced or when system load is low. This policy anticipates future page faults and attempts to reduce page fault service time by having clean pages readily available in memory. It can improve responsiveness but may increase disk I/O if precleaning is too aggressive.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Fred is designing an input device for his mini laptop that would use the DMA I/O technique. Describe the process of reading a block of data from the device.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Process of Reading Data using DMA:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;CPU Initialization: The CPU initiates the DMA transfer by programming the DMA controller. It provides the DMA controller with details such as the source device address, the destination memory address, the amount of data to be transferred (block size), and the direction of transfer (read from device to memory).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;DMA Request and Grant: The DMA controller requests control of the system bus from the CPU. The CPU grants the bus to the DMA controller, typically after the current bus cycle is complete. This process is known as bus arbitration.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Data Transfer by DMA Controller: Once the DMA controller has bus control, it directly transfers data from the input device to main memory without CPU intervention. For each word or block of data, the DMA controller:&lt;/p&gt;
&lt;p&gt;a. Sends a read request to the input device.&lt;/p&gt;
&lt;p&gt;b. Receives the data from the device.&lt;/p&gt;
&lt;p&gt;c. Writes the data to the specified memory address.&lt;/p&gt;
&lt;p&gt;d. Increments the memory address and decrements the byte count.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Transfer Completion and Notification: After transferring the entire block of data, the DMA controller relinquishes control of the system bus and notifies the CPU that the transfer is complete. Notification can be through an interrupt.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;CPU Resumes Processing: The CPU, upon receiving the DMA completion notification, can now access the data in main memory. The CPU is free to perform other tasks during the DMA transfer, enhancing system concurrency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two RAID configurations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;RAID 0 (Striping): Data is striped across multiple disks to increase performance. It provides no redundancy, so failure of one disk results in data loss.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;RAID 1 (Mirroring): Data is mirrored across two disks, providing redundancy. If one disk fails, data is still available from the mirror disk. It improves read performance but write performance is not significantly improved.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (ii) (1) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the following terms as used in disk systems: head;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Head: In disk systems, a head is a component of the disk drive that reads and writes data to and from the disk platter. Each platter typically has two heads, one for each surface. The head contains read/write elements that detect and modify the magnetic orientation on the disk surface to store and retrieve data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (ii) (II) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;density.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Density: In disk systems, density refers to the amount of data that can be stored per unit area on the disk platter. It's typically measured in bits per inch (BPI) along a track (linear density) and tracks per inch (TPI) across the radius of the disk (areal density). Higher density allows for greater storage capacity in the same physical space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (b) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Deric would like to implement an index-sequential file organization system is an operating system he is designing. Explain two types of indexes he could apply in the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Primary Index: A primary index is based on the primary key of the file, which uniquely identifies each record. In an index-sequential file system, the primary index typically points to the physical location of records sorted by the primary key. This index facilitates fast access to records based on their primary key value and maintains the sequential order of records.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Secondary Index: A secondary index is created on non-key attributes of the file, allowing for efficient searching and access based on these attributes. Secondary indexes provide an alternative access path to the data, without requiring sorting of the main data file on the secondary key. They are used to improve query performance for searches based on attributes other than the primary key.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two application areas where the file system in most appropriate.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Library Catalog Systems: In systems like library catalogs, where books are accessed by ISBN (primary key) and also frequently searched by title or author (secondary keys), index-sequential file organization is effective. It allows for sequential processing for catalog updates and indexed access for search queries.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Inventory Management Systems: For inventory systems, where items are primarily identified by a product ID (primary key) and need to be searched by name or category (secondary keys), index-sequential file organization is suitable. It supports efficient retrieval based on product IDs and allows for flexible querying using secondary indexes for stock checks and reports.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (c) Identify the condition depicted in the figure justifying your answer. (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows allocation of resources to two processes. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_14-15-19_2021n.pdf.png&quot; alt=&quot;&quot; width=&quot;968&quot; height=&quot;339&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(i) Identify the condition depicted in the figure justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Deadlock. The figure shows Process X holding Resource A and requesting Resource B, while Process Y is holding Resource B and requesting Resource A. This circular wait condition, where each process is waiting for a resource held by the other, is the defining characteristic of a deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (c) Explain three measures that could have prevented the condition. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain three measures that could have prevented the condition.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Resource Ordering (Prevent Circular Wait): Impose a total ordering on all resource types and require each process to request resources in an increasing order of enumeration. For example, if resources A and B are ordered such that A &amp;lt; B, a process requesting both must request A before B. This prevents the circular wait condition necessary for deadlock.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Resource Preemption (Allow Preemption): Allow the operating system to preempt resources from a process. If a process is holding some resources and requests another resource that cannot be immediately allocated, the OS can preempt some of the resources already held by the process, release them, and allocate them to other processes, breaking the hold-and-wait condition. Preemption is feasible for resources whose state can be easily saved and restored, like memory and CPU registers.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Hold-and-Wait Prevention (Prevent Hold and Wait): Ensure that whenever a process requests a resource, it does not hold any other resources. One way to implement this is to require processes to request all the resources they need before starting execution. Alternatively, if a process needs a new resource, it must release all resources it currently holds. These strategies prevent processes from holding a resource while waiting to acquire another, thereby preventing the hold-and-wait condition necessary for deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between a clock interrupt and an I/O interrupt as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Clock Interrupt:&lt;/p&gt;
&lt;p&gt;A clock interrupt is a periodic interrupt generated by a hardware timer at regular intervals. It is used by the operating system for timekeeping, scheduling processes, and enforcing time limits. Clock interrupts drive time-sharing and preemptive multitasking, allowing the OS to regain control periodically and manage process execution.&lt;/p&gt;
&lt;p&gt;I/O Interrupt:&lt;/p&gt;
&lt;p&gt;An I/O interrupt is generated by an I/O device to signal the completion of an I/O operation or to indicate an event requiring attention. I/O interrupts allow the OS to handle I/O events asynchronously and efficiently. When an I/O operation completes (e.g., data arrival, device ready), the device sends an interrupt to the CPU, prompting the OS to handle the event, such as transferring data or resuming a waiting process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the principle of locality as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The principle of locality, also known as the locality of reference, is the tendency of a processor to access the same set of memory locations repeatedly over a short period of time (temporal locality) and to access memory locations that are physically close to each other (spatial locality). This principle is fundamental to the effectiveness of caching and virtual memory systems, as it allows for predicting future memory accesses based on past access patterns.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four typical contents of page frame data table as applied in memory management systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Page State: Indicates the current status of the page frame, such as whether it is free, allocated to a process, or part of the operating system. The state may also indicate if the page is valid (present in physical memory) or invalid (not in physical memory).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Virtual Page Number: Stores the virtual page number that is currently mapped to this physical page frame. This mapping is essential for translating virtual addresses to physical addresses during memory access.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Reference Count: Tracks the number of virtual pages or processes that are currently sharing this page frame. This is important for shared pages and copy-on-write mechanisms in virtual memory.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Dirty Bit: A flag that indicates whether the page frame has been modified since it was loaded into memory. The dirty bit is used by page replacement algorithms to determine if a page needs to be written back to disk before being replaced. If the dirty bit is set, the page must be written to disk; otherwise, it can be discarded if needed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (c) Evaluate: (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A particular hard disk has a total of 200 tracks. Six processes make requests for data from the following tracks respectively: 60 70 50 30 98 130 For each of the following disk scheduling algorithms, determine the average seek length assuming that the starting track is 100. (i) FIFO;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;FIFO (First-Come, First-Served):&lt;/p&gt;
&lt;p&gt;Request sequence: 60, 70, 50, 30, 98, 130. Starting position: 100.&lt;/p&gt;
&lt;p&gt;Seek lengths: |100-60| + |60-70| + |70-50| + |50-30| + |30-98| + |98-130|&lt;/p&gt;
&lt;p&gt;= 40 + 10 + 20 + 20 + 68 + 32 = 190&lt;/p&gt;
&lt;p&gt;Average seek length = 190 / 6 = 31.67 tracks&lt;/p&gt;
&lt;p&gt;Average Seek Length (FIFO): 31.67 tracks&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (c) Evaluate: (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) SSTF.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;SSTF (Shortest Seek Time First):&lt;/p&gt;
&lt;p&gt;Requests: 60, 70, 50, 30, 98, 130. Starting position: 100.&lt;/p&gt;
&lt;p&gt;1. From 100, closest is 98. Seek to 98 (length 2). Requests left: 60, 70, 50, 30, 130.&lt;/p&gt;
&lt;p&gt;2. From 98, closest is 70. Seek to 70 (length 28). Requests left: 60, 50, 30, 130.&lt;/p&gt;
&lt;p&gt;3. From 70, closest is 60. Seek to 60 (length 10). Requests left: 50, 30, 130.&lt;/p&gt;
&lt;p&gt;4. From 60, closest is 50. Seek to 50 (length 10). Requests left: 30, 130.&lt;/p&gt;
&lt;p&gt;5. From 50, closest is 30. Seek to 30 (length 20). Requests left: 130.&lt;/p&gt;
&lt;p&gt;6. From 30, only request is 130. Seek to 130 (length 100).&lt;/p&gt;
&lt;p&gt;Total seek length = 2 + 28 + 10 + 10 + 20 + 100 = 170&lt;/p&gt;
&lt;p&gt;Average seek length = 170 / 6 = 28.33 tracks&lt;/p&gt;
&lt;p&gt;Average Seek Length (SSTF): 28.33 tracks&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the contiguous file allocation method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Contiguous File Allocation:&lt;/p&gt;
&lt;p&gt;In contiguous file allocation, each file occupies a set of contiguous blocks on the disk. The disk space is allocated in a single continuous section of blocks. The file system only needs to store the starting block address and the length (number of blocks) of the file to locate all its blocks. This method simplifies file access and management.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;diagram_contiguous_allocation.png&quot; alt=&quot;Diagram of Contiguous File Allocation&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Diagram Description:&lt;/p&gt;
&lt;p&gt;The diagram would visually represent a disk divided into blocks. A file, say &quot;File A&quot;, is shown occupying a contiguous set of blocks (e.g., blocks 10-15). The File Directory entry for &quot;File A&quot; would store the starting block number (10) and the length (6 blocks). Other files would similarly be allocated contiguous blocks of disk space. Free space would be represented as unallocated blocks. This illustrates how contiguous allocation stores files in adjacent disk blocks.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the following terms as used in memory management: virtual address;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Virtual Address: A virtual address is a logical address used by a process in a virtual memory system. It is an address within the process's virtual address space. Virtual addresses are translated by the memory management unit (MMU) into physical addresses to access actual physical memory. This abstraction allows processes to have their own private address spaces and use more memory than physically available.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;thrashing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Thrashing: Thrashing is a condition in virtual memory systems where the system spends more time swapping pages between memory and disk than executing processes. This occurs when the system is overloaded, and the working set size of active processes exceeds the available physical memory. Frequent page faults and disk I/O operations lead to a significant decrease in system performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (b) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three lists that are maintained to manage the buffer cache in UNIX systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Free List: A list of buffer blocks in the cache that are currently not in use and are available for allocation. When the system needs a new buffer block, it is taken from the free list. When a buffer block is no longer needed, it is returned to the free list.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Hash Queue: A set of hash queues that are used to quickly locate buffer blocks based on the device number and block number. When the system needs to access a specific disk block, it calculates a hash value based on the device and block number and searches the corresponding hash queue for the buffer block. This speeds up buffer lookup.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;LRU (Least Recently Used) List: A list of buffer blocks in the cache, ordered by their last time of use, with the least recently used block at the head of the list and the most recently used block at the tail. When the cache is full and a new buffer block needs to be allocated, the block at the head of the LRU list (least recently used) is typically chosen for replacement.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (b) (ii) (7 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe a typical organization of I/O subsystem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Typical Organization of I/O Subsystem:&lt;/p&gt;
&lt;p&gt;The I/O subsystem in an operating system typically involves several layers and components that work together to manage data transfer between the system and external devices. It is designed to handle a variety of devices with different characteristics efficiently and abstract device-specific details from the rest of the OS.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;diagram_io_subsystem.png&quot; alt=&quot;Diagram of I/O Subsystem Organization&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Diagram Description:&lt;/p&gt;
&lt;p&gt;The diagram would depict a layered structure:&lt;/p&gt;
&lt;p&gt;User Processes at the top, making I/O requests through System Calls.&lt;/p&gt;
&lt;p&gt;System Call Interface: Handles system call requests and routes them to appropriate I/O modules.&lt;/p&gt;
&lt;p&gt;Device-Independent I/O Layer: Provides a uniform interface for I/O operations, independent of device types. Includes functions for buffering, caching, and error handling.&lt;/p&gt;
&lt;p&gt;Device Drivers: Device-specific modules that communicate directly with hardware devices. Each driver manages a specific type of device (e.g., disk driver, network driver, keyboard driver), translating general I/O requests into device-specific commands and handling device interrupts.&lt;/p&gt;
&lt;p&gt;Interrupt Handlers: Routines that respond to hardware interrupts from I/O devices, signaling completion of operations or device events.&lt;/p&gt;
&lt;p&gt;Hardware Controllers and Devices: Physical I/O devices and their controllers, responsible for the actual data transfer and device operations.&lt;/p&gt;
&lt;p&gt;Data flow is shown from User Processes down through the layers to Hardware and back up, illustrating the path of an I/O request and response. This layered approach provides modularity, device independence, and efficient I/O management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Free space management is important for efficient file management. Explain three techniques applied by operating systems to manage space on disks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Bitmaps: A bitmap or bit vector is used to track the allocation status of disk blocks. Each bit in the bitmap corresponds to a disk block. If a bit is 0, the block is free; if it's 1, the block is allocated. Bitmaps are efficient for finding contiguous free blocks and are relatively simple to implement. They require space proportional to the disk size, but this overhead is usually acceptable for modern disks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Linked Lists: Free disk blocks are linked together in a linked list. Each free block contains a pointer to the next free block. To allocate space, the OS traverses the list to find enough contiguous blocks. To free space, blocks are added back to the list. Linked lists can suffer from fragmentation and can be less efficient for finding contiguous blocks compared to bitmaps.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Grouping: This technique improves linked list approach by storing the addresses of multiple free blocks in one free block, effectively creating groups of free blocks. This reduces the number of disk accesses needed to find free space. A free block now contains pointers to a group of subsequent free blocks, and the last pointer in the group points to another block containing pointers to more free blocks, and so on. This hierarchical grouping helps in managing larger chunks of free space more efficiently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between best-fit and first-fit policies as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;First-Fit:&lt;/p&gt;
&lt;p&gt;First-fit is a dynamic memory allocation algorithm that allocates the first available memory partition (hole) that is large enough to satisfy the request. The algorithm searches the list of free partitions from the beginning and stops as soon as it finds a suitable partition. It is simple and fast but can lead to external fragmentation over time, as larger free partitions might be broken into smaller ones and scattered across memory.&lt;/p&gt;
&lt;p&gt;Best-Fit:&lt;/p&gt;
&lt;p&gt;Best-fit is a dynamic memory allocation algorithm that allocates the smallest available memory partition (hole) that is just large enough to satisfy the request. The algorithm searches the entire list of free partitions to find the smallest suitable one. Best-fit aims to minimize memory wastage and reduce external fragmentation by leaving the largest possible remaining free partition after allocation. However, it is slower than first-fit because it requires searching the entire list.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two categories of user access rights used in file management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Read Access: Read access right allows a user to view or copy the contents of a file. Users with read access can open and read the file data but cannot modify or delete it.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Write Access: Write access right allows a user to modify or delete a file. Users with write access can change the file content, rename the file, or delete it entirely. Write access typically implies read access as well.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;The extent to which user requirements are met by a file management system depends on the application and environment. Outline four such requirements for an interactive and networked environment.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Fast Access and Response Time: In interactive environments, users expect quick response times when accessing or manipulating files. The file management system should provide fast file access, directory navigation, and file operations to ensure a smooth and efficient user experience. Low latency for file operations is crucial for interactive applications.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Concurrent Access and Sharing: In networked environments, multiple users often need to access and share files concurrently. The file management system must support concurrent access, allowing multiple users to read and write files simultaneously without data corruption or conflicts. Mechanisms for file locking and concurrency control are necessary.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Security and Access Control: Security is paramount in networked environments. The file management system must provide robust security features, including user authentication, access control lists (ACLs), and encryption, to protect files from unauthorized access, modification, or deletion. Fine-grained permissions and secure file sharing are essential.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Reliability and Data Integrity: Reliability and data integrity are critical in both interactive and networked environments. The file management system should ensure data durability, protecting against data loss due to system failures, hardware errors, or power outages. Features like journaling, redundancy, and backup/restore mechanisms are important to maintain data integrity and system robustness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (c) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Prince intends to use semaphores for process control in the operating system that he is developing. Outline four typical elements that should constitute the semaphore module.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Semaphore Data Structure: A data structure to represent the semaphore itself. This typically includes an integer value (the semaphore count) and a waiting queue (or list) to hold processes that are blocked on the semaphore.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;P (Wait or Acquire) Operation: A function or system call that decrements the semaphore value. If the value becomes negative, the process is blocked and added to the semaphore's waiting queue. The P operation attempts to acquire or wait for a resource.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;V (Signal or Release) Operation: A function or system call that increments the semaphore value. If there are processes waiting in the queue, one process is unblocked and allowed to proceed. The V operation signals or releases a resource, potentially waking up a waiting process.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Initialization Function: A function to initialize the semaphore data structure, setting the initial semaphore value (usually non-negative) and initializing the waiting queue to be empty. Initialization is necessary before a semaphore can be used for process synchronization and mutual exclusion.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (c) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A computer laboratory technician has been instructed to install a new hard disk with three logical partitions in the HOD's computer. Describe three activities that he/she would carry out before installing the operating system and other applications into the hard disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Physical Installation: Install the new hard disk into the computer. This involves opening the computer case, locating an available drive bay, physically mounting the hard disk securely, and connecting the necessary data and power cables (SATA or IDE). Ensure proper grounding and handling to avoid electrostatic discharge damage.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;BIOS/UEFI Configuration: Access the computer's BIOS or UEFI settings upon startup. Verify that the new hard disk is recognized by the system BIOS/UEFI. If necessary, adjust the boot order settings to ensure the system can boot from installation media (like USB or DVD) if needed for OS installation. Check for any disk-related settings and confirm correct detection.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Partitioning and Formatting: Boot from a live OS environment or installation media. Use disk partitioning tools (like fdisk, gparted, or disk management utilities in Windows PE) to partition the new hard disk into three logical partitions as required. For each partition, choose a file system (like NTFS, FAT32, ext4) and format the partitions. Formatting prepares the partitions for file storage by creating the file system structure on each partition. Label partitions for easy identification (e.g., OS, Data, Backup).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2021 The Kenya National Examinations Council.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="247"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="2_129_2.3"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="14">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="11"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_14-13-32_2021n.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_14-13-32_2021n.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="f75ffbd09efc4300548fcdb7bc4c6385"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="12"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="250"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="2_129_2.4"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="15">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="11"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_14-14-37_2021n.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_14-14-37_2021n.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="f07445838ec7a9862b523e65adc5302b"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="12"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="252"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="2_129_2.5"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="16">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="11"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_14-15-19_2021n.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_14-15-19_2021n.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="06ec51036307a0c6b513f6b8627e64a0"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="12"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="12"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="6"></int>
              <string role="key" value="parentNode"></string>
              <reference key="13"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="2"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="13"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="14"></reference>
            <reference key="15"></reference>
            <reference key="16"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="2"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202021"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="19">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value=" July 2021"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="17">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="18">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="130_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="17"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2021&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four objectives of memory management as a function of the operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;To efficiently utilize available memory space.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;To allow multiprogramming by accommodating multiple processes in memory.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;To provide memory protection to prevent processes from interfering with each other.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;To enable virtual memory, allowing processes to exceed physical memory size.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two functions of shell as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Command Interpretation: The shell interprets commands entered by the user, parsing and executing them. It acts as a command-line interpreter, translating user requests into system calls.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Scripting and Automation: Shells allow users to write scripts (shell scripts) to automate tasks. These scripts can combine multiple commands, control flow, and perform complex operations, enhancing system automation and efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;In an operating system a process may go through several states. Outline six such process states.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;New: The process is being created and has not yet been admitted to the pool of executable processes by the operating system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Ready: The process is waiting to be assigned to a processor. Ready processes are waiting to have processor time allocated to them.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Running: The process is being executed by a processor. Instructions of the process are being carried out.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Waiting/Blocked: The process is waiting for some event to occur, such as completion of an I/O operation or receipt of a signal.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;Suspended Ready: A ready process that has been moved out of main memory to secondary memory (e.g., disk) to free up main memory.&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;Suspended Blocked/Waiting: A blocked process that has been moved out of main memory to secondary memory to free up main memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1 (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Paging is a significant technique used in memory management. Explain three advantages that paging could provide when implemented.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Virtual Memory Implementation: Paging is essential for implementing virtual memory, allowing processes to run even if they are larger than physical memory. It enables the system to bring only necessary pages into RAM, keeping the rest on disk.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Reduced External Fragmentation: Paging eliminates external fragmentation as memory allocation is done in fixed-size pages. Free pages can be allocated to any process, regardless of their physical location, making memory utilization more efficient.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Efficient Memory Sharing: Paging facilitates sharing of code and data among processes. If multiple processes use the same code or libraries, the corresponding pages can be shared in physical memory, reducing memory footprint and improving system efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four types of Direct Memory Access (DMA) transfer mode.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Burst Mode DMA: In burst mode, DMA controller transfers a block of data in a continuous sequence. It gains control of the system bus and retains it until the entire block transfer is complete, leading to high-speed data transfer.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Cycle Stealing DMA: In cycle stealing mode, DMA controller transfers data one byte or word at a time, relinquishing bus control after each transfer. CPU can interleave its operations with DMA transfers, allowing concurrent CPU and I/O activity, though at a reduced DMA transfer rate.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Transparent DMA: In transparent DMA, DMA transfers occur when the CPU is not using the system bus, typically during CPU idle cycles or memory refresh cycles. DMA operations are transparent to the CPU, having minimal impact on CPU performance.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Fly-by DMA: In fly-by DMA, data is transferred directly between two peripherals without going through main memory. DMA controller manages data flow directly from source device to destination device, reducing memory bandwidth usage and latency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two features of the 3rd generation computer operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Multiprogramming: Third-generation operating systems introduced multiprogramming, allowing multiple programs to reside in memory simultaneously. This enabled the CPU to switch between programs, increasing CPU utilization and system throughput by overlapping CPU and I/O operations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Time-Sharing: Time-sharing systems emerged, a logical extension of multiprogramming. They allowed multiple users to interact with the computer system concurrently. CPU time is divided and allocated to each user's process in time slices, providing interactive computing experience and responsiveness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two circumstances under which memory overlay could be implemented in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Limited Memory Size: When the size of a program exceeds the available physical memory, memory overlay can be used to run the program. It divides the program into smaller segments (overlays), loading only necessary segments into memory at any given time, swapping segments in and out as needed.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Simple Program Structure: Memory overlay is more feasible when programs have a relatively simple and modular structure. Programs that can be naturally divided into independent modules or phases that do not need to reside in memory simultaneously are suitable for overlay implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2 (d) (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;When a user program processes a malicious task it causes a threat to the operating system. Explain four such threats.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Malware Installation: Malicious programs can install malware (viruses, worms, Trojans) onto the system. Malware can compromise system integrity, steal data, disrupt operations, or grant unauthorized access to attackers.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Data Breach and Exfiltration: Malicious tasks can lead to data breaches, where sensitive information is accessed and exfiltrated without authorization. This can compromise confidential data, intellectual property, or personal information.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Denial of Service (DoS): Malicious programs can launch denial-of-service attacks, overwhelming system resources (CPU, memory, network) to make the system or services unavailable to legitimate users. DoS attacks can disrupt critical operations and services.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Privilege Escalation: Malicious tasks may attempt to exploit vulnerabilities to escalate privileges, gaining administrative or root access to the system. With elevated privileges, malicious programs can bypass security controls, modify system settings, or perform unauthorized actions, causing severe damage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline the functions of each of the following drivers: kernel device;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Kernel device drivers operate within the kernel space, directly interacting with hardware. Their function is to provide low-level control and management of hardware devices, enabling the operating system to communicate with and utilize hardware resources efficiently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;use mode device;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;User mode device drivers operate outside the kernel in user space. They provide a higher-level interface to hardware devices, often utilizing kernel drivers for low-level operations. User mode drivers enhance system stability by isolating driver failures from the kernel and can simplify driver development for certain devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (iii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;block;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Block device drivers manage block-oriented devices like hard disks and SSDs. Their primary function is to handle block-level I/O operations, such as reading and writing data in fixed-size blocks, managing disk access, and implementing storage protocols.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (a) (iv) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;character.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Character device drivers manage character-oriented devices like keyboards and serial ports. Their function is to handle byte-stream data transfer, managing input and output of individual characters or bytes, and providing interfaces for character-based communication.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following multiprocessor operating system models: master-slave;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Master-Slave Multiprocessor Model: In this model, one processor is designated as the master, and the others are slaves. The master processor handles operating system functions, scheduling, and system management, while slave processors execute user processes under the master's direction. It is simpler to implement but can create a bottleneck at the master processor and is less fault-tolerant.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;symmetric.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Symmetric Multiprocessor (SMP) Model: In SMP, all processors are treated equally and can perform all tasks, including operating system functions and user processes. Processors share memory and I/O resources and communicate through a shared bus or interconnect. SMP provides better load balancing and fault tolerance compared to master-slave but requires more complex OS design to manage concurrency and synchronization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Computer operating systems access files using specific mechanism. Explain three file access mechanisms that could be used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Sequential Access: In sequential access, files are accessed in a linear, ordered manner, from the beginning to the end. Operations like read and write proceed in sequence. This method is efficient for processing files in order, such as log files or batch processing, but inefficient for random access or frequent seeking.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Direct/Random Access: Direct access allows accessing any file record directly without traversing from the beginning. Records are accessed based on their address or position. This method is suitable for applications requiring random data retrieval and updates, such as databases or indexed file systems, providing fast access to specific data records.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Indexed Sequential Access: Indexed sequential access combines sequential and direct access methods. It uses an index to enable direct access to records based on key values, while also supporting sequential processing. Files are stored sequentially, and an index is maintained to locate records quickly. This method balances the advantages of both sequential and direct access, suitable for applications needing both ordered processing and indexed retrieval.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3 (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;RAID storage techniques were introduced to manage the challenges of computer storage. Explain three benefits that could be realised from these techniques.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Improved Performance: RAID techniques like striping (RAID 0) can significantly improve data access and transfer rates by distributing data across multiple disks. This parallel access enhances read and write performance, reducing I/O latency and increasing throughput, beneficial for high-performance applications.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Enhanced Reliability and Fault Tolerance: RAID levels like mirroring (RAID 1) and parity-based RAID (RAID 5, RAID 6) provide data redundancy. In case of a disk failure, data can be recovered or accessed from redundant copies or parity information, ensuring data availability and system resilience. This fault tolerance minimizes downtime and data loss.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Increased Storage Capacity: RAID configurations like spanning (RAID 0) and concatenation can combine multiple physical disks into a single logical volume, increasing total storage capacity. RAID can aggregate storage space from multiple drives, providing larger volumes to accommodate growing data needs. While some RAID levels trade capacity for redundancy, others maximize usable storage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two types of job control language statements used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Command Statements: These JCL statements instruct the operating system to execute specific commands or programs. They initiate program execution, specify program parameters, and control the flow of job processing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Data Definition (DD) Statements: DD statements describe and allocate data resources required by a job. They define input and output datasets, specify file attributes, and associate datasets with programs, enabling data management within jobs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two divisions of addresses generated by the CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Logical Address (Virtual Address): Logical addresses are generated by the CPU and are addresses within the process's virtual address space. They are independent of the physical memory layout and are translated to physical addresses by the Memory Management Unit (MMU). Logical addresses provide processes with a private and contiguous address space.&lt;/p&gt;
&lt;p&gt;Physical Address: Physical addresses are the actual memory addresses in physical RAM. They are used to access physical memory locations. Logical addresses are mapped to physical addresses by the MMU, using techniques like paging or segmentation, to enable virtual memory and memory protection.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between record and file as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Record: A record is a structured unit of data within a file, representing a collection of related data items or fields. Records are logical entities that organize data within a file, e.g., a row in a database table or a line in a text file. Records are the basic units of data manipulation within a file.&lt;/p&gt;
&lt;p&gt;File: A file is a named collection of related records or data, stored and managed by the operating system as a single unit. Files are containers for data and metadata, organized in a file system hierarchy (directories). Files are persistent storage units, providing a way to store and retrieve data persistently on storage devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two circumstances under which deadlocks could occur in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Mutual Exclusion and Hold and Wait: Deadlock can occur when processes require exclusive access to resources (mutual exclusion) and hold allocated resources while waiting to acquire additional resources (hold and wait). If multiple processes hold resources and request resources held by others, a circular wait condition can arise, leading to deadlock.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;No Preemption and Circular Wait: Deadlock can occur when resources cannot be forcibly taken away from a process (no preemption) and a circular wait condition exists. Circular wait happens when two or more processes are waiting for each other to release resources in a circular chain, preventing any process from proceeding and resulting in a deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4 (d) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;In order to achieve device independence, the computer organizes the I/O software in layers. Describe three such layers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;User-Level I/O Libraries: This is the highest layer, consisting of user-level libraries and APIs that provide a device-independent interface for applications to perform I/O operations. Libraries abstract device-specific details, offering high-level functions like file I/O, network communication, and device access. Applications interact with these libraries without needing to know device-specific details.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Device-Independent OS Core: This layer in the OS kernel provides a device-independent abstraction for I/O operations. It includes generic I/O functions, buffering, caching, and error handling mechanisms that are common across different device types. This layer translates device-independent requests from user-level libraries into device-specific requests for lower layers.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Device Drivers: Device drivers are the lowest layer, directly interacting with hardware devices. Each device driver is specific to a particular type of device or device controller. Drivers implement device-specific I/O operations, handle hardware interrupts, and translate generic I/O requests from the OS core into device-specific commands. Device drivers encapsulate hardware-specific details, ensuring device independence for higher layers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in I/O devices: external interrupt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;External Interrupt: An external interrupt is a hardware interrupt generated by an I/O device or external hardware component to signal an event requiring CPU attention. External interrupts are asynchronous signals from peripherals indicating completion of I/O operations, device status changes, or external events, prompting the CPU to handle the interrupt request.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;software interrupt.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Software Interrupt (Trap): A software interrupt, also known as a trap or exception, is an interrupt generated by software, typically by a program executing an instruction that requires OS intervention. Software interrupts are synchronous events caused by program execution, such as system calls, illegal instructions, or page faults, invoking OS services to handle the event.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between deterministic scheduling and non-feministic scheduling algorithms for processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Deterministic Scheduling Algorithms:&lt;/p&gt;
&lt;p&gt;Deterministic scheduling algorithms make scheduling decisions based on predictable process characteristics, such as known burst times or arrival times. These algorithms aim to optimize performance metrics based on this prior knowledge. Examples include First-Come, First-Served (FCFS) and Shortest Job Next (SJN). Deterministic algorithms are predictable and can provide guarantees on performance metrics under known conditions.&lt;/p&gt;
&lt;p&gt;Non-Deterministic Scheduling Algorithms:&lt;/p&gt;
&lt;p&gt;Non-deterministic scheduling algorithms make scheduling decisions without complete prior knowledge of process characteristics. They adapt to dynamic system conditions and process behaviors. Examples include Priority Scheduling, Round Robin, and Multilevel Queue Scheduling. Non-deterministic algorithms are more flexible and adaptable to real-world scenarios with varying process demands but may offer less predictability compared to deterministic algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;The Manager of ABC Company Ltd. intends to learn about the functions of virtual devices. Explain two functions of the device giving an example.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Device Emulation: Virtual devices emulate the functionality of physical hardware devices in a virtualized environment. They provide a software-based abstraction of hardware, allowing virtual machines or applications to interact with devices without direct physical hardware access. Example: Virtual network interface card (vNIC) emulates a physical NIC, enabling network connectivity for virtual machines.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Resource Sharing and Abstraction: Virtual devices enable sharing and abstraction of physical hardware resources among multiple virtual machines or processes. They decouple hardware from software, allowing efficient resource utilization and device management in virtualized or containerized environments. Example: Virtual disk (vDisk) abstracts physical storage, allowing multiple VMs to share underlying storage resources without direct hardware contention.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 1 represents the structure of a computer disk.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_14-32-30_2021j.pdf.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;494&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Use it to answer the questions that follow. Identify the parts labelled (i), (ii), (iii) and (iv).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;(i) Platter: The circular magnetic disk on which data is stored.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;(ii) Track: A concentric circular path on the platter surface where data is recorded.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;(iii) Cylinder: A set of tracks at the same radial position across all platters.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;(iv) Sector: A segment of a track, representing the smallest unit of data storage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two uses of the R/W head of the computer disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Reading Data: The Read/Write (R/W) head is used to detect and sense magnetic patterns on the disk platter surface, converting them into electrical signals representing digital data. During read operations, the head senses the magnetic flux reversals on the disk, retrieving stored data.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Writing Data: The R/W head is used to magnetize areas on the disk platter surface to store digital data. During write operations, the head generates magnetic fields to alter the magnetic orientation of particles on the disk, encoding data onto the storage medium.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two ways of enforcing mutual exclusion in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Semaphores: Semaphores are synchronization primitives used to control access to shared resources and enforce mutual exclusion. A semaphore is an integer variable with atomic operations (P and V). Processes use P operation to request access and V operation to release access, ensuring only one process can access a critical section at a time. Semaphores can be binary (mutex) or counting.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Mutex Locks (Mutual Exclusion Locks): Mutex locks are binary semaphores that provide mutual exclusion. A mutex lock has two states: locked and unlocked. A process acquires the lock before entering a critical section, making it locked. Only the process holding the lock can unlock it after exiting the critical section. Mutex locks ensure that only one process can execute a critical section at any given time, preventing race conditions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between multiple-partition allocation and single-partition allocation as applied in computer memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Single-Partition Allocation:&lt;/p&gt;
&lt;p&gt;In single-partition allocation, main memory is divided into only two partitions: one for the operating system and one for a single user process. The entire user partition is allocated to a single process at a time. It is simple to implement but inefficient as it supports only one user process at a time and leads to memory wastage if the process is smaller than the partition.&lt;/p&gt;
&lt;p&gt;Multiple-Partition Allocation:&lt;/p&gt;
&lt;p&gt;In multiple-partition allocation, main memory is divided into several partitions, each capable of holding a process. Multiple processes can reside in memory concurrently. Partitions can be fixed-sized (static partitioning) or variable-sized (dynamic partitioning). Multiple partitioning improves memory utilization and allows multiprogramming by accommodating several processes simultaneously.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A student intends to study the functions of the dispatcher in process management. Explain three such functions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Context Switching: The dispatcher is responsible for performing context switching, which involves saving the state of the current process (CPU registers, program counter, etc.) and loading the saved state of a new process to be executed. Context switching enables the CPU to switch between processes, supporting multitasking and time-sharing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Process Selection: The dispatcher selects the next process to be executed by the CPU from the ready queue, based on the scheduling algorithm implemented by the operating system. It determines which process gets CPU time allocation based on factors like priority, waiting time, or burst time, ensuring fair or prioritized process execution.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;CPU Allocation: The dispatcher allocates CPU time to the selected process, giving it control of the processor to execute its instructions. It sets up the execution environment for the process and starts its execution. CPU allocation is a core function of the dispatcher in enabling process execution and concurrency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two types of queues that could be used in process scheduling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Ready Queue: The ready queue holds processes that are in the ready state, waiting to be executed by the CPU. Processes in the ready queue are eligible for CPU allocation and are selected by the scheduler based on scheduling algorithms.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Wait/Blocked Queue: Wait queues or blocked queues hold processes that are blocked or waiting for a specific event to occur, such as I/O completion or resource availability. Processes in wait queues are not eligible for CPU allocation until the event they are waiting for occurs, after which they may move to the ready queue.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two circumstance that would lead to external fragmentation in computer memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Dynamic Partitioning with Variable Size Allocation: External fragmentation is common in dynamic partitioning where memory is allocated in variable-sized blocks. Over time, as processes are allocated and deallocated, memory becomes fragmented into small, non-contiguous holes. Even if total free memory is sufficient, a large process may not be allocated memory if no single contiguous block is large enough.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;First-Fit or Best-Fit Allocation Algorithms: Using allocation algorithms like first-fit or best-fit in dynamic partitioning can exacerbate external fragmentation. First-fit tends to allocate memory from the first available large enough block, potentially leaving larger holes fragmented later. Best-fit, while trying to minimize internal fragmentation, can also contribute to external fragmentation by creating many small, unusable free blocks scattered across memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four factors to consider when choosing computer file organization methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Access Pattern: Consider the primary way files will be accessed: sequential, random, or indexed. Sequential access favors sequential file organization, while random access suits direct or indexed organization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;File Size and Volume: Evaluate the size and number of files. For large files, contiguous or indexed sequential methods might be efficient. For numerous small files, indexed or linked methods may be more appropriate.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Performance Requirements: Analyze performance needs for file operations like read, write, search, and update. High-performance applications may require indexed or direct access for faster retrieval, while batch processing might benefit from sequential organization.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Data Volatility and Update Frequency: Consider how often files are updated or modified. For frequently updated files, indexed or direct access methods may be more efficient for in-place updates. For relatively static files, sequential or indexed sequential organization might suffice.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between static loading and dynamic loading in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Static Loading:&lt;/p&gt;
&lt;p&gt;In static loading, the entire program and all its required libraries are loaded into memory before program execution begins. All necessary code and data are loaded at load time. Static loading results in faster program startup as all components are in memory but increases memory usage during the entire execution, even if some parts of the code are not immediately needed.&lt;/p&gt;
&lt;p&gt;Dynamic Loading:&lt;/p&gt;
&lt;p&gt;In dynamic loading, program modules or libraries are loaded into memory only when they are first needed during runtime. Modules are loaded on demand. Dynamic loading reduces initial memory footprint and startup time as only essential parts are loaded initially. It conserves memory by loading modules only when required but may introduce overhead during runtime when loading modules for the first time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A computer technician intends to list the good qualities of a computer clock to employees in a company. Outline six such qualities.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Accuracy: A good computer clock should provide accurate timekeeping, minimizing deviations from real-time. Accuracy ensures precise time measurements and synchronization, critical for time-sensitive applications and system operations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Reliability: A reliable computer clock should maintain consistent and dependable timekeeping over extended periods. Reliability ensures continuous time availability without interruptions or failures, vital for system stability and uptime.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Stability: A stable computer clock should exhibit minimal drift or fluctuations in its timekeeping rate. Stability ensures consistent time progression and prevents time skew or distortions, important for long-term time accuracy and synchronization.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Resolution: High resolution clocks offer fine-grained time measurements, allowing for precise timing and event ordering. Higher resolution clocks enable capturing short-duration events and accurate time-stamping, beneficial for performance analysis and real-time applications.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;Synchronization Capability: A good computer clock should support synchronization with external time sources, such as NTP servers or GPS, to maintain accurate and consistent time across systems. Synchronization ensures time alignment and coordination in distributed environments and networks.&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;Low Overhead: An efficient computer clock should impose minimal overhead on system resources, consuming minimal CPU cycles and power. Low overhead clocks ensure timekeeping operations do not significantly impact system performance or energy consumption, important for resource-constrained systems and energy efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7 (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Most computer systems provide directories to aid users in different areas. Explain three advantages that users would realize from using these directories.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;File Organization and Management: Directories enable users to organize files hierarchically, grouping related files together. This structured organization simplifies file management, making it easier to locate, access, and maintain files. Directories provide a logical structure for organizing and categorizing files, improving file system usability.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Efficient File Searching and Retrieval: Directories facilitate efficient file searching and retrieval. Users can navigate through directory hierarchies to locate specific files quickly. Directory structures, often implemented as trees or graphs, enable fast path traversal and file lookup, reducing file access time and improving user productivity.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Namespace Management and Conflict Resolution: Directories provide namespaces, allowing users to create files with the same name in different directories without naming conflicts. Directories partition the file system namespace, enabling users to manage and organize files within distinct contexts. Namespace management prevents naming collisions and ensures file uniqueness within directories.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four causes of thrashing in computer memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;Insufficient Physical Memory: Thrashing primarily occurs when the amount of physical RAM is insufficient to accommodate the working sets of active processes. When the total memory required by running processes exceeds available RAM, excessive page swapping occurs, leading to thrashing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;High Degree of Multiprogramming: Increasing the number of processes in memory (degree of multiprogramming) beyond the system's memory capacity can lead to thrashing. With more processes competing for limited memory, working sets overlap, causing increased page faults and swapping.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;Global Page Replacement Algorithms: Using global page replacement algorithms, where a page fault in one process can cause page replacement from another process's frame, can contribute to thrashing. Global replacement may lead to processes continuously faulting on pages needed by other processes, increasing overall page fault rate.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;Small Page Size: Very small page sizes can exacerbate thrashing. Smaller pages increase the number of pages required to hold a process's working set. With more pages, page fault frequency may increase, especially if locality of reference is not strong, leading to higher swapping overhead and thrashing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between synchronous I/O and asynchronous I/O in computer devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Synchronous I/O (Blocking I/O):&lt;/p&gt;
&lt;p&gt;In synchronous I/O, when a process initiates an I/O operation, it blocks or waits until the I/O operation is complete before proceeding with further execution. The process is suspended and remains idle while waiting for I/O completion. Synchronous I/O is simpler to program but can lead to CPU underutilization as processes wait for I/O.&lt;/p&gt;
&lt;p&gt;Asynchronous I/O (Non-blocking I/O):&lt;/p&gt;
&lt;p&gt;In asynchronous I/O, when a process initiates an I/O operation, it does not block. The process can continue with other tasks while the I/O operation is performed in the background. The process is notified upon I/O completion, typically through interrupts or callbacks. Asynchronous I/O allows for concurrent processing and better CPU utilization as processes can perform other tasks while waiting for I/O operations to complete.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A lecturer repaired a faulty computer RAM disk. Explain two types of the disks he could have repaired.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;DRAM-based RAM Disk: A DRAM-based RAM disk is created using dynamic random-access memory (DRAM). It uses system RAM to simulate a disk drive, providing very fast read and write access. DRAM-based RAM disks are volatile, meaning data is lost when power is turned off. They are typically repaired by replacing faulty DRAM modules or addressing memory errors through error correction mechanisms.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;Flash-based RAM Disk (Solid State Drive - SSD): Although technically flash memory, SSDs are sometimes referred to as RAM disks due to their solid-state nature and fast access times compared to traditional HDDs. SSDs use non-volatile flash memory for data storage. Repairing a faulty SSD involves diagnosing and addressing issues with flash memory chips, controllers, or firmware. Repair may include firmware updates, bad block management, or component replacement.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Table 1 shows processes in a queue awaiting execution by the scheduler in a round robin scheduling algorithm.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_15-14-03_2021j.pdf.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;212&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Use the information provided to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;Draw a Gantt chart to represent the data in table 1, given quantum time as 20.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Gantt Chart for Round Robin Scheduling (Quantum = 20):&lt;/p&gt;
&lt;p&gt;| P1(20) | P2(20) | P3(20) | P4(20) | P1(20) | P2(7) | P3(20) | P1(23) | P3(18) |&lt;/p&gt;
&lt;p&gt;0 20 40 60 80 100 107 127 147 165&lt;/p&gt;
&lt;p&gt;Explanation:&lt;/p&gt;
&lt;p&gt;P1 runs for 20ms (0-20ms), remaining burst time = 43ms.&lt;/p&gt;
&lt;p&gt;P2 runs for 20ms (20-40ms), remaining burst time = 7ms.&lt;/p&gt;
&lt;p&gt;P3 runs for 20ms (40-60ms), remaining burst time = 38ms.&lt;/p&gt;
&lt;p&gt;P4 runs for 20ms (60-80ms), remaining burst time = 14ms (Process finishes within quantum in the next round, but for chart consistency we show full quantum).&lt;/p&gt;
&lt;p&gt;P1 runs for 20ms (80-100ms), remaining burst time = 23ms.&lt;/p&gt;
&lt;p&gt;P2 runs for remaining 7ms (100-107ms), P2 finishes.&lt;/p&gt;
&lt;p&gt;P3 runs for 20ms (107-127ms), remaining burst time = 18ms.&lt;/p&gt;
&lt;p&gt;P1 runs for remaining 23ms (127-147ms), P1 finishes.&lt;/p&gt;
&lt;p&gt;P3 runs for remaining 18ms (147-165ms), P3 finishes.&lt;/p&gt;
&lt;p&gt;P4 finishes within its first time quantum.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8 (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Determine the average waiting time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Waiting Time Calculation:&lt;/p&gt;
&lt;p&gt;Completion Times: P1: 147, P2: 107, P3: 165, P4: 80&lt;/p&gt;
&lt;p&gt;Burst Times: P1: 63, P2: 27, P3: 58, P4: 34&lt;/p&gt;
&lt;p&gt;Turnaround Times: P1: 147, P2: 107, P3: 165, P4: 80 (Arrival time is assumed 0 for all processes)&lt;/p&gt;
&lt;p&gt;Waiting Times = Turnaround Time - Burst Time:&lt;/p&gt;
&lt;p&gt;P1 Waiting Time: 147 - 63 = 84&lt;/p&gt;
&lt;p&gt;P2 Waiting Time: 107 - 27 = 80&lt;/p&gt;
&lt;p&gt;P3 Waiting Time: 165 - 58 = 107&lt;/p&gt;
&lt;p&gt;P4 Waiting Time: 80 - 34 = 46&lt;/p&gt;
&lt;p&gt;Average Waiting Time = (84 + 80 + 107 + 46) / 4 = 317 / 4 = 79.25&lt;/p&gt;
&lt;p&gt;Average Waiting Time: 79.25 ms&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2021 The Kenya National Examinations Council&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="248"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="3_130_2.2"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="20">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="17"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_14-32-30_2021j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_14-32-30_2021j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="d0f94fb492fe672cb8bb24a2e880f148"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="18"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="254"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="3_130_2.3"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="21">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="17"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_15-14-03_2021j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_15-14-03_2021j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="4baeecabeac90d45f90d0105add085cf"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="18"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="18"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="4"></int>
              <string role="key" value="parentNode"></string>
              <reference key="19"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="3"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="19"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="20"></reference>
            <reference key="21"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="3"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:%20July%202021"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="24">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2019"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="22">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="23">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="131_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="22"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="anchors_linked_from_fields"></string>
              <dictionary></dictionary>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2019&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three disadvantages of serial file organization.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Slow Access Speed&lt;/strong&gt;: Records must be accessed sequentially, meaning to reach a specific record, you must traverse all preceding records. This makes access times slow, especially for large files.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Inefficient for Frequent Updates&lt;/strong&gt;: Updating or inserting records in the middle of a serial file is inefficient. It often requires rewriting the file, as there is no direct way to access and modify a specific record without affecting subsequent records.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Not Suitable for Interactive Applications&lt;/strong&gt;: Due to the slow access speed, serial file organization is not suitable for applications requiring quick retrieval of specific data, such as interactive systems or databases where users need immediate responses.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term port as used in I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;port&lt;/strong&gt;, in the context of I/O devices, is an interface or a connection point through which a computer can communicate with external devices. It is a physical or logical channel that allows data to flow between the computer and peripherals like printers, keyboards, or network adapters.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Access Control Matrix shows the types of access that each user has in a file system. Outline five types of access used in a file system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Read Access&lt;/strong&gt;: Allows a user to view or copy the contents of a file. This is fundamental for accessing information but does not permit modification.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Write Access&lt;/strong&gt;: Enables a user to modify or delete the contents of a file. This is necessary for creating new files or altering existing ones.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Execute Access&lt;/strong&gt;: Permits a user to run a file, typically applicable to executable programs or scripts. Without this, a user cannot execute the file, even if they can read it.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Append Access&lt;/strong&gt;: Allows a user to add data to the end of a file without modifying existing content. This is useful for logging or data collection where historical data should be preserved.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Delete Access&lt;/strong&gt;: Grants a user the right to remove a file from the file system. This is a powerful permission that permanently removes the file.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two typical characteristics of cache memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed&lt;/strong&gt;: Cache memory is significantly faster than main memory (RAM). This speed advantage allows the CPU to access frequently used data and instructions more quickly, reducing the average memory access time.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Limited Size&lt;/strong&gt;: Cache memory is much smaller in size compared to main memory. This is because cache memory is expensive and designed to hold only the most frequently accessed data to maximize performance benefits.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between interrupt handler and interrupt vector as used in I/O communications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Interrupt Vector&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;interrupt vector&lt;/strong&gt; is a pointer or an address that points to the starting address of the interrupt handler routine in memory. When an interrupt occurs, the operating system uses the interrupt vector to quickly locate and jump to the appropriate interrupt handler.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interrupt Handler&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;interrupt handler&lt;/strong&gt; (also known as an interrupt service routine or ISR) is a software routine that is executed when a specific interrupt occurs. It is responsible for servicing the interrupt, which typically involves identifying the source of the interrupt and taking appropriate actions to handle the event, such as transferring data for I/O completion.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The interrupt vector is essentially the &lt;strong&gt;address&lt;/strong&gt;, whereas the interrupt handler is the &lt;strong&gt;actual routine&lt;/strong&gt; of code that gets executed. The vector directs the system to the handler.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe a page table as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;page table&lt;/strong&gt; is a data structure used by operating systems to implement virtual memory. It maps virtual addresses to physical addresses. Each process has its own page table.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram Description&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Imagine a table with two columns:&lt;/p&gt;
&lt;p&gt;- The left column lists &lt;strong&gt;Virtual Page Numbers (VPNs)&lt;/strong&gt;. These are indices representing pages in the process's virtual address space.&lt;/p&gt;
&lt;p&gt;- The right column lists &lt;strong&gt;Physical Frame Numbers (PFNs)&lt;/strong&gt; or pointers to physical memory frames. If a virtual page is in RAM, the PFN indicates where it is. If it's not in RAM (paged out to disk), the entry might indicate its location on disk or be marked as invalid.&lt;/p&gt;
&lt;p&gt;When the CPU generates a virtual address, the OS uses the VPN part of the address to index into the page table. The entry found in the page table provides the corresponding PFN. This PFN is then combined with the page offset (the lower bits of the virtual address) to form the physical address, which is used to access the actual memory location.&lt;/p&gt;
&lt;p&gt;If the page is not in physical memory (page fault), the page table entry will indicate this, triggering the OS to load the page from disk into RAM and update the page table before retrying the memory access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term compaction as used in memory fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Compaction&lt;/strong&gt;, in the context of memory fragmentation, is a memory management technique used to reduce external fragmentation. It involves rearranging the processes in memory to be contiguous, thus consolidating the free memory space into larger, usable blocks. This effectively eliminates or reduces the scattered small fragments of free memory, making it possible to allocate larger blocks of memory to new processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;List four factors that should be considered when selecting random access memory (RAM) for a computer, other than cost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Memory Capacity (Size)&lt;/strong&gt;: The amount of RAM is crucial. Higher capacity allows for running more applications simultaneously and handling larger datasets. Insufficient RAM can lead to performance degradation due to excessive swapping.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory Speed (Clock Rate)&lt;/strong&gt;: RAM speed, measured in MHz or GHz, affects how quickly data can be transferred to and from the CPU. Faster RAM improves system responsiveness and application performance, especially for memory-intensive tasks.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Memory Latency (Timings)&lt;/strong&gt;: RAM latency refers to the delay in accessing data. Lower latency (CAS latency, etc.) means faster data access. Timings are typically represented as a series of numbers (e.g., CL16, CL18), with lower numbers indicating better performance.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Memory Type and Compatibility (DDR Generation)&lt;/strong&gt;: Ensure the RAM type (e.g., DDR4, DDR5) is compatible with the motherboard. Different DDR generations have different speeds, voltages, and physical interfaces. Using incompatible RAM will prevent the system from booting.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe three states process model in a used in operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;three-state process model&lt;/strong&gt; simplifies the lifecycle of a process in an operating system into three fundamental states: Running, Ready, and Waiting (or Blocked).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram Description&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Imagine a state transition diagram with three states represented as circles:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Running&lt;/strong&gt;: The process is currently being executed by the CPU. Only one process can be in the Running state on a single-core processor at any given time.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Ready&lt;/strong&gt;: The process is ready to execute and is waiting for its turn to be assigned to the CPU. It has all the necessary resources but is simply waiting for the scheduler to select it.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Waiting/Blocked&lt;/strong&gt;: The process is unable to execute because it is waiting for some event to occur, such as I/O completion, resource availability, or a signal. While waiting, the process is not eligible to use the CPU.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transitions&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Running to Ready&lt;/strong&gt;: Occurs when the process's allocated time slice expires (time-out) in time-sharing systems, or when a higher-priority process becomes ready.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Running to Waiting&lt;/strong&gt;: Occurs when the process requests an operation that requires waiting, such as I/O (e.g., reading from a file or network).&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Waiting to Ready&lt;/strong&gt;: Occurs when the event the process was waiting for completes (e.g., I/O operation finishes). The process becomes ready to run again.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Ready to Running&lt;/strong&gt;: Occurs when the process scheduler selects a ready process to be executed by the CPU.&lt;/p&gt;
&lt;p&gt;This model provides a simplified view of process execution and management within an OS.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Joan intends to design a job scheduling algorithm. Explain two objectives that should be achieved by the algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Maximize Throughput&lt;/strong&gt;: A primary objective is to &lt;strong&gt;maximize the number of jobs completed per unit of time&lt;/strong&gt;. High throughput indicates efficient utilization of the system's resources, ensuring that the system is processing as many tasks as possible in a given period. This is crucial for overall system performance and productivity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Minimize Turnaround Time&lt;/strong&gt;: Another key objective is to &lt;strong&gt;minimize the turnaround time for each job&lt;/strong&gt;. Turnaround time is the total time taken from job submission to job completion. Reducing turnaround time improves user satisfaction as jobs are completed faster, leading to a more responsive and efficient system. This is important for both batch processing and interactive systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (ii) (4marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;It is recommended that users change their passwords to guarantee good file management. Outline four circumstances that necessitate this action.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Compromised Password&lt;/strong&gt;: If there is any indication that a password has been compromised (e.g., suspicion of unauthorized access, notification of a data breach), it is crucial to change the password immediately to prevent further unauthorized access and protect files.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Regular Security Practice&lt;/strong&gt;: As a proactive security measure, users should change their passwords periodically (e.g., every 30-90 days). Regular password changes reduce the window of opportunity for attackers if a password has been unknowingly compromised or is vulnerable to cracking over time.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;After Security Incidents&lt;/strong&gt;: Following any security incident, such as a malware infection or phishing attack, changing passwords is a necessary step to secure accounts and prevent potential file system compromise or data loss. This helps to close any security loopholes that might have been exploited.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Change in Role or Responsibility&lt;/strong&gt;: When an employee changes roles within an organization or leaves the organization, changing passwords, especially for shared accounts or accounts with elevated privileges, is important. This ensures that access permissions are aligned with current responsibilities and prevents unauthorized access by former employees or individuals in different roles.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three resources required in process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time&lt;/strong&gt;: Processes require &lt;strong&gt;CPU time&lt;/strong&gt; to execute their instructions. The CPU is the central processing unit that performs computations and executes the program code of a process. The scheduler allocates CPU time to different processes to enable them to run.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory&lt;/strong&gt;: Processes need &lt;strong&gt;memory&lt;/strong&gt; to store their program code, data, and execution context. Memory allocation is essential for a process to load its instructions and data into RAM and to manage its working set during execution. This includes both RAM for active execution and potentially secondary storage for virtual memory.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;I/O Resources&lt;/strong&gt;: Many processes require &lt;strong&gt;Input/Output (I/O) resources&lt;/strong&gt; to interact with the external environment. This can include access to devices like disk drives, network interfaces, printers, and user input devices. Processes need I/O resources to read data, write data, communicate over networks, and interact with users.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Gerald was required to highlight principles of memory management in operating systems in a job interview. Outline four principles that he could have highlighted.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Allocation and Deallocation&lt;/strong&gt;: Memory management must efficiently &lt;strong&gt;allocate memory&lt;/strong&gt; to processes when they start or request more memory and &lt;strong&gt;deallocate memory&lt;/strong&gt; when processes terminate or release memory. This ensures that memory is used effectively and prevents memory leaks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Address Translation&lt;/strong&gt;: Memory management is responsible for &lt;strong&gt;translating logical or virtual addresses&lt;/strong&gt; used by processes into physical addresses in RAM. This translation allows for memory protection, virtual memory implementation, and efficient memory utilization.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Protection&lt;/strong&gt;: Memory management must provide &lt;strong&gt;memory protection&lt;/strong&gt; to prevent processes from interfering with each other's memory space or the operating system's memory. This ensures system stability and security by isolating processes.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Virtual Memory&lt;/strong&gt;: Implementing &lt;strong&gt;virtual memory&lt;/strong&gt; is a key principle. It allows processes to access more memory than physically available by using disk space as an extension of RAM. Virtual memory management includes techniques like paging and swapping to manage the movement of data between RAM and disk, enabling the execution of larger programs and multitasking.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Paul investigated the disadvantages of a contiguous file allocation method. Outline five disadvantages that he could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: A major disadvantage is &lt;strong&gt;external fragmentation&lt;/strong&gt;. As files are allocated and deallocated, gaps of free space may be created between allocated file blocks. Over time, these gaps may become too small to allocate to new files, even if the total free space is sufficient, leading to wasted memory.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Difficulty in File Growth&lt;/strong&gt;: Contiguous allocation makes it &lt;strong&gt;difficult to grow files&lt;/strong&gt;. If a file needs to expand, there might not be enough contiguous free space immediately following the file's current allocation. This can lead to needing to relocate the entire file to a larger contiguous block, which is inefficient.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Wasted Space with Internal Fragmentation&lt;/strong&gt;: Although primarily associated with non-contiguous methods, if files are allocated in fixed-size blocks, and a file does not perfectly fill the last block, &lt;strong&gt;internal fragmentation&lt;/strong&gt; can occur within the last allocated block, wasting some space.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Need for Pre-allocation or Dynamic Contiguous Allocation&lt;/strong&gt;: To mitigate file growth issues, systems might require &lt;strong&gt;pre-allocation&lt;/strong&gt; of a large contiguous space, which can lead to wasted space if the file does not grow as expected. Alternatively, dynamic contiguous allocation attempts can be complex and still prone to fragmentation.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Compaction Overhead&lt;/strong&gt;: To reduce external fragmentation, &lt;strong&gt;compaction&lt;/strong&gt; might be needed, which involves moving files to consolidate free space. Compaction is a time-consuming operation that can disrupt system performance and is often not performed frequently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;File recovery is a critical feature in a file system. Explain two functions of this feature.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Restoration after System Failure&lt;/strong&gt;: File recovery enables the &lt;strong&gt;restoration of data after system crashes, power outages, or hardware failures&lt;/strong&gt;. By maintaining logs or backups, the file system can recover to a consistent state, minimizing data loss and ensuring that files are not corrupted due to unexpected interruptions.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Undo Accidental Deletion or Modification&lt;/strong&gt;: File recovery functions allow users to &lt;strong&gt;undo accidental file deletions or modifications&lt;/strong&gt;. Features like the Recycle Bin or shadow copies provide a way to retrieve files that were mistakenly deleted or to revert files to a previous version, protecting against user errors and data loss.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;The principle goal of a multiprocessor system is to balance the load between processors. Explain two load balancing strategies used by these systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Static Load Balancing&lt;/strong&gt;: In &lt;strong&gt;static load balancing&lt;/strong&gt;, the distribution of tasks among processors is determined at system design time or process creation time and remains fixed throughout the execution. This approach is simpler to implement but is less adaptive to runtime variations in processor load. Tasks might be assigned based on expected workload, but it does not dynamically adjust to changes during operation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Dynamic Load Balancing&lt;/strong&gt;: &lt;strong&gt;Dynamic load balancing&lt;/strong&gt; involves distributing tasks among processors at runtime, adjusting the distribution based on the current load of each processor. This approach is more flexible and can adapt to varying workloads and processor availability. It typically involves monitoring processor loads and migrating tasks from heavily loaded processors to lightly loaded ones to maintain balance and optimize performance. Examples include process migration and distributed scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term virtual address space (VAS)as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual Address Space (VAS)&lt;/strong&gt; is the set of virtual addresses that an operating system makes available to a process. It is the logical view of memory that a process sees, which is typically a contiguous range of addresses, regardless of the actual physical memory organization. The VAS is managed by the OS and is translated to physical addresses when the process accesses memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between static and dynamic linking as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Static Linking&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;static linking&lt;/strong&gt;, all the necessary library routines required by a program are copied and linked directly into the executable file during the compilation and linking process. When the program is executed, all the code, including the library routines, is already present in the program's memory space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Linking&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;dynamic linking&lt;/strong&gt;, the linking of library routines is postponed until runtime. Instead of copying library routines into the executable, only references or links to the shared libraries are included. When the program is executed and needs a library routine, the operating system loads the required shared library into memory if it's not already there and then links the program to the library at runtime.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Differences&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Executable Size&lt;/strong&gt;: Static linking results in larger executables because all library code is included, whereas dynamic linking produces smaller executables as library code is shared and loaded separately.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Memory Usage&lt;/strong&gt;: Dynamic linking can save memory if multiple programs use the same library, as only one copy of the library is loaded in memory and shared. Static linking loads a separate copy of library code for each program.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Updates and Maintenance&lt;/strong&gt;: Dynamic linking simplifies library updates and maintenance. Updating a shared library benefits all programs that use it without needing to recompile them. In static linking, programs must be recompiled to incorporate library updates.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;System timer is important in multiprogramming of systems. Explain two roles of the timer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Time Slicing for CPU Scheduling&lt;/strong&gt;: The system timer is crucial for implementing &lt;strong&gt;time slicing&lt;/strong&gt; in preemptive CPU scheduling algorithms, such as Round Robin. The timer generates periodic interrupts at regular intervals. These interrupts signal the operating system to regain control, allowing the scheduler to switch the CPU from the currently running process to another ready process. This ensures that no single process monopolizes the CPU and provides fairness in resource allocation, enabling effective multiprogramming.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;System Clock and Time Management&lt;/strong&gt;: The system timer is fundamental for maintaining the &lt;strong&gt;system clock&lt;/strong&gt; and managing time-related functions. It keeps track of the current time and date, which is essential for various OS operations, including process scheduling, time-stamping files, logging events, and scheduling tasks for future execution. The timer interrupts increment a counter that represents the system's notion of time, allowing the OS to provide time-based services and functionalities.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Tony was required to configure buffering in an operating system that he was installing to a client. Explain three types of buffering he could use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Single Buffering&lt;/strong&gt;: In &lt;strong&gt;single buffering&lt;/strong&gt;, the operating system uses only one buffer in system memory for data transfer between I/O devices and the process. When data is read, it is placed into the buffer, and the process accesses data from this buffer. While the process is processing data from the buffer, the next data block cannot be read into the same buffer until the process is finished with the current block. This is simple to implement but can limit performance as I/O and processing are not fully concurrent.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Double Buffering&lt;/strong&gt;: &lt;strong&gt;Double buffering&lt;/strong&gt; uses two buffers. While one buffer is being filled with data from an I/O device, the process can simultaneously access data from the other buffer. Once the process is done with the data in the first buffer and the second buffer is full, the roles of the buffers are switched. This allows for more overlap between I/O operations and processing, improving performance compared to single buffering. It reduces the waiting time for both the process and the I/O device.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Circular Buffering (Multiple Buffering)&lt;/strong&gt;: &lt;strong&gt;Circular buffering&lt;/strong&gt;, or multiple buffering, employs more than two buffers arranged in a circular queue. This method further enhances concurrency by allowing a sequence of I/O operations and processing to overlap. As one buffer is being processed, others can be filled or emptied. This is particularly useful for continuous data streams, such as in multimedia applications or network data handling, where a continuous flow of data needs to be processed without interruption. It maximizes throughput by keeping both the processor and I/O devices busy as much as possible.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A lecturer described different categories of system calls in a lesson on operating systems. Outline four categories of system calls that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Control&lt;/strong&gt;: System calls in the &lt;strong&gt;process control&lt;/strong&gt; category are related to process management. These include system calls for creating and terminating processes (e.g., `fork`, `exec`, `exit`, `wait`), managing process attributes (e.g., `getpid`, `setpriority`), and process synchronization and communication (e.g., `signal`, `pipe`, `shmem`). They enable the OS to manage the lifecycle and execution of processes.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File Management&lt;/strong&gt;: &lt;strong&gt;File management&lt;/strong&gt; system calls deal with operations on files and directories. This category includes system calls for creating, deleting, opening, closing, reading, and writing files (e.g., `create`, `unlink`, `open`, `close`, `read`, `write`). They also include calls for managing file attributes (e.g., `chmod`, `chown`) and directory operations (e.g., `mkdir`, `rmdir`, `chdir`). These calls provide the interface for users and applications to interact with the file system.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Device Management&lt;/strong&gt;: &lt;strong&gt;Device management&lt;/strong&gt; system calls are used to interact with hardware devices. These calls allow processes to request and release devices, as well as to read from and write to device registers. Examples include system calls for requesting I/O operations, controlling device parameters, and managing device drivers. They abstract the hardware details and provide a uniform interface for device access.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Information Maintenance&lt;/strong&gt;: System calls for &lt;strong&gt;information maintenance&lt;/strong&gt; provide mechanisms to get system data and set system attributes. This category includes system calls to get the current time and date, get system configuration information (e.g., memory usage, CPU utilization), and set system parameters. They provide applications with access to system-level information and control over certain aspects of the system's behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two benefits of a microkernel operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Reliability and Stability&lt;/strong&gt;: By keeping only essential services in the kernel and running other services in user space as &lt;strong&gt;modules&lt;/strong&gt; or servers, a microkernel architecture enhances system reliability. If a service in user space fails, it is less likely to crash the entire system because the kernel remains protected. This modular design improves fault isolation and system stability.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Improved Security&lt;/strong&gt;: The reduced size of the kernel and the separation of services into user space contribute to &lt;strong&gt;improved security&lt;/strong&gt;. A smaller kernel means a smaller attack surface, reducing the potential vulnerabilities within the core OS. Additionally, running services in user space allows for better control over permissions and access, limiting the damage from security breaches in non-kernel components.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between blocking and non blocking O.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Blocking I/O&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;blocking I/O&lt;/strong&gt;, when a process initiates an I/O operation, the process is &lt;strong&gt;blocked&lt;/strong&gt; (suspended or put to sleep) until the I/O operation is complete. During this blocking time, the process cannot perform any other tasks and waits idly for the I/O operation to finish and for the data to become available. Once the I/O operation is completed, the process is resumed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-blocking I/O&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;non-blocking I/O&lt;/strong&gt;, when a process initiates an I/O operation, the operation is started, but the process is &lt;strong&gt;not blocked&lt;/strong&gt;. Instead, the system call returns immediately, indicating whether the I/O operation could be started or not. The process can continue to execute other tasks while the I/O operation proceeds in the background. The process typically needs to periodically check the status of the I/O operation to determine when it is complete and the data is ready.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Differences&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Process Waiting&lt;/strong&gt;: Blocking I/O causes the process to wait (block) until the I/O is complete, while non-blocking I/O allows the process to continue execution without waiting.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;CPU Utilization&lt;/strong&gt;: Non-blocking I/O can lead to better CPU utilization as the process can perform other tasks while I/O is in progress. Blocking I/O may result in CPU idle time while processes are waiting for I/O.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Complexity&lt;/strong&gt;: Non-blocking I/O is generally more complex to implement and manage as it requires the process to handle I/O completion events and manage the state of ongoing I/O operations. Blocking I/O is simpler from the process's perspective.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term segment table as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;segment table&lt;/strong&gt; is a data structure used in memory management, specifically in segmentation. It is a table that maps logical addresses to physical addresses in memory. Each entry in the segment table corresponds to a segment of memory and contains information about that segment, such as its base address in physical memory and its limit (size). It is used by the operating system to manage segmented memory and perform address translation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain three limitations of a best-fit memory placement algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: Although best-fit attempts to minimize wasted space in each allocation, it can still lead to &lt;strong&gt;external fragmentation&lt;/strong&gt; over time. By allocating the smallest available block that fits the process, it tends to leave behind many small, unusable fragments of free memory between allocated blocks. This can make it difficult to allocate larger processes later, even if the total free memory is sufficient but scattered in small chunks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Overhead in Searching for Best Fit&lt;/strong&gt;: The best-fit algorithm requires &lt;strong&gt;searching through the entire list of free memory blocks&lt;/strong&gt; to find the smallest block that is large enough to satisfy the request. This search process can be time-consuming, especially when the list of free blocks is long. This overhead can degrade system performance, particularly with frequent memory allocations and deallocations.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Potential for Small Fragment Generation&lt;/strong&gt;: While aiming to minimize waste, best-fit can ironically lead to the creation of numerous &lt;strong&gt;very small free fragments&lt;/strong&gt;. By always choosing the smallest suitable block, it often leaves behind tiny pieces of free memory that are too small to be useful for future allocations. These tiny fragments accumulate over time and contribute to external fragmentation, sometimes even more so than first-fit in certain scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Patricia was required to describe advantages of distributed operating systems to a client. Describe three advantages that she could have mentioned to the client.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Sharing&lt;/strong&gt;: A significant advantage of distributed operating systems is &lt;strong&gt;resource sharing&lt;/strong&gt;. They allow users to share hardware resources (like printers, storage devices), software resources (like databases, applications), and data across a network of computers. This sharing reduces redundancy, lowers costs by avoiding duplication of resources, and enables collaborative work by providing access to shared resources from different locations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Improved Reliability and Fault Tolerance&lt;/strong&gt;: Distributed systems offer &lt;strong&gt;improved reliability and fault tolerance&lt;/strong&gt;. If one machine in the system fails, the overall system can continue to function, albeit possibly at a reduced capacity, because tasks can be redistributed to other machines. This redundancy and ability to withstand failures of individual components make distributed systems more robust and reliable than single-machine systems. The system can be designed to automatically recover from failures and maintain service availability.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Enhanced Performance and Scalability&lt;/strong&gt;: Distributed operating systems can provide &lt;strong&gt;enhanced performance and scalability&lt;/strong&gt;. By distributing workload across multiple computers, they can achieve higher processing power and handle larger volumes of tasks than a single machine. Scalability is a key benefit; the system can be scaled by adding more machines to the network to handle increased load or to expand capabilities. This parallel processing and distributed architecture can lead to significant performance gains for computationally intensive or large-scale applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 1 shows a cross section of a hard disk. Explain the function of the parts labeled (i) and (ii).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-11_at_15-36-11_2019july.pdf.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;362&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on Figure 1:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Cylinder&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;cylinder&lt;/strong&gt; refers to a set of tracks of the same radius on all platter surfaces that are vertically aligned in a hard disk drive. All tracks at the same radial position constitute a cylinder. The function of a cylinder is to provide a way to access data across multiple platters without moving the read/write heads radially. This improves data access performance by reducing seek time when accessing logically contiguous data that spans across multiple platters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Sector&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;sector&lt;/strong&gt; is the smallest physical storage unit on a hard disk drive, typically 512 bytes or 4096 bytes (4KB) in size. Sectors are segments of tracks on the platter. The function of a sector is to store data. When the operating system reads or writes data to the hard drive, it does so in units of sectors. Sectors are the fundamental blocks of data organization and access on the disk.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain two circumstances under which pre-emptive job scheduling algorithms would be used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Time-Sharing Systems&lt;/strong&gt;: &lt;strong&gt;Pre-emptive scheduling&lt;/strong&gt; is essential in time-sharing operating systems. In these systems, multiple users interact with the computer concurrently, and each user expects timely responses. Pre-emption allows the OS to interrupt a running process after a certain time quantum and switch to another ready process. This time-slicing ensures fairness and prevents a single process from monopolizing the CPU, providing the illusion of simultaneous execution and responsiveness to all users.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Priority-Based Systems&lt;/strong&gt;: When implementing &lt;strong&gt;priority-based scheduling&lt;/strong&gt;, pre-emption is crucial to ensure that higher-priority processes get preferential treatment. If a higher-priority process becomes ready to run while a lower-priority process is executing, pre-emptive scheduling allows the OS to immediately interrupt the lower-priority process and allocate the CPU to the higher-priority process. This ensures that critical or time-sensitive tasks are executed promptly, regardless of what other processes are currently running.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;I/O disk read operation involves several interrupts. Explain two typical interrupts that are likely to be used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;I/O Request Interrupt (Initiation)&lt;/strong&gt;: When a process requests to read data from a disk, the operating system typically initiates the disk read operation. An &lt;strong&gt;I/O request interrupt&lt;/strong&gt; might be generated to signal to the disk controller to start the read operation. This interrupt is essentially the initial signal sent from the OS to the hardware to begin the data retrieval process. It sets in motion the disk seeking and data transfer operations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;I/O Completion Interrupt (Data Ready)&lt;/strong&gt;: Once the disk read operation is completed, and the requested data is ready to be transferred to main memory, the disk controller sends an &lt;strong&gt;I/O completion interrupt&lt;/strong&gt; to the CPU. This interrupt signals to the OS that the data transfer is finished and the data is available. Upon receiving this interrupt, the OS can then handle the data, typically by transferring it from the disk controller's buffer to the process's memory space and resuming the process that initiated the read request.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe two categories of I/O devices giving two examples in each case.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Block Devices&lt;/strong&gt;: &lt;strong&gt;Block devices&lt;/strong&gt; transfer data in blocks of fixed sizes. Data is accessed in chunks, and each block has a unique address. They support random access, meaning data blocks can be accessed in any order. Examples of block devices include:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Hard Disk Drives (HDDs)&lt;/strong&gt;: Store data magnetically on platters and access it in blocks.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Solid State Drives (SSDs)&lt;/strong&gt;: Store data electronically in flash memory and also operate on blocks, offering faster access times.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Character Devices&lt;/strong&gt;: &lt;strong&gt;Character devices&lt;/strong&gt; transfer data character by character, as a stream of bytes. They typically do not support random access and are accessed sequentially. Examples of character devices include:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Keyboard&lt;/strong&gt;: Inputs characters one by one as keys are pressed.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Serial Ports (e.g., for serial communication)&lt;/strong&gt;: Transmit and receive data as a stream of characters, bit by bit.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;File sharing technologies have promoted the concept of global village. Explain two file sharing technologies that are used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Cloud Storage Services&lt;/strong&gt;: &lt;strong&gt;Cloud storage services&lt;/strong&gt; like Google Drive, Dropbox, and OneDrive allow users to store files on remote servers and share them with others over the internet. These services enable easy access to files from anywhere in the world with an internet connection, facilitating collaboration and information exchange across geographical boundaries. Users can share files with specific individuals or make them publicly accessible, promoting global information sharing and contributing to the concept of a global village.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Peer-to-Peer (P2P) File Sharing&lt;/strong&gt;: &lt;strong&gt;Peer-to-peer (P2P) file sharing technologies&lt;/strong&gt;, such as BitTorrent, enable direct file sharing between users' computers without relying on a central server. P2P networks allow users to share files with a large number of people globally. While often associated with copyright infringement, P2P technology fundamentally facilitates decentralized file distribution and sharing on a global scale, connecting individuals directly and enabling the rapid dissemination of information and resources across the globe, thereby fostering the global village idea.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems: (i) shell;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Shell&lt;/strong&gt;: In operating systems, a &lt;strong&gt;shell&lt;/strong&gt; is a command-line interpreter or user interface that allows users to interact with the operating system kernel. It takes commands from the user (typically text-based) and interprets them, instructing the OS kernel to perform specific actions, such as executing programs, managing files, and configuring system settings. The shell acts as an intermediary between the user and the OS, enabling command-based interaction.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems: (ii) thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Thread&lt;/strong&gt;: A &lt;strong&gt;thread&lt;/strong&gt;, in the context of operating systems, is a lightweight unit of execution within a process. It's a single sequential flow of control within a program. Multiple threads can exist within one process and share the same memory space, code segment, and data segment. Threads enable concurrency within a process, allowing different parts of a program to execute in parallel or appear to execute in parallel, improving performance and responsiveness, especially in multi-core systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (2 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Doreen discovered that some of her files in her computer were encrypted and her computer prompted her to pay a certain fee through Internet in order to decrypt her files. (i) Identify the most appropriate type of attack justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The most appropriate type of attack is &lt;strong&gt;Ransomware&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Doreen discovered that some of her files in her computer were encrypted and her computer prompted her to pay a certain fee through Internet in order to decrypt her files. (ii) Outline four possible causes for the attack identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Clicking on Malicious Links or Attachments&lt;/strong&gt;: Ransomware can be distributed through &lt;strong&gt;phishing emails&lt;/strong&gt; containing malicious links or attachments. If Doreen clicked on a deceptive link or opened an infected attachment, it could have initiated the ransomware download and execution.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Visiting Compromised Websites&lt;/strong&gt;: &lt;strong&gt;Malvertising&lt;/strong&gt; or compromised websites can host ransomware. If Doreen visited a website that was infected or serving malicious ads, her computer could have been infected with ransomware through a drive-by download, without requiring her to click on anything explicitly.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Software Vulnerabilities&lt;/strong&gt;: &lt;strong&gt;Unpatched software vulnerabilities&lt;/strong&gt; in the operating system or applications can be exploited by ransomware. If Doreen's system had outdated or vulnerable software, attackers could have used exploit kits to install ransomware onto her computer.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Drive-by Downloads from Infected Networks&lt;/strong&gt;: In some cases, ransomware can spread through &lt;strong&gt;infected networks&lt;/strong&gt;. If Doreen's computer was connected to a network that was already compromised, the ransomware could have spread to her system through network shares or vulnerabilities in network protocols, leading to infection without direct user action.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term spatial locality as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Spatial Locality&lt;/strong&gt;, in memory management, refers to the tendency of a processor to access memory locations that are physically close to each other in memory. If a program accesses a particular memory location, it is likely to access nearby memory locations in the near future. This principle is exploited by cache memory systems to improve performance by pre-fetching blocks of memory around recently accessed locations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between long-term scheduler and short-term scheduler.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Long-Term Scheduler (Job Scheduler)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;long-term scheduler&lt;/strong&gt;, also known as the job scheduler, controls the degree of multiprogramming by selecting processes from a job pool (often from disk) and loading them into memory for execution. It decides which processes are admitted to the ready queue. The long-term scheduler is invoked infrequently, typically when a process finishes execution, and aims to balance the mix of processes in memory (e.g., CPU-bound vs. I/O-bound).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Short-Term Scheduler (CPU Scheduler)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;short-term scheduler&lt;/strong&gt;, or CPU scheduler, selects from the ready queue the process that should be executed next by the CPU and allocates the CPU to it. It is invoked very frequently (milliseconds) whenever an event occurs that may lead to process switching (e.g., time slice expiration, I/O completion). The short-term scheduler focuses on maximizing CPU utilization and meeting process deadlines.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Differences&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;Long-Term Scheduler&lt;/th&gt;
&lt;th&gt;Short-Term Scheduler&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Frequency of Invocation&lt;/td&gt;
&lt;td data-label=&quot;Long-Term Scheduler&quot;&gt;Less frequent (infrequent)&lt;/td&gt;
&lt;td data-label=&quot;Short-Term Scheduler&quot;&gt;Very frequent (milliseconds)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Primary Goal&lt;/td&gt;
&lt;td data-label=&quot;Long-Term Scheduler&quot;&gt;Control degree of multiprogramming, balance process mix&lt;/td&gt;
&lt;td data-label=&quot;Short-Term Scheduler&quot;&gt;Maximize CPU utilization, select process for CPU execution&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Decision&lt;/td&gt;
&lt;td data-label=&quot;Long-Term Scheduler&quot;&gt;Which processes to admit to ready queue from job pool&lt;/td&gt;
&lt;td data-label=&quot;Short-Term Scheduler&quot;&gt;Which ready process gets the CPU next&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Memory fragmentation is not popular with the modern operating systems. Explain two limitations that could be aiding this trend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Inefficient Memory Utilization&lt;/strong&gt;: Memory fragmentation, both internal and external, leads to &lt;strong&gt;inefficient use of available memory&lt;/strong&gt;. External fragmentation results in scattered small blocks of free memory that are too small to satisfy larger allocation requests, even if the total free memory is substantial. Internal fragmentation wastes memory within allocated blocks when the allocated block size is larger than the requested memory. This inefficient utilization reduces the effective capacity of RAM, limiting the number of processes that can run concurrently and degrading overall system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Performance Degradation&lt;/strong&gt;: Fragmentation can cause &lt;strong&gt;performance degradation&lt;/strong&gt;. In cases of external fragmentation, the operating system may need to perform compaction (memory defragmentation) to consolidate free memory, which is a time-consuming operation that can pause system operations. Furthermore, when memory is highly fragmented, the system may be forced to resort to swapping or paging more frequently to accommodate new processes or data, increasing disk I/O and slowing down system responsiveness. The overhead of managing fragmented memory and the performance penalties associated with it make it undesirable in modern operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two functions of device drivers in I/O communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Abstraction of Hardware Differences&lt;/strong&gt;: Device drivers &lt;strong&gt;abstract the hardware-specific details&lt;/strong&gt; of I/O devices from the operating system and applications. They provide a uniform interface for the OS to interact with diverse hardware, hiding the complexities and variations in device controllers, communication protocols, and device-specific commands. This abstraction allows the OS and applications to work with devices in a generic way, regardless of the underlying hardware implementation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Handling I/O Operations and Interrupts&lt;/strong&gt;: Device drivers are responsible for &lt;strong&gt;handling I/O operations and interrupts&lt;/strong&gt; for their respective devices. They manage the communication between the OS and the hardware device, including sending commands to the device, transferring data, and managing data buffers. Drivers also handle interrupts generated by devices, responding to device events such as data arrival, device status changes, and error conditions. They ensure that I/O operations are executed correctly and efficiently, and that device events are properly processed by the OS.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four conditions necessary for deadlock in computing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: &lt;strong&gt;Mutual exclusion&lt;/strong&gt; is a condition where at least one resource must be held in a non-sharable mode. Only one process can use the resource at any given time. If another process requests that resource, it must wait until the resource is released. This condition is essential for deadlock as it prevents simultaneous access to critical resources.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt;: The &lt;strong&gt;hold and wait&lt;/strong&gt; condition occurs when a process is holding at least one resource and is waiting to acquire additional resources held by other processes. The process continues to hold its already allocated resources while requesting new ones, which can lead to a deadlock situation.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;No Preemption&lt;/strong&gt;: &lt;strong&gt;No preemption&lt;/strong&gt; means that resources cannot be forcibly taken away from a process holding them. Resources can only be released voluntarily by the process that is holding them, after that process has completed its task. If preemption were possible, the OS could take resources away from a process, breaking the deadlock cycle.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Circular Wait&lt;/strong&gt;: &lt;strong&gt;Circular wait&lt;/strong&gt; is a condition where there exists a set of waiting processes {P0, P1, ..., Pn} such that P0 is waiting for a resource held by P1, P1 is waiting for a resource held by P2, ..., and Pn is waiting for a resource held by P0. This creates a circular dependency, where each process in the cycle is waiting for a resource held by the next process in the cycle, and none can proceed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between high level and low level formatting as used in storage disks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Low-Level Formatting (Physical Formatting)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Low-level formatting&lt;/strong&gt;, also known as physical formatting, is the initial process that prepares a hard disk or other storage medium for data storage. It creates the physical structure of the disk, including tracks and sectors. It defines the basic layout of the storage medium at the hardware level. This process is usually performed at the factory and is rarely done by end-users.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;High-Level Formatting (Logical Formatting)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;High-level formatting&lt;/strong&gt; is performed after low-level formatting. It sets up the file system structure on the disk partition. This includes creating the file allocation table or other file system metadata, the root directory, and making the partition ready for storing files and directories. High-level formatting is typically performed by the operating system when partitioning or preparing a drive for use.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Differences&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;Low-Level Formatting&lt;/th&gt;
&lt;th&gt;High-Level Formatting&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Level of Operation&lt;/td&gt;
&lt;td data-label=&quot;Low-Level Formatting&quot;&gt;Physical/Hardware level&lt;/td&gt;
&lt;td data-label=&quot;High-Level Formatting&quot;&gt;Logical/Software level&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Purpose&lt;/td&gt;
&lt;td data-label=&quot;Low-Level Formatting&quot;&gt;Create tracks and sectors, physical structure&lt;/td&gt;
&lt;td data-label=&quot;High-Level Formatting&quot;&gt;Create file system, logical structure&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Frequency&lt;/td&gt;
&lt;td data-label=&quot;Low-Level Formatting&quot;&gt;Rarely done outside factory, done once&lt;/td&gt;
&lt;td data-label=&quot;High-Level Formatting&quot;&gt;Done when partitioning or installing OS, can be repeated&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Data Recovery after Formatting&lt;/td&gt;
&lt;td data-label=&quot;Low-Level Formatting&quot;&gt;Very difficult to recover data&lt;/td&gt;
&lt;td data-label=&quot;High-Level Formatting&quot;&gt;Data recovery may be possible&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;For each of the following scenario, identify the appropriate type of computer memory: (i) highly volatile;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;RAM (Random Access Memory)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;For each of the following scenario, identify the appropriate type of computer memory: (ii) stores firmware;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;ROM (Read-Only Memory) or Flash Memory (EEPROM)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;For each of the following scenario, identify the appropriate type of computer memory: (iii) parts of hard disk addressed as computer memory;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual Memory (Swap Space/Page File)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;For each of the following scenario, identify the appropriate type of computer memory: (iv) very short access time and suitable for storage of frequently used instructions by CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cache Memory&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Creation of processes is a fundamental role of operating systems. Explain three ways of creating the processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;System Initialization (Booting)&lt;/strong&gt;: Some processes are created during &lt;strong&gt;system initialization&lt;/strong&gt; or booting. When the operating system starts up, it automatically creates several essential system processes. These processes are crucial for OS functionality, such as process management, memory management, device management, and user interface services. Examples include init or systemd processes on Linux, which are the first processes started by the kernel and responsible for launching other system services.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Creation System Calls (e.g., fork)&lt;/strong&gt;: Processes can be created programmatically using &lt;strong&gt;system calls&lt;/strong&gt; like `fork` (in Unix-like systems) or `CreateProcess` (in Windows). When a running process executes a fork system call, the OS creates a nearly identical copy of the process (child process). The child process inherits many attributes from the parent process but gets a new process ID and its own memory space. System calls provide a direct way for existing processes to initiate the creation of new processes, often to perform concurrent tasks or execute new programs.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;User Requests (Command Line or GUI)&lt;/strong&gt;: Processes are frequently created in response to &lt;strong&gt;user requests&lt;/strong&gt;. When a user types a command in a shell or clicks an application icon in a graphical user interface (GUI), the OS interprets this action as a request to start a new program. The OS then creates a new process to execute the requested program. This is the most common way users interact with the OS to launch applications and perform tasks. The shell or GUI acts as an interface to translate user actions into process creation requests to the OS.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2019 The Kenya National Examinations Council.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="255"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="4_131_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="25">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="22"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-11_at_15-36-11_2019july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmp8ulLq_/Screenshot_2025-03-11_at_15-36-11_2019july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="da0bf12bec7289f5442532a1c0d569e5"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="23"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="23"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="2"></int>
              <string role="key" value="parentNode"></string>
              <reference key="24"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="4"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="24"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="25"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="4"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202019"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="28">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2018"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="26">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="27">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="127_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="26"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2018&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain one function of a memory-management unit (MMU)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;One function of a &lt;strong&gt;memory-management unit (MMU)&lt;/strong&gt; is &lt;strong&gt;address translation&lt;/strong&gt;. The MMU translates logical or virtual addresses used by the CPU into physical addresses in main memory, enabling memory protection and virtual memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between logical and physical memory addresses.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Logical Memory Address (Virtual Address):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; A &lt;strong&gt;logical address&lt;/strong&gt; is generated by the CPU during program execution. It is a virtual address that does not directly correspond to a physical location in memory. It is part of the virtual address space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Program View:&lt;/strong&gt; Logical addresses are viewed by the program; processes operate in logical address space.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Abstraction:&lt;/strong&gt; They provide an abstraction of the actual physical memory, allowing for memory protection and management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical Memory Address:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Definition:&lt;/strong&gt; A &lt;strong&gt;physical address&lt;/strong&gt; is the actual location in the main memory (RAM). It is the address used by the memory controller to access physical memory locations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hardware View:&lt;/strong&gt; Physical addresses are seen by the memory hardware; the memory controller works with physical addresses.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Real Location:&lt;/strong&gt; They directly represent a physical storage location in RAM.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; The main difference is that &lt;strong&gt;logical addresses are virtual and process-specific&lt;/strong&gt;, while &lt;strong&gt;physical addresses are real and hardware-specific&lt;/strong&gt;. The &lt;strong&gt;MMU translates logical addresses to physical addresses&lt;/strong&gt; during memory access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A typical operating system is bound to be upgraded over time for a number of reasons. Outline four reasons that could influence the upgrade.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Security Enhancements:&lt;/strong&gt; Upgrades are often necessary to patch &lt;strong&gt;security vulnerabilities&lt;/strong&gt; discovered in the operating system. These patches protect the system from malware, viruses, and unauthorized access, ensuring system integrity and user data safety.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Performance Improvements:&lt;/strong&gt; Upgrades can include optimizations that enhance the &lt;strong&gt;performance and efficiency&lt;/strong&gt; of the operating system. This can involve improving resource management, reducing overhead, and speeding up system processes, leading to a better user experience.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;New Hardware Support:&lt;/strong&gt; As new hardware technologies emerge (e.g., faster processors, new peripherals), operating system upgrades are required to provide &lt;strong&gt;compatibility and support&lt;/strong&gt; for these devices. This ensures that users can utilize the latest hardware with their existing systems.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Feature Additions and Improvements:&lt;/strong&gt; Upgrades often introduce &lt;strong&gt;new features and functionalities&lt;/strong&gt;, or improve existing ones, to meet evolving user needs and industry trends. These updates can enhance usability, provide new tools, and keep the operating system competitive and relevant.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Judy was required to design a job scheduling algorithm for a proposed operating system. Explain three features she should consider in the design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Fairness:&lt;/strong&gt; The scheduling algorithm should aim to provide &lt;strong&gt;fair allocation of CPU time&lt;/strong&gt; to all processes. This means that no single process should be perpetually starved of CPU resources while others dominate. Fairness ensures that all processes get a reasonable share of processing time, preventing undue delays and improving overall system responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Throughput:&lt;/strong&gt; &lt;strong&gt;Throughput&lt;/strong&gt; is a measure of the number of processes completed per unit of time. Judy should consider designing an algorithm that maximizes throughput. A high throughput indicates that the system is efficiently processing jobs, making effective use of the CPU and system resources, which is crucial for productivity.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Turnaround Time:&lt;/strong&gt; &lt;strong&gt;Turnaround time&lt;/strong&gt; is the total time taken from the submission of a process to its completion. The algorithm should aim to minimize the average turnaround time for processes. A lower turnaround time means that jobs are completed quicker, enhancing user satisfaction and system efficiency. This involves minimizing waiting time and execution time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Operating systems should make several types of scheduling decisions with respect to process execution, Describe two of these processor scheduling decisions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Admission Scheduling:&lt;/strong&gt; This decision involves determining &lt;strong&gt;which processes are allowed to enter the ready queue&lt;/strong&gt; and compete for CPU time. The operating system must decide whether to admit a new process into the system, based on factors such as system load, resource availability, and process priority. Admission control helps to prevent system overload and maintain performance by limiting the number of processes competing for resources at any given time.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Selection for Execution (CPU Scheduling):&lt;/strong&gt; Once processes are in the ready queue, the operating system must decide &lt;strong&gt;which process to execute next&lt;/strong&gt;. This decision is made by the CPU scheduler, using algorithms like FIFO, SJF, Priority Scheduling, Round Robin, etc. The choice of algorithm and the decision criteria (e.g., priority, remaining time, arrival time) directly impact system performance metrics such as response time, throughput, and fairness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three process states as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Running:&lt;/strong&gt; The process is currently being &lt;strong&gt;executed by the CPU&lt;/strong&gt;. Instructions of the process are being processed.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Ready:&lt;/strong&gt; The process is &lt;strong&gt;waiting to be assigned to the CPU&lt;/strong&gt;. It is ready to run but is waiting for the scheduler to select it.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Blocked/Waiting:&lt;/strong&gt; The process is &lt;strong&gt;waiting for some event to occur&lt;/strong&gt;, such as I/O completion or resource availability. It cannot proceed until the event happens.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Modern operating system uses dynamic link memory technology. Explain two advantages of this technology.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Memory Footprint:&lt;/strong&gt; Dynamic linking allows multiple programs to &lt;strong&gt;share a single copy of a library&lt;/strong&gt; in memory. Instead of each program loading its own copy of common libraries, they all link to a shared library at runtime. This significantly reduces memory usage, especially when many programs are using the same libraries, leading to more efficient memory utilization and allowing more programs to run concurrently.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Easier Updates and Maintenance:&lt;/strong&gt; When a library is dynamically linked, updates or bug fixes to that library only need to be applied once to the shared library file. All programs that use this library will automatically benefit from the update the next time they are run, without needing to be recompiled or relinked. This simplifies software maintenance and deployment, ensuring consistency and reducing the effort required for software updates across the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Peter was required to design a file system for a client. Outline five factors that he should consider in the design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Organization and Structure:&lt;/strong&gt; Peter needs to decide how files and directories will be &lt;strong&gt;organized and structured&lt;/strong&gt; within the file system. This includes choosing a directory structure (e.g., hierarchical, flat), metadata management, and file naming conventions. Efficient organization is crucial for easy file access and management.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Storage Efficiency:&lt;/strong&gt; &lt;strong&gt;Efficient use of storage space&lt;/strong&gt; is vital. Peter should consider techniques like block size optimization, compression, and sparse file support to minimize wasted space and maximize the amount of data that can be stored. Efficient storage directly impacts cost and capacity.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Reliability and Fault Tolerance:&lt;/strong&gt; The file system must be &lt;strong&gt;reliable and resilient to failures&lt;/strong&gt;. Peter should consider implementing features like data redundancy (e.g., RAID), journaling, and checksums to protect against data loss due to hardware failures or system crashes. Data integrity and availability are paramount.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Security:&lt;/strong&gt; &lt;strong&gt;Security&lt;/strong&gt; is a critical factor. Peter must consider access control mechanisms (e.g., permissions, ACLs), encryption options, and security policies to protect data from unauthorized access, modification, or deletion. Security measures safeguard sensitive information.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Performance:&lt;/strong&gt; &lt;strong&gt;Performance&lt;/strong&gt; in terms of file access speed (read and write operations) is important for user experience. Peter should consider techniques like caching, disk scheduling algorithms, and file system layout optimization to enhance performance. Fast file access improves application responsiveness and overall system efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Passwords are normally used to enhance security of a file system. Outline four guidelines that should be observed when using passwords.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Use Strong and Complex Passwords:&lt;/strong&gt; Passwords should be &lt;strong&gt;long and complex&lt;/strong&gt;, incorporating a mix of uppercase and lowercase letters, numbers, and special characters. Complexity makes it harder for attackers to guess or crack passwords using brute-force methods. Avoid using easily guessable information like names or dates.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Keep Passwords Confidential:&lt;/strong&gt; Passwords should be treated as &lt;strong&gt;highly confidential&lt;/strong&gt; and never shared with anyone. Avoid writing down passwords in insecure places or disclosing them in emails or messages. Password secrecy is crucial to prevent unauthorized access.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Change Passwords Regularly:&lt;/strong&gt; Passwords should be &lt;strong&gt;changed periodically&lt;/strong&gt; (e.g., every few months) to minimize the risk of compromised accounts. Regular password changes limit the window of opportunity for attackers if a password is ever compromised. Consider using password rotation policies.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Avoid Reusing Passwords:&lt;/strong&gt; &lt;strong&gt;Do not reuse the same password&lt;/strong&gt; across multiple accounts or systems. If one password is compromised, using unique passwords for each account prevents attackers from gaining access to other systems. Password diversification is a key security practice.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Preemptive process scheduling policies incur greater overheads than non-preemptive policies. Explain two strategies that could be used to mitigate these overheads.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduce Context Switching Frequency:&lt;/strong&gt; While preemption requires context switching, &lt;strong&gt;optimizing the frequency of context switches&lt;/strong&gt; can help reduce overhead. This can be achieved by adjusting the time quantum in algorithms like Round Robin. A larger time quantum reduces the number of preemptions and context switches, but it might impact responsiveness for short processes. Balancing the time quantum is key to minimizing overhead without sacrificing fairness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficient Context Switching Implementation:&lt;/strong&gt; &lt;strong&gt;Optimizing the context switching mechanism itself&lt;/strong&gt; is crucial. This involves minimizing the time it takes to save and restore the context of a process. Techniques include streamlining the process state saving and restoring routines, using faster memory for storing process context, and reducing the amount of data that needs to be saved and restored during a context switch. Efficient context switching reduces the time spent on scheduling overhead, improving overall system performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems: kernel;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Kernel:&lt;/strong&gt; The &lt;strong&gt;kernel&lt;/strong&gt; is the core component of an operating system. It is the &lt;strong&gt;lowest level of software&lt;/strong&gt; that has complete control over the hardware. It manages system resources, including the CPU, memory, and I/O devices, and provides essential services to other parts of the OS and applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems: interrupt.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Interrupt:&lt;/strong&gt; An &lt;strong&gt;interrupt&lt;/strong&gt; is a signal to the processor that requires immediate attention and temporarily suspends the current execution. It can be triggered by hardware (e.g., I/O device completion) or software (e.g., system call). Interrupts are essential for &lt;strong&gt;handling asynchronous events&lt;/strong&gt; and enabling efficient system operation by allowing the OS to respond to events in real-time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Purity was required to design an operating system that would provide necessary operating system's services but only mechanisms needed to implement such services. Identify the most appropriate category of operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The most appropriate category of operating system for Purity's requirements is a &lt;strong&gt;Microkernel Operating System&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four benefits that could realize when using the operating system identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Reliability:&lt;/strong&gt; In a microkernel architecture, most OS services run as user-level processes, separate from the kernel. If a service fails, it is &lt;strong&gt;isolated and less likely to crash the entire system&lt;/strong&gt;. Only the microkernel, which is kept small and simple, runs in kernel mode, reducing the attack surface and improving overall system stability.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Security:&lt;/strong&gt; The &lt;strong&gt;small kernel size&lt;/strong&gt; and separation of services into user space enhance security. Fewer functions in kernel mode mean fewer potential vulnerabilities in the most critical part of the system. Service isolation also limits the impact of security breaches in one service on other parts of the OS.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Flexibility and Extensibility:&lt;/strong&gt; Microkernels are designed to be &lt;strong&gt;flexible and extensible&lt;/strong&gt;. New services can be added and existing ones modified or replaced without requiring changes to the kernel itself. This modularity simplifies development, customization, and adaptation to different needs and environments.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Simplified Kernel Design and Maintenance:&lt;/strong&gt; By keeping the kernel small and focused on essential functions, microkernels are &lt;strong&gt;easier to design, implement, and maintain&lt;/strong&gt;. The reduced complexity of the kernel makes it less prone to bugs and easier to debug and update, leading to more robust and manageable operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term dispatcher as used in inter-process communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The term &lt;strong&gt;dispatcher&lt;/strong&gt;, in the context of inter-process communication, is more accurately referred to as the &lt;strong&gt;scheduler or process scheduler&lt;/strong&gt;. The dispatcher is the module that gives control of the CPU to the process selected by the short-term scheduler. It's involved in context switching, which is crucial for managing and switching between processes, including those communicating with each other.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between human and machine readable I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Human-Readable I/O Devices:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Purpose:&lt;/strong&gt; Designed for &lt;strong&gt;interaction with human users&lt;/strong&gt;. They facilitate communication and data exchange between humans and the computer system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Keyboard:&lt;/strong&gt; Input device for text and commands.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Monitor:&lt;/strong&gt; Output device for displaying visual information.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Mouse:&lt;/strong&gt; Input device for pointing and selection.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Slow Speed:&lt;/strong&gt; Operate at speeds limited by human interaction rate.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Formatted Data:&lt;/strong&gt; Data is often formatted for human comprehension (e.g., text, images).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine-Readable I/O Devices:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Purpose:&lt;/strong&gt; Designed for &lt;strong&gt;communication with other machines or for data storage&lt;/strong&gt; that is primarily processed by machines.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Disk Drives (HDD, SSD):&lt;/strong&gt; Storage devices for machine-processed data.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Network Interface Cards (NICs):&lt;/strong&gt; For machine-to-machine network communication.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Sensors:&lt;/strong&gt; Input devices providing data for automated systems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;High Speed:&lt;/strong&gt; Operate at much higher speeds for efficient data transfer.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Raw Data:&lt;/strong&gt; Data is often in raw or machine-optimized formats (e.g., binary, structured data).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; &lt;strong&gt;Human-readable devices&lt;/strong&gt; focus on user interaction and are slower, while &lt;strong&gt;machine-readable devices&lt;/strong&gt; prioritize speed and efficiency for inter-machine communication and data processing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A lecturer described single buffering scheme to an OS class. Outline two techniques used with this scheme that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simple Buffer Management:&lt;/strong&gt; In single buffering, a &lt;strong&gt;single buffer is used in system memory&lt;/strong&gt; to transfer data between an I/O device and the process. The lecturer might have mentioned the simplicity of management as a key aspect. Only one buffer needs to be allocated and managed, which reduces the complexity of buffer control and resource allocation. Data is transferred to the buffer, then processed; this is straightforward to implement.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Synchronous Operation:&lt;/strong&gt; Single buffering typically involves &lt;strong&gt;synchronous I/O operations&lt;/strong&gt;. The process must wait until the data transfer to the buffer is complete before it can process the data. Similarly, the I/O device has to wait until the buffer is emptied by the process before the next transfer can begin. This synchronous nature simplifies the control flow and data handling but can lead to performance bottlenecks if I/O operations are slow, as the CPU remains idle during I/O transfer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three file access methods in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential Access:&lt;/strong&gt; Files are accessed in a &lt;strong&gt;linear, ordered manner&lt;/strong&gt;, from the beginning to the end. To access a specific record, all preceding records must be read. This method is efficient for processing files in order but inefficient for random access.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Direct (Random) Access:&lt;/strong&gt; Files can be accessed in &lt;strong&gt;any order, directly accessing any record&lt;/strong&gt; without needing to read through preceding records. This is achieved using record numbers or keys to determine the exact location of the data. It is efficient for applications needing to access specific parts of a file quickly.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Indexed Sequential Access:&lt;/strong&gt; This method combines sequential and direct access. An &lt;strong&gt;index is created for the file&lt;/strong&gt;, containing keys and pointers to records. Sequential access is still possible, but direct access is also supported through the index, allowing for efficient retrieval based on keys while maintaining sequential processing capability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term disk cache as used in I/O communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Disk cache&lt;/strong&gt; is a portion of &lt;strong&gt;main memory (RAM)&lt;/strong&gt; that is used to store frequently accessed data blocks from the disk. It acts as a &lt;strong&gt;buffer between the disk and the CPU&lt;/strong&gt;, aiming to reduce the average time to access data by serving requests from the faster RAM cache instead of the slower disk.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (ii) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;There are several file directories systems but all support similar file operations. Outline five examples of these file operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create:&lt;/strong&gt; This operation allows users to &lt;strong&gt;create a new file&lt;/strong&gt; within the file system. It involves allocating storage space for the file and adding an entry for it in the directory structure, including metadata such as name, permissions, and timestamps.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Read:&lt;/strong&gt; The &lt;strong&gt;read&lt;/strong&gt; operation enables users to &lt;strong&gt;access and retrieve data&lt;/strong&gt; from an existing file. It involves locating the file, checking access permissions, and transferring the file's content from storage to memory for processing.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Write:&lt;/strong&gt; The &lt;strong&gt;write&lt;/strong&gt; operation allows users to &lt;strong&gt;modify or add data to a file&lt;/strong&gt;. It involves locating the file, checking write permissions, and transferring data from memory to the file's storage location, updating the file's content.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete:&lt;/strong&gt; The &lt;strong&gt;delete&lt;/strong&gt; operation is used to &lt;strong&gt;remove a file&lt;/strong&gt; from the file system. It involves removing the file's directory entry, deallocating the storage space occupied by the file, and updating relevant metadata. Permission checks are typically performed before deletion.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Rename:&lt;/strong&gt; The &lt;strong&gt;rename&lt;/strong&gt; operation allows users to &lt;strong&gt;change the name of a file&lt;/strong&gt;. It involves updating the file's entry in the directory structure with the new name, while preserving the file's content and other metadata. This operation is primarily a metadata update.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two objectives of memory management in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficient Memory Utilization:&lt;/strong&gt; One key objective is to &lt;strong&gt;maximize the use of available memory&lt;/strong&gt;. Memory management aims to allocate memory to processes in a way that minimizes wasted space (e.g., through techniques like dynamic allocation and compaction) and allows as many processes as possible to reside in memory concurrently, improving system throughput.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory Protection:&lt;/strong&gt; &lt;strong&gt;Protecting the memory space of one process from unauthorized access by other processes&lt;/strong&gt; is crucial. Memory management ensures that each process operates within its allocated memory region, preventing interference and data corruption caused by errant or malicious processes. This isolation enhances system stability and security.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between a CD recordable (CD-R) and a CD Rewritable (CD-RW).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;CD-R (CD Recordable):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Capability:&lt;/strong&gt; CD-R media can be &lt;strong&gt;written to only once&lt;/strong&gt;. Once data is written, it becomes permanent and cannot be erased or overwritten.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Technology:&lt;/strong&gt; Uses a dye layer that is permanently altered (burned) by the laser during the writing process to represent data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Usage:&lt;/strong&gt; Suitable for &lt;strong&gt;archiving data&lt;/strong&gt;, distributing software or music, and creating permanent backups where data immutability is desired.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CD-RW (CD Rewritable):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Capability:&lt;/strong&gt; CD-RW media can be &lt;strong&gt;written to, erased, and rewritten multiple times&lt;/strong&gt;. Data can be modified or updated as needed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Technology:&lt;/strong&gt; Uses a phase-change material that can switch between crystalline and amorphous states when heated by the laser, allowing for data to be written, erased, and rewritten.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Usage:&lt;/strong&gt; Suitable for &lt;strong&gt;temporary data storage&lt;/strong&gt;, data backup where updates are needed, and as a reusable storage medium. They are more versatile but typically more expensive than CD-Rs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; The primary difference is that &lt;strong&gt;CD-Rs are write-once media&lt;/strong&gt;, while &lt;strong&gt;CD-RWs are rewritable media&lt;/strong&gt;. CD-Rs are for permanent storage, and CD-RWs are for reusable storage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Modern operating system does not use fixed memory partitioning. Explain two limitations of this memory management technique that could be influence this trend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Internal Fragmentation:&lt;/strong&gt; Fixed partitioning leads to &lt;strong&gt;internal fragmentation&lt;/strong&gt;. Partitions are allocated in fixed sizes, and if a process requires less memory than the partition size, the unused space within the partition is wasted. This wasted space within allocated partitions accumulates and reduces overall memory utilization. For example, if a 10MB partition is allocated to a 2MB process, 8MB is internally fragmented and unusable.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Inefficient Memory Utilization and Program Size Limitation:&lt;/strong&gt; Fixed partitioning is &lt;strong&gt;inefficient in utilizing memory&lt;/strong&gt; because partition sizes are predetermined and static. If a process size exceeds the largest available partition, it cannot be loaded, even if there is enough total free memory, just not in a contiguous block of the required size. This limits the size of programs that can be run and can lead to situations where memory is available in total but not in usable fixed-size chunks, resulting in poor resource utilization and inflexibility.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term segment as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;In memory management, a &lt;strong&gt;segment&lt;/strong&gt; is a logical unit of memory organization that is visible to the programmer. It is a &lt;strong&gt;variable-sized block of memory&lt;/strong&gt; that can represent a logical entity such as a code segment, data segment, or stack segment. Segmentation allows for logical division of a program's address space, providing structure and protection.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;List four requirements for a memory management technique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Relocation:&lt;/strong&gt; The memory management technique must support &lt;strong&gt;relocation&lt;/strong&gt;, allowing processes to be loaded into different physical memory locations. This is necessary because the available memory may not always be at a fixed starting address, and processes might need to be moved during execution (e.g., in swapping or paging systems). Relocation provides flexibility in memory allocation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Protection:&lt;/strong&gt; &lt;strong&gt;Memory protection&lt;/strong&gt; is a crucial requirement. The technique should ensure that processes are protected from each other, preventing unauthorized access to memory regions belonging to other processes or the operating system. Protection is essential for system stability and security, preventing one process from corrupting or interfering with others.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Sharing:&lt;/strong&gt; The memory management scheme should facilitate &lt;strong&gt;sharing of memory&lt;/strong&gt; among processes when needed. This can be useful for sharing code or data between processes, reducing memory usage and enabling inter-process communication. Shared memory segments need to be managed and protected appropriately.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Logical Organization:&lt;/strong&gt; Memory management should support a &lt;strong&gt;logical organization of memory&lt;/strong&gt; that aligns with the programmer's view of memory (e.g., segments, pages). This logical structure simplifies program development and memory management by providing a structured and understandable memory model, abstracting away the physical memory details.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Deadlock in resource allocation exists only if several conditions hold. Explain three conditions that are likely to trigger deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Mutual Exclusion:&lt;/strong&gt; &lt;strong&gt;Mutual exclusion&lt;/strong&gt; condition states that at least one resource must be held in a non-sharable mode. This means that only one process at a time can use the resource. If another process requests that resource, it must wait until the resource is released. This condition is necessary for deadlock because if all resources were sharable, deadlock would not occur.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hold and Wait:&lt;/strong&gt; The &lt;strong&gt;hold and wait&lt;/strong&gt; condition occurs when a process is holding onto at least one resource and is waiting to acquire additional resources that are currently being held by other processes. For deadlock to happen, a process must hold resources it has already been allocated while requesting new ones. If a process had to request all its resources at once and not hold any while waiting, deadlock could be avoided.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;No Preemption:&lt;/strong&gt; The &lt;strong&gt;no preemption&lt;/strong&gt; condition means that resources cannot be forcibly taken away from a process holding them. A resource can only be released voluntarily by the process holding it after that process has completed its task. If resources could be preempted from processes, deadlock could be resolved by taking resources away from a holding process and giving them to a waiting process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distributed Deadlock Detection algorithms are more commonly used in distributed operating systems. Explain two strengths that could be influencing their application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Detection of System-Wide Deadlocks:&lt;/strong&gt; Distributed deadlock detection algorithms are designed to &lt;strong&gt;detect deadlocks that span across multiple nodes&lt;/strong&gt; in a distributed system. In distributed systems, processes on different machines may hold and request resources from other machines, leading to deadlocks that are not confined to a single system. These algorithms can gather information from various nodes to construct a global wait-for graph and identify cycles, indicating deadlocks that would be impossible to detect with local deadlock detection mechanisms.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Autonomous Node Operation:&lt;/strong&gt; Distributed deadlock detection allows each node in the system to operate &lt;strong&gt;autonomously while still participating in deadlock detection&lt;/strong&gt;. Nodes can independently manage their local resources and processes. The distributed algorithm then coordinates across nodes to detect deadlocks without requiring centralized control. This decentralized approach aligns with the nature of distributed systems, enhancing scalability and fault tolerance by avoiding single points of failure and allowing nodes to function even if communication is temporarily disrupted.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (ii) (4marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;An authentication process consists of two steps. Explain two of these steps that could be incorporated in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;User Identification:&lt;/strong&gt; The first step in authentication is &lt;strong&gt;user identification&lt;/strong&gt;. This involves the system requesting the user to provide a unique identifier, typically a username or login ID. The operating system needs to know who is attempting to access the system before it can verify their identity. This step sets the stage for subsequent verification.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Password Verification:&lt;/strong&gt; Following identification, the system performs &lt;strong&gt;password verification&lt;/strong&gt;. The user is prompted to enter a password, which is then compared against a stored (typically hashed) version associated with the provided username. If the entered password matches the stored hash, the user is authenticated. This step confirms that the user is who they claim to be based on secret knowledge (the password).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 1 shows a cross section of a hard disk platter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_11-34-33_2018nov.pdf.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;294&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Describe the function of the parts labeled (i) and (ii).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Referring to Figure 1:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Magnetic Coating (Magnetic Layer):&lt;/strong&gt; This layer is the &lt;strong&gt;magnetic medium&lt;/strong&gt; where data is actually stored on the hard disk platter. It is made of a ferromagnetic material that can be magnetized in different directions to represent binary data (0s and 1s). The read/write head interacts with this layer to write data by magnetizing areas and read data by detecting the magnetization direction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Substrate (Platter Substrate):&lt;/strong&gt; This is the &lt;strong&gt;base material&lt;/strong&gt; of the platter, typically made of aluminum alloy or glass. The substrate provides a rigid and non-magnetic foundation for the magnetic coating. It is crucial for the platter's structural integrity, ensuring it can spin at high speeds without warping or bending, and provides a smooth surface for the magnetic layer to be deposited on.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Mary would like to implement shortest remaining time (SRT) processor scheduling algorithm. State four characteristics expected of the operating system with respect to the process control.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Preemptive Scheduling:&lt;/strong&gt; SRT is a &lt;strong&gt;preemptive algorithm&lt;/strong&gt;. The operating system must support preemption, meaning it can interrupt a running process if a new process arrives with a shorter remaining execution time, or if the remaining time of a running process becomes longer than that of another ready process. Preemption is essential for SRT to dynamically prioritize processes based on remaining time.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Tracking Remaining Execution Time:&lt;/strong&gt; The OS needs to &lt;strong&gt;accurately track or estimate the remaining execution time&lt;/strong&gt; for each process. This is crucial for SRT to make scheduling decisions. The scheduler must have a mechanism to know (or predict) how much CPU time each process still needs to complete, which is often done through estimations based on past behavior or process specifications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Context Switching Overhead:&lt;/strong&gt; Since SRT is preemptive and can lead to frequent context switches (especially if many short processes arrive), the operating system must be able to handle &lt;strong&gt;context switching efficiently&lt;/strong&gt;. Minimizing the overhead of saving and restoring process states is important to prevent excessive performance degradation due to frequent scheduling decisions.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Dynamic Priority Management:&lt;/strong&gt; SRT effectively uses &lt;strong&gt;dynamic priority&lt;/strong&gt;. Process priorities are not fixed but change based on the remaining execution time. The OS must support dynamic priority management, allowing the scheduler to adjust process priorities in real-time as processes execute and their remaining times decrease. The process with the shortest remaining time always gets the highest priority.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Paul was advised to enable I/O buffering in his computer. Explain two conditions that could have informed his friend's advice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed Mismatch between CPU and I/O Devices:&lt;/strong&gt; If Paul's computer frequently performs operations involving &lt;strong&gt;slow I/O devices&lt;/strong&gt; (like hard drives, network connections), enabling I/O buffering can help bridge the speed gap between the fast CPU and slow I/O. Buffering allows the CPU to continue processing other tasks while data is being transferred to or from the slower I/O device in the background, improving overall system throughput and responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Transfer Size Discrepancies:&lt;/strong&gt; If applications on Paul's computer often deal with &lt;strong&gt;data transfers in chunks that are not optimally sized for I/O devices&lt;/strong&gt;, buffering can be beneficial. Buffers can accumulate smaller data chunks into larger, more efficient transfer units for I/O operations, or break down large data into manageable segments. This optimization reduces the overhead of frequent small I/O requests and improves the efficiency of data transfer operations, especially for disk and network I/O.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, outline a process control block.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;Process Control Block (PCB)&lt;/strong&gt; is a data structure used by the operating system to manage and store information about each process. It contains all the necessary details for managing a process's execution and state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagrammatic Outline:&lt;/strong&gt;&lt;/p&gt;
&lt;pre style=&quot;background-color: #f0f0f0; padding: 10px; border-radius: 5px; font-family: monospace; overflow-x: auto;&quot;&gt;+-----------------------+
| Process Identifier (PID)|
+-----------------------+
| Process State         | (e.g., Running, Ready, Blocked)
+-----------------------+
| Program Counter (PC)  | (Address of next instruction)
+-----------------------+
| CPU Registers         | (Accumulators, index registers, etc.)
+-----------------------+
| Memory Management Info| (e.g., Page table base, segment table)
+-----------------------+
| CPU Scheduling Info   | (e.g., Priority, scheduling queue pointers)
+-----------------------+
| I/O Status Info       | (List of open files, I/O devices allocated)
+-----------------------+
| Accounting Info       | (CPU time used, time limits, etc.)
+-----------------------+
| Context Data          | (Saved context when process is not running)
+-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Components of a PCB:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Identifier (PID):&lt;/strong&gt; A &lt;strong&gt;unique number&lt;/strong&gt; to identify the process.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process State:&lt;/strong&gt; Indicates the &lt;strong&gt;current state&lt;/strong&gt; of the process (e.g., running, ready, waiting).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Program Counter (PC):&lt;/strong&gt; Stores the &lt;strong&gt;address of the next instruction&lt;/strong&gt; to be executed.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;CPU Registers:&lt;/strong&gt; Saves the &lt;strong&gt;state of CPU registers&lt;/strong&gt; when the process is interrupted.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Memory Management Information:&lt;/strong&gt; Includes details for &lt;strong&gt;memory management&lt;/strong&gt;, like page tables or segment tables.&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;&lt;strong&gt;CPU Scheduling Information:&lt;/strong&gt; Contains &lt;strong&gt;scheduling priorities&lt;/strong&gt; and pointers to scheduling queues.&lt;/p&gt;
&lt;p data-number=&quot;7&quot;&gt;&lt;strong&gt;I/O Status Information:&lt;/strong&gt; Lists &lt;strong&gt;open files and I/O devices&lt;/strong&gt; allocated to the process.&lt;/p&gt;
&lt;p data-number=&quot;8&quot;&gt;&lt;strong&gt;Accounting Information:&lt;/strong&gt; Tracks &lt;strong&gt;resource usage&lt;/strong&gt;, such as CPU time and limits.&lt;/p&gt;
&lt;p data-number=&quot;9&quot;&gt;&lt;strong&gt;Context Data:&lt;/strong&gt; General &lt;strong&gt;context information&lt;/strong&gt; needed to resume the process execution.&lt;/p&gt;
&lt;p&gt;The PCB is essential for the OS to manage processes, enabling context switching, scheduling, and resource management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Disk mirroring is a feature of Redundant Array of Independent Disks 1(RAID 1). Explain two limitations that could be realized while using it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Storage Capacity:&lt;/strong&gt; In RAID 1 (disk mirroring), &lt;strong&gt;half of the total disk capacity is used for redundancy&lt;/strong&gt;. For every byte of data stored, another byte is duplicated on a mirror disk. This means if you have two 1TB drives in a RAID 1 configuration, you only get 1TB of usable storage space, as the other 1TB is used for mirroring. This effectively reduces the available storage capacity by 50%, making it less storage-efficient compared to RAID levels that utilize capacity more fully.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Write Overhead:&lt;/strong&gt; &lt;strong&gt;Write operations in RAID 1 are slower&lt;/strong&gt; compared to single-disk systems or RAID levels like RAID 0. Every write operation must be performed twice – once to the primary disk and again to the mirror disk to maintain data redundancy. This doubles the write I/O workload, potentially reducing write performance. While read performance can be improved (by reading from either disk), write performance is inherently limited by the need to duplicate every write operation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two examples of resources needed for process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time:&lt;/strong&gt; Processes need &lt;strong&gt;CPU time&lt;/strong&gt; to execute their instructions. The CPU is the primary resource for computation, and processes require slices of CPU time to perform operations, calculations, and execute program code. CPU time is allocated by the operating system's scheduler.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory:&lt;/strong&gt; Processes require &lt;strong&gt;memory (RAM)&lt;/strong&gt; to store their code, data, and stack during execution. Memory is essential for holding the process's working set, including program instructions, variables, and runtime data. Memory must be allocated and managed by the operating system for each process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four factors that may affect performance of a storage disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Seek Time:&lt;/strong&gt; &lt;strong&gt;Seek time&lt;/strong&gt; is the time taken for the disk's read/write head to move to the correct track (cylinder) on the platter. Longer seek times result in slower data access, especially for random access patterns. Seek time is a significant factor in hard disk drive (HDD) performance, less so in solid-state drives (SSDs).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Rotational Latency:&lt;/strong&gt; For HDDs, &lt;strong&gt;rotational latency&lt;/strong&gt; is the time it takes for the desired sector on the track to rotate under the read/write head once the head is positioned over the correct track. Higher rotational speeds (RPM) reduce rotational latency. This is another HDD-specific factor affecting access speed.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Transfer Rate:&lt;/strong&gt; &lt;strong&gt;Transfer rate&lt;/strong&gt; is the speed at which data can be transferred between the disk and the system's memory once the head is in the correct position and the sector is under the head. Higher transfer rates mean faster read and write operations. This is influenced by the disk interface (e.g., SATA, NVMe) and the disk's internal data processing capabilities.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Disk Interface and Bus Bandwidth:&lt;/strong&gt; The &lt;strong&gt;type of disk interface&lt;/strong&gt; (e.g., SATA, NVMe, SAS) and the &lt;strong&gt;bandwidth of the system bus&lt;/strong&gt; (e.g., PCIe) connecting the disk to the motherboard significantly impact performance. A faster interface and bus allow for higher data transfer rates. For example, NVMe over PCIe offers much higher bandwidth and lower latency compared to SATA, resulting in significantly better performance for SSDs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between rename and modify as used in file operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Rename (File Operation):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function:&lt;/strong&gt; &lt;strong&gt;Rename&lt;/strong&gt; operation changes the &lt;strong&gt;name of a file or directory&lt;/strong&gt;. It alters the filename within the file system's directory structure but &lt;strong&gt;does not change the content of the file itself&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scope:&lt;/strong&gt; Primarily affects &lt;strong&gt;metadata&lt;/strong&gt; associated with the file, specifically the filename in the directory entry. The file's data, location on disk, and other attributes (except filename) remain unchanged.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Impact:&lt;/strong&gt; A relatively &lt;strong&gt;lightweight operation&lt;/strong&gt; as it mainly involves updating directory entries. It's fast because it does not involve reading or writing the file's data content.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modify (File Operation):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function:&lt;/strong&gt; &lt;strong&gt;Modify&lt;/strong&gt; operation changes the &lt;strong&gt;content of a file&lt;/strong&gt;. It alters the data stored within the file, potentially adding, deleting, or changing the existing data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scope:&lt;/strong&gt; Directly affects the &lt;strong&gt;data blocks&lt;/strong&gt; on the storage medium where the file's content is stored. Metadata like timestamps (modification time) are also updated.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Impact:&lt;/strong&gt; Can be a &lt;strong&gt;resource-intensive operation&lt;/strong&gt;, especially for large files or significant changes, as it involves reading from and writing to the storage device. Performance depends on file size, changes made, and storage device speed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; &lt;strong&gt;Rename&lt;/strong&gt; changes the filename (metadata), while &lt;strong&gt;modify&lt;/strong&gt; changes the file's content (data). Rename is metadata-focused and fast; modify is data-focused and can be slower depending on the extent of changes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows a typical memory hierarchical map used in computers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_11-41-42_2018nov.pdf.png&quot; alt=&quot;&quot; width=&quot;634&quot; height=&quot;517&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Describe each of the layers labelled (i) and (ii).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Referring to Figure 2, depicting a memory hierarchy:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Cache:&lt;/strong&gt; &lt;strong&gt;Cache memory&lt;/strong&gt; is a &lt;strong&gt;small, fast memory&lt;/strong&gt; located closer to the CPU than main memory (RAM). It stores frequently accessed data and instructions to speed up access times. When the CPU needs to read or write data, it first checks the cache. If the data is found in the cache (a cache hit), it is accessed quickly. If not (a cache miss), it's retrieved from RAM and then placed in the cache for future faster access. Cache is crucial for reducing average memory access time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) RAM (Random Access Memory):&lt;/strong&gt; &lt;strong&gt;RAM&lt;/strong&gt; is the &lt;strong&gt;main memory&lt;/strong&gt; of the computer system. It is larger and slower than cache but much faster than secondary storage (like hard drives). RAM is used to &lt;strong&gt;hold the operating system, currently running applications, and data being actively used&lt;/strong&gt; by the CPU. It provides volatile storage, meaning data is lost when power is turned off. RAM is the primary working memory for active processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe three circumstances under which a new process could be generated in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;System Initialization (Booting):&lt;/strong&gt; When the operating system &lt;strong&gt;starts up (boots)&lt;/strong&gt;, it initiates several processes. The first process, often called 'init' or 'systemd', is created directly by the kernel. This initial process then starts other system daemons and services that are essential for the OS to function, such as process managers, memory managers, device drivers, and user login services. System boot is a fundamental circumstance for process creation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;User Request (Command Execution or Application Launch):&lt;/strong&gt; When a user &lt;strong&gt;executes a command or launches an application&lt;/strong&gt;, the operating system creates a new process to run that program. For example, typing a command in the terminal or clicking an application icon triggers the OS to create a new process and load the program's code and data into memory, starting its execution. User interactions are a common trigger for process generation.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Process Spawning (Parent Process Creating Child Process):&lt;/strong&gt; An &lt;strong&gt;existing process&lt;/strong&gt; can create one or more new processes, known as &lt;strong&gt;child processes&lt;/strong&gt;. This is often done when an application needs to perform concurrent tasks or divide work into smaller, manageable units. For instance, a web server process might spawn new child processes to handle incoming client requests concurrently. Process spawning allows for modularity and parallelism in software execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;9. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two reasons that could be influencing the use of cache memory in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed Gap between CPU and Main Memory:&lt;/strong&gt; Cache memory is used to address the &lt;strong&gt;significant speed difference&lt;/strong&gt; between the fast CPU and slower main memory (RAM). CPUs operate much faster than RAM can provide data. Cache acts as a high-speed buffer, storing frequently accessed data closer to the CPU, reducing the CPU's wait time for memory access and improving overall processing speed. This speed gap is a primary driver for cache use.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Locality of Reference:&lt;/strong&gt; Computer programs exhibit &lt;strong&gt;locality of reference&lt;/strong&gt;, meaning they tend to access data and instructions in clusters, both temporally (repeated access to the same data in a short period) and spatially (access to data located near each other in memory). Cache memory leverages this principle by storing recently accessed data (temporal locality) and data adjacent to recently accessed data (spatial locality). This increases the probability of cache hits, making data access faster and more efficient due to program behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;9. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between asynchronous and synchronous as applied in windows I/O communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Synchronous I/O (Blocking I/O):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation:&lt;/strong&gt; In &lt;strong&gt;synchronous I/O&lt;/strong&gt;, when a process initiates an I/O operation, it &lt;strong&gt;blocks or waits&lt;/strong&gt; until the operation is fully completed. The process is suspended and cannot continue execution until the I/O request is served, and the data is transferred.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Blocking:&lt;/strong&gt; Process is blocked during I/O operation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Simpler Programming:&lt;/strong&gt; Easier to program and understand for simple I/O tasks.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Inefficient Resource Usage:&lt;/strong&gt; CPU remains idle while waiting for I/O, potentially wasting resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asynchronous I/O (Non-blocking I/O):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Operation:&lt;/strong&gt; In &lt;strong&gt;asynchronous I/O&lt;/strong&gt;, when a process starts an I/O operation, it &lt;strong&gt;does not wait&lt;/strong&gt; for completion. The process continues to execute other tasks. The OS handles the I/O operation in the background and notifies the process when the operation is complete, typically through signals or callbacks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Characteristics:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Non-blocking:&lt;/strong&gt; Process does not block and can perform other tasks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Complex Programming:&lt;/strong&gt; More complex to program, requires handling of callbacks or event notifications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Efficient Resource Usage:&lt;/strong&gt; CPU can perform other tasks while I/O operations are in progress, improving resource utilization and system responsiveness.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; &lt;strong&gt;Synchronous I/O blocks&lt;/strong&gt; the process until completion, while &lt;strong&gt;asynchronous I/O is non-blocking&lt;/strong&gt;, allowing the process to continue execution while I/O operations are performed in the background, leading to better resource utilization and responsiveness in many scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;9. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term spatial locality as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Spatial Locality&lt;/strong&gt;, in operating systems, refers to the tendency of a processor to &lt;strong&gt;access memory locations that are physically close to each other in memory&lt;/strong&gt;. If a process accesses a particular memory location, it is likely to access nearby memory locations in the near future. This principle is exploited by cache memory systems to improve performance by fetching blocks of data around the requested location.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;9. (b) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain three types of information that should be found in a memory table.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Allocation Status of Memory Blocks:&lt;/strong&gt; Memory tables should track the &lt;strong&gt;allocation status&lt;/strong&gt; of each block of memory (e.g., page, segment, partition). This includes indicating whether a block is currently &lt;strong&gt;allocated (in use) or free (available)&lt;/strong&gt;. For allocated blocks, it should specify which process or entity is using the block. This information is crucial for memory management functions like allocation, deallocation, and preventing memory conflicts.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Physical Address Mapping:&lt;/strong&gt; In virtual memory systems, memory tables (like page tables or segment tables) must store the &lt;strong&gt;mapping between virtual addresses and physical addresses&lt;/strong&gt;. For each virtual page or segment, the table should contain the corresponding physical frame number where the data is actually stored in RAM. This mapping is essential for the MMU to translate virtual addresses generated by the CPU into physical addresses for memory access. If a virtual page is not in RAM, the table entry will indicate its location on secondary storage (e.g., disk).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Protection and Access Control Information:&lt;/strong&gt; Memory tables should include &lt;strong&gt;protection bits or access control information&lt;/strong&gt; for each memory block. This information specifies the &lt;strong&gt;access rights&lt;/strong&gt; (e.g., read, write, execute) granted to processes or users for each memory region. Protection bits ensure memory security by preventing unauthorized access and modifications, enforcing memory protection policies and isolating processes from each other's memory spaces. Examples include read-only, read-write, supervisor mode access, etc.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;10. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Typically, users or groups of users are granted certain access rights to a file in a computer system. Describe three examples of these access rights that could be found in computer systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Read Access:&lt;/strong&gt; &lt;strong&gt;Read access&lt;/strong&gt; right allows a user or group to &lt;strong&gt;view or copy the contents of a file&lt;/strong&gt;. With read permission, users can open and read the file's data but cannot make any changes to it. This right is essential for allowing users to access information without the risk of accidental or malicious modification. It is a fundamental access right for data sharing and information retrieval.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Write Access:&lt;/strong&gt; &lt;strong&gt;Write access&lt;/strong&gt; right grants a user or group the ability to &lt;strong&gt;modify or delete a file&lt;/strong&gt;. With write permission, users can change the file's content, add new data, or remove existing data. It often implies read access as well, as users typically need to read a file before modifying it. Write access is critical for users who need to update or manage files, but it must be controlled to prevent unauthorized alteration of important data.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Execute Access:&lt;/strong&gt; &lt;strong&gt;Execute access&lt;/strong&gt; right allows a user or group to &lt;strong&gt;run a file as a program or script&lt;/strong&gt;. This right is primarily relevant for executable files (e.g., .exe files on Windows, scripts on Linux/Unix). With execute permission, users can launch and execute the code contained in the file. For non-executable files, execute permission may have no effect or may be interpreted differently depending on the operating system. Controlling execute access is vital for system security, preventing the execution of unauthorized or malicious software.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;©2018 The Kenya National Examinations Council&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="256"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="5_127_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="29">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="26"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_11-34-33_2018nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_11-34-33_2018nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="1f8d509306fa209f2c2f3f38c581c1c0"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="27"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="257"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="5_127_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="30">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="26"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_11-41-42_2018nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_11-41-42_2018nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="da1f04d04b3704187a6b38e5391be8a5"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="27"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="27"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="2"></int>
              <string role="key" value="parentNode"></string>
              <reference key="28"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="5"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="28"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="29"></reference>
            <reference key="30"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="5"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202018"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="33">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2017"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="31">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="32">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="128_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="31"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2017&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline three functions of the job control language in a computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Job Submission&lt;/strong&gt;: JCL provides a means for users to submit jobs to the operating system for processing. It acts as the interface through which users communicate their processing requests.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Resource Allocation&lt;/strong&gt;: JCL allows users to specify the resources required for their jobs, such as memory, input/output devices, and processing time. This enables the operating system to allocate resources efficiently and manage job execution.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Job Control&lt;/strong&gt;: JCL enables users to control the execution sequence of programs within a job. It defines the steps to be performed, including the programs to be executed, the data files to be used, and the desired output.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) spooling;&lt;/p&gt;
&lt;p&gt;(ii) warm boot;&lt;/p&gt;
&lt;p&gt;(iii) context switch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Spooling&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spooling&lt;/strong&gt; (Simultaneous Peripheral Operations On-Line) is a process in which data is temporarily held in a buffer to be used and executed by a device, program or the system. Data is sent to and stored in temporary storage such as a disk or memory for execution at a later time. Spooling is useful because devices access data at different rates. For example, a printer is much slower than a CPU. Spooling allows the CPU to continue processing other jobs while the printer is working, improving overall system efficiency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Warm boot&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;warm boot&lt;/strong&gt;, also known as a soft reboot, is the process of restarting a computer system without interrupting the power supply. In a warm boot, the operating system is instructed to restart, typically through a software command or a system menu option. The system goes through a restart sequence, but it doesn't power down completely. It is generally faster than a cold boot as some system components may retain their state. However, it may not resolve issues that require a complete power cycle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iii) Context switch&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;context switch&lt;/strong&gt; is the procedure followed by the operating system kernel to switch the CPU from one process to another. It involves saving the state of the current process (including the program counter, registers, and memory management information) and loading the saved state of the new process to be executed. Context switching is essential for multitasking operating systems, allowing multiple processes to share the CPU and appear to run concurrently. It is a fundamental operation for achieving concurrency and responsiveness in modern operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (7 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A disk has the following head movement queue 95, 190, 40, 115, 18, 123, 52, 60 with the read-write head initially at track 40 and the tail track at 210. With the aid of a Gantt graph, determine the total seek time using each of the following disk scheduling algorithms:&lt;/p&gt;
&lt;p&gt;(i) shortest seek time first;&lt;/p&gt;
&lt;p&gt;(ii) elevator assuming the head moves towards 0.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Shortest Seek Time First (SSTF)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart for SSTF:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[40] - 52 - 60 - 40 - 18 - 95 - 115 - 123 - 190&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek Sequence:&lt;/strong&gt; 40, 52, 60, 40, 18, 95, 115, 123, 190&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek Time Calculation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;|52 - 40| + |60 - 52| + |40 - 60| + |18 - 40| + |95 - 18| + |115 - 95| + |123 - 115| + |190 - 123|&lt;/p&gt;
&lt;p&gt;= 12 + 8 + 20 + 22 + 77 + 20 + 8 + 67 = 234&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Total seek time for SSTF is 234 track movements.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Elevator (SCAN) assuming the head moves towards 0&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart for Elevator (SCAN):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[40] - 18 - 40 - 52 - 60 - 95 - 115 - 123 - 190&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek Sequence:&lt;/strong&gt; 40, 18, 40, 52, 60, 95, 115, 123, 190&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek Time Calculation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;|18 - 40| + |40 - 18| + |52 - 40| + |60 - 52| + |95 - 60| + |115 - 95| + |123 - 115| + |190 - 123|&lt;/p&gt;
&lt;p&gt;= 22 + 22 + 12 + 8 + 35 + 20 + 8 + 67 = 194&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Total seek time for Elevator (SCAN) is 194 track movements.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Explain two reasons why application programs are temporarily stored in the main memory of a computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Access Speed&lt;/strong&gt;: Main memory (RAM) offers significantly faster access speeds compared to secondary storage (like hard disks or SSDs). The CPU can fetch instructions and data from RAM much more quickly, which is crucial for program execution. Temporarily storing application programs in main memory allows the CPU to access them rapidly, leading to faster program execution and improved system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Execution Requirement&lt;/strong&gt;: Application programs need to be in main memory to be executed by the CPU. The CPU can only directly access instructions and data that are present in the main memory. When an application is launched, its executable code and necessary data are loaded from secondary storage into main memory. This loading process is essential because the CPU fetches and executes instructions sequentially from main memory to run the program.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline three examples of systems calls for each of the following:&lt;/p&gt;
&lt;p&gt;(i) file manipulation;&lt;/p&gt;
&lt;p&gt;(ii) communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) File Manipulation System Calls:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;`open()`&lt;/strong&gt;: This system call is used to &lt;strong&gt;open a file&lt;/strong&gt;. It typically takes the filename and mode (read, write, append) as arguments and returns a file descriptor, which is used for subsequent operations on the file.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;`read()`&lt;/strong&gt;: The `read()` system call is used to &lt;strong&gt;read data from a file&lt;/strong&gt;. It takes the file descriptor, a buffer to store the data, and the number of bytes to read as arguments. It returns the number of bytes actually read, which may be less than requested.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;`write()`&lt;/strong&gt;: This system call is used to &lt;strong&gt;write data to a file&lt;/strong&gt;. It takes the file descriptor, a buffer containing the data to be written, and the number of bytes to write as arguments. It returns the number of bytes actually written.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Communication System Calls:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;`socket()`&lt;/strong&gt;: The `socket()` system call is used to &lt;strong&gt;create a new socket&lt;/strong&gt;, which is an endpoint for communication. It takes arguments specifying the address family, socket type, and protocol. It returns a file descriptor representing the socket.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;`send()`&lt;/strong&gt;: The `send()` system call is used to &lt;strong&gt;transmit data to another socket&lt;/strong&gt;. It takes the socket descriptor, a buffer containing the data to be sent, and the length of the data as arguments. It is typically used for connection-oriented sockets (e.g., TCP).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;`recv()`&lt;/strong&gt;: The `recv()` system call is used to &lt;strong&gt;receive data from a socket&lt;/strong&gt;. It takes the socket descriptor, a buffer to store the received data, and the maximum number of bytes to receive as arguments. It returns the number of bytes received.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Explain two modes of processing supported by multiprocessing operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Symmetric Multiprocessing (SMP)&lt;/strong&gt;: In &lt;strong&gt;SMP&lt;/strong&gt;, multiple processors share the system memory and I/O resources. Each processor runs an identical copy of the operating system, and they can execute different processes or threads concurrently. SMP provides true parallelism and is commonly used in systems requiring high performance and throughput. The processors are treated equally, and the OS manages the distribution of tasks across them.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Asymmetric Multiprocessing (AMP)&lt;/strong&gt;: In &lt;strong&gt;AMP&lt;/strong&gt;, processors are assigned specific tasks. Typically, one processor acts as the master processor, running the operating system and managing the system, while other processors (slave processors) are dedicated to specific tasks or applications. AMP is simpler to implement than SMP but offers less flexibility and scalability. It's often used in embedded systems or specialized applications where tasks can be clearly partitioned and assigned to different processors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Several programs can be run simultaneously using a multiprogramming operating system.&lt;/p&gt;
&lt;p&gt;(i) Explain the objective of this mode of processing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Objective of Multiprogramming&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The primary objective of multiprogramming is to &lt;strong&gt;maximize CPU utilization&lt;/strong&gt; and &lt;strong&gt;increase system throughput&lt;/strong&gt;. By keeping multiple programs in memory, the operating system can switch the CPU to another program whenever the current program is waiting for I/O operations to complete. This prevents the CPU from sitting idle and ensures that it is always working on some task, thus improving overall system efficiency and responsiveness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain the problem associated with this mode of processing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Problem associated with Multiprogramming&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;One of the main problems associated with multiprogramming is &lt;strong&gt;increased memory management complexity&lt;/strong&gt;. Keeping multiple programs in memory simultaneously requires sophisticated memory management techniques to prevent programs from interfering with each other, to allocate memory efficiently, and to handle swapping or paging when memory becomes full. This complexity adds overhead to the operating system and can potentially lead to performance issues if not managed effectively.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Joseph intends to acquire an operating system for his company's network system. Explain three factors he should consider other than cost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Security Features&lt;/strong&gt;: Joseph should consider the &lt;strong&gt;security features&lt;/strong&gt; offered by the operating system. This includes evaluating the OS's vulnerability to malware, its firewall capabilities, intrusion detection/prevention systems, and user access control mechanisms. A secure operating system is crucial for protecting sensitive company data and maintaining the integrity of the network system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Scalability and Performance&lt;/strong&gt;: The operating system should be &lt;strong&gt;scalable&lt;/strong&gt; to handle future growth in network size and user load. Joseph needs to assess the OS's performance under heavy network traffic, its ability to manage a large number of concurrent connections, and its efficiency in resource utilization. Performance and scalability are vital for ensuring the network system remains responsive and efficient as the company expands.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Compatibility and Support&lt;/strong&gt;: Joseph must ensure the operating system is &lt;strong&gt;compatible&lt;/strong&gt; with the existing hardware and software infrastructure within his company. He also needs to consider the availability of technical support, updates, and a strong community for the chosen OS. Good compatibility minimizes integration issues, while reliable support ensures timely resolution of any operational problems and long-term system maintainability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) The operating system uses various approaches of interfacing with users. Describe three such approaches.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Command Line Interface (CLI)&lt;/strong&gt;: A &lt;strong&gt;CLI&lt;/strong&gt; allows users to interact with the operating system by typing text-based commands. Users enter commands at a prompt, and the system responds with text output. CLIs are efficient and powerful for experienced users, offering precise control over the system. Examples include the terminal in Linux/macOS and Command Prompt in Windows.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Graphical User Interface (GUI)&lt;/strong&gt;: A &lt;strong&gt;GUI&lt;/strong&gt; provides a visual way for users to interact with the operating system using icons, menus, and windows. Users interact using a mouse, keyboard, or touch input. GUIs are user-friendly and intuitive, making computers accessible to a wider range of users. Examples include Windows desktop, macOS Finder, and GNOME or KDE in Linux.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Batch Interface&lt;/strong&gt;: In a &lt;strong&gt;batch interface&lt;/strong&gt;, users prepare a batch of commands or jobs in a file and submit it to the operating system for execution. The system processes the batch without requiring user interaction during execution. Batch interfaces are suitable for automating repetitive tasks and processing large volumes of data. They were common in early operating systems and are still used for tasks like overnight processing or scheduled jobs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Explain each of the modes of programmable clocks as used in I/O device management:&lt;/p&gt;
&lt;p&gt;(i) one-shot;&lt;/p&gt;
&lt;p&gt;(ii) square-wave.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) One-Shot Mode&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;one-shot mode&lt;/strong&gt;, the programmable clock is set to generate a single pulse or interrupt after a specified time interval. Once the timer counts down to zero and generates the interrupt, it stops and needs to be re-armed or re-initialized to trigger again. This mode is useful for tasks that require a single timed event, such as setting a delay or triggering an action after a specific duration. After the event, the clock becomes inactive until explicitly restarted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Square-Wave Mode&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;square-wave mode&lt;/strong&gt;, the programmable clock is configured to generate a continuous, periodic sequence of pulses or interrupts. Once started, the timer repeatedly counts down to zero and generates an interrupt, then automatically restarts the countdown from the initial value. This creates a square wave output, where the frequency and duty cycle can be configured. Square-wave mode is suitable for tasks that require periodic events, such as real-time clock functions, generating PWM signals, or scheduling recurring tasks at regular intervals.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Distinguish between the CPU bound and I/O bound jobs during inter process communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;CPU-Bound Jobs&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU-bound jobs&lt;/strong&gt; are processes where the rate at which the process progresses is primarily limited by the speed of the CPU. These jobs require significant processing power and spend most of their time performing computations in the CPU. In inter-process communication, CPU-bound jobs might be involved in intensive data processing or calculations before or after communication, but the communication itself is not the bottleneck. The performance of CPU-bound jobs heavily depends on CPU speed and efficiency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O-Bound Jobs&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O-bound jobs&lt;/strong&gt; are processes where the rate of progress is limited by the speed of I/O operations, such as reading from or writing to disks, network communication, or user input. These jobs spend a significant portion of their time waiting for I/O operations to complete. In inter-process communication, I/O-bound jobs might be waiting for data to be received from another process, or they might be sending data that takes time to be transmitted. The communication aspect is more central to the job's performance compared to CPU-bound jobs. Performance of I/O-bound jobs is more dependent on I/O subsystem speed and efficiency of communication channels.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Files can be stored on a directory using various logical structures. Describe three such structures that the operating system supports.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Single-Level Directory&lt;/strong&gt;: A &lt;strong&gt;single-level directory structure&lt;/strong&gt; is the simplest form, where all files are placed in a single directory. This structure is easy to implement but has limitations, especially when the number of files increases. It can lead to naming conflicts if two users want to use the same filename, and it becomes difficult to organize and manage a large number of files. It is rarely used in modern operating systems due to its lack of scalability and organization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Two-Level Directory&lt;/strong&gt;: A &lt;strong&gt;two-level directory structure&lt;/strong&gt; introduces a hierarchy by having a master directory and user-level directories. Each user has their own directory under the master directory, and all files belonging to a user are placed in their respective user directory. This structure solves the naming conflict issue of the single-level directory and provides some level of organization. However, it still lacks flexibility for users to further organize their files within their own directories.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Tree-Structured Directory&lt;/strong&gt;: A &lt;strong&gt;tree-structured directory&lt;/strong&gt; (or hierarchical directory) is the most common and flexible structure used in modern operating systems. It allows users to create directories within directories, forming a tree-like hierarchy. This structure provides a high degree of organization and allows users to create a logical grouping of files and directories. It supports efficient file searching and management and is widely used in systems like Unix, Linux, and Windows. Users can create a directory hierarchy that mirrors their organizational needs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline three objectives of I/O scheduling in a computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Maximize Throughput&lt;/strong&gt;: One key objective of I/O scheduling is to &lt;strong&gt;maximize the number of I/O requests processed per unit of time (throughput)&lt;/strong&gt;. Efficient scheduling algorithms aim to reduce the total time spent in servicing I/O requests, allowing more requests to be completed in a given period. This improves the overall performance of the system by reducing I/O bottlenecks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Minimize Response Time&lt;/strong&gt;: Another important objective is to &lt;strong&gt;minimize the response time for I/O requests&lt;/strong&gt;. Response time is the delay between issuing an I/O request and receiving the response or completion signal. Lower response times lead to faster program execution and a more responsive system, particularly important for interactive applications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Ensure Fairness&lt;/strong&gt;: I/O scheduling also aims to &lt;strong&gt;ensure fairness among different processes or users&lt;/strong&gt; requesting I/O operations. Fairness means that no process or user should be unfairly starved of I/O service, and all requests should eventually be served in a reasonable amount of time. This prevents one process from monopolizing the I/O resources and degrading the performance of other processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) With the aid of an example, describe each of the following pathnames as used in directory management.&lt;/p&gt;
&lt;p&gt;(i) absolute path;&lt;/p&gt;
&lt;p&gt;(ii) relative path.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Absolute Path&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;absolute path&lt;/strong&gt; is a pathname that specifies the location of a file or directory starting from the root directory of the file system. It provides a complete and unambiguous path to the target, regardless of the current working directory. In Unix-like systems, it begins with a forward slash `/`, and in Windows, it typically starts with a drive letter followed by a colon and a backslash, like `C:\`.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example (Unix-like):&lt;/strong&gt; `/home/user/documents/report.txt` - This absolute path starts from the root directory `/`, goes through the `home` directory, then the `user` directory, then `documents`, and finally points to the file `report.txt`.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example (Windows):&lt;/strong&gt; `C:\Users\Public\Pictures\sample.jpg` - This absolute path starts from drive `C:`, goes through `Users`, then `Public`, then `Pictures`, and points to the file `sample.jpg`.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Relative Path&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;relative path&lt;/strong&gt; specifies the location of a file or directory relative to the current working directory. It does not start from the root directory. Relative paths are shorter and more convenient when working within a specific part of the file system. They are interpreted based on the current directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example (assuming current working directory is `/home/user/documents/` in Unix-like systems):&lt;/strong&gt; `./project/data.csv` or `project/data.csv` - This relative path assumes the current directory is `/home/user/documents/`. It points to a subdirectory `project` within the current directory, and then to the file `data.csv` within `project`. `../images/logo.png` - This relative path goes up one level from the current directory (`/home/user/documents/` to `/home/user/`) and then into the `images` directory to find `logo.png`.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A computer system has a set of five processes P1, P2, P3, P4 and Ps on the queue and which arrive at time 0, in that order. Each of the processes has a CPU burst time as shown in Table 1. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Table 1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;Burst time(ms)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P1&lt;/td&gt;
&lt;td data-label=&quot;Burst time(ms)&quot;&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P2&lt;/td&gt;
&lt;td data-label=&quot;Burst time(ms)&quot;&gt;25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P3&lt;/td&gt;
&lt;td data-label=&quot;Burst time(ms)&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P4&lt;/td&gt;
&lt;td data-label=&quot;Burst time(ms)&quot;&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P5&lt;/td&gt;
&lt;td data-label=&quot;Burst time(ms)&quot;&gt;15&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Determine each of the following:&lt;/p&gt;
&lt;p&gt;(i) the average waiting time, assuming non-preemptive shortest job first scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Average waiting time using Non-Preemptive Shortest Job First (SJF)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process Execution Order (SJF - Non-Preemptive):&lt;/strong&gt; P3 (6ms), P4 (9ms), P1 (12ms), P5 (15ms), P2 (25ms)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[P3(6)] [P4(15)] [P1(27)] [P5(42)] [P2(67)]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P3: 6ms&lt;/p&gt;
&lt;p&gt;P4: 6 + 9 = 15ms&lt;/p&gt;
&lt;p&gt;P1: 15 + 12 = 27ms&lt;/p&gt;
&lt;p&gt;P5: 27 + 15 = 42ms&lt;/p&gt;
&lt;p&gt;P2: 42 + 25 = 67ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Turnaround Times (TAT) = Completion Time - Arrival Time (Arrival Time = 0 for all processes):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TAT(P3) = 6ms&lt;/p&gt;
&lt;p&gt;TAT(P4) = 15ms&lt;/p&gt;
&lt;p&gt;TAT(P1) = 27ms&lt;/p&gt;
&lt;p&gt;TAT(P5) = 42ms&lt;/p&gt;
&lt;p&gt;TAT(P2) = 67ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting Times (WT) = Turnaround Time - Burst Time:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WT(P3) = 6 - 6 = 0ms&lt;/p&gt;
&lt;p&gt;WT(P4) = 15 - 9 = 6ms&lt;/p&gt;
&lt;p&gt;WT(P1) = 27 - 12 = 15ms&lt;/p&gt;
&lt;p&gt;WT(P5) = 42 - 15 = 27ms&lt;/p&gt;
&lt;p&gt;WT(P2) = 67 - 25 = 42ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Waiting Time = (WT(P1) + WT(P2) + WT(P3) + WT(P4) + WT(P5)) / 5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Average Waiting Time = (15 + 42 + 0 + 6 + 27) / 5 = 90 / 5 = 18ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The average waiting time for Non-Preemptive SJF is 18ms.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) the waiting time for processes p1, p3 and ps assuming first come first served scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Waiting time for P1, P3, and P5 using First Come First Served (FCFS)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process Execution Order (FCFS - Arrival Order):&lt;/strong&gt; P1, P2, P3, P4, P5&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[P1(12)] [P2(37)] [P3(43)] [P4(52)] [P5(67)]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P1: 12ms&lt;/p&gt;
&lt;p&gt;P2: 12 + 25 = 37ms&lt;/p&gt;
&lt;p&gt;P3: 37 + 6 = 43ms&lt;/p&gt;
&lt;p&gt;P4: 43 + 9 = 52ms&lt;/p&gt;
&lt;p&gt;P5: 52 + 15 = 67ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting Times (WT) = Turnaround Time - Burst Time (Arrival Time = 0 for all processes):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WT(P1) = 12 - 12 = 0ms&lt;/p&gt;
&lt;p&gt;WT(P3) = 43 - 6 = 37ms&lt;/p&gt;
&lt;p&gt;WT(P5) = 67 - 15 = 52ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting time for P1 is 0ms, for P3 is 37ms, and for P5 is 52ms.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a schematic diagram, describe swapping technique, assuming two processes are run on a round-robin scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Swapping Technique with Round-Robin Scheduling&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swapping&lt;/strong&gt; is a memory management technique used in operating systems to handle processes that exceed the available main memory (RAM). It involves moving processes between main memory and secondary storage (disk). In the context of Round-Robin scheduling with two processes (Process A and Process B), the swapping technique works as follows:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic Diagram:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-----------------+     +-----------------+
|   Main Memory   |     | Secondary Storage|
+-----------------+     +-----------------+
| Process A (RAM) | &amp;lt;---&amp;gt; | Process B (Disk)|
|     ...         |     |     ...         |
+-----------------+     +-----------------+
    CPU
     ^
     |
+--------+
| Kernel |
+--------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Swapping Process:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Time Quantum Allocation (Round-Robin):&lt;/strong&gt; The Round-Robin algorithm assigns a fixed time quantum to each process. Let's say the time quantum is 'q'. Initially, Process A is loaded into main memory and gets CPU time for 'q' milliseconds. If Process A does not complete within 'q', it gets preempted.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Swapping (Out):&lt;/strong&gt; When Process A's time quantum expires or it needs to wait for I/O, the operating system's scheduler decides to switch to Process B. Before Process B can run, Process A is swapped out of main memory and onto secondary storage (disk). This means the entire memory image of Process A (or relevant parts) is written to a swap space on disk.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Process Swapping (In):&lt;/strong&gt; Process B, which was residing on secondary storage, is then swapped into main memory. The operating system loads the memory image of Process B from the disk into RAM. Now, Process B is ready to run.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Context Switching and Execution:&lt;/strong&gt; A context switch occurs to save the state of Process A and restore the state of Process B. The CPU then starts executing Process B for its allocated time quantum 'q'.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Cycle Repetition:&lt;/strong&gt; This process repeats. When Process B's time quantum is over, if Process A is ready to run again (and has been swapped out earlier), Process B will be swapped out to disk, and Process A will be swapped back into main memory. The cycle continues, allowing both processes to take turns executing on the CPU in a round-robin fashion, even if the total memory requirement exceeds the available RAM. The swapping mechanism allows for the execution of processes larger than the available physical memory by trading off disk I/O for memory space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Consider the following system resources to answer the question that follows:&lt;/p&gt;
&lt;p&gt;Loader, DRAM, driver, android, windows vista, disk, memory stick, interpreter&lt;/p&gt;
&lt;p&gt;Classify the resources under either hardware or software.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Hardware Resources:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;DRAM (Dynamic Random Access Memory)&lt;/strong&gt;: This is a type of &lt;strong&gt;hardware memory&lt;/strong&gt; used as main memory in computers.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Disk&lt;/strong&gt;: A &lt;strong&gt;disk&lt;/strong&gt; (Hard Disk Drive or Solid State Drive) is a &lt;strong&gt;hardware storage device&lt;/strong&gt; used for persistent data storage.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Memory Stick&lt;/strong&gt;: A &lt;strong&gt;memory stick&lt;/strong&gt; (USB flash drive) is a portable &lt;strong&gt;hardware storage device&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Software Resources:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Loader&lt;/strong&gt;: A &lt;strong&gt;loader&lt;/strong&gt; is a &lt;strong&gt;software program&lt;/strong&gt; that loads programs and libraries into main memory for execution.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Driver&lt;/strong&gt;: A &lt;strong&gt;driver&lt;/strong&gt; is a &lt;strong&gt;software program&lt;/strong&gt; that controls a particular type of device connected to the computer, such as a disk drive or network card.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Android&lt;/strong&gt;: &lt;strong&gt;Android&lt;/strong&gt; is a mobile &lt;strong&gt;operating system software&lt;/strong&gt; developed by Google.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Windows Vista&lt;/strong&gt;: &lt;strong&gt;Windows Vista&lt;/strong&gt; is a desktop &lt;strong&gt;operating system software&lt;/strong&gt; developed by Microsoft.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Interpreter&lt;/strong&gt;: An &lt;strong&gt;interpreter&lt;/strong&gt; is a &lt;strong&gt;software program&lt;/strong&gt; that executes program instructions line by line (e.g., Python interpreter).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Distinguish between the functions of long term and short term schedulers in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Long-Term Scheduler (Job Scheduler):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;long-term scheduler&lt;/strong&gt;, also known as the job scheduler, controls the &lt;strong&gt;degree of multiprogramming&lt;/strong&gt; – the number of processes in memory. Its primary function is to &lt;strong&gt;select processes from a job pool and load them into memory for execution&lt;/strong&gt;. It is invoked infrequently, typically when a process finishes, and it aims to balance the mix of processes (e.g., CPU-bound vs. I/O-bound) in the system to optimize resource utilization and system performance. The long-term scheduler influences system stability and resource allocation over longer time scales.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Short-Term Scheduler (CPU Scheduler):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;short-term scheduler&lt;/strong&gt;, also known as the CPU scheduler, is responsible for &lt;strong&gt;selecting one process from the ready queue and allocating the CPU to it&lt;/strong&gt;. It is invoked very frequently (milliseconds) whenever an event occurs that might lead to process switching (e.g., timer interrupts, I/O completion). Its main objective is to &lt;strong&gt;maximize CPU utilization and system throughput while minimizing response time and turnaround time&lt;/strong&gt;. The short-term scheduler directly impacts the system's responsiveness and the efficiency of CPU usage on a very short time scale.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction:&lt;/strong&gt; The long-term scheduler manages the flow of processes into the ready queue (memory), while the short-term scheduler manages the flow of processes onto the CPU from the ready queue.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Explain three functions of buffers as used in I/O device management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed Mismatch Handling&lt;/strong&gt;: Buffers are used to &lt;strong&gt;cope with speed mismatches between different components&lt;/strong&gt; of a computer system, particularly between fast CPUs and slower I/O devices. For example, when data is transferred from a disk to memory, or from memory to a printer, the I/O device operates at a slower rate than the CPU and memory. A buffer acts as a temporary holding area, allowing the faster component to transfer data quickly to the buffer and continue with other tasks, while the slower component can retrieve data from the buffer at its own pace. This prevents the faster component from being stalled waiting for the slower one.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Size Adaptation&lt;/strong&gt;: Buffers help in &lt;strong&gt;adapting data sizes between producers and consumers&lt;/strong&gt;. I/O devices and processes might produce or consume data in different sized chunks. For instance, a network interface may receive data in packets of varying sizes, while an application process might need data in fixed-size blocks. A buffer can accumulate data until a block of the required size is formed before passing it to the consumer, or it can break down large blocks of data into smaller units suitable for the producer. This simplifies data handling and processing for both sides of the communication.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Support for Copy Semantics&lt;/strong&gt;: Buffers are essential for &lt;strong&gt;supporting copy semantics in data transfer&lt;/strong&gt;. When data is read from or written to a buffer, it creates a copy of the data. This is important in scenarios where the source of data might change while it's being processed or transmitted. By using a buffer, the system ensures that the consumer works with a consistent snapshot of the data, even if the original data source is modified concurrently. This is crucial for maintaining data integrity and preventing race conditions in I/O operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) During large data transfers, computers use Direct Memory Access controllers to avoid burdening the main CPU with programmable I/O. Describe this procedure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Direct Memory Access (DMA) Procedure for Large Data Transfers&lt;/strong&gt;:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;DMA Request Initiation&lt;/strong&gt;: When a process needs to perform a large data transfer (e.g., reading a large file from disk), it initiates an I/O request. Instead of the CPU handling each byte of data transfer using programmed I/O, the process signals the DMA controller to manage the data transfer directly.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;DMA Controller Setup&lt;/strong&gt;: The CPU sets up the DMA transfer by providing the DMA controller with the following information: * &lt;strong&gt;Source Address&lt;/strong&gt;: The starting address of the data to be transferred from the I/O device (e.g., disk buffer). * &lt;strong&gt;Destination Address&lt;/strong&gt;: The starting address in main memory where the data should be written to or read from. * &lt;strong&gt;Transfer Length (Count)&lt;/strong&gt;: The number of bytes or blocks to be transferred. * &lt;strong&gt;Transfer Mode&lt;/strong&gt;: Read or Write operation, and other control flags.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;CPU Relinquishes Bus Control&lt;/strong&gt;: Once the DMA transfer is set up, the CPU signals the DMA controller to start the transfer and relinquishes control of the system bus (address bus, data bus, and control bus). The CPU can then proceed with other tasks or processes, effectively offloading the data transfer operation.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;DMA Transfer Execution&lt;/strong&gt;: The DMA controller takes over control of the system bus and directly transfers data between the I/O device and main memory without CPU intervention. For each byte or block of data, the DMA controller performs the following steps: * Requests bus access from the bus controller. * Once granted, it reads data from the source address (I/O device or memory). * Writes the data to the destination address (memory or I/O device). * Increments the source and destination addresses and decrements the transfer count.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Transfer Completion and CPU Notification&lt;/strong&gt;: The DMA controller continues the data transfer until the specified number of bytes has been transferred. Upon completion of the transfer, the DMA controller notifies the CPU by sending an interrupt signal. This interrupt signals to the CPU that the DMA transfer is complete, and the data is now available in main memory (for read operations) or has been sent to the I/O device (for write operations).&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;&lt;strong&gt;CPU Resumes Operation&lt;/strong&gt;: The CPU, upon receiving the DMA completion interrupt, can now resume processing the data that has been transferred. Because the CPU was not involved in the byte-by-byte transfer, it was free to perform other computations concurrently, significantly improving system performance, especially for large data I/O operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline four causes of file system failure in a computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hardware Failures&lt;/strong&gt;: &lt;strong&gt;Hardware failures&lt;/strong&gt;, particularly in storage devices like hard drives or SSDs, are a primary cause of file system failure. Disk crashes, head failures, sector errors, or controller malfunctions can lead to data corruption or loss, rendering parts or all of the file system inaccessible or inconsistent. Physical damage to storage media due to power surges, overheating, or mechanical issues can also cause failures.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Software Errors&lt;/strong&gt;: &lt;strong&gt;Software errors&lt;/strong&gt; within the operating system or file system drivers can lead to corruption or inconsistencies in the file system structure. Bugs in file system implementation, improper handling of disk operations, or errors during system updates can cause metadata corruption, lost files, or directory structure damage. File system utilities themselves, if faulty, can also lead to failures during operations like formatting or repair.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Power Outages and System Crashes&lt;/strong&gt;: &lt;strong&gt;Abrupt power outages or system crashes&lt;/strong&gt; while file system operations are in progress can leave the file system in an inconsistent state. If metadata updates (like directory entries, inodes, or file allocation tables) are interrupted mid-write, the file system structure on disk might become corrupted, leading to data loss or file system errors upon reboot. Unclean shutdowns are a common cause of file system problems.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Human Error&lt;/strong&gt;: &lt;strong&gt;Human error&lt;/strong&gt;, such as accidental deletion of critical system files, incorrect file permissions leading to access issues, or improper use of file system utilities (e.g., formatting the wrong partition), can result in file system failures. User actions that unintentionally modify or damage file system structures can also lead to data loss or system instability. Lack of proper backup and recovery procedures can exacerbate the impact of human errors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Priority scheduling algorithm is one of the techniques the operating system use in job scheduling.&lt;/p&gt;
&lt;p&gt;(i) Describe one problem associated with this algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Problem with Priority Scheduling: Starvation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;One significant problem associated with priority scheduling is &lt;strong&gt;starvation&lt;/strong&gt;. Starvation occurs when &lt;strong&gt;low-priority processes are indefinitely blocked from running because higher-priority processes continuously arrive and get executed&lt;/strong&gt;. If there is a constant stream of high-priority jobs, lower-priority jobs may never get a chance to run, effectively being starved of CPU time. This can lead to unfair resource allocation and prevent essential low-priority tasks from being completed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain a solution to the problem in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Solution to Starvation: Aging&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A common solution to the starvation problem in priority scheduling is &lt;strong&gt;aging&lt;/strong&gt;. &lt;strong&gt;Aging is a technique that gradually increases the priority of processes that have been waiting in the ready queue for a long time&lt;/strong&gt;. Over time, even low-priority processes will have their priority increased enough to eventually become the highest priority process and get scheduled to run. This ensures that no process is indefinitely postponed and provides a form of fairness in priority scheduling. Aging can be implemented by periodically increasing the priority level of waiting processes based on their waiting time. For example, every certain time interval, the priority of each waiting process is increased by a small amount. This ensures that eventually, even the lowest priority process will have a high enough priority to be executed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) The first-fit strategy for memory allocation suffers from the problem of external fragmentation. Describe a solution to this problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Solution to External Fragmentation for First-Fit: Compaction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A primary solution to the problem of external fragmentation, particularly when using first-fit memory allocation, is &lt;strong&gt;compaction&lt;/strong&gt;. &lt;strong&gt;Compaction is a memory management technique that rearranges processes in memory to consolidate the free space into larger contiguous blocks&lt;/strong&gt;. When external fragmentation becomes severe (i.e., many small, non-contiguous blocks of free memory), the operating system can perform compaction. This involves moving all allocated memory blocks to one end of the memory space, leaving all the free memory together in one large block at the other end.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compaction Process:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Identify Movable Blocks&lt;/strong&gt;: The system needs to identify which memory blocks can be relocated. Typically, code and data segments of processes are relocatable.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Relocate Processes&lt;/strong&gt;: Processes are moved in memory such that they become contiguous, and all free space is grouped together. This may involve adjusting process address tables and pointers to reflect the new memory locations.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Update Memory Management Data Structures&lt;/strong&gt;: After relocation, the memory management data structures (e.g., free lists, bitmaps) are updated to reflect the new layout of allocated and free memory. Compaction effectively eliminates external fragmentation by creating larger contiguous blocks of free memory, making it possible to allocate memory for larger processes that could not be accommodated before due to fragmentation. However, compaction is a costly operation as it involves moving potentially large amounts of data in memory, which can lead to system performance overhead. It is typically performed only when memory fragmentation becomes a critical issue.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) A system disk has been diagnosed to be having low access speed. Explain three ways in which the operating system could improve the performance of such a disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Disk Caching&lt;/strong&gt;: Implementing &lt;strong&gt;disk caching&lt;/strong&gt; can significantly improve disk access speed. Disk caching involves using a portion of main memory (RAM) as a cache to store frequently accessed disk blocks. When a read request comes, the operating system first checks if the requested data is in the cache. If it is (cache hit), the data is served directly from the faster RAM, avoiding the slower disk access. For write operations, write-back caching can be used, where data is initially written to the cache and later flushed to disk, allowing for faster write operations as well. Effective caching algorithms (like LRU or FIFO) can drastically reduce the average disk access time by serving a high percentage of requests from the cache.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Disk Scheduling Algorithms&lt;/strong&gt;: Employing efficient &lt;strong&gt;disk scheduling algorithms&lt;/strong&gt; can optimize the order in which disk I/O requests are serviced, thereby reducing seek time and rotational latency. Algorithms like SSTF (Shortest Seek Time First), SCAN (Elevator), and C-SCAN aim to minimize the head movement across the disk surface. By servicing requests in an optimized sequence, these algorithms reduce the total time spent in disk head movements, leading to faster overall disk access and improved throughput. Selecting the appropriate scheduling algorithm based on the workload characteristics can significantly enhance disk performance.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;File System Optimization and Defragmentation&lt;/strong&gt;: The operating system can improve disk performance through &lt;strong&gt;file system optimization and defragmentation&lt;/strong&gt;. Over time, file systems can become fragmented, meaning that files are stored in non-contiguous blocks across the disk. This increases seek time as the disk head has to move to different physical locations to read a single file. Defragmentation tools reorganize files on the disk to make them contiguous, reducing fragmentation. Additionally, optimizing file system structures (e.g., efficient directory organization, metadata management) can also improve file access times. Regular file system maintenance, including defragmentation and error checking, can help maintain optimal disk performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline two examples for each of the following types of interrupts within a computer system:&lt;/p&gt;
&lt;p&gt;(i) external;&lt;/p&gt;
&lt;p&gt;(ii) internal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) External Interrupts&lt;/strong&gt;:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hardware Device Interrupts&lt;/strong&gt;: &lt;strong&gt;Hardware device interrupts&lt;/strong&gt; are generated by I/O devices to signal the CPU about an event that requires attention. Examples include a &lt;strong&gt;keyboard interrupt&lt;/strong&gt;, generated when a key is pressed, signaling the CPU to process the keystroke, or a &lt;strong&gt;network interface card (NIC) interrupt&lt;/strong&gt;, indicating that a network packet has arrived and needs to be processed.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Timer Interrupts&lt;/strong&gt;: &lt;strong&gt;Timer interrupts&lt;/strong&gt; are generated by a hardware timer at regular intervals. These interrupts are used by the operating system for time management tasks, such as &lt;strong&gt;time-slicing in process scheduling&lt;/strong&gt;, where the timer interrupt preempts the currently running process after a time quantum, or for &lt;strong&gt;maintaining the system clock&lt;/strong&gt; and scheduling periodic tasks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Internal Interrupts (Traps)&lt;/strong&gt;:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;System Calls (Software Interrupts)&lt;/strong&gt;: &lt;strong&gt;System calls&lt;/strong&gt; are &lt;strong&gt;software-generated interrupts&lt;/strong&gt; that occur when a user program needs to request a service from the operating system kernel. For instance, when a program wants to &lt;strong&gt;open a file&lt;/strong&gt; or &lt;strong&gt;allocate memory&lt;/strong&gt;, it executes a system call instruction, which triggers an internal interrupt, transferring control to the kernel to handle the request.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Exceptions (Faults and Traps)&lt;/strong&gt;: &lt;strong&gt;Exceptions&lt;/strong&gt; are internal interrupts triggered by error conditions or exceptional situations during program execution. Examples include &lt;strong&gt;page faults&lt;/strong&gt;, which occur when a program tries to access a memory page that is not currently in RAM, or &lt;strong&gt;division by zero errors&lt;/strong&gt;, which occur when a program attempts to divide a number by zero. These exceptions cause the CPU to transfer control to an exception handler within the operating system to manage the error condition.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) With the aid of a diagram, describe three of the layered structures of a file system as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Layered Structures of a File System&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;File systems in operating systems are typically organized in a layered structure to manage complexity and provide modularity. Here are three common layers:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic Diagram of Layered File System:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-------------------------+  &amp;lt;-- User Applications
|     User Interface      |
+-------------------------+
             | System Calls (e.g., read(), write(), open())
             V
+-------------------------+
|  Logical File System    |  &amp;lt;-- Directory structure, file naming, permissions
+-------------------------+
             | Logical Block Addresses, File Metadata
             V
+-------------------------+
| File Organization Module|  &amp;lt;-- Translates logical to physical addresses, manages free space
+-------------------------+
             | Physical Block Addresses, Disk Commands
             V
+-------------------------+
|   Basic File System     |  &amp;lt;-- Issues commands to disk driver, manages buffers and caches
+-------------------------+
             | Raw Disk Blocks
             V
+-------------------------+
|     I/O Control         |  &amp;lt;-- Disk driver, hardware interaction
+-------------------------+  &amp;lt;-- Disk Hardware
&lt;/pre&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Logical File System Layer&lt;/strong&gt;: This layer is concerned with &lt;strong&gt;logical file operations&lt;/strong&gt; and the &lt;strong&gt;user's view of the file system&lt;/strong&gt;. It manages file metadata, such as file names, directory structures, permissions, and file attributes. It translates file operations (like `open`, `read`, `write`, `delete`) requested by user applications into a sequence of lower-level operations. This layer is responsible for maintaining the file system's logical structure and enforcing access control policies. It operates in terms of logical block addresses and file identifiers, abstracting away the physical disk layout.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File Organization Module (or File System Implementation Layer)&lt;/strong&gt;: This layer is responsible for &lt;strong&gt;mapping logical file blocks to physical disk blocks&lt;/strong&gt;. It manages the physical storage space on the disk, including free space management, allocation of disk blocks to files, and keeping track of file locations on disk. It translates logical block addresses provided by the logical file system layer into physical block addresses that the disk hardware can understand. This layer implements the specific file allocation method (e.g., contiguous, linked, indexed) and is crucial for efficient disk space utilization and file access performance. It often includes buffer and cache management to optimize disk I/O.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Basic File System (or I/O Control Layer)&lt;/strong&gt;: This is the &lt;strong&gt;lowest layer of the file system hierarchy&lt;/strong&gt; and directly interacts with the disk hardware through the device driver. It is responsible for &lt;strong&gt;issuing commands to the disk controller&lt;/strong&gt; to perform physical I/O operations (read and write sectors). This layer handles the physical transfer of data between memory and disk. It also manages I/O buffers and caches at the hardware level to improve performance. The basic file system layer abstracts away the hardware specifics of the disk device and provides a uniform interface for higher layers to interact with the storage hardware. It is closely tied to the device driver for the specific disk hardware in use.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Differentiate between deadlock avoidance and deadlock prevention as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Deadlock Prevention&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deadlock prevention&lt;/strong&gt; aims to &lt;strong&gt;prevent deadlocks by ensuring that at least one of the necessary conditions for deadlock cannot hold&lt;/strong&gt;. These conditions are mutual exclusion, hold and wait, no preemption, and circular wait. Prevention strategies work by &lt;strong&gt;restricting resource allocation&lt;/strong&gt; or process behavior in a way that violates at least one of these conditions. For example, to prevent &quot;hold and wait,&quot; a system might require processes to request all necessary resources at once before starting execution. Prevention is a proactive approach applied at the system design level to avoid deadlocks from ever occurring. However, prevention methods can often lead to lower resource utilization and reduced system throughput as they impose restrictions on resource usage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deadlock Avoidance&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deadlock avoidance&lt;/strong&gt; allows all four deadlock conditions to potentially exist, but it makes &lt;strong&gt;dynamic decisions about resource allocation to ensure that the system never enters a deadlock state&lt;/strong&gt;. Avoidance algorithms require the operating system to have &lt;strong&gt;advance information about the maximum resource requirements of each process&lt;/strong&gt;. Using this information, the system checks if granting a resource request would lead to a &quot;safe state.&quot; A safe state is one in which there is at least one execution order of all processes that allows them all to complete without deadlock. Avoidance algorithms, like the Banker's Algorithm, dynamically examine the resource allocation state and grant resources only if the resulting state is safe. Avoidance is more flexible than prevention but requires more overhead for runtime checking and advance knowledge of process resource needs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Prevention focuses on removing the possibility of deadlock conditions statically, while avoidance focuses on making runtime decisions to keep the system in a safe state, thus preventing deadlocks dynamically.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Explain two circumstances under which a preemptive scheduling decision would be made by the operating system during inter-process communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Higher Priority Process Arrival&lt;/strong&gt;: In a preemptive priority scheduling system, if a &lt;strong&gt;higher-priority process becomes ready to run&lt;/strong&gt; (e.g., it arrives in the ready queue or becomes unblocked), the operating system will make a preemptive scheduling decision. The currently running, lower-priority process will be &lt;strong&gt;preempted&lt;/strong&gt; (interrupted and its state saved), and the CPU will be allocated to the newly ready, higher-priority process. This ensures that high-priority processes get immediate attention and reduces their response time, which is crucial in real-time systems or when handling urgent tasks. Preemption based on priority is a common mechanism in many preemptive scheduling algorithms.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Time Quantum Expiration in Round Robin&lt;/strong&gt;: When using &lt;strong&gt;Round Robin scheduling&lt;/strong&gt;, each process is given a fixed time quantum to execute. If a process is still running when its time quantum expires, a &lt;strong&gt;preemptive scheduling decision is made&lt;/strong&gt;. The operating system preempts the currently running process, saves its state, and moves it to the back of the ready queue. Then, the next process in the ready queue is scheduled to run for its time quantum. Time quantum expiration is a fundamental trigger for preemption in Round Robin, ensuring fairness and preventing any single process from monopolizing the CPU for too long in a time-shared environment.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Explain two disadvantages associated with linked file allocation method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential Access for Direct Access Files&lt;/strong&gt;: &lt;strong&gt;Linked allocation&lt;/strong&gt; is inefficient for direct (random) access files. To access a block in the middle or at the end of a file, it's necessary to traverse the linked list of blocks from the beginning of the file. This results in &lt;strong&gt;sequential access performance&lt;/strong&gt; even when direct access is desired, leading to slow access times for applications that require random file access patterns. For example, to read the 100th block of a file, the system must read the preceding 99 blocks to follow the pointers, which is highly inefficient compared to contiguous or indexed allocation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Overhead for Disk Space and I/O Operations&lt;/strong&gt;: Linked allocation introduces &lt;strong&gt;overhead in terms of disk space and I/O operations&lt;/strong&gt; due to the storage of pointers. Each block of a file must contain a pointer to the next block, which reduces the amount of space available for actual data in each block. Additionally, reading a file involves following pointers from block to block, which can require &lt;strong&gt;multiple disk I/O operations&lt;/strong&gt; to fetch the pointers themselves. This overhead can decrease the effective storage capacity and increase the overall I/O time, especially for files that are highly fragmented or spread across many non-contiguous blocks. Pointer maintenance and retrieval add extra steps to file operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Distinguish between page and frame as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Page&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;page&lt;/strong&gt; is a &lt;strong&gt;fixed-size block of logical memory&lt;/strong&gt;. It is a unit of memory as seen by the process or the virtual address space. When a program is executed, its logical address space is divided into pages of equal size. Pages are a concept within the &lt;strong&gt;virtual memory system&lt;/strong&gt;. They are logical divisions and are used to organize the program's address space. The size of a page is typically a power of 2 (e.g., 4KB, 8KB) and is defined by the operating system and hardware architecture. Processes operate with pages, and the operating system manages memory in terms of pages.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Frame&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;frame&lt;/strong&gt; is a &lt;strong&gt;fixed-size block of physical memory (RAM)&lt;/strong&gt;. It is a unit of memory in the physical address space. Physical memory is divided into frames of the same size as pages. Frames are the actual physical locations in RAM where pages can be loaded. When a page of a process needs to be loaded into physical memory, it is placed into a frame. Frames are part of the &lt;strong&gt;physical memory organization&lt;/strong&gt;. The operating system maintains a mapping between pages (logical addresses) and frames (physical addresses) using page tables. The number of frames is determined by the amount of physical RAM available in the system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction:&lt;/strong&gt; Pages are logical units of memory in the virtual address space, while frames are physical units of memory in RAM. The operating system maps pages to frames to enable virtual memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A deadlock can be eliminated by either of the following methods:&lt;/p&gt;
&lt;p&gt;(i) aborting deadlocked processes all at once;&lt;/p&gt;
&lt;p&gt;(ii) aborting one process at a time until the deadlock is eliminated.&lt;/p&gt;
&lt;p&gt;Describe a disadvantage associated with each elimination method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Aborting Deadlocked Processes All at Once - Disadvantage: Significant Work Loss&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The major disadvantage of &lt;strong&gt;aborting all deadlocked processes at once&lt;/strong&gt; is the potential for &lt;strong&gt;significant work loss&lt;/strong&gt;. When all processes involved in a deadlock are terminated abruptly, any computations they have performed up to that point are lost. If these processes have been running for a long time or have performed critical operations, restarting them from the beginning can lead to a considerable waste of CPU time, resources, and user effort. It is a drastic measure that sacrifices all progress made by the deadlocked processes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Aborting One Process at a Time Until Deadlock is Eliminated - Disadvantage: Repeated Overhead and Potential Starvation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The disadvantage of &lt;strong&gt;aborting one process at a time until the deadlock is resolved&lt;/strong&gt; is the &lt;strong&gt;overhead of repeatedly checking for deadlock and aborting processes&lt;/strong&gt;. After aborting a process, the system needs to re-evaluate if the deadlock is resolved. If not, another process must be chosen and aborted, and the check is repeated. This iterative process can be &lt;strong&gt;computationally expensive&lt;/strong&gt; and time-consuming. Furthermore, there's a risk of &lt;strong&gt;choosing the same process repeatedly for abortion&lt;/strong&gt; if the deadlock situation is complex or if the process is frequently involved in deadlocks, potentially leading to starvation for that particular process. Selecting the 'right' process to abort to efficiently resolve the deadlock is also a non-trivial problem, and poor choices can prolong the deadlock resolution process and increase overhead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Distinguish between each of the following process states as used in process control:&lt;/p&gt;
&lt;p&gt;(i) running state and ready state;&lt;/p&gt;
&lt;p&gt;(ii) blocked state and terminated state.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Running State vs. Ready State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Running State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A process is in the &lt;strong&gt;running state&lt;/strong&gt; when it is &lt;strong&gt;currently being executed by the CPU&lt;/strong&gt;. At any given moment, on a single-processor system, there is at most one process in the running state. The process in the running state is actively using the CPU to execute its instructions. It has been selected by the short-term scheduler to be dispatched to the CPU. The transition to the running state occurs when the scheduler selects a process from the ready queue and allocates the CPU to it. A process continues in the running state until it completes its CPU burst, gets preempted, or blocks for an event.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ready State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A process is in the &lt;strong&gt;ready state&lt;/strong&gt; when it is &lt;strong&gt;prepared and waiting to be executed by the CPU&lt;/strong&gt;, but the CPU is currently allocated to another process. Processes in the ready state are in memory and are eligible to run. They are waiting for their turn to be assigned to the CPU by the short-term scheduler. Processes enter the ready state after they are admitted into the system, after completing an I/O operation, or after being preempted from the running state. The ready state forms a queue (ready queue) from which the scheduler selects the next process to run based on the scheduling algorithm.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction (Running vs. Ready):&lt;/strong&gt; A process in the running state is actively using the CPU, while a process in the ready state is waiting to use the CPU and is eligible to be run as soon as the CPU becomes available.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Blocked State vs. Terminated State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Blocked State (Waiting State)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A process is in the &lt;strong&gt;blocked state&lt;/strong&gt;, also known as the waiting state, when it is &lt;strong&gt;waiting for some event to occur before it can proceed&lt;/strong&gt;. This event is typically an external event, such as the completion of an I/O operation (e.g., disk read/write, network data arrival), or the release of a resource it has requested (e.g., semaphore, lock). While in the blocked state, a process cannot use the CPU, even if it is available. Processes transition to the blocked state when they initiate an operation that requires waiting, such as an I/O request or a synchronization operation. They remain in the blocked state until the event they are waiting for occurs, at which point they typically transition to the ready state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Terminated State (Completed State)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A process is in the &lt;strong&gt;terminated state&lt;/strong&gt;, also known as the completed or finished state, when it has &lt;strong&gt;finished its execution and is no longer active&lt;/strong&gt;. Once a process has completed its final instruction and exited, it enters the terminated state. In this state, the process is no longer eligible to run and its resources (memory, CPU time, etc.) are typically deallocated and returned to the system. The operating system reclaims the resources held by the terminated process. From the terminated state, a process cannot transition to any other state; it is the final state of a process's lifecycle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction (Blocked vs. Terminated):&lt;/strong&gt; A process in the blocked state is temporarily inactive and waiting for an event to continue execution, while a process in the terminated state has completed its execution and is no longer active or waiting.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;footer&gt;©2017 The Kenya National Examinations Council&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="32"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <none></none>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="6"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="33"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="6"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202017"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="36">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2017"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="34">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="35">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="129_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="34"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2017&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following file allocation methods:&lt;/p&gt;
&lt;p&gt;(i) contiguous;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Contiguous Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;contiguous allocation&lt;/strong&gt;, each file occupies a set of &lt;strong&gt;adjacent blocks&lt;/strong&gt; on the disk. The disk blocks are allocated to a file in a contiguous manner. This means that if a file requires 'n' blocks of disk space, then 'n' contiguous blocks are allocated to it. The disk address of the first block and the number of blocks allocated are recorded in the directory entry for that file. This method simplifies file access and provides good performance for sequential file access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) linked.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Linked Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;linked allocation&lt;/strong&gt;, each file is a &lt;strong&gt;linked list of disk blocks&lt;/strong&gt;. The blocks allocated to a file may be scattered anywhere on the disk. Each block contains data and a pointer to the next block in the file. The directory entry for a file contains a pointer to the first block of the file. Following the pointers in each block leads to the subsequent blocks of the file. This method eliminates external fragmentation and allows files to grow dynamically, but it is less efficient for direct access due to the need to traverse the linked list.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Outline two approaches that could be used to improve computer file performance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Disk Caching&lt;/strong&gt;: Implementing &lt;strong&gt;disk caching&lt;/strong&gt; can significantly improve file access performance. Disk caching uses a portion of main memory (RAM) to store frequently accessed file blocks. When a file is accessed, the system first checks the cache. If the data is found in the cache (cache hit), it is retrieved much faster from RAM than from the disk. This reduces the average access time and improves overall file system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File System Defragmentation&lt;/strong&gt;: &lt;strong&gt;File system defragmentation&lt;/strong&gt; reorganizes files on the disk to store them in contiguous blocks. Over time, files can become fragmented, meaning their blocks are scattered across the disk. Defragmentation reduces seek times because the disk head needs to move less to read a file. This leads to faster file access and improved file system performance, especially for frequently used files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Four jobs were scheduled as follows: 7 minutes, 3 minutes, 5 minutes and 2 minutes. Compare the turnaround times using each of the following scheduling algorithms:&lt;/p&gt;
&lt;p&gt;(i) Shortest Job First (SJF);&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Shortest Job First (SJF)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Jobs in order of burst time: 2, 3, 5, 7 minutes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt chart:&lt;/strong&gt; [Job 4 (2)] [Job 2 (5)] [Job 3 (10)] [Job 1 (17)]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Job 4: 2 minutes&lt;/p&gt;
&lt;p&gt;Job 2: 2 + 3 = 5 minutes&lt;/p&gt;
&lt;p&gt;Job 3: 5 + 5 = 10 minutes&lt;/p&gt;
&lt;p&gt;Job 1: 10 + 7 = 17 minutes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Turnaround times (TAT)&lt;/strong&gt; = Completion Time - Arrival Time (assuming arrival time is 0 for all jobs):&lt;/p&gt;
&lt;p&gt;TAT (Job 4) = 2 minutes&lt;/p&gt;
&lt;p&gt;TAT (Job 2) = 5 minutes&lt;/p&gt;
&lt;p&gt;TAT (Job 3) = 10 minutes&lt;/p&gt;
&lt;p&gt;TAT (Job 1) = 17 minutes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Turnaround Time (SJF)&lt;/strong&gt; = (2 + 5 + 10 + 17) / 4 = 34 / 4 = 8.5 minutes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) First Come First Served (FCFS).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) First Come First Served (FCFS)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Jobs in order of arrival: Job 1 (7), Job 2 (3), Job 3 (5), Job 4 (2) minutes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt chart:&lt;/strong&gt; [Job 1 (7)] [Job 2 (10)] [Job 3 (15)] [Job 4 (17)]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Job 1: 7 minutes&lt;/p&gt;
&lt;p&gt;Job 2: 7 + 3 = 10 minutes&lt;/p&gt;
&lt;p&gt;Job 3: 10 + 5 = 15 minutes&lt;/p&gt;
&lt;p&gt;Job 4: 15 + 2 = 17 minutes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Turnaround times (TAT)&lt;/strong&gt; = Completion Time - Arrival Time (assuming arrival time is 0 for all jobs):&lt;/p&gt;
&lt;p&gt;TAT (Job 1) = 7 minutes&lt;/p&gt;
&lt;p&gt;TAT (Job 2) = 10 minutes&lt;/p&gt;
&lt;p&gt;TAT (Job 3) = 15 minutes&lt;/p&gt;
&lt;p&gt;TAT (Job 4) = 17 minutes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Turnaround Time (FCFS)&lt;/strong&gt; = (7 + 10 + 15 + 17) / 4 = 49 / 4 = 12.25 minutes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Comparison:&lt;/strong&gt; The &lt;strong&gt;Shortest Job First (SJF)&lt;/strong&gt; algorithm has a &lt;strong&gt;lower average turnaround time (8.5 minutes)&lt;/strong&gt; compared to the &lt;strong&gt;First Come First Served (FCFS)&lt;/strong&gt; algorithm (12.25 minutes) for these jobs. SJF is generally better at minimizing turnaround time when job burst times are known in advance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Outline four computer files attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Name&lt;/strong&gt;: The &lt;strong&gt;name&lt;/strong&gt; is a human-readable identifier for the file, used to access and refer to the file within the file system. It's how users and applications identify a specific file. Naming conventions vary between operating systems, but typically include a base name and an extension.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Type&lt;/strong&gt;: The &lt;strong&gt;type&lt;/strong&gt; of a file indicates its format and intended use. File types can be identified by extensions (e.g., .txt, .jpg, .exe) or internal file headers. The operating system and applications use the file type to determine how to process the file's contents. Common types include text files, executable files, image files, and directories.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Location&lt;/strong&gt;: The &lt;strong&gt;location&lt;/strong&gt; attribute specifies where the file is stored within the directory structure of the file system. It is often represented as a path, indicating the sequence of directories to traverse to reach the file. The location is crucial for the operating system to find and access the file's data on the storage device.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Size&lt;/strong&gt;: The &lt;strong&gt;size&lt;/strong&gt; attribute indicates the current amount of storage space occupied by the file, typically measured in bytes, kilobytes, megabytes, or gigabytes. The size reflects the quantity of data stored in the file and is important for managing storage space and understanding file resource usage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (e) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(e) With the aid of a diagram in each case, describe two types of directory structures.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Single-Level Directory Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;single-level directory structure&lt;/strong&gt;, there is only one directory for all files in the system. All files are placed in this single directory. This is the simplest directory structure.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-----------------------+
| Root Directory        |
+-----------------------+
| File A                |
| File B                |
| File C                |
| ...                   |
| File N                |
+-----------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; All files are contained within one directory. It is easy to implement but leads to naming conflicts if multiple users or applications need to use the same file name. It also becomes difficult to organize and manage a large number of files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Two-Level Directory Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;two-level directory structure&lt;/strong&gt;, there is a master directory (root directory) and user directories under it. Each user has their own directory, and they can create files within their directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-----------------------+
| Root Directory        |
+-----------------------+
| User Directory 1      | --&amp;gt; | File 1A | File 1B | ... |
| User Directory 2      | --&amp;gt; | File 2A | File 2B | ... |
| User Directory 3      | --&amp;gt; | File 3A | File 3B | ... |
| ...                   |
| User Directory N      | --&amp;gt; | File NA | File NB | ... |
+-----------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Each user has their own user directory in the root directory. This structure resolves naming conflicts as each user has a separate namespace for their files. However, it still lacks flexibility for users to create subdirectories to further organize their files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) (i) State two modes of operations of programmable clocks as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;One-Shot Mode&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Square-Wave Mode&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two duties of an I/O control system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Driver Management&lt;/strong&gt;: The I/O control system is responsible for &lt;strong&gt;managing device drivers&lt;/strong&gt;. Device drivers are software modules that interface with specific hardware devices. The I/O control system loads, initializes, and unloads device drivers as needed. It provides a standardized interface for the operating system to communicate with diverse hardware devices, abstracting away the hardware-specific details. This includes handling driver installation, configuration, and updates to ensure proper communication between the OS and hardware.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;I/O Request Handling and Scheduling&lt;/strong&gt;: The I/O control system &lt;strong&gt;manages and schedules I/O requests&lt;/strong&gt; from various processes. When a process initiates an I/O operation, the request is routed to the I/O control system. This system then queues and schedules these requests based on various algorithms (e.g., priority, FCFS, SSTF for disks) to optimize I/O performance and fairness. It ensures that I/O operations are performed in an efficient order, minimizing latency and maximizing throughput. The I/O control system also handles issues like buffering and caching to further improve I/O efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) A disk has 40 cylinders. An initial request comes in to read a block on cylinder 6. New requests come in for cylinder 1, 31, 11, 29, 4 and 7 in that order.&lt;/p&gt;
&lt;p&gt;(i) Calculate the arm motions required using each of the following disk scheduling algorithms:&lt;/p&gt;
&lt;p&gt;I. Shortest Seek First (SSF);&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Shortest Seek First (SSF)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Initial head position: 6. Requests: 1, 31, 11, 29, 4, 7.&lt;/p&gt;
&lt;p&gt;Starting at 6, closest request is 7, then 4, then 1, then 11, then 29, then 31.&lt;/p&gt;
&lt;p&gt;Seek sequence: 6 -&amp;gt; 7 -&amp;gt; 4 -&amp;gt; 1 -&amp;gt; 11 -&amp;gt; 29 -&amp;gt; 31.&lt;/p&gt;
&lt;p&gt;Arm motions: |7-6| + |4-7| + |1-4| + |11-1| + |29-11| + |31-29|&lt;/p&gt;
&lt;p&gt;= 1 + 3 + 3 + 10 + 18 + 2 = 37 cylinders.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arm motions for SSF: 37 cylinders.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;II. First Come First Served (FCFS);&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;II. First Come First Served (FCFS)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Initial head position: 6. Requests in order: 1, 31, 11, 29, 4, 7.&lt;/p&gt;
&lt;p&gt;Seek sequence: 6 -&amp;gt; 1 -&amp;gt; 31 -&amp;gt; 11 -&amp;gt; 29 -&amp;gt; 4 -&amp;gt; 7.&lt;/p&gt;
&lt;p&gt;Arm motions: |1-6| + |31-1| + |11-31| + |29-11| + |4-29| + |7-4|&lt;/p&gt;
&lt;p&gt;= 5 + 30 + 20 + 18 + 25 + 3 = 101 cylinders.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arm motions for FCFS: 101 cylinders.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;III. SCAN.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;III. SCAN (Elevator)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Assuming SCAN moves towards cylinder 0 initially.&lt;/p&gt;
&lt;p&gt;Initial head position: 6. Requests: 1, 31, 11, 29, 4, 7.&lt;/p&gt;
&lt;p&gt;Moving towards 0: 6 -&amp;gt; 4 -&amp;gt; 1 -&amp;gt; 0 (turnaround) -&amp;gt; 7 -&amp;gt; 11 -&amp;gt; 29 -&amp;gt; 31.&lt;/p&gt;
&lt;p&gt;Seek sequence: 6 -&amp;gt; 4 -&amp;gt; 1 -&amp;gt; 7 -&amp;gt; 11 -&amp;gt; 29 -&amp;gt; 31.&lt;/p&gt;
&lt;p&gt;Arm motions: |4-6| + |1-4| + |7-1| + |11-7| + |29-11| + |31-29|&lt;/p&gt;
&lt;p&gt;= 2 + 3 + 6 + 4 + 18 + 2 = 35 cylinders.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arm motions for SCAN: 35 cylinders.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Represent graphically each of the disk scheduling algorithms in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Graphical Representation of Disk Scheduling Algorithms&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I. Shortest Seek First (SSF) Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;Cylinder: 0---1---2---3---4---5---6---7---8---9---10--11---...---29---30--31---...---40
          |       |       |   Start-&amp;gt;|-&amp;gt;7-&amp;gt;|-&amp;gt;4-&amp;gt;|-&amp;gt;1---------|--------&amp;gt;11----------------------&amp;gt;29----&amp;gt;31|
          +-------+-------+---------+-----+-----+-------------+------------------------------------+-----+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;II. First Come First Served (FCFS) Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;Cylinder: 0---1---2---3---4---5---6---7---8---9---10--11---...---29---30--31---...---40
          |-&amp;gt;1----------------------------------------------------------------------------------------&amp;gt;31|
          +--------------------------------------------------------------------------------------------+
          Start-&amp;gt;6------------------------------------------------------------------------------------------&amp;gt;7
                                  |--------------------&amp;gt;11----------------------------------------&amp;gt;29-|
                                  +---------------------+------------------------------------------+
                                                        |-----&amp;gt;4------------------------------------|
                                                        +------+------------------------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;III. SCAN (Elevator) Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;Cylinder: 0---1---2---3---4---5---6---7---8---9---10--11---...---29---30--31---...---40
          |-&amp;gt;4-&amp;gt;|-&amp;gt;1-----------------------------------------&amp;gt;7-&amp;gt;|-&amp;gt;11----------------------&amp;gt;29----&amp;gt;31|
          +-----+------+----------------------------------------+------+------------------------------------+
          Start-&amp;gt;6------------------------------------------------------------------------------------------&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A certain organization opted for a client-server model for its operating systems. Explain two advantages that could have influenced the choice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Sharing and Centralized Management&lt;/strong&gt;: The client-server model facilitates &lt;strong&gt;efficient resource sharing&lt;/strong&gt;. Servers can provide centralized access to resources such as files, databases, printers, and applications. This reduces redundancy and cost as resources are not duplicated on every client machine. Additionally, it allows for &lt;strong&gt;centralized management and administration&lt;/strong&gt; of these resources. IT staff can manage, update, and secure resources from a central server location, simplifying maintenance and improving consistency across the organization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Improved Security and Scalability&lt;/strong&gt;: Client-server architectures often offer &lt;strong&gt;enhanced security&lt;/strong&gt;. Security measures can be concentrated on the server-side, making it easier to implement and enforce security policies. Access control, authentication, and data protection are managed centrally, reducing vulnerabilities at individual client machines. Furthermore, client-server systems are generally &lt;strong&gt;more scalable&lt;/strong&gt;. As the organization grows, it is easier to add more clients without significantly impacting performance, and server resources can be upgraded or scaled to meet increasing demands. This scalability is crucial for long-term growth and adaptability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) An IT professional designed an operating system consisting of several modules. Each module was designed on one below it.&lt;/p&gt;
&lt;p&gt;(i) State the name given to the resultant structure after design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Layered Structure&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline one advantage of this structure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Simplified Design and Development&lt;/strong&gt;: A layered structure &lt;strong&gt;simplifies operating system design and development&lt;/strong&gt; by breaking down the system into smaller, more manageable modules or layers. Each layer provides specific services and relies only on the layer below it. This modularity allows developers to focus on implementing and debugging individual layers independently, making the development process more organized and less complex. Changes in one layer are less likely to affect other layers, promoting easier maintenance and updates.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (a) (i) Describe the terms relocating loader as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Relocating Loader&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;relocating loader&lt;/strong&gt; is a type of loader that can load program code and data into &lt;strong&gt;any available region of memory&lt;/strong&gt;. Unlike absolute loaders which require programs to be loaded at a specific memory address, a relocating loader adjusts the program's addresses (both code and data addresses) during loading so that it can run correctly regardless of its actual load address. This is crucial for multiprogramming and dynamic memory management, allowing programs to be loaded into different memory locations each time they are executed, improving memory utilization and flexibility.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of a diagram in each case explain the effect of double buffering as compared to single buffering data transfer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Double Buffering vs. Single Buffering Data Transfer&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Single Buffering&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;single buffering&lt;/strong&gt;, only &lt;strong&gt;one buffer&lt;/strong&gt; is used in system memory for data transfer between an I/O device and the process. The process must wait until the buffer is filled (for input) or emptied (for output) before it can continue processing or initiate another I/O operation. During data transfer, the CPU might be idle, waiting for I/O to complete. This can lead to performance bottlenecks, especially if I/O operations are slow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Single Buffering:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+     +---------+     +---------+
|  Device | --&amp;gt; |  Buffer | --&amp;gt; | Process |
+---------+     +---------+     +---------+
     Data In          Processing
       |                |
       +----------------+ (Wait Time for Process during I/O)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Double Buffering&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;double buffering&lt;/strong&gt;, &lt;strong&gt;two buffers&lt;/strong&gt; are used. While one buffer is being filled by the I/O device (for input) or emptied by the process (for output), the process (or device) can simultaneously work with the other buffer. This allows for &lt;strong&gt;overlapping of I/O operations with processing&lt;/strong&gt;, reducing the wait time and improving throughput. While the process is processing data in one buffer, the next block of data can be transferred into the other buffer, and vice versa. This technique minimizes CPU idle time due to I/O waits.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Double Buffering:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;          +---------+     +---------+
Device 1 --&amp;gt;| Buffer 1| --&amp;gt; | Process |
          +---------+     +---------+
               ^             | Processing data from Buffer 1
               |
          +---------+     +---------+
Device 2 --&amp;gt;| Buffer 2|     |         |
          +---------+     +---------+
             Filling Buffer 2 (Simultaneous I/O)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Effect Comparison:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Single buffering&lt;/strong&gt; leads to &lt;strong&gt;alternating periods of I/O and processing&lt;/strong&gt;, with CPU often idle during I/O. &lt;strong&gt;Double buffering&lt;/strong&gt; enables &lt;strong&gt;concurrent I/O and processing&lt;/strong&gt;, significantly reducing CPU idle time and increasing data transfer rates and overall system efficiency by overlapping operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Mary's printer has a device that intercepts data sent to it, stores the data in disk files and manages the printing when convenient for the system.&lt;/p&gt;
&lt;p&gt;(i) Name the device that Mary had installed in her printer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Spooler&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline three advantages she would get from the device identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Improved System Throughput&lt;/strong&gt;: A spooler &lt;strong&gt;improves system throughput&lt;/strong&gt; by allowing processes to quickly output data to be printed without waiting for the actual printing to complete. The data is spooled to disk or memory, and the process can continue with other tasks. Printing occurs in the background, managed by the spooler, thus freeing up the CPU and application processes to perform other operations concurrently. This concurrent operation significantly increases overall system efficiency.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Printer Resource Management&lt;/strong&gt;: A spooler effectively &lt;strong&gt;manages printer resources&lt;/strong&gt;, especially in a shared environment. It can handle multiple print jobs from different users or processes, queuing them and printing them in an orderly fashion. This prevents print jobs from interfering with each other and ensures fair access to the printer. The spooler can also prioritize print jobs, handle printer errors, and provide status information about print queues, making printer usage more organized and efficient.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Support for Delayed and Scheduled Printing&lt;/strong&gt;: Spooling allows for &lt;strong&gt;delayed or scheduled printing&lt;/strong&gt;. Users can submit print jobs even when the printer is busy or unavailable, and the spooler will store these jobs and print them when the printer becomes free or at a scheduled time. This is particularly useful for large print jobs or for printing during off-peak hours to reduce system load during busy periods. It provides flexibility in managing print tasks and optimizes printer usage based on system load and user needs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Explain the function of job control language as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Job Control Language (JCL) Function&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Job Control Language (JCL)&lt;/strong&gt; serves as a &lt;strong&gt;command language&lt;/strong&gt; used primarily in batch processing systems to &lt;strong&gt;instruct the operating system on how to run a batch job&lt;/strong&gt;. JCL defines the sequence of operations, the programs to be executed, the input and output data sets, and the resources required for a job. It acts as an interface between the user or application and the operating system, specifying all necessary details for the OS to execute a series of tasks automatically without user intervention during processing. JCL enables automation of complex workflows and efficient batch processing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) A certain organization bought a new system for its file systems. Explain three considerations that could be put in place with regard to their file management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Backup and Recovery Strategy&lt;/strong&gt;: A crucial consideration is establishing a robust &lt;strong&gt;data backup and recovery strategy&lt;/strong&gt;. This involves regular backups of important files and file system metadata to a separate storage medium. The backup strategy should include scheduling (frequency of backups), selection of data to be backed up, and backup methods (e.g., full, incremental, differential). A well-defined recovery plan is equally important, outlining procedures for restoring data in case of data loss due to hardware failure, software errors, or human mistakes. Regular testing of the recovery process is essential to ensure its effectiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File System Security and Access Control&lt;/strong&gt;: Implementing strong &lt;strong&gt;file system security and access control mechanisms&lt;/strong&gt; is vital. This includes setting appropriate file permissions and access rights to control who can access, modify, or delete files and directories. Access control should be based on the principle of least privilege, granting users only the necessary permissions for their tasks. Security considerations should also include protection against unauthorized access, malware, and data breaches. Regular security audits and updates are necessary to maintain file system integrity and confidentiality.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;File System Organization and Structure&lt;/strong&gt;: Careful &lt;strong&gt;planning of file system organization and structure&lt;/strong&gt; is important for efficient file management and user accessibility. This involves designing a logical directory hierarchy that is intuitive and easy to navigate for users. Consistent naming conventions for files and directories should be established to improve file findability and organization. The structure should be scalable to accommodate future data growth and organizational changes. A well-organized file system enhances productivity, simplifies file retrieval, and reduces administrative overhead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) (i) Define the term virtual memory as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Virtual Memory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Virtual memory&lt;/strong&gt; is a memory management technique that &lt;strong&gt;allows processes to execute even if they are not entirely loaded into physical memory&lt;/strong&gt;. It creates an illusion of a larger memory space than physically available RAM by using disk space as an extension of RAM. Virtual memory works by swapping pages (blocks of virtual memory) between RAM and disk. This technique enables the execution of programs larger than physical memory and improves the degree of multiprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Consider an executing process P that issues I/O request. The processes temporarily stopped. At some later point, a disk interrupt occurs and the driver detects that P's request is satisfied. At some later time, the operating system looks for a job to run and picks P. With the aid of diagrams outline these process states.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Process State Transitions for I/O Request:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Initial State: Running&lt;/strong&gt; - Process P is initially in the &lt;strong&gt;running state&lt;/strong&gt;, executing on the CPU.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram 1: Running State&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+
| Running | &amp;lt;--- Process P executing
+---------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Transition 1: Blocked/Waiting State&lt;/strong&gt; - When Process P issues an I/O request, it transitions to the &lt;strong&gt;blocked (or waiting) state&lt;/strong&gt;. It is no longer using the CPU and is waiting for the I/O operation to complete.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram 2: Blocked State&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+      I/O Request
| Running | --------&amp;gt; +---------+
+---------+          | Blocked | &amp;lt;--- Process P waiting for I/O
                       +---------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Transition 2: Ready State&lt;/strong&gt; - Upon completion of the I/O request and processing of the disk interrupt, Process P becomes ready to run again. It transitions from the blocked state to the &lt;strong&gt;ready state&lt;/strong&gt;, waiting to be scheduled on the CPU.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram 3: Ready State&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+   I/O Complete   +---------+
| Blocked | ----------&amp;gt; |  Ready  | &amp;lt;--- Process P ready to run, waiting for CPU
+---------+              +---------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Transition 3: Running State (again)&lt;/strong&gt; - Eventually, the operating system scheduler selects Process P from the ready queue to run on the CPU. Process P transitions back to the &lt;strong&gt;running state&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram 4: Running State (Resumed)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+   Scheduled by OS   +---------+
|  Ready  | -----------------&amp;gt; | Running | &amp;lt;--- Process P resumes execution
+---------+                     +---------+
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Figure 1 shows file system architecture of a certain organization.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-10-10_2017july.pdf.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;368&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;(b) Outline the function of each of the parts marked (i), (ii), (iii) and (iv).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-003.png&quot; alt=&quot;Figure 1&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) User Program&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;User Program&lt;/strong&gt; is the &lt;strong&gt;application or software being executed by the user&lt;/strong&gt;. It is at the highest level of the file system architecture and interacts with the file system to perform file operations such as creating, reading, writing, and deleting files. The user program makes system calls to request file system services. It represents the interface through which users or applications interact with the file system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Logical File System&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Logical File System&lt;/strong&gt; layer is responsible for &lt;strong&gt;interpreting file operations&lt;/strong&gt; requested by the user program. It manages the directory structure, file naming, and file metadata (attributes). This layer translates logical file operations (like 'open file by name') into a series of lower-level operations that the file organization module can understand. It deals with logical file and directory structures, access control, and file system integrity from a logical perspective.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iii) File Organization Module&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;File Organization Module&lt;/strong&gt; (or File System Implementation) is responsible for &lt;strong&gt;mapping logical file blocks to physical blocks on the storage device&lt;/strong&gt;. It manages the physical storage space, block allocation, and free space management. This layer implements the file allocation method (e.g., contiguous, linked, indexed) and translates logical block addresses into physical disk addresses. It also handles buffering and caching to optimize disk I/O. This module is the bridge between the logical view of files and the physical storage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iv) Basic I/O Supervisor&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Basic I/O Supervisor&lt;/strong&gt; (or I/O Control Layer) is the &lt;strong&gt;lowest layer of the file system architecture&lt;/strong&gt; that directly interacts with the hardware. It is responsible for &lt;strong&gt;initiating and controlling physical I/O operations&lt;/strong&gt;. This layer includes device drivers that communicate with specific disk controllers. It handles the physical transfer of data between memory and the disk, manages I/O channels, and controls the hardware-level operations required to read and write data to the storage device. It provides a hardware-independent interface for the higher file system layers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Differentiate between monoprogramming and multiprogramming as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Monoprogramming&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monoprogramming&lt;/strong&gt; is an operating system approach where &lt;strong&gt;only one program can reside in main memory and execute at a time&lt;/strong&gt;. When a program is running, it has exclusive control of all system resources, including the CPU, memory, and I/O devices. No other program can be executed until the current program completes. This is a simpler form of operating system, but it leads to &lt;strong&gt;low CPU utilization&lt;/strong&gt;, as the CPU often sits idle while the running program is waiting for I/O operations to complete. Throughput is low, and response time can be poor, especially for interactive applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Multiprogramming&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Multiprogramming&lt;/strong&gt; is an operating system technique that allows &lt;strong&gt;multiple programs to reside in main memory simultaneously&lt;/strong&gt;. The operating system keeps several programs in memory and switches between them to keep the CPU busy. When one program is waiting for an I/O operation, the CPU can switch to another program that is ready to execute. This significantly &lt;strong&gt;improves CPU utilization and system throughput&lt;/strong&gt;. Multiprogramming enhances system efficiency by overlapping CPU and I/O operations, leading to better resource utilization and improved responsiveness compared to monoprogramming. It is the basis for modern operating systems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Monoprogramming executes one program at a time, leading to idle CPU time, while multiprogramming allows multiple programs to reside in memory and share the CPU, improving CPU utilization and throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Explain the term starvation as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Starvation in Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Starvation&lt;/strong&gt; in operating systems refers to a situation where a &lt;strong&gt;process is indefinitely denied access to the resources it needs to make progress&lt;/strong&gt;, even though the resources are available. This typically occurs in priority scheduling systems where high-priority processes continuously monopolize resources, preventing low-priority processes from ever getting a chance to run or acquire necessary resources. Starvation is a severe form of unfairness and can lead to critical processes being unable to complete, degrading system performance and responsiveness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (ii) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of a diagram, describe a direct memory access operation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Direct Memory Access (DMA) Operation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DMA&lt;/strong&gt; is a hardware mechanism that allows &lt;strong&gt;I/O devices to transfer data directly to or from main memory without involving the CPU for every byte transferred&lt;/strong&gt;. This significantly reduces CPU overhead and improves the efficiency of data transfers, especially for large blocks of data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of DMA Operation:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+     +----------+     +----------+
|  Device | ----&amp;gt; | DMA      | ----&amp;gt; | Memory   |
+---------+     | Controller|     +----------+
      Request      +----------+         Data Transfer
          ^             | Control Signals
          |             V
          +----------+
          |   CPU    |
          +----------+
            Initialize DMA, Start Transfer
            Interrupt upon Completion
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Steps in DMA Operation:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Initialization&lt;/strong&gt;: The CPU initiates the DMA transfer by &lt;strong&gt;configuring the DMA controller&lt;/strong&gt;. It provides the DMA controller with details such as the source address (device buffer), destination address (memory location), the amount of data to be transferred, and the direction of transfer (read or write).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;DMA Request&lt;/strong&gt;: The I/O device requests a data transfer through the DMA controller.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Bus Grant&lt;/strong&gt;: The DMA controller requests control of the system bus from the CPU. Once the CPU grants the bus, the DMA controller becomes the bus master for the duration of the data transfer.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Data Transfer&lt;/strong&gt;: The DMA controller directly transfers data between the I/O device and main memory, &lt;strong&gt;bypassing the CPU for each byte transfer&lt;/strong&gt;. The DMA controller manages the address and control lines to perform the data transfer in blocks.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Transfer Completion&lt;/strong&gt;: Once the data transfer is complete, the DMA controller signals the CPU via an &lt;strong&gt;interrupt&lt;/strong&gt;. The CPU is then notified that the data transfer is finished and can proceed with processing the data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Effect:&lt;/strong&gt; DMA operation significantly offloads the CPU from handling byte-by-byte data transfers, allowing the CPU to perform other processing tasks concurrently during I/O operations. This results in faster data transfer rates and improved system performance, especially for high-bandwidth I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) State two purposes of device drivers as used in a computer operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hardware Abstraction&lt;/strong&gt;: Device drivers provide a &lt;strong&gt;hardware abstraction layer&lt;/strong&gt;. They hide the complexities and specific details of hardware devices from the operating system kernel and application software. Drivers offer a uniform interface for the OS to interact with different types of hardware, regardless of their manufacturer or model. This abstraction simplifies OS development and makes the system more portable, as the OS does not need to be rewritten for every new device.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Device Communication and Control&lt;/strong&gt;: Device drivers are responsible for &lt;strong&gt;enabling communication and control of hardware devices&lt;/strong&gt;. They contain the specific code and instructions needed to send commands to devices, receive data from them, and handle device-specific operations. Drivers act as translators, converting generic OS requests into device-specific commands and interpreting device responses. They manage the interaction protocols and timing requirements of hardware devices, ensuring correct and efficient operation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Outline two operations that could be used to implement a semaphore.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Wait (or P or Acquire) Operation&lt;/strong&gt;: The &lt;strong&gt;wait operation&lt;/strong&gt;, often denoted as `wait(S)` or `P(S)`, is used to &lt;strong&gt;decrement the semaphore value&lt;/strong&gt;. If the semaphore value becomes negative after decrementing, the process executing the wait operation is blocked (put to sleep) and added to the semaphore's waiting queue. The wait operation is used to acquire or request access to a resource protected by the semaphore. It ensures that a process waits until the resource is available (semaphore value is positive).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Signal (or V or Release) Operation&lt;/strong&gt;: The &lt;strong&gt;signal operation&lt;/strong&gt;, often denoted as `signal(S)` or `V(S)`, is used to &lt;strong&gt;increment the semaphore value&lt;/strong&gt;. If there are processes blocked in the semaphore's waiting queue, one of them is unblocked (woken up) and moved to the ready queue. The signal operation is used to release a resource that was being held and to notify waiting processes that the resource might be available. It allows processes to proceed after a resource has been released.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Describe three requirements for critical section problem as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: &lt;strong&gt;Mutual exclusion&lt;/strong&gt; is a primary requirement. It dictates that &lt;strong&gt;only one process can be inside its critical section at any given time&lt;/strong&gt;. If one process is executing in its critical section, no other process is allowed to enter its critical section. This is essential to prevent race conditions and data inconsistency when multiple processes access shared resources. Mutual exclusion ensures that access to shared resources is serialized and controlled, maintaining data integrity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Progress&lt;/strong&gt;: &lt;strong&gt;Progress&lt;/strong&gt; ensures that if no process is executing in its critical section and some processes wish to enter their critical sections, then &lt;strong&gt;only those processes that are not in their remainder sections can participate in deciding which will enter its critical section next&lt;/strong&gt;, and this selection cannot be postponed indefinitely. In simpler terms, if no process is in a critical section and some processes want to enter, one of them should be able to enter without waiting indefinitely. Progress avoids deadlock or indefinite postponement in entering critical sections.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Bounded Waiting&lt;/strong&gt;: &lt;strong&gt;Bounded waiting&lt;/strong&gt; requires that there must be a &lt;strong&gt;limit on the number of times other processes can enter their critical sections after a process has made a request to enter its critical section and before that request is granted&lt;/strong&gt;. This means no process should face starvation. There should be a guarantee that each process will eventually get to enter its critical section within a bounded amount of time, preventing indefinite delay. Bounded waiting ensures fairness and prevents any process from being perpetually blocked from accessing the critical section.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Differentiate between first fit and next fit dynamic partitioning algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;First Fit&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First Fit&lt;/strong&gt; is a dynamic memory allocation algorithm that &lt;strong&gt;allocates the first available partition (hole) in memory that is large enough to satisfy the request&lt;/strong&gt;. When searching for a free partition, First Fit starts from the beginning of the memory or the list of free partitions and stops as soon as it finds a partition that is large enough. It then allocates the required memory from this partition, potentially splitting the partition if it's larger than needed. First Fit is simple to implement and generally fast for allocation, but it can lead to fragmentation, particularly external fragmentation, and may create many small partitions at the beginning of memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Next Fit&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Next Fit&lt;/strong&gt; is similar to First Fit but starts its search for a free partition from the &lt;strong&gt;location where the previous allocation ended&lt;/strong&gt;, rather than always starting from the beginning of memory. It keeps track of the last partition allocated and begins searching for the next available partition from that point onwards, wrapping around to the beginning if necessary. Next Fit aims to distribute allocations more evenly across memory, potentially reducing clustering of allocations at the beginning. However, it can also lead to fragmentation and might not always find the best fitting partition, potentially resulting in slightly worse memory utilization compared to First Fit in some scenarios. Next Fit is also relatively simple to implement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; First Fit always starts searching for a free partition from the beginning of memory, while Next Fit starts its search from the location of the last allocation. Next Fit aims to improve allocation distribution across memory compared to First Fit.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) An operating system uses detection and recovery methods to deal with possible deadlocks. Explain three criteria that could be used when selecting processes to abort in such an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Priority&lt;/strong&gt;: &lt;strong&gt;Process priority&lt;/strong&gt; can be a criterion for selecting processes to abort. In a priority-based system, it may be more beneficial to &lt;strong&gt;abort lower-priority processes&lt;/strong&gt; to resolve a deadlock. Aborting high-priority processes can have more significant consequences, affecting critical system operations or user-critical tasks. By choosing to terminate lower-priority processes, the system aims to minimize the impact on overall system functionality and user experience, preserving the execution of more important tasks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Execution Time/Progress&lt;/strong&gt;: The &lt;strong&gt;execution time or progress&lt;/strong&gt; of a process can be considered. Processes that have &lt;strong&gt;consumed less CPU time or made less progress&lt;/strong&gt; towards completion might be preferable candidates for abortion. Aborting processes that are early in their execution or have not performed much work results in less wasted computation compared to aborting processes that are close to completion or have already performed significant tasks. This criterion aims to minimize the loss of computational effort due to process termination.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Resources Held by Process&lt;/strong&gt;: The &lt;strong&gt;number and type of resources held by a process&lt;/strong&gt; can influence the selection for abortion. Processes holding &lt;strong&gt;fewer resources or resources that are easily preemptible or less critical&lt;/strong&gt; might be chosen for termination. Aborting a process that holds many resources or critical resources can lead to cascading aborts and system instability. Selecting processes holding fewer and less critical resources aims to minimize resource wastage and disruption to other processes. The type of resources (e.g., exclusive locks, shared resources) also plays a role in the decision.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) Outline three functions of a memory manager as used in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Memory Allocation and Deallocation&lt;/strong&gt;: The memory manager is responsible for &lt;strong&gt;allocating memory to processes when they need it and deallocating memory when processes no longer require it&lt;/strong&gt;. This includes keeping track of available memory space, selecting suitable memory blocks for allocation, and reclaiming memory when processes terminate or release memory. Efficient allocation and deallocation are crucial for managing system resources and supporting multiprogramming.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory Protection&lt;/strong&gt;: The memory manager ensures &lt;strong&gt;memory protection&lt;/strong&gt;, preventing processes from accessing memory regions that do not belong to them. This is vital for system stability and security, as it prevents one process from corrupting the memory of another process or the operating system itself. Memory protection mechanisms include techniques like base and limit registers, segmentation, and paging, which define and enforce memory access boundaries for each process.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Virtual Memory Management&lt;/strong&gt;: In systems with virtual memory, the memory manager &lt;strong&gt;implements and manages the virtual memory system&lt;/strong&gt;. This involves handling page faults, swapping pages between RAM and disk, and maintaining page tables that translate virtual addresses to physical addresses. Virtual memory management allows processes to use more memory than physically available, improving memory utilization and enabling the execution of larger programs. It also handles memory sharing and protection in a virtualized environment.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) State two primitive system calls used in message passing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Send (message)&lt;/strong&gt;: The &lt;strong&gt;send&lt;/strong&gt; system call is used by a process to &lt;strong&gt;transmit a message to another process or processes&lt;/strong&gt;. It typically involves specifying the destination process (or process group) and the message data. The send operation may be synchronous (blocking) or asynchronous (non-blocking), depending on the communication semantics. It is a fundamental operation for inter-process communication using message passing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Receive (message)&lt;/strong&gt;: The &lt;strong&gt;receive&lt;/strong&gt; system call is used by a process to &lt;strong&gt;receive a message&lt;/strong&gt;. It typically involves specifying a source process (or allowing messages from any source) and providing a buffer to store the received message. Like send, receive can be synchronous or asynchronous. When synchronous, the receiving process blocks until a message arrives. Receive is the counterpart to send, enabling processes to exchange information via messages.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) A system administrator of a certain organization is contemplating using monitors as inter-process communication method. Explain two challenges the administrator is likely to face.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Complexity in Nested Monitor Calls&lt;/strong&gt;: One challenge is the &lt;strong&gt;complexity in handling nested monitor calls&lt;/strong&gt;. If a process within a monitor calls another monitor (nested call), it can lead to complications, particularly with respect to mutual exclusion and condition variables. Improperly managed nested monitor calls can potentially lead to deadlocks or unexpected behavior if not carefully designed and implemented. Ensuring correct synchronization and avoiding deadlocks in nested monitor scenarios requires careful consideration of monitor entry and exit protocols and condition variable usage.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Potential for Priority Inversion&lt;/strong&gt;: &lt;strong&gt;Priority inversion&lt;/strong&gt; can be a challenge when using monitors in priority-based systems. If a high-priority process is blocked waiting to enter a monitor that is currently held by a low-priority process, and if medium-priority processes preempt the low-priority process, the high-priority process can be effectively blocked by medium-priority processes, violating priority order. While monitors provide mutual exclusion, they do not inherently prevent priority inversion, and additional mechanisms (like priority inheritance or priority ceiling protocols) might be needed to mitigate this issue and ensure predictable priority behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (i) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Process A of capacity 15k was running in the memory, and then processes B of capacity 20k and C of capacity 35k are created. Later process A terminates and is swapped out of memory to disk. Then process D of capacity 10k is created and then process B is swapped out of memory to disk. Then process E of capacity 18k is created. The total memory capacity is 75k.&lt;/p&gt;
&lt;p&gt;(i) Use sketches to illustrate this memory allocation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Memory Allocation Sketches:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Initial State: Process A (15k) Running&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Process A (15k)     |
+---------------------+
| Free Memory (60k)   |
+---------------------+
Total: 75k
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 1: Processes B (20k) and C (35k) Created&lt;/strong&gt; (assuming First-Fit and sufficient contiguous space)&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Process A (15k)     |
+---------------------+
| Process B (20k)     |
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 2: Process A Terminates and Swapped Out&lt;/strong&gt; (Memory becomes free where A was)&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Free Memory (15k)   |  &amp;lt;-- Space freed by A
+---------------------+
| Process B (20k)     |
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 3: Process D (10k) Created&lt;/strong&gt; (allocated in the first available free space)&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Process D (10k)     |  &amp;lt;-- Process D allocated in first 10k of free space
+---------------------+
| Free Memory (5k)    |  &amp;lt;-- Remaining from the 15k block
+---------------------+
| Process B (20k)     |
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 4: Process B Swapped Out&lt;/strong&gt; (Memory becomes free where B was)&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Process D (10k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
| Free Memory (20k)   |  &amp;lt;-- Space freed by B
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 5: Process E (18k) Created&lt;/strong&gt; (allocated in the contiguous free space of 20k)&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Process D (10k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
| Process E (18k)     |  &amp;lt;-- Process E allocated in the 20k block
+---------------------+
| Free Memory (2k)    |  &amp;lt;-- Remaining from the 20k block
+---------------------+
| Process C (35k)     |
+---------------------+
| Free Memory (5k)    |
+---------------------+
Total: 75k
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain the state that the final memory would have.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Final Memory State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The final memory state shows &lt;strong&gt;fragmentation&lt;/strong&gt;. We have &lt;strong&gt;Process D (10k)&lt;/strong&gt;, followed by &lt;strong&gt;5k of free memory&lt;/strong&gt;, then &lt;strong&gt;Process E (18k)&lt;/strong&gt;, &lt;strong&gt;2k of free memory&lt;/strong&gt;, &lt;strong&gt;Process C (35k)&lt;/strong&gt;, and finally another &lt;strong&gt;5k of free memory&lt;/strong&gt;. The total free memory is 5k + 2k + 5k = 12k, which is &lt;strong&gt;scattered into three non-contiguous blocks&lt;/strong&gt;. This state illustrates &lt;strong&gt;external fragmentation&lt;/strong&gt;, where sufficient total free memory exists (12k) but it is not contiguous, potentially making it difficult to allocate larger processes that require contiguous memory blocks, even though the total available memory is adequate.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Mary an IT expert would like to design an operating system for I/O devices. Explain two issues that she could put into consideration.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Diversity and Heterogeneity&lt;/strong&gt;: A major issue is the &lt;strong&gt;diversity and heterogeneity of I/O devices&lt;/strong&gt;. Operating systems need to support a wide range of I/O devices, from keyboards and mice to disks, network interfaces, and specialized sensors. These devices vary greatly in their characteristics (speed, data transfer methods, control interfaces, protocols). Mary needs to design the OS to accommodate this diversity through modular device drivers that can be easily added or updated to support new devices. The OS must provide a consistent and abstract interface for applications to interact with these diverse devices, hiding the hardware-specific details.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Performance and Efficiency of I/O Operations&lt;/strong&gt;: &lt;strong&gt;Performance and efficiency of I/O operations&lt;/strong&gt; are critical. I/O operations are often the bottleneck in computer systems, especially with increasing data volumes and real-time requirements. Mary must consider efficient I/O management techniques, such as buffering, caching, DMA, and I/O scheduling algorithms, to minimize I/O latency and maximize throughput. The OS design should aim to overlap I/O operations with CPU processing to improve overall system performance. Efficient handling of interrupts, device polling, and data transfer mechanisms are essential for achieving high I/O performance in the operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) Explain each of the following terms as used in operating systems.&lt;/p&gt;
&lt;p&gt;(i) compaction;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Compaction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compaction&lt;/strong&gt; is a memory management technique used to &lt;strong&gt;reduce external fragmentation&lt;/strong&gt;. It involves &lt;strong&gt;rearranging the processes in memory&lt;/strong&gt; so that all free memory is contiguous in one large block. This is achieved by moving all allocated blocks to one end of memory, leaving all free blocks together in a single block at the other end. Compaction makes it possible to allocate larger contiguous blocks of memory to processes that could not be allocated before due to fragmentation, even if the total amount of free memory was sufficient.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) overlaying.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Overlaying&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt; is a memory management technique used in older systems to &lt;strong&gt;enable a program to be larger than the amount of memory allocated to it&lt;/strong&gt;. It works by dividing the program into logical units called overlays. Only the overlays currently needed are kept in memory; when a different overlay is needed, it replaces the current one in memory. Overlaying requires manual programming effort to divide the program and manage overlays, and it is less common in modern systems with virtual memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) State three conditions that could cause a program running in a computer to terminate.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Normal Completion&lt;/strong&gt;: A program terminates upon &lt;strong&gt;normal completion&lt;/strong&gt; when it has &lt;strong&gt;executed all its instructions successfully&lt;/strong&gt; and reaches its natural end point. This is the intended and expected termination scenario where the program finishes its task without errors or external interruptions. The program may explicitly terminate itself using an exit system call, or it may implicitly terminate when it reaches the end of its main execution flow.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Voluntary Termination due to Error&lt;/strong&gt;: A program may terminate &lt;strong&gt;voluntarily due to an error condition&lt;/strong&gt; it encounters during execution. This occurs when the program detects an error it cannot recover from, such as invalid input, file not found, or resource allocation failure. In such cases, the program may decide to terminate itself gracefully to prevent further erroneous operations or system instability. The program typically reports the error condition before terminating.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Involuntary Termination by Operating System&lt;/strong&gt;: A program can be &lt;strong&gt;involuntarily terminated by the operating system&lt;/strong&gt; due to various reasons. These include fatal errors like segmentation faults (memory access violations), illegal instructions, time limit exceeded, or system crashes. The operating system may terminate a program to protect system integrity, prevent resource hogging, or in response to external signals (e.g., user-initiated termination, process kill command). Involuntary termination is often a result of unrecoverable errors or system-level policies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) State one scheduling goal that could be achieved in each of the following systems;&lt;/p&gt;
&lt;p&gt;I. batch systems;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Batch Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maximize throughput&lt;/strong&gt; is a primary scheduling goal in batch systems. The objective is to process as many jobs as possible in a given amount of time. Batch systems are designed for high-volume, non-interactive job processing, and maximizing the number of completed jobs (throughput) is a key metric for efficiency. Minimizing turnaround time and maximizing resource utilization also contribute to achieving high throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;II. real time systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;II. Real Time Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Meeting deadlines&lt;/strong&gt; is a critical scheduling goal in real-time systems. Real-time systems must respond to events within strict time constraints. The primary goal is to ensure that tasks are completed before their deadlines to guarantee system correctness and responsiveness. Scheduling algorithms in real-time systems prioritize tasks based on their deadlines and timing requirements to ensure timely execution and prevent deadline misses, which could lead to system failure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Table 1 show two concurrent processes P1 and P2 and their timed I/O requests. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Table 1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Time&lt;/th&gt;
&lt;th&gt;P1&lt;/th&gt;
&lt;th&gt;P2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Time&quot;&gt;1&lt;/td&gt;
&lt;td data-label=&quot;P1&quot;&gt;Request R1&lt;/td&gt;
&lt;td data-label=&quot;P2&quot;&gt;Request R2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Time&quot;&gt;2&lt;/td&gt;
&lt;td data-label=&quot;P1&quot;&gt;Request R2&lt;/td&gt;
&lt;td data-label=&quot;P2&quot;&gt;Request R1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Time&quot;&gt;3&lt;/td&gt;
&lt;td data-label=&quot;P1&quot;&gt;Release R1&lt;/td&gt;
&lt;td data-label=&quot;P2&quot;&gt;Release R2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Draw the resource allocation graph for these possible executions of the processes, indicating when deadlock occurs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Resource Allocation Graph and Deadlock Analysis:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resources:&lt;/strong&gt; R1, R2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Processes:&lt;/strong&gt; P1, P2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P1 requests R1, P2 requests R2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Graph at Time 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;     R1     R2
     /\     /\
    |  |   |  |
    V  V   V  V
   P1--&amp;gt;   P2--&amp;gt;
&lt;/pre&gt;
&lt;p&gt;No deadlock yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time 2:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P1 requests R2, P2 requests R1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Graph at Time 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;     R1     R2
     /\     /\
    |  |   |  |
    V  V   V  V
   P1--&amp;gt;   P2--&amp;gt;
    ^       ^
    |       |
    -----   -----
         Requests
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Deadlock occurs at Time 2.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deadlock Condition:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At Time 2, P1 is holding R1 and requesting R2. Simultaneously, P2 is holding R2 and requesting R1. This creates a &lt;strong&gt;circular wait&lt;/strong&gt; condition: P1 is waiting for a resource (R2) held by P2, and P2 is waiting for a resource (R1) held by P1. This circular dependency forms a cycle in the resource allocation graph, indicating a deadlock.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resource Allocation Graph Indicating Deadlock:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;     R1     R2
     /\     /\
    |  |   |  |
    V  V   V  V
   P1&amp;lt;--&amp;gt;   P2&amp;lt;--&amp;gt;
     Circular Wait Cycle Detected
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Release R1 and R2 (These releases cannot happen as deadlock is already present at Time 2).&lt;/p&gt;
&lt;p&gt;In a deadlock situation, processes will remain blocked indefinitely unless deadlock resolution mechanisms are employed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a sleeping barber classical example, describe the inter-process communication problem as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Sleeping Barber Problem as Inter-Process Communication Example&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Sleeping Barber problem&lt;/strong&gt; is a classical synchronization problem that illustrates inter-process communication and synchronization challenges, particularly related to &lt;strong&gt;producer-consumer scenarios and mutual exclusion&lt;/strong&gt;. It describes a barbershop with one barber, one barber chair, and a waiting room with a limited number of chairs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scenario Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Barber's State&lt;/strong&gt;: If there are no customers, the barber goes to sleep in the barber chair. The barber is a 'consumer' waiting for customers ('producers').&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Customer Arrival&lt;/strong&gt;: When a customer arrives, they check if the barber is free.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Waiting Room Full&lt;/strong&gt;: If all waiting chairs are occupied, the customer leaves (drops out – resource limit). This illustrates buffer overflow if waiting queue (waiting room) is full.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Waiting Room Available&lt;/strong&gt;: If there are chairs available in the waiting room, the customer sits and waits.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Waking the Barber&lt;/strong&gt;: If the barber is sleeping, the arriving customer wakes up the barber. Waking up process is a form of inter-process signaling (communication).&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;&lt;strong&gt;Getting Haircut&lt;/strong&gt;: Once the barber is awake (or if the barber was already free), the customer gets a haircut. Haircut process is the 'critical section' where barber and customer interact exclusively (mutual exclusion).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inter-Process Communication and Synchronization Issues Illustrated:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;: Synchronization is crucial to manage the states of the barber and customers correctly. The barber needs to sleep when there are no customers and be woken up when a customer arrives. Customers need to wait if the barber is busy or if the waiting room is full.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: Mutual exclusion is required for accessing shared resources like the barber chair and waiting room chairs. Only one customer can be in the barber chair getting a haircut at a time (barber chair mutual exclusion). Access to waiting room chairs also needs to be managed to prevent race conditions when multiple customers arrive or leave simultaneously.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Producer-Consumer Relationship&lt;/strong&gt;: The problem represents a producer-consumer relationship where customers are 'producers' of haircut requests, and the barber is the 'consumer' who provides haircuts. Communication between producers and consumers (customers and barber) needs to be synchronized to avoid issues like the barber trying to cut hair when no customer is present, or customers not being able to get a haircut when the barber is available.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Deadlock and Starvation Potential&lt;/strong&gt;: Improper synchronization in the Sleeping Barber problem can lead to deadlock or starvation scenarios. For example, if synchronization mechanisms are not correctly implemented, it's possible for both barber and customers to get stuck in waiting loops, leading to deadlock. Starvation could occur if customers keep arriving and waking up the barber before a waiting customer gets a haircut.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Communication Mechanism&lt;/strong&gt;: Condition variables or semaphores are typically used to implement solutions to the Sleeping Barber problem, enabling processes (barber and customers) to communicate and synchronize their actions based on the state of the barbershop (e.g., barber sleeping, waiting chairs available).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) Differentiate between multiprocessor and distributed types of operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Multiprocessor Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Multiprocessor operating systems&lt;/strong&gt; manage a &lt;strong&gt;single computer system with multiple CPUs (processors)&lt;/strong&gt;. These processors share the same physical memory, I/O devices, and system bus. The operating system manages the coordination and communication between these processors to execute tasks in parallel. Multiprocessor systems aim to improve processing speed and system throughput by utilizing multiple CPUs to concurrently execute different parts of a program or multiple programs. They typically use techniques like symmetric multiprocessing (SMP) or asymmetric multiprocessing (AMP) to distribute tasks across processors. Examples include server operating systems and high-performance computing systems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Distributed Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Distributed operating systems&lt;/strong&gt; manage a &lt;strong&gt;group of independent computers (nodes) that are networked together to work as a single, unified system&lt;/strong&gt;. Each computer in a distributed system has its own CPU, memory, and I/O devices, and they communicate with each other over a network. The distributed OS coordinates the activities of these networked computers to achieve a common goal or provide a distributed service. They focus on resource sharing, communication, and fault tolerance across multiple machines. Distributed systems are often used for large-scale applications, cloud computing, and network services. Examples include cluster computing and grid computing environments.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Differences:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;th&gt;Multiprocessor OS&lt;/th&gt;
&lt;th&gt;Distributed OS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Number of Computers&lt;/td&gt;
&lt;td data-label=&quot;Multiprocessor OS&quot;&gt;Single computer with multiple CPUs&lt;/td&gt;
&lt;td data-label=&quot;Distributed OS&quot;&gt;Multiple computers networked together&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Memory&lt;/td&gt;
&lt;td data-label=&quot;Multiprocessor OS&quot;&gt;Shared physical memory&lt;/td&gt;
&lt;td data-label=&quot;Distributed OS&quot;&gt;Each computer has its own memory (distributed memory)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Communication&lt;/td&gt;
&lt;td data-label=&quot;Multiprocessor OS&quot;&gt;Shared memory and system bus&lt;/td&gt;
&lt;td data-label=&quot;Distributed OS&quot;&gt;Network communication (message passing)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;System Structure&lt;/td&gt;
&lt;td data-label=&quot;Multiprocessor OS&quot;&gt;Tightly coupled system&lt;/td&gt;
&lt;td data-label=&quot;Distributed OS&quot;&gt;Loosely coupled system&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Feature&quot;&gt;Goal&lt;/td&gt;
&lt;td data-label=&quot;Multiprocessor OS&quot;&gt;Increase processing speed and throughput within a single system&lt;/td&gt;
&lt;td data-label=&quot;Distributed OS&quot;&gt;Resource sharing, scalability, fault tolerance across multiple systems&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Describe two parts of an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Kernel&lt;/strong&gt;: The &lt;strong&gt;kernel&lt;/strong&gt; is the &lt;strong&gt;core component of the operating system&lt;/strong&gt;. It is the innermost layer and has direct control over the hardware. The kernel provides essential services such as process management, memory management, file system management, device management, and interrupt handling. It acts as the interface between the hardware and the rest of the operating system and applications. The kernel is typically resident in memory and executes in a privileged mode (kernel mode) to control system resources and enforce security. It is responsible for the fundamental operations that make the system functional and responsive.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;System Programs (or System Utilities)&lt;/strong&gt;: &lt;strong&gt;System programs&lt;/strong&gt; are a set of &lt;strong&gt;utility programs that are bundled with the operating system&lt;/strong&gt; to assist users and system administrators in managing and utilizing the computer system effectively. These programs provide a range of functions, including file management (e.g., file explorers, command-line shells), system configuration, monitoring, software installation, and network utilities. System programs run in user mode and utilize system calls to request services from the kernel. They enhance the user experience and provide tools for system maintenance and administration, extending the functionality of the core OS kernel.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (i) I. (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Karen was running a system using priority scheduling. She had two processes X and Y with run times of 20 minutes and 60 minutes respectively. Determine the processes to be selected:&lt;/p&gt;
&lt;p&gt;(i) I. If both wait for 5 minutes;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. If both wait for 5 minutes&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;If both processes X and Y have been waiting for 5 minutes and priority is based on waiting time (aging might increase priority over time), and assuming no initial priority difference, process &lt;strong&gt;X should be selected first&lt;/strong&gt; because it has a shorter run time (20 minutes) compared to Y (60 minutes). Selecting the shorter job first, in this context, minimizes the time until the first process completes and may improve overall system responsiveness. However, if initial priorities are different, the higher priority process would be selected regardless of waiting time, until aging increases the waiting process’s priority.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (i) II. (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;II. If Y waits for 35 minutes;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;II. If Y waits for 35 minutes&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;If process Y has been waiting for 35 minutes, and process X's waiting time is not specified (assuming shorter or negligible waiting time for X in comparison, or newly arrived), then process &lt;strong&gt;Y should be selected&lt;/strong&gt;. The significantly longer waiting time for Y, especially if aging is implemented, would likely have increased its priority considerably. Even if X has a higher initial priority, the prolonged waiting of Y would likely elevate its priority enough to be selected over X to prevent starvation and ensure fairness. Priority scheduling with aging is designed to prioritize longer waiting processes eventually.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (i) III. (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;III. If X start at time 0.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;III. If X starts at time 0&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;If process X starts at time 0, it implies &lt;strong&gt;process X is selected first&lt;/strong&gt;. In priority scheduling, if process X has a higher priority than Y initially or at time 0, or if X arrives before Y and the scheduling is also considering arrival time along with priority, X would be scheduled to run first. Starting at time 0 simply means X is chosen to run initially, possibly due to its higher priority or earlier arrival.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline the way this technique avoids starvation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Avoidance of Starvation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Priority scheduling avoids starvation through &lt;strong&gt;aging&lt;/strong&gt;. Aging is a technique that &lt;strong&gt;gradually increases the priority of processes that have been waiting in the ready queue for a long time&lt;/strong&gt;. As a process waits longer, its priority increases, making it more likely to be selected for execution, even if it initially had a low priority. Eventually, through aging, even a low-priority process will reach a priority level high enough to be scheduled, preventing indefinite postponement and starvation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) State four types of access rights that could be granted in a file sharing computer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Read Access&lt;/strong&gt;: &lt;strong&gt;Read access&lt;/strong&gt; right allows a user or process to &lt;strong&gt;view or read the contents of a file&lt;/strong&gt;. With read access, the user can open the file and read its data but cannot make any changes to the file's content. This is a basic access right that grants viewing privileges.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Write Access&lt;/strong&gt;: &lt;strong&gt;Write access&lt;/strong&gt; right permits a user or process to &lt;strong&gt;modify or write data to a file&lt;/strong&gt;. With write access, the user can change the file's contents, append data, or overwrite existing data. Write access usually implies read access as well, as one might need to read a file before modifying it. This right grants modification privileges.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Execute Access&lt;/strong&gt;: &lt;strong&gt;Execute access&lt;/strong&gt; right allows a user or process to &lt;strong&gt;run or execute a file&lt;/strong&gt;, typically applicable to executable files or scripts. For executable files, this right is necessary to launch and run the program. For directories, execute access might mean the ability to search through the directory or access files within it. This right grants execution privileges.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete Access&lt;/strong&gt;: &lt;strong&gt;Delete access&lt;/strong&gt; right grants a user or process the permission to &lt;strong&gt;remove or delete a file&lt;/strong&gt;. With delete access, a user can permanently erase the file from the file system. This is a powerful right that should be granted cautiously, as it can lead to data loss if used improperly. This right grants deletion privileges.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of an illustration, differentiate the sequential and indexed sequential file organization methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Sequential vs. Indexed Sequential File Organization&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequential File Organization&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;sequential file organization&lt;/strong&gt;, records are stored in a &lt;strong&gt;linear sequence&lt;/strong&gt;, one after another, in the order they are entered. Records are typically arranged based on a key field, but access is primarily sequential. To access a specific record, one must traverse through all preceding records. Sequential files are efficient for operations that process records in order, like batch processing, but inefficient for random access or direct access to specific records.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Illustration of Sequential File Organization:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-----------------+-----------------+-----------------+-----+-----------------+
| Record 1        | Record 2        | Record 3        | ... | Record N        |
+-----------------+-----------------+-----------------+-----+-----------------+
  (Key: Key1)       (Key: Key2)       (Key: Key3)             (Key: KeyN)
  Stored in sequential order
  Access: Sequential traversal from Record 1 to Record N
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Indexed Sequential File Organization&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Indexed sequential file organization&lt;/strong&gt; combines sequential access with direct access capabilities by using an &lt;strong&gt;index&lt;/strong&gt;. Records are stored sequentially, similar to sequential files, but an index is also created that maps key values to the disk addresses of records or blocks of records. The index allows for direct access to a record by looking up its key in the index and then directly accessing its location on disk. Sequential access is still efficient, and direct access is also supported through the index, making it more versatile than purely sequential organization.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Illustration of Indexed Sequential File Organization:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;Index:
+-----------+-------------+
| Key Value | Disk Address|
+-----------+-------------+
| Key1      | Address 1   | --&amp;gt; +-----------------+-----------------+-----+
| Key5      | Address 5   | --&amp;gt; | Record 1        | Record 2        | ... | Sequential Block 1
| Key10     | Address 10  | --&amp;gt; +-----------------+-----------------+-----+
| ...       | ...         |
| KeyN      | Address N   | --&amp;gt; +-----------------+-----------------+-----+
+-----------+-------------+     | Record X        | Record Y        | ... | Sequential Block N
                                  +-----------------+-----------------+-----+
  Index for Direct Access       Data Records in Sequential Order
  Access: Sequential and Direct (via Index)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Key Differentiation:&lt;/strong&gt; Sequential files support only sequential access, while indexed sequential files support both sequential access for ordered processing and direct access via an index for efficient retrieval of specific records. Indexed sequential organization provides a balance between sequential processing efficiency and direct access capability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2017 The Kenya National Examinations Council&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="258"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="7_129_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="37">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="34"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-10-10_2017july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-10-10_2017july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="1e6eb86fceff856121bd3a0cb65a8d76"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="35"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="35"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="1"></int>
              <string role="key" value="parentNode"></string>
              <reference key="36"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="7"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="36"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="37"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="7"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202017"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="40">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2016"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="38">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="39">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="130_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="38"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2016&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Explain the term system call as applied in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;system call&lt;/strong&gt; is a &lt;strong&gt;request made by a user-level process to the operating system kernel&lt;/strong&gt; to perform a privileged operation. It acts as the &lt;strong&gt;interface between user space and kernel space&lt;/strong&gt;, allowing user programs to request services from the OS, such as I/O operations, process creation, and memory allocation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Outline four benefits of virtual memory in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Running Larger Programs&lt;/strong&gt;: Virtual memory allows users to run &lt;strong&gt;programs larger than the physical RAM&lt;/strong&gt; available. It achieves this by using disk space as an extension of RAM, swapping portions of programs (pages) between disk and memory as needed.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Multiprogramming&lt;/strong&gt;: By enabling programs larger than physical memory to run, virtual memory &lt;strong&gt;increases the degree of multiprogramming&lt;/strong&gt;. More processes can reside in memory (partially), improving CPU utilization and system throughput.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Efficient Memory Utilization&lt;/strong&gt;: Virtual memory leads to more &lt;strong&gt;efficient utilization of physical RAM&lt;/strong&gt;. Only the necessary parts of a program are loaded into memory, freeing up space for other processes or data.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Memory Protection&lt;/strong&gt;: Virtual memory enhances &lt;strong&gt;memory protection&lt;/strong&gt;. Each process operates in its own virtual address space, isolated from other processes, preventing unauthorized access and interference.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Describe three strategies that could be used to mitigate deadlocks in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Deadlock Prevention&lt;/strong&gt;: &lt;strong&gt;Deadlock prevention&lt;/strong&gt; aims to &lt;strong&gt;prevent deadlocks by ensuring that at least one of the necessary conditions for deadlock cannot hold&lt;/strong&gt;. These conditions are mutual exclusion, hold and wait, no preemption, and circular wait. Prevention techniques might include: * &lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: Not easily preventable, as some resources are inherently non-sharable. * &lt;strong&gt;Hold and Wait&lt;/strong&gt;: Processes must request all required resources before execution or release all held resources before requesting new ones. * &lt;strong&gt;No Preemption&lt;/strong&gt;: If a process holding certain resources requests another resource that cannot be immediately allocated, the held resources are preempted (temporarily taken away). * &lt;strong&gt;Circular Wait&lt;/strong&gt;: Impose a linear ordering of resource types and require that each process requests resources in an increasing order of enumeration.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Deadlock Avoidance&lt;/strong&gt;: &lt;strong&gt;Deadlock avoidance&lt;/strong&gt; allows all four deadlock conditions to be possible but makes &lt;strong&gt;dynamic decisions about resource allocation to ensure that the system never enters a deadlock state&lt;/strong&gt;. This often involves using algorithms like the Banker's Algorithm. Avoidance requires the system to have prior information about the maximum resource needs of each process. The system then analyzes each resource request to ensure that granting it will keep the system in a 'safe state' (a state from which all processes can complete without deadlock).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Deadlock Detection and Recovery&lt;/strong&gt;: &lt;strong&gt;Deadlock detection and recovery&lt;/strong&gt; allow deadlocks to occur, then &lt;strong&gt;detect and resolve them&lt;/strong&gt;. Detection involves periodically checking the system state to see if a deadlock has occurred, typically by building and searching a resource allocation graph for cycles. Once a deadlock is detected, recovery strategies may include: * &lt;strong&gt;Process Termination&lt;/strong&gt;: Aborting one or more processes involved in the deadlock. This can be drastic, potentially losing progress. Selection of processes to abort can be based on priority, progress made, or resources held. * &lt;strong&gt;Resource Preemption&lt;/strong&gt;: Forcibly taking resources away from one or more deadlocked processes. This is only feasible if the resource state can be easily saved and restored. The preempted process may need to be rolled back to a safe state and restarted.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Several resources are prerequisite for a successful process execution by the CPU. Outline four examples of these resources that should be availed to the CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time&lt;/strong&gt;: &lt;strong&gt;CPU time&lt;/strong&gt; is the fundamental resource required for process execution. The CPU needs to allocate processing cycles to the process so it can execute its instructions. Scheduling algorithms determine how CPU time is distributed among competing processes.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory&lt;/strong&gt;: &lt;strong&gt;Memory (RAM)&lt;/strong&gt; is essential for storing the process's code, data, and stack. The CPU fetches instructions and data from memory to execute the process. Sufficient memory must be allocated to the process for it to run effectively.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Input/Output (I/O) Devices&lt;/strong&gt;: Processes often require access to &lt;strong&gt;I/O devices&lt;/strong&gt; such as disks, network interfaces, keyboards, and displays. Access to these devices allows processes to interact with the external environment, read input, and produce output.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Files&lt;/strong&gt;: Processes frequently need to access &lt;strong&gt;files&lt;/strong&gt; for reading data or storing results. File system resources, including file handles, disk space, and file metadata, are necessary for file operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Sifa was required to identify advantages of the pre-emptive job scheduling techniques. Explain two advantages that she could have identified.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Improved Responsiveness&lt;/strong&gt;: &lt;strong&gt;Pre-emptive scheduling&lt;/strong&gt; significantly improves system responsiveness, especially for interactive and time-sensitive applications. By allowing the operating system to interrupt (preempt) a running process and switch to another ready process, pre-emptive scheduling ensures that high-priority or interactive tasks can get quick CPU access. This reduces latency and provides a more interactive user experience, as the system remains responsive even under heavy load.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Fairer Allocation of CPU Time&lt;/strong&gt;: Pre-emptive scheduling promotes a &lt;strong&gt;fairer allocation of CPU time&lt;/strong&gt; among processes. It prevents a single process from monopolizing the CPU for extended periods, which can happen in non-preemptive systems where a long-running process can block shorter or higher-priority processes. Techniques like time-slicing in Round Robin scheduling, a pre-emptive algorithm, ensure that each process gets a fair share of CPU time over time, improving overall system fairness and preventing starvation of processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline three file operations that could be applied to a file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create&lt;/strong&gt;: The &lt;strong&gt;create&lt;/strong&gt; operation is used to &lt;strong&gt;establish a new file&lt;/strong&gt; in the file system. It involves allocating storage space for the file and creating a directory entry with the file's name and attributes. Creating a file makes it ready for data to be written into it.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Read&lt;/strong&gt;: The &lt;strong&gt;read&lt;/strong&gt; operation allows for &lt;strong&gt;retrieving data from an existing file&lt;/strong&gt;. It involves accessing the file's contents from the storage medium and transferring the data to memory for processing or display. Reading a file is a fundamental operation for accessing and using stored information.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Write&lt;/strong&gt;: The &lt;strong&gt;write&lt;/strong&gt; operation is used to &lt;strong&gt;store data into a file&lt;/strong&gt;. It involves transferring data from memory to the file on the storage medium, updating the file's contents. Writing to a file is essential for saving new information or modifying existing file data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (1) Define the term sector as applied in computer storage.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;sector&lt;/strong&gt; in computer storage, particularly in hard disk drives and floppy disks, is the &lt;strong&gt;smallest physical storage unit on a disk&lt;/strong&gt;. It is a &lt;strong&gt;fixed-size block of data&lt;/strong&gt;, traditionally 512 bytes or 4KB, that can be read or written in a single operation. Sectors are arranged in tracks and are the fundamental unit of data organization and access on disk media.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of a diagram, describe file allocation table as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) File Allocation Table (FAT)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;File Allocation Table (FAT)&lt;/strong&gt; is a &lt;strong&gt;data structure used by some operating systems to manage file storage on disk&lt;/strong&gt;, particularly in older systems like DOS and early Windows versions. It acts as an &lt;strong&gt;index&lt;/strong&gt; that maps files to the clusters (groups of sectors) they occupy on the disk. The FAT is essentially a table that resides at the beginning of a disk partition, containing entries for each cluster on the disk. Each entry indicates whether a cluster is free, allocated to a file, or marked as bad. For allocated clusters, it points to the next cluster in the file, forming a chain of clusters for each file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of FAT Structure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;Disk Partition:
+-----------------------+-----------------------+-----------------------+-----+-----------------------+
| Reserved Area         | FAT 1                 | FAT 2 (Backup)        | ... | Data Area             |
+-----------------------+-----------------------+-----------------------+-----+-----------------------+

File Allocation Table (FAT):
+---------+---------+---------+-----+---------+
| Cluster 0| Cluster 1| Cluster 2| ... | Cluster N|
+---------+---------+---------+-----+---------+
| Entry 0 | Entry 1 | Entry 2 | ... | Entry N |  &amp;lt;-- Entries contain cluster status or pointer to next cluster
+---------+---------+---------+-----+---------+

Example FAT Entries:
- 0x0000: Free cluster
- 0xFFFF: End of file cluster chain
- Cluster number: Pointer to the next cluster in the file chain

Directory Entry:
+---------------+---------------+-----+---------------+
| File Name     | Starting      | ... | File Attributes|
|               | Cluster Number|     |                |
+---------------+---------------+-----+---------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;FAT Location&lt;/strong&gt;: The FAT is typically located at the &lt;strong&gt;beginning of a disk partition&lt;/strong&gt;, often with a backup copy (FAT2) for redundancy.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Cluster Mapping&lt;/strong&gt;: The FAT is an array where each entry corresponds to a &lt;strong&gt;cluster on the disk&lt;/strong&gt;. The entry for each cluster indicates its status (free, allocated, bad) or, if allocated, the &lt;strong&gt;number of the next cluster in the file's chain&lt;/strong&gt;.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;File Allocation&lt;/strong&gt;: When a file is created or expanded, the operating system searches the FAT for &lt;strong&gt;free clusters&lt;/strong&gt;, allocates them to the file, and updates the FAT entries to link these clusters together in a chain. The directory entry for a file stores the &lt;strong&gt;starting cluster number&lt;/strong&gt; of the file.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;File Access&lt;/strong&gt;: To access a file, the OS reads the starting cluster number from the directory entry and then &lt;strong&gt;traverses the chain of clusters&lt;/strong&gt; by following the pointers in the FAT entries until it reaches the end-of-file marker. This linked list structure allows for non-contiguous file allocation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Outline two limitations of fixed memory partitioning.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;: &lt;strong&gt;Internal fragmentation&lt;/strong&gt; occurs when a process is allocated a partition larger than its actual memory requirement. The unused space within the partition is wasted and cannot be used by other processes. Since partitions are fixed in size, there is often a mismatch between process size and partition size, leading to inefficient memory utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Limited Multiprogramming Degree&lt;/strong&gt;: &lt;strong&gt;Fixed partitioning limits the degree of multiprogramming&lt;/strong&gt;. The number of partitions is fixed at system startup, restricting the number of processes that can reside in memory simultaneously. If all partitions are occupied, new processes must wait even if there is enough total free memory, just not in appropriately sized partitions. This can reduce overall system throughput and responsiveness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between single and double buffering as used in I/O ports registers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Single Buffering&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;single buffering&lt;/strong&gt;, a &lt;strong&gt;single buffer&lt;/strong&gt; is used in memory for data transfer between an I/O device and the processor via I/O port registers. Data is transferred in chunks, and the processor must wait for each chunk transfer to complete before initiating the next operation. This leads to &lt;strong&gt;alternating periods of data transfer and processing&lt;/strong&gt;, with the processor often idle during data transfer. Single buffering is simple but can be inefficient due to the wait times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Double Buffering&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;double buffering&lt;/strong&gt;, &lt;strong&gt;two buffers&lt;/strong&gt; are used. While one buffer is being filled or emptied by the I/O device (via I/O port registers), the processor can simultaneously process data in the other buffer. This allows for &lt;strong&gt;overlapping of I/O operations with processing&lt;/strong&gt;. The processor does not have to wait for each I/O operation to complete before starting processing, reducing idle time and improving throughput. Double buffering enhances efficiency by enabling concurrency between data transfer and processing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Single buffering uses one buffer and involves sequential I/O and processing, leading to processor idle time. Double buffering uses two buffers to overlap I/O and processing, reducing idle time and improving efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Tom would like to design a memory system that uses best-fit placement algorithm. Explain two limitations of this algorithm that would affect the performance of the memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Search Time for Allocation&lt;/strong&gt;: The &lt;strong&gt;best-fit algorithm&lt;/strong&gt; requires &lt;strong&gt;searching the entire list of free memory partitions&lt;/strong&gt; to find the smallest partition that is large enough to satisfy the memory request. This exhaustive search can be &lt;strong&gt;time-consuming&lt;/strong&gt;, especially when there are many free partitions. The overhead of searching for the best fit can increase memory allocation time, impacting system performance, particularly for frequent memory allocation requests.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: While best-fit aims to minimize wasted space, it can still lead to &lt;strong&gt;external fragmentation&lt;/strong&gt;. By allocating memory from the smallest suitable partition, it tends to leave behind &lt;strong&gt;many small, unusable fragments&lt;/strong&gt; of free memory between allocated blocks. Over time, this can result in a situation where there is sufficient total free memory, but it is scattered in small chunks, making it difficult to allocate memory for larger processes that require contiguous blocks. This fragmentation reduces the usability of total memory and can degrade performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (e) Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(1) kernel;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Kernel&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;kernel&lt;/strong&gt; is the &lt;strong&gt;core of an operating system&lt;/strong&gt;. It is the &lt;strong&gt;lowest-level software&lt;/strong&gt; that has direct control over the system hardware. The kernel provides essential services such as process management, memory management, file system management, device control, and system calls. It acts as a bridge between hardware and user-level applications and is responsible for managing system resources.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(!!) monitor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Monitor&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In operating systems, a &lt;strong&gt;monitor&lt;/strong&gt; is a &lt;strong&gt;synchronization construct&lt;/strong&gt; used for controlling access to shared resources in concurrent programming. A monitor encapsulates shared data and a set of procedures (methods) that operate on that data. Monitors ensure &lt;strong&gt;mutual exclusion&lt;/strong&gt; (only one process can be active inside the monitor at any time) and provide &lt;strong&gt;condition variables&lt;/strong&gt; for processes to wait and signal each other within the monitor.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Elsie was required to select an operating system that would be used on a server computer to provide a wide range of services to other desktop computers.&lt;/p&gt;
&lt;p&gt;(i) Identify the most appropriate type of operating system that she could select justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Network Operating System (NOS)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The most appropriate type of operating system Elsie could select is a &lt;strong&gt;Network Operating System (NOS)&lt;/strong&gt;. A NOS is specifically designed to &lt;strong&gt;manage server operations and provide network services&lt;/strong&gt; to client computers. It is optimized for resource sharing, network management, security, and handling multiple client requests efficiently, making it ideal for server environments providing services to desktop computers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two benefits that her company could realize when using the operating system identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Centralized Resource Management and Sharing&lt;/strong&gt;: Using a NOS on a server enables &lt;strong&gt;centralized management and sharing of resources&lt;/strong&gt;. The server can host and manage resources like files, printers, applications, databases, and internet access, making them available to multiple desktop computers (clients) across the network. This centralized approach simplifies administration, reduces redundancy, and improves resource utilization. It allows for efficient sharing of expensive resources and easier control over access and usage.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Security and Control&lt;/strong&gt;: A NOS provides &lt;strong&gt;enhanced security and control&lt;/strong&gt; over network resources and data. Security features like user authentication, access control lists, firewalls, and encryption can be centrally implemented and managed on the server. This central security administration simplifies the enforcement of security policies, protects sensitive data, and reduces vulnerabilities across the network. A NOS allows for better control over user access, data integrity, and network traffic, improving overall system security posture.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Explain the term Remote Procedure Call (RPC) as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Remote Procedure Call (RPC)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remote Procedure Call (RPC)&lt;/strong&gt; is a &lt;strong&gt;protocol that allows a program on one computer to execute a procedure or function on another computer over a network&lt;/strong&gt; as if it were a local procedure call. RPC abstracts the complexities of network communication, making distributed computing easier. It enables client-server interactions where a client can request services from a server by invoking procedures remotely, simplifying distributed application development.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between communication and storage I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Communication I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Communication I/O devices&lt;/strong&gt; are used for &lt;strong&gt;data transfer between computer systems or networks&lt;/strong&gt;. They facilitate data exchange over communication channels. Examples include &lt;strong&gt;network interface cards (NICs)&lt;/strong&gt;, modems, and serial ports. The primary function of communication I/O devices is to enable networking and data transmission between computers, allowing for distributed processing, network access, and remote communication.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Storage I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Storage I/O devices&lt;/strong&gt; are used for &lt;strong&gt;persistent data storage and retrieval within a computer system&lt;/strong&gt;. They provide non-volatile storage for data that needs to be retained even when the system is powered off. Examples include &lt;strong&gt;hard disk drives (HDDs)&lt;/strong&gt;, solid-state drives (SSDs), and USB drives. The main purpose of storage I/O devices is to store files, applications, and operating system data, enabling long-term data retention and access.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Communication I/O devices are for inter-system data exchange over networks, while storage I/O devices are for persistent data storage within a single computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) A computer is made up of different types of internal buses to facilitate communication. Explain two types of such buses found in a computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Bus&lt;/strong&gt;: The &lt;strong&gt;data bus&lt;/strong&gt; is a set of parallel wires (lines) used to &lt;strong&gt;transfer actual data between components of a computer system&lt;/strong&gt;. It carries the binary data being processed or stored. The width of the data bus (number of lines) determines the amount of data that can be transferred simultaneously in one clock cycle. Common data bus widths are 32-bit, 64-bit, or wider. A wider data bus allows for faster data transfer rates, improving system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Address Bus&lt;/strong&gt;: The &lt;strong&gt;address bus&lt;/strong&gt; is another set of parallel wires used to &lt;strong&gt;specify the memory location or I/O port address that the CPU wants to access&lt;/strong&gt;. The CPU places an address on the address bus to select a specific memory location or I/O device for read or write operations. The width of the address bus determines the total amount of memory that the CPU can address. For example, a 32-bit address bus can address 2^32 bytes (4GB) of memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) (1) Outline three examples of roles that could be provided by a parent processor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Creation&lt;/strong&gt;: A parent processor (or process) is responsible for &lt;strong&gt;creating child processes&lt;/strong&gt;. It initiates the execution of new processes, allocating necessary resources and setting up the execution environment for the child processes. Process creation is a fundamental role in process management, allowing for multitasking and parallel processing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Resource Allocation&lt;/strong&gt;: Parent processors can &lt;strong&gt;allocate resources to their child processes&lt;/strong&gt;. This includes memory allocation, file access permissions, and access to I/O devices. Resource allocation ensures that child processes have the necessary resources to execute effectively and prevents resource conflicts between processes.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Process Control and Monitoring&lt;/strong&gt;: Parent processors play a role in &lt;strong&gt;controlling and monitoring their child processes&lt;/strong&gt;. They can manage the execution of child processes, including starting, suspending, resuming, and terminating them. Parent processes can also monitor the status and resource usage of their children, enabling process management and system monitoring functionalities.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of a diagram, describe the burst DMA mode of operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Burst DMA Mode of Operation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Burst DMA (Direct Memory Access) mode&lt;/strong&gt;, the DMA controller &lt;strong&gt;transfers a continuous block of data in a single burst&lt;/strong&gt;. Once the DMA controller gains control of the system bus, it transfers multiple data words or bytes in rapid succession without releasing the bus between each transfer. This mode is highly efficient for large data transfers as it minimizes the overhead of bus arbitration for each data unit. The CPU is suspended from bus access during the entire burst transfer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Burst DMA Mode:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------+     +----------+     +----------+     +---------+
|  Device | ----&amp;gt; | DMA      | ----&amp;gt; | Memory   | &amp;lt;----| CPU   |
+---------+     | Controller|     +----------+      Suspend
      Request      +----------+         Data Burst Transfer
          ^             | Bus Grant (One Time)
          |             V
          +----------+
          |   CPU    |
          +----------+
            Initialize DMA, Request Burst Transfer, Wait for Completion
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;DMA Request and Bus Grant&lt;/strong&gt;: The I/O device requests a DMA transfer. The DMA controller requests control of the system bus from the CPU. Once the CPU grants the bus, the DMA controller gains exclusive control for a burst transfer.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Burst Data Transfer&lt;/strong&gt;: The DMA controller transfers a &lt;strong&gt;block of data (burst) continuously&lt;/strong&gt; between the I/O device and memory &lt;strong&gt;without releasing the bus&lt;/strong&gt; after each data unit. It performs multiple read or write operations in quick succession, using the granted bus access efficiently.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;CPU Suspension&lt;/strong&gt;: During the burst transfer, the &lt;strong&gt;CPU is suspended from accessing the system bus&lt;/strong&gt;. It has to wait until the DMA controller completes the entire burst transfer and releases the bus. This is known as cycle stealing, although in burst mode, it's a block of cycles.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Transfer Completion and Bus Release&lt;/strong&gt;: After the burst transfer is complete (specified number of bytes transferred), the DMA controller &lt;strong&gt;releases control of the system bus&lt;/strong&gt;, and the CPU can resume its bus operations. The DMA controller then notifies the CPU of transfer completion via an interrupt.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage:&lt;/strong&gt; Burst DMA mode is very &lt;strong&gt;efficient for high-speed data transfers&lt;/strong&gt; because it reduces bus arbitration overhead, leading to higher throughput compared to single-transfer DMA modes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) With the aid of a diagram, describe a hierarchical file system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Hierarchical File System (Tree-Structured Directory)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;hierarchical file system&lt;/strong&gt;, also known as a tree-structured directory, is a file organization system that uses a &lt;strong&gt;directory hierarchy&lt;/strong&gt; to organize files and directories. It is structured like an inverted tree, with a single root directory at the top, and directories and files branching out from it. This structure allows users to organize files into logical groups and sub-groups, making file management more organized and scalable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Hierarchical File System:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                      Root Directory (/)
                         |
             +-----------+-----------+
             |                       |
          Directory A             Directory B
             |                       |
     +-------+-------+         +-------+-------+
     |               |         |               |
  Directory C     File 1      Directory D     File 2
     |                         |
 +-----+-----+               +-----+-----+
 |           |               |           |
File 3      File 4         File 5      File 6

... and so on, forming a tree-like structure.
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Root Directory&lt;/strong&gt;: At the top of the hierarchy is the &lt;strong&gt;root directory&lt;/strong&gt;, denoted as '/' in Unix-like systems or drive letter (e.g., 'C:\') in Windows. It is the starting point of the entire file system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Directories (Folders)&lt;/strong&gt;: Directories, also known as folders, are containers that can hold files and other directories (subdirectories). They are used to organize files into logical groupings. Directories create levels in the hierarchy.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Files&lt;/strong&gt;: Files are the actual data containers, stored within directories. Each file has a name and resides in a specific directory. Files are the leaf nodes in the tree structure.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Pathnames&lt;/strong&gt;: Files and directories are accessed using &lt;strong&gt;pathnames&lt;/strong&gt;, which specify the sequence of directories to traverse from the root to reach the target file or directory. Pathnames can be absolute (starting from the root) or relative (starting from the current working directory).&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Navigation&lt;/strong&gt;: Users can navigate through the directory hierarchy to access files and directories. Operations like creating, deleting, moving, and renaming files and directories are performed within this hierarchical structure.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantages:&lt;/strong&gt; Hierarchical file systems provide &lt;strong&gt;better organization&lt;/strong&gt;, &lt;strong&gt;scalability&lt;/strong&gt;, and &lt;strong&gt;manageability&lt;/strong&gt; compared to flat file systems. They allow users to structure their data logically, avoid naming conflicts, and efficiently manage large numbers of files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Mark proposed a file encryption technique for his company's file system. Explain two techniques that he could have proposed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Symmetric Encryption&lt;/strong&gt;: Mark could propose using &lt;strong&gt;symmetric encryption&lt;/strong&gt; techniques. In symmetric encryption, the &lt;strong&gt;same key is used for both encryption and decryption&lt;/strong&gt;. Techniques like AES (Advanced Encryption Standard), DES (Data Encryption Standard), or Triple DES could be employed. When a file is encrypted, it is transformed into an unreadable format using the symmetric key. To decrypt the file and access the original data, the same key must be used. Symmetric encryption is generally faster and more efficient for encrypting large files, making it suitable for file system encryption. Key management and secure key distribution are crucial considerations with symmetric encryption.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Asymmetric Encryption (Public-Key Encryption)&lt;/strong&gt;: Mark could also consider &lt;strong&gt;asymmetric encryption&lt;/strong&gt;, also known as public-key encryption. Asymmetric encryption uses &lt;strong&gt;key pairs: a public key for encryption and a private key for decryption&lt;/strong&gt;. Techniques like RSA (Rivest-Shamir-Adleman) or ECC (Elliptic Curve Cryptography) could be used. Files can be encrypted using the public key, and only the corresponding private key can decrypt them. Asymmetric encryption provides more secure key management as the private key does not need to be shared. It can be used for encrypting files or for secure key exchange to then use symmetric encryption for bulk data encryption. Asymmetric encryption is generally slower than symmetric encryption and is often used in combination with symmetric methods.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Deadlocks are inevitable in operating systems. Explain two conditions that should hold to trigger this anomaly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: &lt;strong&gt;Mutual exclusion&lt;/strong&gt; is a condition where &lt;strong&gt;at least one resource must be held in a non-sharable mode&lt;/strong&gt;. This means that only one process at a time can use the resource. If another process requests that resource, it must wait until the resource is released. If mutual exclusion does not hold for all resources, deadlocks cannot occur, as processes could share resources freely.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt;: The &lt;strong&gt;hold and wait&lt;/strong&gt; condition occurs when a process is &lt;strong&gt;holding at least one resource and is waiting to acquire additional resources&lt;/strong&gt; that are currently being held by other processes. For a deadlock to occur, processes must hold resources while simultaneously requesting new ones. If processes were required to request all needed resources at the start and not hold resources while waiting for others, deadlocks could be prevented.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) (i) Name two ways of creating processes during execution by operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Forking (System Call)&lt;/strong&gt;: The &lt;strong&gt;fork system call&lt;/strong&gt; is a common method for process creation. When a process calls fork, the operating system &lt;strong&gt;creates a duplicate of the calling process&lt;/strong&gt;. The new process, called the child process, is nearly identical to the parent process, inheriting its code, data, and resources, but with a new process ID (PID).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Exec (System Call)&lt;/strong&gt;: The &lt;strong&gt;exec system call&lt;/strong&gt; is used to &lt;strong&gt;replace the current process's memory space with a new program&lt;/strong&gt;. Typically used after a fork, exec loads and runs a new executable file in the child process's context. This allows a process to initiate and run a completely different program than itself.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four advantages of peer-to-peer file sharing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Decentralization&lt;/strong&gt;: &lt;strong&gt;Peer-to-peer (P2P) file sharing&lt;/strong&gt; is &lt;strong&gt;decentralized&lt;/strong&gt;, meaning there is no central server or authority controlling the file sharing process. This decentralization makes the network more robust and resistant to single points of failure. If one peer goes offline, the network can continue to function as long as other peers are available.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Scalability&lt;/strong&gt;: P2P networks are inherently &lt;strong&gt;scalable&lt;/strong&gt;. As the number of users (peers) increases, the network's capacity and bandwidth also increase because each new peer contributes resources (bandwidth, storage) to the network. This scalability makes P2P suitable for large user bases and heavy file sharing loads.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Cost-Effective&lt;/strong&gt;: P2P file sharing can be &lt;strong&gt;cost-effective&lt;/strong&gt; compared to centralized systems. There is no need for expensive central servers and infrastructure. Resources are distributed among peers, reducing infrastructure costs and reliance on central providers.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Increased Availability and Redundancy&lt;/strong&gt;: Files shared on P2P networks are often &lt;strong&gt;distributed across multiple peers&lt;/strong&gt;. This redundancy enhances file availability. If one peer hosting a file goes offline, other peers may still have copies of the file, ensuring that the file remains accessible to the network. This improves data resilience and availability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between seek time and rotational delay as used in disk management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Seek Time&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek time&lt;/strong&gt; is the &lt;strong&gt;time it takes for the disk arm and read/write head to move to the correct track (cylinder) on the disk surface&lt;/strong&gt; where the desired data is located. Seek time is a major component of disk access time and is influenced by the distance the head needs to travel across the disk. Shorter seek times result in faster data access. Disk scheduling algorithms aim to minimize average seek time by optimizing the order in which disk requests are serviced.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rotational Delay (Latency)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rotational delay&lt;/strong&gt;, also known as rotational latency, is the &lt;strong&gt;time it takes for the desired sector of the disk to rotate under the read/write head once the head is positioned over the correct track&lt;/strong&gt;. After the seek operation positions the head over the correct track, rotational delay is the time for the disk to spin until the beginning of the requested sector reaches the head. Rotational delay is dependent on the disk's rotation speed (RPM). Higher RPM disks have lower rotational latency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Seek time is the time for head movement across tracks, while rotational delay is the time for disk rotation to position the sector under the head after the head is on the correct track. Both contribute to total disk access time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Identify the type of memory used in each case:&lt;/p&gt;
&lt;p&gt;(i) temporarily store results of processing by CPU;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Registers&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) retains stored information event after computer restarts;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Secondary Storage (e.g., Hard Disk Drive, SSD)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) portion of hard disk that is logically addressed as a main memory;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Virtual Memory (Swap Space/Page File)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iv) bridges the speed gap between the processor and RAM;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iv) Cache Memory&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Sam was required to enumerate objectives of inter process communication in operating systems during a regional symposium for programmer's. Explain three objectives that he could have outlined.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Sharing&lt;/strong&gt;: One primary objective of inter-process communication (IPC) is to enable &lt;strong&gt;data sharing between processes&lt;/strong&gt;. IPC mechanisms allow processes to exchange information and data, facilitating collaborative tasks. Processes may need to share data to coordinate activities, process data in stages, or access shared resources. Data sharing through IPC is essential for building complex applications and systems that require cooperation between different components.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Resource Sharing&lt;/strong&gt;: IPC facilitates &lt;strong&gt;resource sharing among processes&lt;/strong&gt;. Operating systems often manage resources like files, I/O devices, and memory segments. IPC mechanisms allow processes to coordinate access to these shared resources, ensuring controlled and synchronized usage. Resource sharing prevents conflicts and enables efficient utilization of system resources by multiple processes.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Synchronization&lt;/strong&gt;: &lt;strong&gt;Process synchronization&lt;/strong&gt; is a crucial objective of IPC. When processes share resources or data, they need to be synchronized to maintain data consistency and prevent race conditions. IPC mechanisms provide tools for process synchronization, allowing processes to coordinate their execution order, wait for specific events, and ensure that critical sections of code are executed atomically. Synchronization is vital for building reliable and predictable concurrent systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) Explain the term frame as applied in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;In memory management, a &lt;strong&gt;frame&lt;/strong&gt; is a &lt;strong&gt;fixed-size block of physical memory (RAM)&lt;/strong&gt;. When using paging, physical memory is divided into equal-sized blocks called frames. Frames are used to hold pages of processes that are loaded into physical memory. Frames are the basic units of physical memory allocation in paging systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between base register and bound register as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Base Register&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;base register&lt;/strong&gt;, in memory management with segmentation or base-limit registers, is a register that &lt;strong&gt;holds the starting physical address of a process's segment in memory&lt;/strong&gt;. When a process is loaded into memory, the base address of its allocated segment is loaded into the base register. Every logical address generated by the process is added to the value in the base register to get the corresponding physical address. The base register defines the starting location of the process's memory region in physical RAM.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bound Register (Limit Register)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;bound register&lt;/strong&gt;, also known as a limit register, is used in conjunction with a base register to define the &lt;strong&gt;size or range of a process's memory segment&lt;/strong&gt;. The bound register holds the &lt;strong&gt;size of the memory segment&lt;/strong&gt; allocated to the process, or the value of the highest valid address relative to the base address. When a process generates a logical address, the operating system checks if the address is within the valid range defined by the bound register (i.e., logical address must be less than the bound). If the address is outside the bound, a memory protection fault (trap) occurs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; The base register defines the starting address of a memory segment, while the bound register defines the size or limit of that segment. Together, they establish the valid memory range for a process and provide memory protection.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Monolithic operating systems are not popular. Outline four limitations of monolithic operating systems that could be influencing this trend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Lack of Modularity&lt;/strong&gt;: &lt;strong&gt;Monolithic kernels lack modularity&lt;/strong&gt;. All OS services (process management, memory management, file system, device drivers, etc.) are tightly integrated into a single, large kernel space. This makes the system complex to understand, maintain, and modify. Changes in one part of the kernel can have unintended consequences in other parts, increasing development and debugging difficulty.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Large Kernel Size&lt;/strong&gt;: Monolithic kernels tend to be &lt;strong&gt;very large in size&lt;/strong&gt; as they include all OS functionalities in one executable. A large kernel consumes significant memory space and can increase the system's attack surface, making it more vulnerable to security exploits. Larger kernels also lead to increased boot times and can reduce the amount of memory available for user applications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;System Instability&lt;/strong&gt;: A fault in any part of a monolithic kernel can potentially &lt;strong&gt;crash the entire system&lt;/strong&gt;. Because all services run in kernel space, errors in device drivers or any other kernel component can lead to system-wide failures. This lack of fault isolation makes monolithic systems less robust and reliable compared to more modular approaches.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Portability Challenges&lt;/strong&gt;: Monolithic kernels are often &lt;strong&gt;less portable across different hardware architectures&lt;/strong&gt;. Due to the tight integration of all components, adapting a monolithic kernel to a new hardware platform can be complex and time-consuming. Changes often need to be made throughout the kernel, hindering portability and increasing development effort for supporting diverse hardware.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) With the aid of sketches, explain two issues associated with memory fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) External Fragmentation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;External fragmentation&lt;/strong&gt; occurs when &lt;strong&gt;total free memory space is sufficient to satisfy a memory request, but it is not contiguous&lt;/strong&gt;. Free memory is scattered in small, non-adjacent blocks between allocated memory regions. As processes are allocated and deallocated memory over time, external fragmentation can increase, making it impossible to allocate larger contiguous blocks, even when total free memory is adequate. This leads to wasted memory and reduced efficiency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sketch of External Fragmentation:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+----------+---------+----------+---------+----------+
| Process A| Free    | Process B| Free    | Process C|  &amp;lt;-- Non-contiguous free blocks
+----------+---------+----------+---------+----------+
       ^         ^         ^
       |         |         |
       Free Block 1 Free Block 2 Free Block 3

Total Free Memory = Free Block 1 + Free Block 2 + Free Block 3 (Sufficient in total, but not contiguous)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(ii) Internal Fragmentation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Internal fragmentation&lt;/strong&gt; occurs in fixed partitioning or paging systems where memory is allocated in fixed-size blocks (partitions or pages). When a process is allocated a partition or page that is larger than its actual memory requirement, the &lt;strong&gt;unused space within the allocated block is wasted and cannot be used by other processes&lt;/strong&gt;. This wasted space within allocated partitions is internal fragmentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sketch of Internal Fragmentation:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-----------------------+
| Process D (Uses part) | &amp;lt;-- Process uses only a portion
+-----------------------+
| Wasted Memory        | &amp;lt;-- Internally fragmented space within partition
+-----------------------+
       ^
       |
Allocated Partition (Fixed Size, Larger than Process D's Need)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Maria intends to use round robin job scheduling algorithm in an operating system. Explain three benefits of using this algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Fairness&lt;/strong&gt;: &lt;strong&gt;Round Robin (RR) scheduling&lt;/strong&gt; is designed to be &lt;strong&gt;fair to all processes&lt;/strong&gt;. It gives each process an equal share of CPU time by allocating a fixed time quantum to each process in a cyclic order. Every process gets a chance to run within a reasonable interval, preventing any process from being starved of CPU time. This fairness is particularly beneficial in time-sharing systems where multiple users or processes share the system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Responsiveness for Interactive Systems&lt;/strong&gt;: RR scheduling provides &lt;strong&gt;good responsiveness for interactive systems&lt;/strong&gt;. Because each process gets a small time quantum, interactive tasks, like user input processing or GUI updates, can be executed quickly and frequently. This results in short response times and a more interactive and user-friendly experience, as users do not experience long delays when interacting with applications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Easy to Implement&lt;/strong&gt;: Round Robin is a &lt;strong&gt;relatively simple algorithm to implement&lt;/strong&gt;. It only requires maintaining a ready queue and a timer to manage time quanta. The simplicity of RR scheduling reduces the overhead of scheduling decisions and makes it easier to integrate into operating systems. Its straightforward logic makes it less prone to implementation errors and easier to understand and debug compared to more complex scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) (i) Outline two factors to be considered when selecting computer memory, other than cost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed (Access Time)&lt;/strong&gt;: &lt;strong&gt;Memory speed&lt;/strong&gt;, often measured by access time or clock speed (for RAM), is a critical factor. Faster memory allows the CPU to fetch instructions and data more quickly, improving overall system performance. Different types of memory (e.g., DDR5 RAM vs. DDR4 RAM, SSD vs. HDD) offer varying speeds. Selecting memory with appropriate speed is essential to match the system's performance requirements.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Capacity (Size)&lt;/strong&gt;: &lt;strong&gt;Memory capacity&lt;/strong&gt;, the amount of data that can be stored, is another key consideration. Sufficient memory capacity is necessary to run applications and handle data effectively. Insufficient memory can lead to performance bottlenecks, swapping, and system slowdowns. The required memory capacity depends on the intended workload and applications that will be run on the computer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between 1/0 bound and CPU bound jobs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I/O-Bound Jobs&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O-bound jobs&lt;/strong&gt; are processes where the &lt;strong&gt;rate at which the process progresses is primarily limited by the speed of I/O operations&lt;/strong&gt;. These jobs spend a significant portion of their time waiting for I/O operations to complete (e.g., reading from disk, network communication, user input). The CPU is often idle while the process is waiting for I/O. Examples include file processing, network servers, and database applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU-Bound Jobs&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU-bound jobs&lt;/strong&gt; are processes where the &lt;strong&gt;rate of progress is primarily limited by the speed of the CPU&lt;/strong&gt;. These jobs require significant processing power and spend most of their time performing computations in the CPU. I/O operations are relatively infrequent compared to CPU computations. Examples include scientific simulations, video encoding, and complex calculations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; I/O-bound jobs are limited by I/O speed and spend more time waiting for I/O, while CPU-bound jobs are limited by CPU speed and spend more time in computation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (1) Define the term dispatcher as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Dispatcher&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;dispatcher&lt;/strong&gt; is a &lt;strong&gt;module within the operating system's short-term scheduler&lt;/strong&gt; (CPU scheduler). It is responsible for the &lt;strong&gt;actual context switching&lt;/strong&gt; of the CPU from one process to another. When the scheduler selects a process to run, the dispatcher takes over and performs the tasks needed to switch the CPU to the selected process. This includes saving the state of the previously running process and loading the saved state of the new process, effectively giving control of the CPU to the newly chosen process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Describe three advantages of paging memory as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Elimination of External Fragmentation&lt;/strong&gt;: &lt;strong&gt;Paging eliminates external fragmentation&lt;/strong&gt;. Because memory is divided into fixed-size pages and frames, and processes are also divided into pages, memory allocation is always in units of pages and frames. There are no variable-sized partitions, so there are no gaps of free memory between allocated blocks that are too small to be used. Free frames can be allocated to any process page, regardless of their location in physical memory, thus preventing external fragmentation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficient Memory Utilization&lt;/strong&gt;: Paging allows for more &lt;strong&gt;efficient memory utilization&lt;/strong&gt; compared to segmentation or contiguous allocation. By using fixed-size pages, memory allocation and deallocation become simpler and more flexible. Only the necessary pages of a process need to be loaded into memory, and pages can be placed in any available frame. This reduces memory wastage and allows for a higher degree of multiprogramming, as memory can be used more effectively.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Support for Virtual Memory&lt;/strong&gt;: Paging is a fundamental technique for &lt;strong&gt;implementing virtual memory&lt;/strong&gt;. It allows the operating system to create a virtual address space for each process that is larger than the physical RAM. Pages of a process can reside either in RAM (frames) or on disk (swap space). The operating system manages the swapping of pages between RAM and disk, enabling processes to run even if their total memory requirement exceeds the available physical memory. Virtual memory, enabled by paging, allows for running larger programs and increasing multiprogramming levels.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Lloyd was required to design a file system for a client that will support indiscriminate access of files by system users.&lt;/p&gt;
&lt;p&gt;(i) Identify the most appropriate file access method that he could use justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Sequential Access Method&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The most appropriate file access method for indiscriminate access is the &lt;strong&gt;sequential access method&lt;/strong&gt;. In sequential access, files are accessed in a &lt;strong&gt;linear, ordered fashion, from the beginning to the end&lt;/strong&gt;. This method is simple to implement and understand, and it inherently supports indiscriminate access because any user can read through the file from start to finish without restrictions on access order.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two advantages of file access method identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simplicity and Ease of Implementation&lt;/strong&gt;: The &lt;strong&gt;sequential access method&lt;/strong&gt; is very &lt;strong&gt;simple to implement and understand&lt;/strong&gt;. It requires minimal overhead in terms of file system structures and algorithms. Files are simply read from start to end, which is straightforward to manage. This simplicity reduces the complexity of file system design and implementation, making it easier to develop and maintain.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficiency for Certain Applications&lt;/strong&gt;: For applications that process files in a &lt;strong&gt;sequential manner&lt;/strong&gt;, such as batch processing, log file analysis, or streaming data, sequential access is highly &lt;strong&gt;efficient&lt;/strong&gt;. Reading files in order eliminates the need for random seeks or complex indexing, resulting in faster read operations for these types of applications. It is well-suited for scenarios where data is processed in a linear flow from beginning to end.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) Figure 1 shows a sketch of a section of a hard disk.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-14-48_2016nov.pdf.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;252&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Explain the functions of each of the parts labeled (i) and (ii).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-004.png&quot; alt=&quot;Figure 1&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on the typical structure of a hard disk sketch, assuming (i) is pointing to the circular platters and (ii) is pointing to the read/write heads:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Platters&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;platters&lt;/strong&gt; are the &lt;strong&gt;circular magnetic disks&lt;/strong&gt; that are the fundamental data storage components of a hard disk drive. Data is &lt;strong&gt;recorded magnetically on the surfaces of these platters&lt;/strong&gt;. Modern hard disks typically have multiple platters stacked on a spindle. Each platter surface is divided into tracks, sectors, and cylinders. The platters rotate at high speeds, allowing the read/write heads to access data sectors. The magnetic material on the platters retains data even when power is off, providing non-volatile storage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Read/Write Heads&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;read/write heads&lt;/strong&gt; are small electromagnetic components that are positioned just above the platters' surfaces. Their function is to &lt;strong&gt;read data from and write data to the magnetic platters&lt;/strong&gt;. Each platter surface has a dedicated read/write head. When writing data, the heads magnetize the platter surface to represent binary data. When reading, they detect the magnetic patterns on the platter to retrieve stored data. The heads move radially across the platters to access different tracks and sectors. They operate very close to the platter surface but do not touch it during normal operation, floating on a thin air cushion.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Dennis investigated challenges faced while using non-preemptive job scheduling in operating systems. Explain two challenges that he could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Poor Responsiveness for Interactive Tasks&lt;/strong&gt;: &lt;strong&gt;Non-preemptive scheduling&lt;/strong&gt; can lead to &lt;strong&gt;poor responsiveness for interactive tasks&lt;/strong&gt;. Once a process is given the CPU, it runs until it voluntarily releases the CPU by completing its CPU burst or performing I/O. If a long-running process is executing, interactive processes or high-priority tasks have to wait until the current process finishes. This can result in noticeable delays and a sluggish user experience, especially in interactive environments.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Risk of Starvation&lt;/strong&gt;: Non-preemptive scheduling can lead to a &lt;strong&gt;risk of starvation for shorter or I/O-bound processes&lt;/strong&gt;. If there is a continuous stream of long-running CPU-bound processes, shorter processes or I/O-bound processes might have to wait for extended periods before getting CPU time. This can result in unfair resource allocation and potential starvation, where some processes are indefinitely delayed from getting CPU access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Bernard intends to configure access control list (ACI) in a one of his client's file system. Explain two reasons that could influence his decision.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Enhanced File System Security&lt;/strong&gt;: Implementing Access Control Lists (ACLs) provides &lt;strong&gt;enhanced file system security&lt;/strong&gt;. ACLs allow for fine-grained control over file and directory access permissions. Instead of basic owner-group-others permissions, ACLs enable administrators to define specific access rights (read, write, execute, delete, etc.) for individual users or groups for each file and directory. This granular control improves security by allowing precise permission settings, minimizing unauthorized access and protecting sensitive data more effectively.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Flexible Access Management&lt;/strong&gt;: ACLs offer &lt;strong&gt;flexible access management&lt;/strong&gt;. They go beyond traditional permission models by allowing the assignment of permissions to multiple users and groups, not just owner, group, and others. This flexibility is crucial in complex environments where different users or groups need varying levels of access to different files and directories. ACLs simplify the management of complex permission scenarios, making it easier to grant appropriate access rights based on organizational needs and security policies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Cindy was required to indentify characteristics of a 4th generation operating system during an exam. Outline four characteristics that she could have listed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Large Scale Integration (LSI) and Very Large Scale Integration (VLSI) Technology&lt;/strong&gt;: 4th generation operating systems were developed alongside the advent of &lt;strong&gt;LSI and VLSI technology&lt;/strong&gt; in hardware. This allowed for more powerful and compact processors and memory, enabling more complex and feature-rich operating systems. The increased processing power and memory capacity facilitated the development of advanced OS features.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Graphical User Interfaces (GUIs)&lt;/strong&gt;: The 4th generation saw the widespread adoption of &lt;strong&gt;Graphical User Interfaces (GUIs)&lt;/strong&gt;. Operating systems like macOS and Windows introduced user-friendly, icon-based interfaces, making computers more accessible to non-technical users. GUIs replaced command-line interfaces for many common tasks, enhancing user experience and productivity.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Personal Computing and Workstations&lt;/strong&gt;: 4th generation OSs were designed for &lt;strong&gt;personal computers and workstations&lt;/strong&gt;. They focused on providing user-centric features, supporting single-user interactive computing, and catering to individual productivity needs. These operating systems were tailored for desktop environments and individual user applications.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Networking and Distributed Systems Support&lt;/strong&gt;: Networking capabilities and support for &lt;strong&gt;distributed systems&lt;/strong&gt; became prominent in 4th generation OSs. Features for network communication, file sharing, and client-server computing were integrated. Operating systems started to support network protocols and services, enabling computers to connect and communicate in networks and distributed environments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) RDS Company Ltd. intends to deploy Redundant Array of Independent Disks (RAID) in its file system. Explain two benefits that the company could realize from using the technology.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Improved Data Reliability and Fault Tolerance&lt;/strong&gt;: &lt;strong&gt;RAID (Redundant Array of Independent Disks)&lt;/strong&gt; significantly improves &lt;strong&gt;data reliability and fault tolerance&lt;/strong&gt;. By using techniques like mirroring (RAID 1) or striping with parity (RAID 5, RAID 6), RAID provides redundancy. If one disk in the array fails, data can be recovered or continued to be accessed from the remaining disks. This redundancy minimizes data loss and system downtime due to disk failures, enhancing data integrity and system availability, which is crucial for business continuity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Performance (in some RAID levels)&lt;/strong&gt;: Certain RAID levels, such as &lt;strong&gt;RAID 0 (striping) and RAID 5/6 (striping with parity)&lt;/strong&gt;, can improve &lt;strong&gt;I/O performance&lt;/strong&gt;. RAID 0 stripes data across multiple disks, allowing for parallel read and write operations, which can significantly increase data transfer rates and reduce access times. RAID 5 and RAID 6 also offer performance benefits for read operations due to data striping. Enhanced performance, especially for I/O intensive applications, can improve application responsiveness and overall system efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;©2016 The Kenya National Examinations Council.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="259"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="8_130_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="41">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="38"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-14-48_2016nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-14-48_2016nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="66226ec92ff28e7fe8ea7866c5c2b015"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="39"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="39"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="1"></int>
              <string role="key" value="parentNode"></string>
              <reference key="40"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="8"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="40"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="41"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="8"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202016"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="44">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2016"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="42">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="43">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="131_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="42"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2016&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Explain the term interrupt as used in operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;An &lt;strong&gt;interrupt&lt;/strong&gt; is a &lt;strong&gt;signal&lt;/strong&gt; generated by hardware or software to &lt;strong&gt;indicate an event that needs immediate attention&lt;/strong&gt; from the operating system. It causes the CPU to &lt;strong&gt;suspend its current execution&lt;/strong&gt;, save its state, and transfer control to an interrupt handler routine to deal with the event. After handling the interrupt, the CPU typically resumes the interrupted execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Describe the term swapping as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Swapping&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swapping&lt;/strong&gt; is a memory management technique where processes are &lt;strong&gt;moved between main memory (RAM) and secondary storage (disk)&lt;/strong&gt; to allow more processes to run than can fit in memory at once. When memory is full, processes that are not currently active are swapped out to disk to free up space, and when they need to run again, they are swapped back into memory. Swapping is used to increase the degree of multiprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four types of computer registers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: The &lt;strong&gt;Program Counter (PC)&lt;/strong&gt; is a register that &lt;strong&gt;holds the address of the next instruction to be executed&lt;/strong&gt;. It is incremented after each instruction is fetched, allowing the CPU to execute instructions in sequence. The PC is crucial for controlling the flow of execution in a program.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Accumulator&lt;/strong&gt;: The &lt;strong&gt;Accumulator&lt;/strong&gt; is a register used for &lt;strong&gt;intermediate arithmetic and logical results&lt;/strong&gt;. In older architectures, it was often the primary operand and destination for arithmetic operations. Modern CPUs may have multiple general-purpose registers, but the accumulator concept is still relevant for understanding CPU operations.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Memory Address Register (MAR)&lt;/strong&gt;: The &lt;strong&gt;Memory Address Register (MAR)&lt;/strong&gt; holds the &lt;strong&gt;memory address to be accessed&lt;/strong&gt; (read or write). When the CPU needs to access a location in memory, it loads the address into the MAR. The MAR is connected to the address bus and is essential for memory access operations.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Memory Data Register (MDR)&lt;/strong&gt;: The &lt;strong&gt;Memory Data Register (MDR)&lt;/strong&gt;, also known as Memory Buffer Register (MBR), &lt;strong&gt;holds the data being transferred to or from memory&lt;/strong&gt;. When reading from memory, data fetched from the memory location specified by the MAR is loaded into the MDR. When writing to memory, the data to be written is placed in the MDR and then transferred to the memory location specified by the MAR.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Explain three roles of process control block in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process State Management&lt;/strong&gt;: The &lt;strong&gt;Process Control Block (PCB)&lt;/strong&gt; is crucial for &lt;strong&gt;managing the state of a process&lt;/strong&gt;. It stores information about the current state of the process (e.g., running, ready, blocked), allowing the OS to track the execution status of each process. When a context switch occurs, the OS saves the current state of the running process in its PCB and restores the state of the next process from its PCB. This enables the OS to suspend and resume processes seamlessly, maintaining the execution context.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Identification and Scheduling&lt;/strong&gt;: The PCB serves as a &lt;strong&gt;unique identifier for each process&lt;/strong&gt;. It contains the process ID (PID) and other identifiers that distinguish one process from another. The PCB also includes scheduling information, such as process priority, scheduling queue pointers, and CPU usage statistics. This scheduling information is used by the OS scheduler to make decisions about which process to run next and to implement scheduling policies (e.g., priority, round robin, etc.).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Resource Management and Accounting&lt;/strong&gt;: The PCB is used for &lt;strong&gt;managing and accounting the resources allocated to a process&lt;/strong&gt;. It stores information about allocated memory, open files, I/O devices, and other resources used by the process. The OS uses the PCB to track resource ownership and usage, enforce resource limits, and deallocate resources when the process terminates. Resource accounting information in the PCB can also be used for performance monitoring and system administration.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Outline two objectives for designing an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;User Convenience and Efficiency&lt;/strong&gt;: One primary objective is to design an OS that is &lt;strong&gt;convenient and efficient for users&lt;/strong&gt;. This includes providing a user-friendly interface, making the system easy to use and navigate, and ensuring good performance and responsiveness for user applications. The OS should aim to simplify user tasks and enhance productivity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Resource Management and Optimization&lt;/strong&gt;: Another key objective is &lt;strong&gt;efficient resource management and optimization&lt;/strong&gt;. The OS should manage system resources (CPU, memory, I/O devices) effectively to maximize utilization, throughput, and fairness. This involves implementing efficient scheduling algorithms, memory management techniques, and I/O management strategies to ensure optimal system performance and resource utilization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Most processors support at least two modes of process execution. Explain two modes that are likely to be supported.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Kernel Mode (System Mode or Privileged Mode)&lt;/strong&gt;: &lt;strong&gt;Kernel mode&lt;/strong&gt; is a &lt;strong&gt;privileged execution mode&lt;/strong&gt; in which the operating system kernel runs. In kernel mode, the CPU has unrestricted access to system hardware and memory. The kernel can execute any instruction, including privileged instructions, and can directly access memory and I/O devices. Kernel mode is essential for performing critical system operations, managing hardware, and enforcing security. It is typically reserved for OS kernel code to protect system integrity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;User Mode (Non-privileged Mode)&lt;/strong&gt;: &lt;strong&gt;User mode&lt;/strong&gt; is a &lt;strong&gt;non-privileged execution mode&lt;/strong&gt; in which user applications run. In user mode, the CPU has restricted access to system resources. User-mode processes cannot directly execute privileged instructions or access kernel memory or hardware. They must rely on system calls to request services from the kernel. User mode provides protection and security by isolating user applications from direct hardware access and preventing them from interfering with the OS or other processes. Most application code runs in user mode.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Kernel mode is privileged, with full hardware access for the OS kernel. User mode is non-privileged, with restricted access for user applications, enhancing system security and stability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) Explain each of the following terms as used in operating system:&lt;/p&gt;
&lt;p&gt;(i) time slice;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Time Slice&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;time slice&lt;/strong&gt;, also known as a time quantum, is a &lt;strong&gt;short interval of CPU time&lt;/strong&gt; that is allocated to each process in Round Robin scheduling. The operating system scheduler assigns a time slice to a process, and the process is allowed to run for that duration. After the time slice expires, the process is preempted, and the CPU is given to the next process in the ready queue. Time slices ensure fair CPU sharing and responsiveness in time-sharing systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Thread&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;thread&lt;/strong&gt; is a &lt;strong&gt;lightweight unit of execution within a process&lt;/strong&gt;. It is a single sequential flow of control within a program. Multiple threads can exist within a single process and share the same process resources such as memory space, code segment, and data segment. Threads allow for concurrency within a process, enabling parallel execution of different parts of a program. Threads are often used to improve performance and responsiveness, especially in applications that can benefit from parallelism.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) James was required to design an operating system that would perform a number of essentially independent tasks that do not need to be serialized.&lt;/p&gt;
&lt;p&gt;(i) Identify the most appropriate processing technique that he could use justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Multiprocessing (Parallel Processing)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The most appropriate processing technique for James is &lt;strong&gt;multiprocessing&lt;/strong&gt;, also known as &lt;strong&gt;parallel processing&lt;/strong&gt;. Multiprocessing involves using &lt;strong&gt;multiple CPUs or cores to execute multiple independent tasks simultaneously&lt;/strong&gt;. Since the tasks are essentially independent and do not need to be serialized, multiprocessing can significantly improve performance by running these tasks in parallel, fully utilizing the available processing resources. This approach is ideal for tasks that can be divided and executed concurrently without dependencies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four advantages of the processing techniques identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Throughput&lt;/strong&gt;: &lt;strong&gt;Multiprocessing&lt;/strong&gt; significantly &lt;strong&gt;increases system throughput&lt;/strong&gt;. By executing multiple tasks in parallel across multiple processors, the system can accomplish more work in a given time. This is especially beneficial for tasks that can be divided into independent subtasks and processed concurrently, leading to higher overall processing capacity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Improved Performance for Concurrent Tasks&lt;/strong&gt;: Multiprocessing provides &lt;strong&gt;improved performance for concurrent tasks&lt;/strong&gt;. Applications that involve multiple independent operations or threads can run much faster when executed on a multiprocessing system. Tasks can be distributed among processors, allowing for true parallel execution and reduced execution times for concurrent workloads.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Enhanced Responsiveness&lt;/strong&gt;: Multiprocessing can enhance system &lt;strong&gt;responsiveness&lt;/strong&gt;, especially in multi-user or multitasking environments. By distributing workload across multiple processors, the system can handle more user requests or application tasks concurrently without significant performance degradation. This leads to a more responsive and smoother user experience, even under heavy load.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Fault Tolerance and Redundancy&lt;/strong&gt;: In multiprocessing systems, the presence of &lt;strong&gt;multiple processors provides a degree of fault tolerance and redundancy&lt;/strong&gt;. If one processor fails, the system can continue to operate, although possibly at a reduced performance level, using the remaining processors. This redundancy increases system reliability and availability, as the system is less likely to experience complete downtime due to a single processor failure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Explain the term process spawning as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Process Spawning&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process spawning&lt;/strong&gt;, also known as process creation, is the &lt;strong&gt;mechanism by which an existing process (parent process) creates one or more new processes (child processes)&lt;/strong&gt;. It is the action of initiating a new process by the operating system, typically in response to a request from a running process or system event. Process spawning is fundamental for multitasking and allowing applications to perform concurrent operations by creating new processes as needed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(i) Differentiate between cluster and sector as applied to physical storage disks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cluster&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;cluster&lt;/strong&gt; is a &lt;strong&gt;group of sectors&lt;/strong&gt; and is the &lt;strong&gt;smallest unit of disk space that is allocated to store a file&lt;/strong&gt; by the operating system's file system. When a file is written to disk, space is allocated in units of clusters, not sectors. Even if a file is smaller than a cluster, a whole cluster is allocated to it. Cluster size is typically larger than sector size (e.g., 4KB, 8KB, etc.) and is determined during disk formatting. Using clusters reduces the overhead of managing disk space and file allocation metadata but can lead to internal fragmentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sector&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;sector&lt;/strong&gt; is the &lt;strong&gt;smallest physical storage unit on a disk&lt;/strong&gt;. It is a &lt;strong&gt;fixed-size block of data&lt;/strong&gt;, traditionally 512 bytes or 4KB, that can be read or written in a single operation by the disk controller. Sectors are the fundamental building blocks of disk storage organization. Clusters are logical groupings of sectors managed by the file system, while sectors are hardware-level units managed by the disk controller.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; A sector is the smallest physical unit on a disk, while a cluster is a logical unit consisting of one or more sectors, and it is the smallest unit of disk space allocated to a file by the file system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Joy intends to buy an I/O device for her computer. Outline four factors that she should consider, other than the cost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Performance (Speed and Throughput)&lt;/strong&gt;: &lt;strong&gt;Performance&lt;/strong&gt; is a crucial factor. Joy should consider the &lt;strong&gt;speed and throughput&lt;/strong&gt; of the I/O device. For storage devices (like SSDs or HDDs), this includes data transfer rates (read/write speeds), access times, and latency. For network devices, it's data transmission speed. Higher performance devices improve system responsiveness and reduce I/O bottlenecks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Compatibility&lt;/strong&gt;: &lt;strong&gt;Compatibility&lt;/strong&gt; with her computer system is essential. Joy needs to ensure that the I/O device is &lt;strong&gt;compatible with her computer's interfaces&lt;/strong&gt; (e.g., USB, PCIe, SATA), operating system, and drivers. Incompatibility can lead to non-functionality or performance issues. Checking compatibility specifications and driver availability is crucial before purchase.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Reliability and Durability&lt;/strong&gt;: &lt;strong&gt;Reliability and durability&lt;/strong&gt; of the I/O device are important for long-term use and data integrity. For storage devices, this includes factors like MTBF (Mean Time Between Failures), endurance (for SSDs), and build quality. For other devices, robustness and lifespan are important. Choosing reliable and durable devices reduces the risk of failures and data loss.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Power Consumption and Efficiency&lt;/strong&gt;: &lt;strong&gt;Power consumption and efficiency&lt;/strong&gt; should be considered, especially for portable computers or systems with power constraints. Power-efficient I/O devices can reduce energy usage, extend battery life in laptops, and lower overall system power requirements. Devices with lower power consumption are also often associated with less heat generation and improved thermal management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (a) (1) Outline three disadvantages of system buffering in I/O communications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Overhead&lt;/strong&gt;: &lt;strong&gt;System buffering&lt;/strong&gt; introduces &lt;strong&gt;overhead&lt;/strong&gt;. Copying data to and from buffers requires CPU and memory bandwidth, adding to the overall processing time of I/O operations. For each data transfer, there are buffer management operations (allocation, deallocation, copying), which can consume system resources and reduce efficiency, especially for frequent small I/O transfers.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Latency and Delay&lt;/strong&gt;: Buffering can introduce &lt;strong&gt;latency and delay&lt;/strong&gt; in data transfer. Data may need to be accumulated in the buffer before being processed or transferred further. This buffering delay can be noticeable in real-time or interactive applications where immediate data processing or response is required. Buffering can increase the overall response time of I/O operations.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Complexity in Management&lt;/strong&gt;: &lt;strong&gt;Buffer management&lt;/strong&gt; adds &lt;strong&gt;complexity&lt;/strong&gt; to the operating system and device drivers. The system needs to manage buffer allocation, deallocation, buffer sizes, and synchronization between buffer operations and process execution. Incorrect buffer management can lead to buffer overflows, data corruption, or synchronization issues, increasing the complexity of OS and driver development and maintenance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Mitchell was required to investigate characteristics of a First-In, First-Out (FIFO) disk scheduling algorithm system. Describe two typical characteristics that she could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simplicity and Fairness&lt;/strong&gt;: &lt;strong&gt;FIFO (First-In, First-Out) disk scheduling&lt;/strong&gt;, also known as FCFS (First-Come, First-Served), is characterized by its &lt;strong&gt;simplicity and inherent fairness&lt;/strong&gt;. It services disk I/O requests in the order they arrive in the queue, without prioritizing or reordering. This straightforward approach ensures that all requests are eventually served in the order of their arrival, providing a basic level of fairness among requests. Implementation is simple as it just requires maintaining a request queue.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Poor Performance (High Seek Times)&lt;/strong&gt;: A typical characteristic of FIFO disk scheduling is its &lt;strong&gt;potentially poor performance in terms of seek time and throughput&lt;/strong&gt;. Because FIFO services requests in arrival order, it does not optimize disk head movement. This can lead to large disk head movements across the disk surface as requests may be for tracks far apart from each other. Consequently, FIFO can result in higher average seek times, increased rotational latency, and lower overall disk throughput compared to more optimized disk scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) A lecturer explained the desirable qualities of file organization to a class. Outline five qualities that he could be possibly facing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficiency&lt;/strong&gt;: &lt;strong&gt;Efficiency&lt;/strong&gt; in file organization is crucial for minimizing disk access time and maximizing throughput. A good file organization method should allow for &lt;strong&gt;fast retrieval and storage of data&lt;/strong&gt;, reducing I/O overhead. Efficiency can be measured in terms of access speed, storage space utilization, and the overhead of file operations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Ease of Access&lt;/strong&gt;: &lt;strong&gt;Ease of access&lt;/strong&gt; refers to how simple and convenient it is for users and applications to locate and access files. A desirable file organization should provide &lt;strong&gt;intuitive and logical access paths&lt;/strong&gt; to files, making file retrieval straightforward. This includes well-structured directory hierarchies, clear naming conventions, and efficient search mechanisms.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data Integrity and Reliability&lt;/strong&gt;: &lt;strong&gt;Data integrity and reliability&lt;/strong&gt; are essential qualities. File organization should ensure that data is &lt;strong&gt;stored securely and reliably&lt;/strong&gt;, protecting against data corruption, loss, and unauthorized access. Mechanisms for error detection, data redundancy, and backup/recovery contribute to data integrity and reliability.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Adaptability and Scalability&lt;/strong&gt;: A good file organization method should be &lt;strong&gt;adaptable to changing requirements and scalable to handle growing data volumes&lt;/strong&gt;. It should be flexible enough to accommodate different file types, sizes, and access patterns, and should scale efficiently as the number of files and data size increases. Scalability ensures that the file system can handle future data growth without performance degradation.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Security&lt;/strong&gt;: &lt;strong&gt;Security&lt;/strong&gt; is a critical quality. File organization should provide &lt;strong&gt;mechanisms to control access to files and directories&lt;/strong&gt;, protecting sensitive data from unauthorized access, modification, or deletion. Security features like access permissions, encryption, and access control lists are essential for maintaining data confidentiality and integrity in a multi-user environment.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Reader Company Ltd. is experiencing data security threats. Outline four threats that the company could be facing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Malware Infections (Viruses, Worms, Trojans)&lt;/strong&gt;: &lt;strong&gt;Malware infections&lt;/strong&gt;, including viruses, worms, and Trojans, pose a significant threat. Malware can infiltrate systems, corrupt or delete data, disrupt operations, steal sensitive information, and spread to other systems. Malware threats can lead to data breaches, system instability, and financial losses.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Breaches and Unauthorized Access&lt;/strong&gt;: &lt;strong&gt;Data breaches&lt;/strong&gt; involve unauthorized access to sensitive or confidential data by external attackers or insider threats. This can result in the &lt;strong&gt;leakage of proprietary information, customer data, financial records, or trade secrets&lt;/strong&gt;. Data breaches can lead to financial losses, reputational damage, legal liabilities, and loss of customer trust.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Phishing and Social Engineering Attacks&lt;/strong&gt;: &lt;strong&gt;Phishing and social engineering attacks&lt;/strong&gt; exploit human vulnerabilities to gain unauthorized access or information. Attackers may use deceptive emails, websites, or social tactics to trick employees into revealing credentials, sensitive data, or performing actions that compromise security. These attacks can lead to data breaches, malware infections, and financial fraud.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Denial of Service (DoS) and Distributed Denial of Service (DDoS) Attacks&lt;/strong&gt;: &lt;strong&gt;Denial of Service (DoS) and Distributed Denial of Service (DDoS) attacks&lt;/strong&gt; aim to disrupt the availability of services by overwhelming systems with malicious traffic. DoS/DDoS attacks can make websites, applications, or network resources unavailable to legitimate users, causing business disruption, financial losses, and reputational damage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Pato installed a micro kernel operating system in his computer. Explain two benefit that he could realize while using it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Improved System Stability and Reliability&lt;/strong&gt;: &lt;strong&gt;Microkernel operating systems&lt;/strong&gt; generally offer &lt;strong&gt;improved system stability and reliability&lt;/strong&gt;. In a microkernel architecture, only essential core services run in kernel space, while other services (like file systems, device drivers, network stack) run in user space as servers. This separation reduces the risk of system-wide failures because a fault in a user-space service is less likely to crash the entire system. Fault isolation enhances robustness and reliability.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Security&lt;/strong&gt;: Microkernels can provide &lt;strong&gt;enhanced security&lt;/strong&gt;. By minimizing the amount of code running in privileged kernel mode, the attack surface of the system is reduced. Security vulnerabilities in user-space servers are less critical than vulnerabilities in a monolithic kernel because they have limited access to system-level resources. The principle of least privilege is better enforced in microkernels, improving overall system security and reducing the potential impact of security breaches.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline three typical address information in a file directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;File Name&lt;/strong&gt;: The &lt;strong&gt;file name&lt;/strong&gt; is a human-readable name assigned to the file for identification and access. It is the primary way users and applications refer to a file within a directory. The file name is stored in the directory entry and is used to locate the file's metadata and data blocks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Starting Address (or Pointer)&lt;/strong&gt;: The &lt;strong&gt;starting address&lt;/strong&gt; or pointer in a directory entry indicates the &lt;strong&gt;location of the file's data on the storage device&lt;/strong&gt;. This could be the starting block number, inode number, or the address of the first cluster where the file's data begins. The starting address is crucial for the file system to locate and retrieve the file's contents.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;File Attributes&lt;/strong&gt;: Directory entries typically store &lt;strong&gt;file attributes&lt;/strong&gt;, which describe various properties of the file. Attributes can include file type (e.g., regular file, directory), file size, timestamps (creation, modification, access times), access permissions, and ownership information. File attributes provide metadata about the file and control its behavior and access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Define the term key field as used in file management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Key Field&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;key field&lt;/strong&gt;, in file management and databases, is a &lt;strong&gt;specific field within a record or file that is used to uniquely identify each record&lt;/strong&gt;. It serves as an index or identifier for records, allowing for efficient searching, sorting, and retrieval of records based on the value of this field. Key fields are essential for organizing and accessing data in structured files and databases.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (ii) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Typically, users are granted certain access rights to a file. Outline five examples of access rights that can be assigned to a user.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Read&lt;/strong&gt;: &lt;strong&gt;Read access&lt;/strong&gt; right allows a user to &lt;strong&gt;view or read the contents of a file&lt;/strong&gt;. Users with read access can open and read the file but cannot modify or delete it. This is a basic right for accessing file information.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Write&lt;/strong&gt;: &lt;strong&gt;Write access&lt;/strong&gt; right permits a user to &lt;strong&gt;modify or write data to a file&lt;/strong&gt;. Users with write access can change the file's contents, add new data, or overwrite existing data. Write access typically includes read access as well.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Execute&lt;/strong&gt;: &lt;strong&gt;Execute access&lt;/strong&gt; right allows a user to &lt;strong&gt;run or execute a file&lt;/strong&gt;, primarily applicable to executable files and scripts. For executable files, this right is necessary to launch and run the program. For directories, execute access may be required to enter or search the directory.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete&lt;/strong&gt;: &lt;strong&gt;Delete access&lt;/strong&gt; right grants a user permission to &lt;strong&gt;remove or delete a file&lt;/strong&gt;. Users with delete access can permanently erase the file from the file system. This right is often restricted to file owners or administrators.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Append&lt;/strong&gt;: &lt;strong&gt;Append access&lt;/strong&gt; right allows a user to &lt;strong&gt;add data to the end of a file&lt;/strong&gt; without modifying existing content. Users with append access can extend the file by adding new data at the end but cannot change or delete the existing content. This is useful for log files or data accumulation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Outline two problems that could be experienced with fixed memory partitioning.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;: &lt;strong&gt;Internal fragmentation&lt;/strong&gt; is a problem where &lt;strong&gt;allocated partitions may be larger than the memory required by a process&lt;/strong&gt;. The unused space within the partition is wasted and cannot be allocated to other processes, leading to inefficient memory utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: &lt;strong&gt;External fragmentation&lt;/strong&gt; can occur when &lt;strong&gt;total free memory is sufficient but is scattered into small, non-contiguous partitions&lt;/strong&gt;. If a process requires a large contiguous block of memory, it may not be allocatable even if the total free memory is adequate, due to fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between block-oriented and Stream-oriented devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Block-Oriented Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block-oriented devices&lt;/strong&gt; transfer data in &lt;strong&gt;fixed-size blocks or chunks&lt;/strong&gt;. Data is accessed and transferred in blocks, and each block has a specific address. These devices typically support random access to data blocks. Examples include &lt;strong&gt;hard disk drives (HDDs)&lt;/strong&gt;, solid-state drives (SSDs), and USB drives. File systems are usually designed to work with block-oriented devices, managing storage in blocks (clusters) and providing file abstractions on top of block storage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream-Oriented Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream-oriented devices&lt;/strong&gt; transfer data as a &lt;strong&gt;continuous stream of bytes or characters&lt;/strong&gt;, without fixed block sizes. Data is accessed sequentially in a stream, and random access is generally not supported or efficient. Examples include &lt;strong&gt;keyboards&lt;/strong&gt;, &lt;strong&gt;printers&lt;/strong&gt;, and &lt;strong&gt;network interfaces&lt;/strong&gt;. Data flows in a continuous stream, and operations typically involve reading or writing a sequence of bytes rather than addressing specific blocks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Block-oriented devices handle data in fixed-size blocks and support random access, while stream-oriented devices handle data as continuous streams of bytes and are primarily sequential access oriented.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Memory paging is a popular technology in operating systems. Explain two advantages of the technology that could be influencing the trend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Eliminates External Fragmentation&lt;/strong&gt;: &lt;strong&gt;Memory paging&lt;/strong&gt; effectively &lt;strong&gt;eliminates external fragmentation&lt;/strong&gt;. Since memory is allocated in fixed-size pages and frames, there are no issues with fragmented free space between variable-sized blocks. All free memory is managed in units of frames, and any free frame can be used to store any page of any process. This efficient management of memory space reduces wastage and improves overall memory utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Supports Virtual Memory Efficiently&lt;/strong&gt;: &lt;strong&gt;Paging is essential for efficient implementation of virtual memory&lt;/strong&gt;. It provides the foundation for address translation, page swapping, and demand paging. Virtual memory systems rely on paging to manage the mapping between virtual addresses and physical addresses, allowing processes to use memory beyond the physical RAM capacity. Paging enables efficient swapping of pages between RAM and disk, making virtual memory practical and effective.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline four desirable features of a file system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficiency and Performance&lt;/strong&gt;: A desirable file system should be &lt;strong&gt;efficient and provide good performance&lt;/strong&gt;. This includes fast file access times, high throughput for read and write operations, and minimal overhead for file management operations. Efficiency in storage utilization and I/O operations is crucial for overall system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Reliability and Data Integrity&lt;/strong&gt;: &lt;strong&gt;Reliability and data integrity&lt;/strong&gt; are paramount. A good file system must ensure that data is stored reliably and protected against corruption or loss. This includes features like error detection and correction, data redundancy, and mechanisms to ensure data consistency even in case of system failures or crashes.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Security and Access Control&lt;/strong&gt;: &lt;strong&gt;Security features and robust access control&lt;/strong&gt; are essential. A desirable file system should provide mechanisms to control access to files and directories, protecting sensitive data from unauthorized access, modification, or deletion. Access control should be flexible and granular, allowing administrators to define permissions for users and groups.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;User-Friendliness and Convenience&lt;/strong&gt;: A file system should be &lt;strong&gt;user-friendly and convenient to use&lt;/strong&gt;. This includes providing an intuitive directory structure, easy file naming conventions, and user-friendly tools for file management operations (create, delete, rename, copy, etc.). User convenience enhances productivity and simplifies file organization and access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between memory address register (MAR), and memory buffer register (MBR), as applied in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Memory Address Register (MAR)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Memory Address Register (MAR)&lt;/strong&gt; is a CPU register that &lt;strong&gt;holds the address of a memory location that the CPU wants to access&lt;/strong&gt;. When the CPU needs to read from or write to memory, it first loads the desired memory address into the MAR. The MAR is directly connected to the address bus, and it provides the address to the memory system for data access. The MAR specifies *where* in memory the CPU intends to operate.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memory Buffer Register (MBR)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Memory Buffer Register (MBR)&lt;/strong&gt;, also known as the Memory Data Register (MDR), is a CPU register that &lt;strong&gt;holds the data being transferred to or from the memory location&lt;/strong&gt; specified by the MAR. When the CPU writes data to memory, it places the data into the MBR, which is then written to the memory location indicated by the MAR. When the CPU reads data from memory, the data fetched from the memory location is placed into the MBR for the CPU to use. The MBR holds *what* data is being transferred between the CPU and memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; MAR holds the memory address (location), while MBR holds the actual data being transferred to or from that memory address. MAR specifies the *where*, and MBR specifies the *what* of memory access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Outline four reasons that would render a process into suspension state.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Swapping Out&lt;/strong&gt;: A process may be &lt;strong&gt;suspended and swapped out to secondary storage (disk)&lt;/strong&gt; to free up main memory. This is done when memory is overcommitted, and the system needs to reduce the number of processes in RAM to improve performance or make space for higher-priority processes. Swapping out is a form of temporary suspension to manage memory resources.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;User Request or Intervention&lt;/strong&gt;: A user may &lt;strong&gt;explicitly request to suspend a process&lt;/strong&gt;, for example, using a command like 'stop' or 'pause'. This could be done for debugging, system administration, or to temporarily halt a process's execution. User-initiated suspension is often a manual control action.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Parent Process Request&lt;/strong&gt;: A &lt;strong&gt;parent process may suspend one of its child processes&lt;/strong&gt;. This can be done for process control, coordination, or synchronization purposes. A parent process might suspend a child to examine its state, modify its resources, or synchronize its execution with other parts of the application.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;System Load Balancing&lt;/strong&gt;: In heavily loaded systems, the operating system may &lt;strong&gt;suspend lower-priority processes to improve the performance of higher-priority or critical processes&lt;/strong&gt;. Suspension can be used as a dynamic load-balancing technique to ensure that important tasks get sufficient resources and responsiveness, even under high system load conditions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Figure 1 shows virtual memory addressing scheme in an operating system.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-37-12_2016july.pdf.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;381&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Explain the two memory addresses labelled I. and II.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-003.png&quot; alt=&quot;Figure 1&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on the context of virtual memory addressing and the labels in Figure 1:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I. Logical Address (or Virtual Address)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Memory address labeled &lt;strong&gt;I&lt;/strong&gt; is the &lt;strong&gt;Logical Address&lt;/strong&gt;, also known as a &lt;strong&gt;Virtual Address&lt;/strong&gt;. This is the address &lt;strong&gt;generated by the CPU&lt;/strong&gt; when a program is executed. Logical addresses are part of the process's virtual address space. They are independent of the physical memory addresses and are translated by the Memory Management Unit (MMU) into physical addresses before actual memory access. Processes operate using logical addresses, which provide abstraction and protection.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. Physical Address&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Memory address labeled &lt;strong&gt;II&lt;/strong&gt; is the &lt;strong&gt;Physical Address&lt;/strong&gt;. This is the &lt;strong&gt;actual address in physical RAM (main memory) where data is stored&lt;/strong&gt;. Physical addresses are used by the memory controller to access specific locations in physical memory chips. The MMU performs the &lt;strong&gt;translation from logical addresses to physical addresses&lt;/strong&gt; using page tables or segment tables. Physical addresses are what the hardware understands and uses to access memory locations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Relationship:&lt;/strong&gt; The virtual memory addressing scheme involves translating logical addresses (I) generated by the CPU into physical addresses (II) that correspond to actual locations in main memory. This translation is managed by the Memory Management Unit (MMU), enabling virtual memory functionality.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Oliver was required to prepare a presentation on I/O facilities in operating system. Describe two I/O facilities that she could have highlighted in her presentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Buffering&lt;/strong&gt;: &lt;strong&gt;Buffering&lt;/strong&gt; is a key I/O facility. It involves using &lt;strong&gt;temporary storage areas (buffers) in memory to hold data during I/O transfers&lt;/strong&gt;. Buffering helps to cope with speed mismatches between fast CPUs and slower I/O devices, allows for data size adaptation, and supports copy semantics. Techniques like single buffering, double buffering, and circular buffering are used to improve I/O performance and efficiency. Buffering is essential for smooth and efficient data flow between system components.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Spooling&lt;/strong&gt;: &lt;strong&gt;Spooling (Simultaneous Peripheral Operations On-Line)&lt;/strong&gt; is an I/O facility, especially for output devices like printers. It involves &lt;strong&gt;redirecting output data to a disk buffer (spool area) instead of directly to the output device&lt;/strong&gt;. A spooler process then manages the actual output to the device in the background. Spooling allows processes to generate output data quickly without waiting for the slower output device, improves system throughput, and enables features like print queuing and job scheduling for output operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) (i) Outline two requirements for virtual memory in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Paging or Segmentation Hardware Support&lt;/strong&gt;: &lt;strong&gt;Hardware support for paging or segmentation&lt;/strong&gt; is essential. The CPU and Memory Management Unit (MMU) must support address translation mechanisms to map virtual addresses to physical addresses. This hardware support typically includes page tables or segment tables, translation lookaside buffers (TLBs), and control registers to manage virtual memory operations efficiently.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Secondary Storage (Disk Space)&lt;/strong&gt;: Sufficient &lt;strong&gt;secondary storage space (disk space)&lt;/strong&gt; is required to act as the backing store for virtual memory. Virtual memory uses disk space to store pages that are not currently in RAM. The swap space or page file on disk needs to be large enough to accommodate the virtual memory needs of running processes. Fast disk I/O performance is also important for efficient swapping and overall virtual memory performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between a parent process and a child process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Parent Process&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;parent process&lt;/strong&gt; is an &lt;strong&gt;existing process that creates a new process&lt;/strong&gt;. It is the process that initiates the creation of a child process using system calls like `fork()`. The parent process continues to exist after creating the child, and it can control and manage the child process. Parent processes are responsible for initiating and supervising child processes. They can share resources with children and communicate with them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Child Process&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;child process&lt;/strong&gt; is a &lt;strong&gt;new process created by a parent process&lt;/strong&gt;. It is a duplicate or a new instance of a program spawned by a parent process. The child process inherits certain attributes from its parent, such as code, data, open files, and environment. However, it has its own process ID (PID), memory space, and execution context. Child processes execute concurrently and independently of the parent process, although they can communicate and synchronize with the parent if needed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; The parent process is the process that creates another process, while the child process is the newly created process. The parent process exists before and typically continues after the child process is created, and it has a hierarchical relationship with the child.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Define the term thrashing as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Thrashing&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thrashing&lt;/strong&gt; in memory management is a &lt;strong&gt;performance problem that occurs in virtual memory systems&lt;/strong&gt; when the system spends &lt;strong&gt;more time swapping pages (page faults) than executing processes&lt;/strong&gt;. This happens when the degree of multiprogramming is too high, and processes do not have enough pages in memory to execute efficiently. Constant page swapping between RAM and disk leads to very low CPU utilization and system performance grinds to a halt.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two types of virtual memory replacement policy/strategy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Least Recently Used (LRU)&lt;/strong&gt;: The &lt;strong&gt;Least Recently Used (LRU)&lt;/strong&gt; page replacement policy replaces the page that has &lt;strong&gt;not been used for the longest period in the past&lt;/strong&gt;. LRU is based on the principle of locality of reference, assuming that pages that have not been accessed recently are less likely to be accessed in the near future. LRU aims to keep frequently used pages in memory and replace pages that are least likely to be needed again soon. It generally performs well but requires overhead to track page usage history.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;First-In, First-Out (FIFO)&lt;/strong&gt;: The &lt;strong&gt;First-In, First-Out (FIFO)&lt;/strong&gt; page replacement policy replaces the page that has been in memory for the &lt;strong&gt;longest time&lt;/strong&gt;, regardless of its usage frequency. FIFO is simple to implement, as it only requires tracking the order in which pages were loaded into memory. However, FIFO may not always be efficient because pages that have been in memory longest are not necessarily the least useful. It can lead to Belady's anomaly in some cases, where increasing the number of frames can increase page faults.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Figure 1 shows a typical file allocation method.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-38-18_2016july.pdf.png&quot; alt=&quot;&quot; width=&quot;946&quot; height=&quot;451&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-003.png&quot; alt=&quot;Figure 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(1) Describe the file allocation method depicted in the diagram.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Linked Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The file allocation method depicted in Figure 1 is &lt;strong&gt;linked allocation&lt;/strong&gt;. In linked allocation, each file is a &lt;strong&gt;linked list of disk blocks&lt;/strong&gt;. Blocks can be scattered anywhere on the disk. Each block contains data and a pointer to the next block in the file. The directory entry for each file contains a pointer to the first block of the file. Following the pointers in each block allows access to subsequent blocks of the file, forming a chain.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline two advantages of the file allocation method described in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;No External Fragmentation&lt;/strong&gt;: &lt;strong&gt;Linked allocation&lt;/strong&gt; effectively &lt;strong&gt;eliminates external fragmentation&lt;/strong&gt;. Since file blocks do not need to be contiguous, any free block on the disk can be used to extend a file. This prevents the problem of free memory being fragmented into small, unusable chunks, improving disk space utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Dynamic File Size&lt;/strong&gt;: Linked allocation supports &lt;strong&gt;dynamic file size&lt;/strong&gt;. Files can grow in size dynamically at runtime because blocks can be added to the file's linked list as needed, without requiring contiguous space. This flexibility allows files to expand as required without pre-allocating a fixed amount of space, making it efficient for files that vary in size.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (iii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) Explain two strategies that could be adapted to conserve disk space when using file allocation method described in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Cluster Size Optimization&lt;/strong&gt;: Optimize &lt;strong&gt;cluster size&lt;/strong&gt; to minimize internal fragmentation. While linked allocation eliminates external fragmentation, &lt;strong&gt;internal fragmentation&lt;/strong&gt; can still occur if the cluster size is too large. By choosing an &lt;strong&gt;appropriate cluster size&lt;/strong&gt;, the average wasted space per file due to clusters being larger than file sizes can be reduced. Smaller cluster sizes generally reduce internal fragmentation but may increase metadata overhead and potentially slow down sequential access for very large files.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File Compression&lt;/strong&gt;: Implement &lt;strong&gt;file compression&lt;/strong&gt; techniques. &lt;strong&gt;Compressing files&lt;/strong&gt; reduces the amount of disk space they occupy. By compressing files before storing them using linked allocation, the overall disk space usage can be significantly reduced. Compression algorithms can reduce file sizes, saving storage space, and also potentially improving I/O transfer times for compressed data. Decompression is performed when files are accessed, adding some processing overhead but saving disk space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) For each of the following tasks identify appropriate file operation that could be used:&lt;/p&gt;
&lt;p&gt;(i) replacing filename;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Rename&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) display file content;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Read&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) formatting a disk that contains files;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Format (This operation is typically discouraged on disks with files as it erases all data)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iv) stores a new file in disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iv) Create&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Lucky was investigating factors influences deadlocks in operating systems. Outline four factors that he could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: &lt;strong&gt;Mutual exclusion&lt;/strong&gt; is a necessary condition for deadlock. It occurs when &lt;strong&gt;resources are non-sharable&lt;/strong&gt;, meaning only one process can use a resource at a time. If resources were infinitely sharable, processes would not need to wait for exclusive access, preventing deadlocks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt;: &lt;strong&gt;Hold and wait&lt;/strong&gt; is a deadlock condition where a process is &lt;strong&gt;holding at least one resource and is waiting to acquire additional resources held by other processes&lt;/strong&gt;. If processes did not hold resources while waiting for new ones, deadlocks would be less likely to occur.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;No Preemption&lt;/strong&gt;: &lt;strong&gt;No preemption&lt;/strong&gt; is a condition where &lt;strong&gt;resources cannot be forcibly taken away from a process holding them&lt;/strong&gt;. If resources could be preempted from processes, the OS could break deadlock cycles by taking resources away from one process and giving them to another.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Circular Wait&lt;/strong&gt;: &lt;strong&gt;Circular wait&lt;/strong&gt; is a deadlock condition where there is a &lt;strong&gt;circular chain of processes&lt;/strong&gt;, each waiting for a resource held by the next process in the chain. For example, process A waits for a resource held by B, B waits for a resource held by C, and C waits for a resource held by A, forming a cycle. Circular wait is a direct consequence of hold and wait and no preemption conditions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Programmers encounter several challenges when using memory overlay in operating systems. Explain two challenges that they are likely to experience.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Complexity of Program Design and Segmentation&lt;/strong&gt;: &lt;strong&gt;Designing programs for overlaying is complex and requires significant programmer effort&lt;/strong&gt;. Programmers must manually divide the program into overlays, determine the overlay structure, and manage the loading and unloading of overlays. This segmentation and overlay management process is intricate and error-prone, adding substantial complexity to software development.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Development and Maintenance Overhead&lt;/strong&gt;: Memory overlay techniques lead to &lt;strong&gt;increased development and maintenance overhead&lt;/strong&gt;. Programmers have to deal with the complexities of overlay management throughout the software lifecycle. Changes to the program structure or functionality can necessitate re-designing the overlay scheme. Debugging overlay-based programs is also more challenging due to the manual memory management and overlay loading logic, increasing maintenance costs and effort.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Nancy intends to develop an operating system that would supports several types of RAID configurations. Explain two types of RAID configurations she should consider.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;RAID 0 (Striping)&lt;/strong&gt;: &lt;strong&gt;RAID 0&lt;/strong&gt;, known as &lt;strong&gt;striping&lt;/strong&gt;, distributes data evenly across two or more disks without redundancy. Data is divided into stripes, and each stripe is written across the disks in the array. RAID 0 aims to &lt;strong&gt;improve performance&lt;/strong&gt; by allowing parallel read and write operations across multiple disks, increasing throughput and speed. However, RAID 0 provides &lt;strong&gt;no fault tolerance&lt;/strong&gt;; if any disk in the array fails, all data in the RAID 0 array is lost. It is suitable for applications where performance is critical and data redundancy is not a primary concern.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;RAID 1 (Mirroring)&lt;/strong&gt;: &lt;strong&gt;RAID 1&lt;/strong&gt;, known as &lt;strong&gt;mirroring&lt;/strong&gt;, duplicates data across two disks, providing &lt;strong&gt;data redundancy and fault tolerance&lt;/strong&gt;. Every write operation is performed on both disks in the mirror set. If one disk fails, data is still available from the other disk without data loss or downtime. RAID 1 enhances &lt;strong&gt;reliability and data availability&lt;/strong&gt;. Read performance can also improve as read requests can be serviced from either disk. However, RAID 1 effectively halves the usable storage capacity, as half of the disk space is used for redundancy. It is suitable for critical systems where data reliability and availability are paramount.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) The CPU uses several types of interrupt to handle I/O communications in a computer. Outline four types of interrupts that could be used in a computer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hardware Interrupts (Device Interrupts)&lt;/strong&gt;: &lt;strong&gt;Hardware interrupts&lt;/strong&gt; are generated by I/O devices to &lt;strong&gt;signal the CPU about an event requiring attention&lt;/strong&gt;. Examples include: * &lt;strong&gt;Disk Interrupts&lt;/strong&gt;: Signals completion of a disk read or write operation. * &lt;strong&gt;Network Interrupts&lt;/strong&gt;: Indicates arrival of a network packet. * &lt;strong&gt;Keyboard Interrupts&lt;/strong&gt;: Generated when a key is pressed. * &lt;strong&gt;Timer Interrupts&lt;/strong&gt;: Generated by a hardware timer at regular intervals for time-slicing and system clock maintenance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Software Interrupts (System Calls)&lt;/strong&gt;: &lt;strong&gt;Software interrupts&lt;/strong&gt;, also known as traps or system calls, are &lt;strong&gt;generated by software to request services from the operating system kernel&lt;/strong&gt;. When a user program needs to perform a privileged operation (e.g., file I/O, memory allocation, process control), it issues a system call, which triggers a software interrupt. Examples include `read()`, `write()`, `open()`, `exit()`, etc.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Exceptions (Processor Exceptions)&lt;/strong&gt;: &lt;strong&gt;Exceptions&lt;/strong&gt; are interrupts generated by the CPU itself when it encounters an &lt;strong&gt;error or exceptional condition during program execution&lt;/strong&gt;. Examples include: * &lt;strong&gt;Page Faults&lt;/strong&gt;: Occurs when a process tries to access a memory page not currently in RAM. * &lt;strong&gt;Segmentation Faults&lt;/strong&gt;: Memory access violation. * &lt;strong&gt;Division by Zero&lt;/strong&gt;: Arithmetic error. * &lt;strong&gt;Illegal Instruction&lt;/strong&gt;: Attempt to execute an invalid or privileged instruction in user mode.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Inter-Processor Interrupts (IPIs)&lt;/strong&gt;: &lt;strong&gt;Inter-Processor Interrupts (IPIs)&lt;/strong&gt; are used in &lt;strong&gt;multiprocessor systems&lt;/strong&gt; to enable &lt;strong&gt;communication and synchronization between CPUs&lt;/strong&gt;. One CPU can send an IPI to another CPU to request it to perform certain tasks, handle events, or synchronize operations. IPIs are essential for coordinating activities and managing shared resources in multiprocessor architectures.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) (i) Explain the term frame as applied in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Frame&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In memory management, a &lt;strong&gt;frame&lt;/strong&gt; is a &lt;strong&gt;fixed-size block of physical memory (RAM)&lt;/strong&gt;. When using paging, physical memory is divided into equal-sized blocks called frames. Frames are the units into which physical memory is divided and are used to hold pages of processes. The size of a frame is the same as the size of a page (typically 4KB or 8KB).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between fetch and cleaning policies as applied in virtual memory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Fetch Policy&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;fetch policy&lt;/strong&gt; in virtual memory management &lt;strong&gt;determines when a page should be brought into main memory (RAM)&lt;/strong&gt;. It decides when to load a page from secondary storage (disk) into a frame in RAM. Common fetch policies include: * &lt;strong&gt;Demand Paging&lt;/strong&gt;: Pages are loaded into memory &lt;strong&gt;only when they are needed&lt;/strong&gt; (on demand), i.e., when a page fault occurs. * &lt;strong&gt;Prepaging&lt;/strong&gt;: &lt;strong&gt;Multiple pages are loaded into memory in advance&lt;/strong&gt;, anticipating future needs, often based on locality of reference or program behavior patterns.&lt;/p&gt;
&lt;p&gt;Fetch policy is about *when* to bring a page into RAM.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cleaning Policy&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;cleaning policy&lt;/strong&gt; in virtual memory management &lt;strong&gt;determines when a modified page (dirty page) in RAM should be written back to secondary storage (disk)&lt;/strong&gt;. It decides when to write back a page from RAM to disk to update the copy on disk. Common cleaning policies include: * &lt;strong&gt;Demand Cleaning&lt;/strong&gt;: Dirty pages are written back to disk &lt;strong&gt;only when they are selected for replacement&lt;/strong&gt; (page replacement). * &lt;strong&gt;Precleaning&lt;/strong&gt;: Dirty pages are written back to disk &lt;strong&gt;periodically or in batches&lt;/strong&gt;, before they are needed to be replaced, often to maintain a pool of clean frames.&lt;/p&gt;
&lt;p&gt;Cleaning policy is about *when* to write a modified page back to disk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Fetch policy concerns when to bring pages into RAM, while cleaning policy concerns when to write modified pages back to disk.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Clifford was required to design a general-purpose time-sharing system for his client.&lt;/p&gt;
&lt;p&gt;(1) Describe the most appropriate process scheduling technique that he could use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Round Robin (RR) Scheduling&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The most appropriate process scheduling technique for a general-purpose time-sharing system is &lt;strong&gt;Round Robin (RR) scheduling&lt;/strong&gt;. RR is designed to provide &lt;strong&gt;fairness and responsiveness in time-sharing environments&lt;/strong&gt; by giving each process a small, equal time slice of CPU time in a cyclic manner. This approach ensures that no single process monopolizes the CPU, and all processes get a fair share of processing time, leading to good interactive performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline two disadvantages of process scheduling technique described in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Performance Overhead due to Context Switching&lt;/strong&gt;: &lt;strong&gt;Round Robin scheduling&lt;/strong&gt; can incur &lt;strong&gt;performance overhead due to frequent context switching&lt;/strong&gt;. Since each process runs for only a short time slice before being preempted, the system performs context switches frequently, especially with small time quanta. Context switching involves saving and restoring process states, which consumes CPU time and can reduce overall system efficiency if the overhead becomes significant.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Turnaround Time Variance&lt;/strong&gt;: While Round Robin provides fairness in terms of CPU time allocation, it can lead to &lt;strong&gt;variance in turnaround time&lt;/strong&gt;, especially for processes with similar burst times. Processes with longer burst times may experience longer overall turnaround times compared to Shortest Job Next (SJN) or similar algorithms. The uniform time slice allocation can result in longer completion times for processes that could have finished quicker with other scheduling approaches.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) Explain one factor that affects performance in the process scheduling technique described in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Time Quantum Size&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;size of the time quantum&lt;/strong&gt; is a critical factor that affects the performance of &lt;strong&gt;Round Robin scheduling&lt;/strong&gt;. * &lt;strong&gt;Small Time Quantum&lt;/strong&gt;: A very small time quantum leads to &lt;strong&gt;frequent context switches&lt;/strong&gt;, increasing overhead and potentially reducing CPU efficiency. While it improves responsiveness, excessive context switching can decrease throughput. * &lt;strong&gt;Large Time Quantum&lt;/strong&gt;: A very large time quantum approaches &lt;strong&gt;First-Come, First-Served (FCFS) behavior&lt;/strong&gt;. Responsiveness for interactive tasks may degrade, as long-running processes can monopolize the CPU for longer periods within a time slice. * &lt;strong&gt;Optimal Time Quantum&lt;/strong&gt;: The &lt;strong&gt;optimal time quantum size&lt;/strong&gt; is a balance and depends on system characteristics and workload. It should be large enough to allow for reasonable process execution before preemption, but small enough to maintain good responsiveness and fairness. Finding the right balance is crucial for RR performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Memory segmentation allows programmers to create memory references in their design. Outline four advantages programmers could realize using memory references.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Modularity and Code Reusability&lt;/strong&gt;: Memory segmentation &lt;strong&gt;enhances modularity in programming&lt;/strong&gt;. Programmers can divide programs into logical segments (e.g., code, data, stack) and manage memory references within these segments. This modularity promotes code organization, making it easier to develop, debug, and maintain large programs. It also facilitates code reusability, as segments can be designed as independent modules that can be reused in different parts of the program or in other programs.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data and Code Protection&lt;/strong&gt;: Memory segmentation provides &lt;strong&gt;memory protection&lt;/strong&gt;. Segments can be assigned different access rights (read-only, read-write, execute), allowing the operating system to enforce protection boundaries between segments. This prevents accidental or malicious access to code or data segments, improving system security and program stability. Memory references within segments are controlled and validated, reducing the risk of memory corruption.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Simplified Memory Management for Programmers&lt;/strong&gt;: Segmentation can &lt;strong&gt;simplify memory management from the programmer's perspective&lt;/strong&gt;. Programmers can think in terms of logical segments and memory references within those segments, rather than dealing with flat, linear memory addresses. The OS and hardware handle the mapping of segments to physical memory. This abstraction simplifies program development and reduces the burden of manual memory management for programmers.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Efficient Data Sharing and Memory Sharing&lt;/strong&gt;: Memory segmentation facilitates &lt;strong&gt;efficient data sharing and memory sharing between processes&lt;/strong&gt;. Segments can be shared between processes, allowing them to access common code or data regions. Shared segments reduce memory duplication, save memory space, and enable efficient inter-process communication and data exchange. Programmers can use shared memory segments to implement shared libraries or shared data structures for concurrent applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Distributed operating systems are widely used in many organizations. Explain two features that could be influencing the trend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Scalability and Performance&lt;/strong&gt;: &lt;strong&gt;Scalability and performance&lt;/strong&gt; are major factors driving the adoption of distributed operating systems. Distributed systems can easily scale to handle increasing workloads by adding more nodes (computers) to the system. Workload can be distributed across multiple machines, enabling parallel processing and higher throughput compared to single-system OS. This scalability allows organizations to accommodate growing demands and improve application performance by leveraging distributed computing resources.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Fault Tolerance and High Availability&lt;/strong&gt;: &lt;strong&gt;Fault tolerance and high availability&lt;/strong&gt; are critical advantages of distributed operating systems. In a distributed system, if one node fails, the system can continue to operate using the remaining nodes. Redundancy and fault isolation in distributed architectures minimize the impact of hardware or software failures. This enhances system reliability and ensures high availability of services and applications, which is crucial for business-critical operations and continuous service delivery.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;THIS IS THE LAST PRINTED PAGE.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="260"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="9_131_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="45">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="42"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-37-12_2016july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-37-12_2016july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="5358ef71b276e08378cbffb1322b6dda"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="43"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="261"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="9_131_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="46">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="42"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-38-18_2016july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-38-18_2016july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="afa2aace01081ab5ba1b5b2182b64732"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="43"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="43"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="2"></int>
              <string role="key" value="parentNode"></string>
              <reference key="44"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="9"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="44"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="45"></reference>
            <reference key="46"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="9"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202016"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="49">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2015"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="47">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="48">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="132_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="47"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2015&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) (i) Explain the term page table as applied in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;page table&lt;/strong&gt; is a &lt;strong&gt;data structure used by the operating system to implement virtual memory&lt;/strong&gt;. It is used to &lt;strong&gt;translate virtual addresses to physical addresses&lt;/strong&gt; for each process. Each process has its own page table which maps virtual pages to physical frames in memory or to secondary storage if the page is not currently in RAM.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four advantages of First Come First Served (FCFS) scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simplicity&lt;/strong&gt;: &lt;strong&gt;FCFS is simple to understand and implement&lt;/strong&gt;. It is straightforward to program and requires minimal overhead in terms of algorithm complexity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Fairness&lt;/strong&gt;: FCFS is inherently &lt;strong&gt;fair&lt;/strong&gt; in that it processes jobs in the order of their arrival. Every process gets a chance to run, and there is no starvation.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;No Starvation&lt;/strong&gt;: Due to its fair nature, &lt;strong&gt;FCFS prevents starvation&lt;/strong&gt;. Every process will eventually get its turn to be executed based on its arrival time.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Easy to Predict&lt;/strong&gt;: The behavior of FCFS is &lt;strong&gt;predictable&lt;/strong&gt;. The order of execution is determined solely by the arrival time of the processes, making it easy to estimate turnaround and waiting times in simple scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Paul was investigating the challenges that his company might be experiencing as a result of using monolithic operating system. Explain two challenges he could have identified.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Lack of Modularity and Maintainability&lt;/strong&gt;: &lt;strong&gt;Monolithic operating systems lack modularity&lt;/strong&gt;. All system services run within the kernel, making it complex and tightly coupled. This leads to difficulties in maintenance, debugging, and implementing changes or updates. Any modification can have unintended side effects across the system, increasing instability.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;System Instability&lt;/strong&gt;: In a monolithic kernel, a &lt;strong&gt;failure in one component can crash the entire system&lt;/strong&gt;. Because all services are integrated into a single kernel space, there is no fault isolation. A bug in a device driver or any other part of the kernel can lead to system-wide crashes, reducing reliability and uptime.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Explain two circumstances that could necessitate implementation of a client server operating system in an organization.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Sharing and Centralized Management&lt;/strong&gt;: When an organization needs to &lt;strong&gt;share resources such as files, printers, and applications among multiple users&lt;/strong&gt;, a client-server OS becomes necessary. It allows for centralized management of these resources on a server, making them accessible to clients. Centralizing resources simplifies administration, enhances security, and reduces redundancy.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Need for Centralized Services and Scalability&lt;/strong&gt;: If an organization requires &lt;strong&gt;centralized services like email, web hosting, databases, or application servers&lt;/strong&gt; and needs to &lt;strong&gt;scale its IT infrastructure&lt;/strong&gt;, a client-server OS is essential. Server operating systems are designed to handle high loads, manage numerous client requests, and provide robust services. The client-server model allows for scalability by adding more servers or upgrading server hardware to meet increasing demands.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) (i) Outline two file allocation methods that could be used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Contiguous Allocation&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Linked Allocation&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two reasons for adapting buffering technique in I/O communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed Mismatch Handling&lt;/strong&gt;: Buffering is used to handle &lt;strong&gt;speed mismatches between I/O devices and the CPU or memory&lt;/strong&gt;. I/O devices often operate at speeds much slower than the CPU and memory. Buffers act as a temporary holding area, allowing the faster component to transfer data to the buffer quickly and proceed with other tasks, while the slower device can access data from the buffer at its own pace. This prevents the faster component from being stalled waiting for the slower one.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Size Adaptation&lt;/strong&gt;: Buffers help in &lt;strong&gt;adapting data sizes between producers and consumers&lt;/strong&gt;. I/O devices and processes may produce or consume data in different sized chunks. Buffers can accumulate data until a block of the required size is formed before passing it to the consumer, or they can break down large blocks of data into smaller units suitable for the producer. This simplifies data handling and processing for both sides of the communication.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Figure 1 shows inbound memory hierarchy diagram.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-43-42_2015nov.pdf.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;333&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Describe each of the layers labeled A, B and C.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-007.png&quot; alt=&quot;Figure 1&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on a typical memory hierarchy, and assuming Figure 1 represents levels of memory from slowest/lowest to fastest/highest:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer A: Secondary Storage (e.g., Hard Disk, SSD)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer A&lt;/strong&gt; represents &lt;strong&gt;Secondary Storage&lt;/strong&gt;. This is the &lt;strong&gt;slowest and cheapest level of memory&lt;/strong&gt; in the hierarchy, but it has the &lt;strong&gt;largest capacity&lt;/strong&gt;. It is non-volatile, meaning data is retained even when power is off. Secondary storage is used for long-term storage of data, including the operating system, applications, and user files. Access times are slow compared to RAM and cache, but it provides persistent storage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer B: Main Memory (RAM)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer B&lt;/strong&gt; represents &lt;strong&gt;Main Memory (RAM - Random Access Memory)&lt;/strong&gt;. This level is &lt;strong&gt;faster and more expensive than secondary storage but has less capacity&lt;/strong&gt;. RAM is volatile, meaning data is lost when power is off. Main memory is used to hold the programs and data that are currently being used by the CPU. It provides faster access compared to secondary storage, enabling efficient program execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer C: Cache Memory (CPU Cache)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer C&lt;/strong&gt; represents &lt;strong&gt;Cache Memory&lt;/strong&gt;. This is the &lt;strong&gt;fastest and most expensive level of memory&lt;/strong&gt;, with the &lt;strong&gt;smallest capacity&lt;/strong&gt;. Cache memory is used to store frequently accessed data and instructions from main memory to reduce average memory access time. It acts as a buffer between the CPU and RAM. Cache memory is typically implemented in multiple levels (L1, L2, L3), with each level being faster and smaller than the level below it. It significantly improves CPU performance by providing very fast access to frequently used data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inbound Memory Hierarchy&lt;/strong&gt;: The diagram depicts an inbound memory hierarchy, suggesting data moves &quot;inward&quot; towards the CPU as it becomes more frequently used or actively processed, transitioning from slower, larger storage (Layer A) to faster, smaller caches (Layer C).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Several design issues are of concern in disk cache implementation. Explain two typical considerations that should be observed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Cache Size and Block Size&lt;/strong&gt;: &lt;strong&gt;Cache size&lt;/strong&gt; is a critical consideration. A &lt;strong&gt;larger cache can store more data&lt;/strong&gt;, potentially increasing the cache hit rate and improving performance. However, larger caches are more expensive and consume more memory. &lt;strong&gt;Block size&lt;/strong&gt; (or cache line size) also matters. It determines the unit of data transfer between cache and main memory. Choosing an appropriate cache size and block size involves balancing cost, performance, and memory usage to optimize cache effectiveness for the expected workload.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Cache Replacement Policy&lt;/strong&gt;: The &lt;strong&gt;cache replacement policy&lt;/strong&gt; determines which block to evict from the cache when new data needs to be loaded and the cache is full. Common policies include &lt;strong&gt;Least Recently Used (LRU), First-In, First-Out (FIFO), and Least Frequently Used (LFU)&lt;/strong&gt;. The choice of replacement policy significantly impacts cache hit rate and overall performance. LRU is generally effective but complex to implement, while FIFO is simple but may not be as efficient. Selecting a suitable replacement policy depends on the access patterns of the data being cached.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Beth intends to adopt a full backup scheme for her company's file system. Explain two disadvantages that she could likely realize while using this backup scheme.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Time-Consuming Backup Process&lt;/strong&gt;: A &lt;strong&gt;full backup&lt;/strong&gt; scheme is &lt;strong&gt;very time-consuming&lt;/strong&gt;, especially for large file systems. It involves backing up all files and directories, regardless of whether they have changed since the last backup. The entire backup process can take a significant amount of time, potentially disrupting normal operations, especially if backups are performed during peak hours. Long backup windows can impact system availability and user productivity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Large Storage Space Requirement&lt;/strong&gt;: Full backups require a &lt;strong&gt;large amount of storage space&lt;/strong&gt;. Each backup operation duplicates the entire file system, leading to high storage consumption. Storing multiple full backups over time can quickly fill up backup storage media, increasing storage costs and management complexity. The large storage footprint of full backups can be inefficient and costly, especially for organizations with rapidly growing data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Distinguish between human-readable and machine-readable I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Human-Readable I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Human-readable I/O devices&lt;/strong&gt; are designed to &lt;strong&gt;interact directly with human users&lt;/strong&gt;. They are used for input from and output to humans. Examples include &lt;strong&gt;keyboards&lt;/strong&gt;, &lt;strong&gt;mice&lt;/strong&gt;, &lt;strong&gt;monitors&lt;/strong&gt;, and &lt;strong&gt;printers&lt;/strong&gt;. These devices are characterized by their orientation towards human communication, involving formats and interfaces that humans can easily understand and use. They are often slower in terms of data transfer rates compared to machine-readable devices, as human interaction speed is the limiting factor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine-Readable I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Machine-readable I/O devices&lt;/strong&gt; are designed for &lt;strong&gt;communication between computer systems or for data storage that is primarily processed by machines&lt;/strong&gt;. They are used for high-speed data transfer and storage operations. Examples include &lt;strong&gt;disk drives (HDDs, SSDs)&lt;/strong&gt;, &lt;strong&gt;network interface cards (NICs)&lt;/strong&gt;, and &lt;strong&gt;sensors&lt;/strong&gt;. These devices are optimized for efficiency, speed, and data throughput in machine-to-machine communication and data handling. They typically use formats and protocols designed for machine processing, not direct human interpretation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Human-readable devices are for human interaction, focusing on user-friendly interfaces, while machine-readable devices are for machine-to-machine communication and data storage, emphasizing speed and efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Sarah intends to select a file system for her company. Outline four factors that she should consider other than cost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Performance and Efficiency&lt;/strong&gt;: &lt;strong&gt;Performance&lt;/strong&gt; is a key factor. Sarah should consider the file system's &lt;strong&gt;speed and efficiency in file operations&lt;/strong&gt; such as read, write, create, delete, and search. Performance metrics include throughput, latency, and I/O operations per second (IOPS). An efficient file system will ensure fast data access and overall system responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Scalability and Capacity&lt;/strong&gt;: &lt;strong&gt;Scalability&lt;/strong&gt; is important for future growth. Sarah needs to consider if the file system can &lt;strong&gt;handle increasing data volumes and file counts&lt;/strong&gt; as the company's data grows. The maximum file size, maximum volume size, and overall scalability of the file system should be evaluated to ensure it can meet long-term storage needs.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Reliability and Data Integrity&lt;/strong&gt;: &lt;strong&gt;Reliability and data integrity&lt;/strong&gt; are crucial for protecting valuable company data. The file system should offer features like &lt;strong&gt;data journaling, error detection and correction, and fault tolerance&lt;/strong&gt; to prevent data loss and ensure data consistency, even in case of system failures or crashes. Reliability is paramount for business continuity.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Security Features&lt;/strong&gt;: &lt;strong&gt;Security features&lt;/strong&gt; are vital for protecting sensitive company data from unauthorized access. Sarah should consider the file system's &lt;strong&gt;access control mechanisms, permissions management, encryption capabilities, and security auditing features&lt;/strong&gt;. Robust security features are necessary to maintain data confidentiality, integrity, and compliance with security policies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Define each of the following terms as used in file system:&lt;/p&gt;
&lt;p&gt;(i) field;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Field&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In a file system context, particularly when discussing record-based file organization, a &lt;strong&gt;field&lt;/strong&gt; is a &lt;strong&gt;basic unit of data within a record&lt;/strong&gt;. It represents a &lt;strong&gt;single piece of information or attribute&lt;/strong&gt; about an entity. For example, in a file containing employee records, fields could be 'Employee ID', 'Name', 'Department', etc. Fields are the smallest named data components within a record.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) record.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Record&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In a file system context, a &lt;strong&gt;record&lt;/strong&gt; is a &lt;strong&gt;collection of related fields that are treated as a single unit&lt;/strong&gt;. It represents a &lt;strong&gt;complete entry or instance of an entity&lt;/strong&gt;. For example, an employee record might consist of fields like 'Employee ID', 'Name', 'Department', and 'Salary'. Records are organized into files, forming structured data sets in file systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) The short-term scheduler is invoked whenever an event occurs that may lead to the blocking of the current process in an operating system. Outline four examples of such events that could be invoked.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;I/O Request&lt;/strong&gt;: When a running process &lt;strong&gt;initiates an I/O operation&lt;/strong&gt;, such as reading from a disk, network, or keyboard, it typically needs to wait for the I/O operation to complete. This waiting period blocks the process, and the short-term scheduler is invoked to select another process to run while the current process is blocked waiting for I/O.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Semaphore Wait Operation&lt;/strong&gt;: If a process &lt;strong&gt;performs a wait operation on a semaphore&lt;/strong&gt; and the semaphore value is not positive (resource not available), the process gets blocked. It enters a waiting queue associated with the semaphore, and the short-term scheduler is invoked to choose another process to execute.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Page Fault&lt;/strong&gt;: In a virtual memory system, when a process &lt;strong&gt;accesses a memory page that is not currently in RAM (page fault)&lt;/strong&gt;, the process is blocked. The OS needs to load the required page from secondary storage into memory, which is a time-consuming I/O operation. During this page fault handling, the short-term scheduler is invoked to schedule another process.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Process Suspension (e.g., due to User Request)&lt;/strong&gt;: If a process is &lt;strong&gt;explicitly suspended&lt;/strong&gt;, either by a user command or by another process, it transitions to a blocked or suspended state. The short-term scheduler is invoked to select a different process to run, as the suspended process is no longer ready for execution until it is resumed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two circumstances under which an operating system would prompt a user to rename a file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Filename Conflict&lt;/strong&gt;: If a user attempts to &lt;strong&gt;create a new file or directory with a name that already exists&lt;/strong&gt; in the same directory, the operating system would prompt the user to rename the new file or resolve the naming conflict. Filename conflicts occur because within a single directory, filenames must be unique. The OS prompts for renaming to maintain file system integrity and prevent overwriting existing files unintentionally.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Invalid Filename Characters&lt;/strong&gt;: If a user tries to &lt;strong&gt;rename a file or create a file with a name that contains characters not allowed by the file system's naming conventions&lt;/strong&gt;, the operating system would prompt the user to rename the file with a valid name. Filename conventions vary across OSs, and using invalid characters can cause errors or prevent the file from being created or accessed correctly. The OS prompts for renaming to ensure filenames adhere to valid syntax and file system rules.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) port;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Port&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In operating systems and networking, a &lt;strong&gt;port&lt;/strong&gt; is a &lt;strong&gt;virtual endpoint for communication&lt;/strong&gt;. It is a &lt;strong&gt;numbered connection point&lt;/strong&gt; used by processes or applications to send and receive data over a network or within a system. Ports allow multiple applications or services to share a single network interface or system IP address by distinguishing traffic based on port numbers. They are essential for multiplexing network connections and directing data to the correct application or service.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) message.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Message&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;message&lt;/strong&gt; in operating systems and inter-process communication (IPC) is a &lt;strong&gt;unit of data or information exchanged between processes or components&lt;/strong&gt;. Messages are used for communication, synchronization, and data transfer between different parts of a system. They can be used in various IPC mechanisms like message queues, message passing systems, and network communication to enable processes to interact and coordinate their activities.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Figure 2 shows a cross section of a disk platter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-44-38_2015nov.pdf.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;356&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Outline each of the parts label (i) and (ii).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-009.png&quot; alt=&quot;Figure 2&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on a typical cross-section of a disk platter diagram, assuming (i) points to a track and (ii) points to a sector:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Track&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Part labeled &lt;strong&gt;(i)&lt;/strong&gt; represents a &lt;strong&gt;Track&lt;/strong&gt;. A track is a &lt;strong&gt;concentric circular path on the surface of a disk platter&lt;/strong&gt; where data is recorded magnetically. Platters are divided into numerous concentric tracks, each serving as a storage path for data. Tracks are further divided into smaller units called sectors. The read/write heads move radially across the platter surface to access different tracks. Data is recorded and read along these circular tracks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Sector&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Part labeled &lt;strong&gt;(ii)&lt;/strong&gt; represents a &lt;strong&gt;Sector&lt;/strong&gt;. A sector is a &lt;strong&gt;segment or division of a track on a disk platter&lt;/strong&gt;. It is the &lt;strong&gt;smallest addressable unit on a disk&lt;/strong&gt;, typically storing a fixed amount of data (e.g., 512 bytes or 4KB). Each track is divided into multiple sectors. Sectors are used to organize data on the disk surface and are the basic units for reading and writing data to the disk. Disk addresses are often given in terms of sector numbers or logical block addresses (LBAs) that map to sectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Relationship:&lt;/strong&gt; Tracks are circular paths on the platter, and sectors are segments within these tracks. Sectors are subdivisions of tracks and are the smallest units of data storage and access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Kate was investigating conditions necessary for deadlocks in operating systems. Outline four conditions that she was likely to identify.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: &lt;strong&gt;Mutual exclusion&lt;/strong&gt; is a condition where &lt;strong&gt;resources are non-sharable&lt;/strong&gt;. At least one resource must be held in a non-sharable mode, meaning only one process can use it at a time. If multiple processes request exclusive access to a non-sharable resource, mutual exclusion may lead to deadlocks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hold and Wait&lt;/strong&gt;: &lt;strong&gt;Hold and wait&lt;/strong&gt; condition occurs when a process is &lt;strong&gt;holding at least one resource and is waiting to acquire additional resources&lt;/strong&gt; that are currently held by other processes. The process holds onto resources it has already acquired while waiting for new resources, potentially leading to deadlocks.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;No Preemption&lt;/strong&gt;: &lt;strong&gt;No preemption&lt;/strong&gt; condition means that &lt;strong&gt;resources cannot be forcibly taken away from a process holding them&lt;/strong&gt;. Resources can only be released voluntarily by the process holding them after it has completed its task. Lack of preemption allows processes to hold onto resources indefinitely, contributing to deadlock situations.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Circular Wait&lt;/strong&gt;: &lt;strong&gt;Circular wait&lt;/strong&gt; condition is a situation where there is a &lt;strong&gt;circular chain of two or more processes&lt;/strong&gt;, each waiting for a resource held by the next process in the chain. For example, process A waits for a resource held by process B, and process B waits for a resource held by process A, creating a cycle of dependencies and leading to deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Julie intends to use fixed memory partitioning in an operating system that she was designing for a client. Explain two difficulties that she could experience while using this memory technique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;: &lt;strong&gt;Internal fragmentation&lt;/strong&gt; is a significant difficulty. In fixed partitioning, partitions are pre-sized, and if a process is smaller than the partition it is allocated, the unused space within the partition is wasted. This wasted space, known as internal fragmentation, reduces memory utilization efficiency. For example, if a 10KB process is placed in a 20KB partition, 10KB is internally fragmented and lost.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Inefficient Memory Utilization and Limited Multiprogramming&lt;/strong&gt;: Fixed partitioning can lead to &lt;strong&gt;inefficient memory utilization and limits the degree of multiprogramming&lt;/strong&gt;. If partition sizes are not well-matched to process sizes, memory can be wasted due to internal fragmentation. Also, the total number of processes that can be in memory at once is limited by the fixed number of partitions. If all partitions are in use, even if there is sufficient total free memory (but not in appropriately sized partitions), new processes cannot be loaded, restricting multiprogramming and system throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Load sharing is one of un-processor scheduling technique. Explain two versions of this technique that could be implemented in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Load Sharing with Thresholds&lt;/strong&gt;: In this version of load sharing, &lt;strong&gt;thresholds are set for CPU utilization or queue lengths&lt;/strong&gt;. When a processor's load exceeds a certain threshold, it attempts to &lt;strong&gt;transfer some of its workload to a less loaded processor&lt;/strong&gt;. This can be implemented by migrating processes or tasks to processors with lower utilization. Thresholds help to trigger load sharing actions only when necessary, avoiding excessive migration overhead when the load is already balanced or within acceptable limits. Thresholds can be static or dynamically adjusted.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Load Sharing with Periodic Polling/Sampling&lt;/strong&gt;: In this approach, each processor &lt;strong&gt;periodically polls or samples the load of other processors&lt;/strong&gt; in the system. Based on the sampled load information, processors can make decisions about load sharing. If a processor detects that it is heavily loaded compared to others, it may initiate load sharing by migrating tasks to less loaded processors. Periodic polling/sampling allows for dynamic load assessment and adjustment, enabling the system to adapt to changing workloads over time. The polling interval needs to be carefully chosen to balance responsiveness and overhead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) Explain each of the following types of I/O operations:&lt;/p&gt;
&lt;p&gt;(i) control;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Control I/O Operations&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Control I/O operations&lt;/strong&gt; involve &lt;strong&gt;sending commands to I/O devices to control their functions or modes of operation&lt;/strong&gt;. These operations do not typically involve transferring large amounts of data but rather sending control signals or commands. Examples include commands to start or stop a device, set device parameters, rewind a tape drive, or position a disk head. Control operations are essential for managing and configuring I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) status;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Status I/O Operations&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Status I/O operations&lt;/strong&gt; involve &lt;strong&gt;querying I/O devices to obtain information about their current state or condition&lt;/strong&gt;. These operations are used to check the device's status, such as whether it is ready, busy, idle, or if any errors have occurred. Status operations do not transfer large amounts of data but retrieve status information. Examples include checking if a printer is online, if a disk drive is ready, or if there are any pending errors from a device.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) transfer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Transfer I/O Operations&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer I/O operations&lt;/strong&gt; involve the &lt;strong&gt;actual movement of data between the main memory and an I/O device&lt;/strong&gt;. These operations are used to read data from an input device into memory or to write data from memory to an output device. Transfer operations typically involve transferring blocks of data and are the primary operations for data input and output. Examples include reading data from a disk file, sending data to a network interface, or displaying data on a monitor.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Explain two circumstances that could render use of context switching in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Time Slice Expiry in Time-Sharing Systems&lt;/strong&gt;: In time-sharing operating systems using scheduling algorithms like Round Robin, &lt;strong&gt;context switching is triggered when a process's allocated time slice (time quantum) expires&lt;/strong&gt;. After a process has run for its time slice, the scheduler preempts the process, saves its current state, and performs a context switch to load the state of another ready process, allowing it to run for its time slice. This time-slicing mechanism ensures fair CPU sharing and responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;I/O Wait&lt;/strong&gt;: When a running process &lt;strong&gt;initiates an I/O operation&lt;/strong&gt; (e.g., disk read, network request), it typically needs to wait for the I/O operation to complete. During this waiting period, the process becomes blocked or enters a waiting state. The operating system performs a &lt;strong&gt;context switch to another ready process&lt;/strong&gt;, allowing the CPU to be utilized by other processes while the original process is waiting for I/O. Context switching in I/O wait scenarios improves CPU utilization by overlapping CPU processing with I/O operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Hillary was required to identify disadvantages of sequential file access method during a job interview. Outline five disadvantages that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Inefficient for Random Access&lt;/strong&gt;: &lt;strong&gt;Sequential access is inefficient for applications requiring random or direct access to specific records&lt;/strong&gt;. To access a record in the middle or end of a sequential file, one must read through all preceding records. This results in slow access times for random access patterns, making it unsuitable for applications that frequently need to jump to arbitrary positions in the file.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Difficult to Update or Insert Records in the Middle&lt;/strong&gt;: &lt;strong&gt;Updating or inserting records in the middle of a sequential file is cumbersome and inefficient&lt;/strong&gt;. To insert a record, one typically needs to rewrite the file from the point of insertion onwards. Similarly, updating a record often requires rewriting the entire record or even subsequent parts of the file to maintain sequence and structure. These update and insertion operations are time-consuming and resource-intensive.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Limited Flexibility in File Organization&lt;/strong&gt;: Sequential file organization offers &lt;strong&gt;limited flexibility in how data can be organized and accessed&lt;/strong&gt;. Records are strictly ordered, typically based on a key, and access is primarily limited to sequential traversal. It is not well-suited for complex data structures or applications that require more flexible or indexed access patterns.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Slower for Searching Specific Records&lt;/strong&gt;: &lt;strong&gt;Searching for a specific record in a sequential file can be slow&lt;/strong&gt;, especially for large files. A linear search from the beginning of the file is required to find a record based on a specific criterion or key value. This linear search time increases proportionally with file size, making sequential search inefficient for large datasets.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Data Redundancy and Inconsistency Potential&lt;/strong&gt;: In some sequential file implementations, &lt;strong&gt;managing relationships between data can be challenging&lt;/strong&gt;, potentially leading to data redundancy and inconsistency. Lack of indexing or direct access mechanisms can make it harder to maintain data integrity and enforce relationships between records, especially in complex data management scenarios.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a diagram, describe a process control block PCB as applied in operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Process Control Block (PCB) Description with Diagram&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;Process Control Block (PCB)&lt;/strong&gt; is a &lt;strong&gt;data structure used by the operating system to store all the information needed to manage a particular process&lt;/strong&gt;. It contains process-specific information that the OS needs to control and track the execution of each process. The PCB is created when a process is created and is updated and used throughout the process's lifecycle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of a Process Control Block (PCB):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-----------------------------------+
| Process ID (PID)                  |  &amp;lt;-- Unique identifier for the process
+-----------------------------------+
| Process State                     |  &amp;lt;-- Running, Ready, Blocked, etc.
+-----------------------------------+
| Program Counter (PC)              |  &amp;lt;-- Address of the next instruction to execute
+-----------------------------------+
| CPU Registers                     |  &amp;lt;-- Contents of CPU registers (Accumulator, etc.)
+-----------------------------------+
| Memory Management Information     |  &amp;lt;-- Page table base, segment table base, etc.
+-----------------------------------+
| CPU Scheduling Information        |  &amp;lt;-- Priority, scheduling queue pointers
+-----------------------------------+
| Accounting Information            |  &amp;lt;-- CPU time used, time limits, etc.
+-----------------------------------+
| I/O Status Information            |  &amp;lt;-- List of open files, I/O devices allocated
+-----------------------------------+
| Context Data                      |  &amp;lt;-- Other context-specific data for process state
+-----------------------------------+
| Pointer to Parent PCB             |  &amp;lt;-- Pointer to PCB of parent process
+-----------------------------------+
| Pointers to Child PCBs            |  &amp;lt;-- List of pointers to PCBs of child processes
+-----------------------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of PCB Components:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process ID (PID)&lt;/strong&gt;: A &lt;strong&gt;unique identifier&lt;/strong&gt; that distinguishes each process from others.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process State&lt;/strong&gt;: Indicates the &lt;strong&gt;current state of the process&lt;/strong&gt; (e.g., running, ready, blocked, new, terminated).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: Stores the &lt;strong&gt;address of the next instruction&lt;/strong&gt; that the process will execute.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;CPU Registers&lt;/strong&gt;: Saves the &lt;strong&gt;contents of CPU registers&lt;/strong&gt; when the process is switched out, so the process can resume execution correctly later.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Memory Management Information&lt;/strong&gt;: Includes details for memory management, such as &lt;strong&gt;page table base address or segment table information&lt;/strong&gt;, used for virtual address translation.&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;&lt;strong&gt;CPU Scheduling Information&lt;/strong&gt;: Contains data used for process scheduling, like &lt;strong&gt;priority level and pointers to scheduling queues&lt;/strong&gt;.&lt;/p&gt;
&lt;p data-number=&quot;7&quot;&gt;&lt;strong&gt;Accounting Information&lt;/strong&gt;: Tracks &lt;strong&gt;resource usage&lt;/strong&gt; by the process, such as CPU time used, real time elapsed, account numbers, etc.&lt;/p&gt;
&lt;p data-number=&quot;8&quot;&gt;&lt;strong&gt;I/O Status Information&lt;/strong&gt;: Keeps track of &lt;strong&gt;I/O devices allocated to the process and lists of open files&lt;/strong&gt;.&lt;/p&gt;
&lt;p data-number=&quot;9&quot;&gt;&lt;strong&gt;Pointers&lt;/strong&gt;: Includes &lt;strong&gt;pointers to parent and child PCBs&lt;/strong&gt; to establish process hierarchy.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function:&lt;/strong&gt; The PCB is the central repository of information that the operating system uses to manage and control processes. It is essential for context switching, process scheduling, resource management, and inter-process communication.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) Explain each of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(i) address space;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Address Space&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Address space&lt;/strong&gt; is the &lt;strong&gt;range of memory addresses available to a process&lt;/strong&gt;. It is the set of addresses that a process can logically access. In virtual memory systems, this is typically a virtual address space, which is separate from the physical memory addresses. Each process has its own address space, providing isolation and protection from other processes. The address space defines the memory view of a process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) user space.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) User Space&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User space&lt;/strong&gt; is the &lt;strong&gt;memory area where user-level processes execute&lt;/strong&gt;. It is a part of the virtual address space that is accessible to user applications. User space is typically protected, meaning user processes have restricted access to system hardware and kernel memory. Code and data of user applications reside in user space, and they interact with the operating system kernel through system calls to request privileged operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Distinguish between a ready-state and blocked-state of a process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Ready State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A process is in the &lt;strong&gt;ready state&lt;/strong&gt; when it is &lt;strong&gt;prepared and waiting to be executed by the CPU&lt;/strong&gt;. The process has all the necessary resources it needs to run, except for the CPU itself. Processes in the ready state are waiting in a ready queue for their turn to be scheduled on the CPU by the short-term scheduler. They are runnable and will transition to the running state when the scheduler selects them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Blocked State (Waiting State)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A process is in the &lt;strong&gt;blocked state&lt;/strong&gt;, also known as the waiting state, when it is &lt;strong&gt;waiting for some event to occur before it can proceed&lt;/strong&gt;. This event is typically an external event, such as the completion of an I/O operation, release of a resource, or reception of a signal. While in the blocked state, a process cannot use the CPU, even if it is available. Processes in the blocked state are not eligible to run until the event they are waiting for occurs, after which they typically transition to the ready state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; A process in the ready state is waiting for CPU allocation and is ready to run, while a process in the blocked state is waiting for an external event and cannot run even if the CPU is available.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Amos was required to implement remote file sharing system for a client. Explain three methods that he could consider for the client.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Network File System (NFS)&lt;/strong&gt;: &lt;strong&gt;Network File System (NFS)&lt;/strong&gt; is a &lt;strong&gt;distributed file system protocol&lt;/strong&gt; that allows users to access files over a network as if they were on their local file system. NFS enables clients to mount file systems located on servers and access files transparently. It is widely used in Unix-like systems and provides file sharing capabilities across heterogeneous environments. NFS is suitable for sharing files among users and applications in a network environment, providing file-level access and sharing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Server Message Block (SMB/CIFS)&lt;/strong&gt;: &lt;strong&gt;Server Message Block (SMB)&lt;/strong&gt;, also known as Common Internet File System (CIFS), is a &lt;strong&gt;network file sharing protocol&lt;/strong&gt; commonly used in Windows environments (but also available for other OSs like Linux via Samba). SMB allows clients to access files and directories shared on servers over a network. It provides file and printer sharing services and supports features like file locking and authentication. SMB/CIFS is widely used in Windows networks for file sharing among Windows clients and servers.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Distributed File System (DFS)&lt;/strong&gt;: &lt;strong&gt;Distributed File System (DFS)&lt;/strong&gt; is a &lt;strong&gt;file system that spans multiple servers and locations&lt;/strong&gt;, presenting a unified view of shared files to users. DFS can aggregate multiple file shares into a single logical namespace, simplifying access to distributed files. It can also provide features like fault tolerance, load balancing, and data replication. DFS is suitable for large organizations with geographically distributed file servers and users needing access to files across different locations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Figure 3 shows a memory allocation technique.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-45-27_2015nov.pdf.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;509&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Use it to answer questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;paperpaper-009.png&quot; alt=&quot;Figure 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(i) Identify the appropriate memory management techniques depicted in the figure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Swapping&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The memory management technique depicted in Figure 3 is &lt;strong&gt;swapping&lt;/strong&gt;. The diagram illustrates a process (Process P1) being &lt;strong&gt;swapped out&lt;/strong&gt; of main memory to secondary storage (store) and another process (Process P2) being &lt;strong&gt;swapped in&lt;/strong&gt; from secondary storage into main memory. This exchange of processes between RAM and disk is characteristic of swapping.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two benefits that could be realized when using memory management technique identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Degree of Multiprogramming&lt;/strong&gt;: &lt;strong&gt;Swapping allows for an increased degree of multiprogramming&lt;/strong&gt;. By temporarily moving processes out of main memory to secondary storage, swapping frees up RAM, allowing the operating system to load and execute more processes concurrently than would fit in physical memory at once. This increases CPU utilization and system throughput as more processes can compete for CPU time.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Running Larger Programs than Physical Memory&lt;/strong&gt;: Swapping enables the execution of &lt;strong&gt;programs that are larger than the available physical RAM&lt;/strong&gt;. By swapping parts of a program (or whole processes) in and out of memory as needed, swapping creates the illusion of a larger memory space than physically present. This allows users to run applications that would otherwise exceed the physical memory capacity of the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) (i) Outline four typical resources needed in a process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time&lt;/strong&gt;: &lt;strong&gt;CPU time&lt;/strong&gt; is the fundamental processing resource required for a process to execute its instructions. The process needs to be allocated CPU cycles by the operating system scheduler to perform computations and execute program code.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory Space&lt;/strong&gt;: &lt;strong&gt;Memory space (RAM)&lt;/strong&gt; is needed to store the process's code, data, and stack during execution. The process requires memory to hold its instructions, variables, and runtime data. Sufficient memory allocation is essential for the process to run correctly.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Files&lt;/strong&gt;: &lt;strong&gt;File resources&lt;/strong&gt; are often required for processes to interact with data stored in files. Processes may need to open, read, write, create, or delete files to perform their tasks. Access to file system resources is essential for many applications.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;I/O Devices&lt;/strong&gt;: &lt;strong&gt;Input/Output (I/O) devices&lt;/strong&gt; are necessary for processes to interact with the external environment or other system components. Processes may require access to devices like keyboards, monitors, network interfaces, or printers to receive input, display output, or communicate with networks.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between data and system buses as used in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Data Bus&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;data bus&lt;/strong&gt; is a set of wires or conductors that &lt;strong&gt;carries actual data being transferred between different components of a computer system&lt;/strong&gt;, such as the CPU, memory, and I/O devices. It is used to transmit data for processing and storage. The width of the data bus (number of parallel lines) determines the amount of data that can be transferred simultaneously in a single bus cycle. Data buses are bidirectional, allowing data to flow in both directions (to and from components).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Bus&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;system bus&lt;/strong&gt; is a &lt;strong&gt;collection of buses that connect major components of a computer system&lt;/strong&gt;, including the CPU, memory, and peripherals. It is a higher-level bus that typically includes the data bus, address bus, and control bus. The system bus provides a pathway for communication and data transfer between these major components, facilitating overall system operation. It is responsible for handling all types of system-level communication, including data transfer, address signaling, and control signals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; The data bus is specifically for transferring data, while the system bus is a broader term encompassing the data bus along with address and control buses, serving as the main communication pathway for major system components.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Describe the term disk cache as applied in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Disk Cache&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk cache&lt;/strong&gt; is a &lt;strong&gt;portion of RAM (main memory) used as a cache to store frequently accessed data from a hard disk drive (HDD) or solid-state drive (SSD)&lt;/strong&gt;. It acts as a buffer between the slower disk storage and the faster CPU and main memory. The disk cache stores recently accessed disk blocks or frequently used files, allowing the system to retrieve data from the faster RAM cache instead of the slower disk, improving I/O performance and reducing disk access latency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Anna was required to investigate I/O protection measures that could be implemented in an operating system for her company. Explain two measures that could have identified.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Control Lists (ACLs) for I/O Devices&lt;/strong&gt;: Implementing &lt;strong&gt;Access Control Lists (ACLs) for I/O devices&lt;/strong&gt; can provide fine-grained control over which processes or users can access specific I/O devices. ACLs can define permissions (read, write, control) for different users or groups for each I/O device. This measure helps to prevent unauthorized access to sensitive hardware resources and ensures that only authorized processes can perform I/O operations on specific devices, enhancing system security and device access control.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory Protection for I/O Buffers&lt;/strong&gt;: Employing &lt;strong&gt;memory protection mechanisms for I/O buffers&lt;/strong&gt; is crucial. This involves ensuring that only authorized processes can access I/O buffers used for data transfer between memory and I/O devices. Memory protection techniques like memory segmentation or paging can be used to isolate I/O buffers in protected memory regions, preventing unauthorized processes from reading or writing to these buffers. Protecting I/O buffers helps to maintain data integrity during I/O operations and prevents malicious or accidental data corruption.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A number of memory placement techniques exist in an operating system. Explain three of such techniques that could be adapted in a given operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;First-Fit&lt;/strong&gt;: &lt;strong&gt;First-Fit&lt;/strong&gt; is a dynamic memory allocation algorithm that &lt;strong&gt;allocates the first available free partition (hole) in memory that is large enough to satisfy the request&lt;/strong&gt;. When searching for a free partition, First-Fit starts from the beginning of the memory or the list of free partitions and allocates the first suitable one it finds. It is simple and fast for allocation but can lead to fragmentation, especially external fragmentation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Best-Fit&lt;/strong&gt;: &lt;strong&gt;Best-Fit&lt;/strong&gt; algorithm allocates the &lt;strong&gt;smallest free partition that is large enough to satisfy the memory request&lt;/strong&gt;. It searches the entire list of free partitions and selects the one that is closest in size to the requested memory. Best-Fit aims to minimize wasted space (internal fragmentation) but can be slower than First-Fit due to the need to search all free partitions, and it can still lead to external fragmentation over time.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Worst-Fit&lt;/strong&gt;: &lt;strong&gt;Worst-Fit&lt;/strong&gt; algorithm allocates the &lt;strong&gt;largest available free partition&lt;/strong&gt; to satisfy a memory request. It searches the entire list of free partitions and selects the largest one. The idea behind Worst-Fit is to leave larger free partitions remaining after allocation, hoping to accommodate larger future requests. However, it can actually increase external fragmentation by breaking down large free blocks into smaller, less usable pieces.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) (i) Define the term monitor as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Monitor&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In process management, a &lt;strong&gt;monitor&lt;/strong&gt; is a &lt;strong&gt;high-level synchronization construct&lt;/strong&gt; used for controlling access to shared resources in concurrent programming. It encapsulates shared data and the procedures (methods) that operate on that data, ensuring &lt;strong&gt;mutual exclusion&lt;/strong&gt; and providing &lt;strong&gt;condition variables&lt;/strong&gt; for process synchronization. Monitors simplify concurrent programming by providing a structured way to manage shared resources and synchronize process interactions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Distinguish between logical and physical addresses as applied in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Logical Address (Virtual Address)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logical addresses&lt;/strong&gt;, also known as virtual addresses, are the &lt;strong&gt;addresses generated by the CPU when a program is executed&lt;/strong&gt;. They are part of the process's virtual address space and are independent of the physical memory addresses. Logical addresses are used by programmers and processes to refer to memory locations. They are translated to physical addresses by the Memory Management Unit (MMU) during memory access. Each process has its own logical address space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical Address&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical addresses&lt;/strong&gt; are the &lt;strong&gt;actual addresses in physical RAM (main memory)&lt;/strong&gt;. They represent the real locations in memory hardware where data is stored. Physical addresses are used by the memory controller to access specific memory locations in RAM chips. Logical addresses are mapped to physical addresses by the MMU using page tables or segment tables. Physical addresses are what the hardware understands and uses to access memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Logical addresses are virtual and process-specific, used by programs. Physical addresses are real hardware addresses in RAM, used by the memory controller. The MMU translates logical to physical addresses.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Tom was required to develop a clock module for an operating system for a client. Outline four functions of this module to the proposed operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Timekeeping and System Clock Maintenance&lt;/strong&gt;: The clock module is responsible for &lt;strong&gt;maintaining the system clock&lt;/strong&gt;, keeping track of the current date and time. It updates the system time based on hardware clock ticks and provides system calls for applications and the OS to query the current time. Accurate timekeeping is essential for various system functions, such as scheduling, timestamps, and logging.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Scheduling and Time Slicing&lt;/strong&gt;: The clock module generates &lt;strong&gt;timer interrupts&lt;/strong&gt; at regular intervals, which are used by the operating system's scheduler for &lt;strong&gt;time-slicing and process scheduling&lt;/strong&gt;. Timer interrupts trigger context switches, allowing the scheduler to preempt currently running processes and allocate CPU time to other ready processes in Round Robin or similar scheduling algorithms. This ensures fairness and responsiveness in time-sharing systems.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Timeouts and Delays&lt;/strong&gt;: The clock module provides mechanisms for implementing &lt;strong&gt;timeouts and delays&lt;/strong&gt;. The OS and applications can use the clock module to set timers for specific events, such as I/O operations, network communication, or alarms. Timeouts are crucial for handling time-dependent operations, detecting failures, and implementing time-based functionalities in various system components.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Profiling and Performance Measurement&lt;/strong&gt;: The clock module can be used for &lt;strong&gt;profiling and performance measurement&lt;/strong&gt;. By measuring time intervals using the system clock or high-resolution timers provided by the clock module, the OS and performance monitoring tools can measure execution times of processes, system calls, or specific code sections. This information is valuable for performance analysis, debugging, and optimization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Nabat described several objectives for developing an I/O module to his friends. Outline four objectives that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Independence&lt;/strong&gt;: A key objective is to achieve &lt;strong&gt;device independence&lt;/strong&gt;. The I/O module should provide a &lt;strong&gt;uniform interface for the rest of the operating system and applications&lt;/strong&gt;, regardless of the specific characteristics of the underlying I/O devices. Device independence allows the OS and applications to interact with I/O devices in a generic way, without needing to be rewritten or modified for each different device type. Device drivers handle the device-specific details, abstracting hardware differences.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficiency&lt;/strong&gt;: &lt;strong&gt;Efficiency&lt;/strong&gt; is a critical objective. The I/O module should be designed to &lt;strong&gt;maximize I/O throughput and minimize latency&lt;/strong&gt;. Efficient I/O operations are essential for overall system performance. Techniques like buffering, caching, DMA, and optimized I/O scheduling algorithms are employed in the I/O module to improve efficiency and reduce the overhead of I/O operations.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Error Handling and Reliability&lt;/strong&gt;: &lt;strong&gt;Error handling and reliability&lt;/strong&gt; are important objectives. The I/O module should handle &lt;strong&gt;device errors, I/O errors, and exceptions gracefully&lt;/strong&gt;. It should provide mechanisms for error detection, error recovery, and reporting errors to the OS and applications. Robust error handling is necessary to ensure data integrity and system stability in the presence of I/O device issues.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Abstraction and Simplification of I/O Operations&lt;/strong&gt;: The I/O module aims to &lt;strong&gt;abstract and simplify I/O operations for higher-level software layers&lt;/strong&gt; (OS kernel and applications). It provides a set of &lt;strong&gt;high-level, easy-to-use interfaces (system calls)&lt;/strong&gt; for performing common I/O tasks, hiding the complexities of device-specific control and low-level hardware interactions. This abstraction simplifies programming and makes I/O operations more manageable for developers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Nissi Company Ltd. was experiencing security issues with its file system. Explain three logical security measures that it could implement in order to mitigate the issue.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Control Lists (ACLs) Implementation&lt;/strong&gt;: Implement &lt;strong&gt;Access Control Lists (ACLs)&lt;/strong&gt; to provide fine-grained control over file and directory permissions. ACLs allow administrators to define specific access rights (read, write, execute, delete, etc.) for individual users or groups for each file and directory. This measure enhances security by allowing precise permission settings, minimizing unauthorized access beyond basic owner-group-others permissions. ACLs offer more granular and flexible access control.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File System Encryption&lt;/strong&gt;: Implement &lt;strong&gt;file system encryption&lt;/strong&gt; to protect sensitive data at rest. Encrypting the file system ensures that data stored on disk is unreadable without the correct decryption key, even if unauthorized users gain physical access to the storage media or bypass access controls. Encryption protects data confidentiality and mitigates the risk of data breaches. Both full-disk encryption and file-level encryption can be considered depending on requirements.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Regular Security Audits and Monitoring&lt;/strong&gt;: Conduct &lt;strong&gt;regular security audits and monitoring of file system access and activities&lt;/strong&gt;. Implement logging and auditing mechanisms to track file access attempts, permission changes, and other relevant events. Regular security audits help identify vulnerabilities, misconfigurations, or suspicious activities. Monitoring file system logs can detect and respond to security incidents promptly. Proactive security monitoring and auditing are essential for maintaining file system security over time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;THIS IS THE LAST PRINTED PAGE.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="262"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="10_132_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="50">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="47"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-43-42_2015nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-43-42_2015nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="bf2488e175bb0704b02d7ae754f3b9d3"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="48"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="263"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="10_132_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="51">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="47"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-44-38_2015nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-44-38_2015nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="5c46784f5453126618a52f94e1ead9f5"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="48"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="264"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="10_132_2.2"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="52">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="47"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-45-27_2015nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-45-27_2015nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="c8830fefff9ec1c3b202b551daf13eaa"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="48"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="48"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="3"></int>
              <string role="key" value="parentNode"></string>
              <reference key="49"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="10"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="49"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="50"></reference>
            <reference key="51"></reference>
            <reference key="52"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="10"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202015"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="55">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2015"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="53">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="54">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="133_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="53"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2015&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) Outline three types of file sharing technologies that could be implemented in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Network File System (NFS)&lt;/strong&gt;: &lt;strong&gt;NFS&lt;/strong&gt; allows file sharing across a network, primarily used in Unix and Linux environments.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Server Message Block (SMB/CIFS)&lt;/strong&gt;: &lt;strong&gt;SMB/CIFS&lt;/strong&gt; enables file sharing in Windows environments and is also compatible with other operating systems through Samba.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Distributed File System (DFS)&lt;/strong&gt;: &lt;strong&gt;DFS&lt;/strong&gt; aggregates file shares across multiple servers into a single namespace, providing a unified view of distributed files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Define the term cluster as used in file management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Cluster&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;cluster&lt;/strong&gt; is the &lt;strong&gt;smallest unit of disk space allocation&lt;/strong&gt; in a file system, comprising one or more contiguous sectors. It's the minimum amount of storage that can be allocated to a file, with file systems managing disk space in clusters rather than individual sectors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Operating system uses file allocation table to position files on a disk. Outline five desirable features of a good file allocation table.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficiency in Disk Space Management&lt;/strong&gt;: A good FAT should efficiently manage disk space by &lt;strong&gt;minimizing fragmentation&lt;/strong&gt; and optimizing the allocation of clusters to files. Efficient space management ensures that disk space is utilized effectively, reducing wastage and maximizing storage capacity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Fast File Access and Retrieval&lt;/strong&gt;: The FAT should facilitate &lt;strong&gt;fast file access and retrieval&lt;/strong&gt;. It should enable quick lookups of file locations and efficient traversal of file clusters to minimize access time and improve file system performance. Fast file access is crucial for application responsiveness and overall system performance.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Robustness and Reliability&lt;/strong&gt;: A desirable FAT should be &lt;strong&gt;robust and reliable&lt;/strong&gt;, ensuring data integrity and preventing file system corruption. Features like redundancy, error checking, and recovery mechanisms are important to protect the FAT structure and file metadata from failures, maintaining data integrity and system stability.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Scalability to Handle Large Disks and Files&lt;/strong&gt;: The FAT structure should be &lt;strong&gt;scalable to handle large disk volumes and a large number of files&lt;/strong&gt;. It should efficiently manage increasing storage capacities and file counts without performance degradation. Scalability ensures that the file system can accommodate future data growth and remain efficient over time.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Simplicity and Ease of Implementation&lt;/strong&gt;: While being efficient and robust, a good FAT should also be &lt;strong&gt;relatively simple to implement and maintain&lt;/strong&gt;. Simplicity reduces the complexity of file system design and development, making it easier to implement, debug, and manage. A simpler FAT structure can also reduce overhead and improve overall file system efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Outline two disadvantages of memory fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Inefficient Memory Utilization&lt;/strong&gt;: Memory fragmentation leads to &lt;strong&gt;inefficient utilization of memory&lt;/strong&gt;. External fragmentation results in usable memory being scattered in small chunks, while internal fragmentation wastes space within allocated partitions. In both cases, memory is not used optimally, reducing the system's capacity to run more processes or handle larger datasets.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Reduced System Performance&lt;/strong&gt;: Fragmentation can &lt;strong&gt;degrade system performance&lt;/strong&gt;. External fragmentation may lead to failure to allocate memory for new processes or require memory compaction, which is time-consuming. Internal fragmentation wastes allocated memory, reducing the effective memory available and potentially causing more swapping or paging, thus slowing down system operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between device controller and device driver as used in computer systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Device Controller&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;device controller&lt;/strong&gt; is a &lt;strong&gt;hardware component&lt;/strong&gt; (chip or circuit board) that &lt;strong&gt;manages and controls the physical operations of an I/O device&lt;/strong&gt;. It acts as an interface between the I/O device and the system bus. The device controller handles low-level operations such as data transfer, device signaling, error detection, and device-specific protocols. It is responsible for the physical control of the hardware device and interacts directly with the device hardware.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device Driver&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;device driver&lt;/strong&gt; is a &lt;strong&gt;software component&lt;/strong&gt; that &lt;strong&gt;enables the operating system to communicate with and control a specific hardware device&lt;/strong&gt;. It acts as a software interface between the OS kernel and the device controller. The device driver translates generic OS commands into device-specific instructions that the device controller can understand. It handles device initialization, I/O request processing, interrupt handling, and device management functions. Device drivers abstract the hardware details and provide a uniform interface for the OS to interact with diverse hardware devices.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; The device controller is hardware that physically controls the I/O device, while the device driver is software that allows the OS to communicate with and manage the device controller and, thus, the I/O device.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Disk caching increases performance of a computer. Explain two ways used in disk caching to justify this statement.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Disk Access Time&lt;/strong&gt;: &lt;strong&gt;Disk caching reduces disk access time&lt;/strong&gt; by storing frequently accessed data in a cache memory (RAM), which has much faster access speeds than hard disks or SSDs. When data is requested, the system first checks the disk cache. If the data is found in the cache (cache hit), it is served directly from the cache, avoiding the slower disk access. Serving more requests from the cache significantly lowers the average access time, improving overall system responsiveness and speed of data retrieval.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased I/O Throughput&lt;/strong&gt;: Disk caching &lt;strong&gt;increases I/O throughput&lt;/strong&gt; by reducing the number of actual disk I/O operations. By serving read requests from the cache and buffering write operations in the cache (write-back caching), disk caching reduces the load on the disk subsystem. Higher cache hit rates mean fewer disk accesses are needed to satisfy I/O requests, allowing the disk subsystem to handle more I/O operations in a given time, thus increasing overall I/O throughput and system efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) (i) Outline three groups of I/O instructions used in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Control Instructions&lt;/strong&gt;: &lt;strong&gt;Control instructions&lt;/strong&gt; are used to &lt;strong&gt;control the operation of I/O devices&lt;/strong&gt;. These instructions send commands to devices to initiate actions, set modes, or manage device functions. Examples include commands to start or stop a device, rewind a tape, or seek a specific track on a disk. They manage the behavior and state of I/O devices.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Status Instructions&lt;/strong&gt;: &lt;strong&gt;Status instructions&lt;/strong&gt; are used to &lt;strong&gt;query the status of I/O devices&lt;/strong&gt;. These instructions allow the CPU or operating system to check the current state of a device, such as its readiness, error status, or completion status. Status instructions are essential for device monitoring and error handling, enabling the system to check if a device is ready for data transfer or if any errors have occurred.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data Transfer Instructions&lt;/strong&gt;: &lt;strong&gt;Data transfer instructions&lt;/strong&gt; are used to &lt;strong&gt;transfer actual data between the CPU/memory and I/O devices&lt;/strong&gt;. These instructions handle the movement of data for input and output operations. Examples include instructions to read data from an I/O port to memory or write data from memory to an I/O port. Data transfer instructions are the core of I/O operations, facilitating the exchange of data between the system and external devices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Most computer systems have implemented dynamic memory access. Describe the procedure used to transfer data from I/O devices in these systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Procedure for Data Transfer from I/O Devices using Dynamic Memory Access (DMA)&lt;/strong&gt;:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;DMA Request&lt;/strong&gt;: The I/O device initiates a data transfer by sending a &lt;strong&gt;DMA request signal&lt;/strong&gt; to the DMA controller. This request indicates that the device has data to transfer to memory or is ready to receive data from memory.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;DMA Controller Setup&lt;/strong&gt;: Upon receiving the DMA request, the DMA controller &lt;strong&gt;requests control of the system bus&lt;/strong&gt; from the CPU. The CPU may grant the bus to the DMA controller after completing the current bus cycle.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data Transfer by DMA Controller&lt;/strong&gt;: Once the DMA controller gains control of the bus, it directly &lt;strong&gt;transfers data between the I/O device and main memory&lt;/strong&gt; without involving the CPU for each byte transferred. The DMA controller acts as the bus master, managing the data transfer process independently.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;DMA Completion and Notification&lt;/strong&gt;: After the data transfer is complete, the DMA controller &lt;strong&gt;notifies the CPU via an interrupt signal&lt;/strong&gt;. The CPU is then informed that the DMA transfer is finished and can resume processing or initiate further operations. This process offloads data transfer tasks from the CPU, allowing it to perform other computations concurrently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Rosalina would like to design a file management system. Outline five objectives of the system that she should consider in the design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Meeting User Needs and Requirements&lt;/strong&gt;: The primary objective is to design a file management system that &lt;strong&gt;effectively meets the needs and requirements of users&lt;/strong&gt;. This includes providing functionalities for file creation, deletion, organization, sharing, and access in a manner that is user-friendly and efficient. User needs should drive the design and features of the file system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficient Data Storage and Retrieval&lt;/strong&gt;: The file system should ensure &lt;strong&gt;efficient storage of data on storage devices and fast retrieval of files&lt;/strong&gt; when needed. This involves optimizing disk space utilization, minimizing fragmentation, and implementing efficient algorithms for file access, directory operations, and metadata management. Performance in data storage and retrieval is crucial for system responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data Integrity and Reliability&lt;/strong&gt;: Maintaining &lt;strong&gt;data integrity and reliability&lt;/strong&gt; is a critical objective. The file system must protect data from corruption, loss, and unauthorized modifications. Features like error detection and correction, data journaling, backup and recovery mechanisms, and robust metadata management are essential to ensure data integrity and system reliability.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Security and Access Control&lt;/strong&gt;: Implementing &lt;strong&gt;strong security and access control mechanisms&lt;/strong&gt; is vital. The file system should provide features to control access to files and directories, ensuring data confidentiality and preventing unauthorized access. Access control should be flexible, allowing for permissions based on users, groups, and roles, and should protect against both internal and external security threats.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Scalability and Adaptability&lt;/strong&gt;: The file management system should be &lt;strong&gt;scalable to handle increasing data volumes and file counts&lt;/strong&gt; as the system grows. It should also be &lt;strong&gt;adaptable to different storage technologies and evolving user needs&lt;/strong&gt;. Scalability and adaptability ensure that the file system can meet current and future storage requirements and remain efficient and functional over time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (a) Explain the semaphore as used in operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Semaphore Explanation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;semaphore&lt;/strong&gt; is a &lt;strong&gt;synchronization primitive&lt;/strong&gt; used in operating systems for controlling access to shared resources and coordinating process execution. It is an &lt;strong&gt;integer variable&lt;/strong&gt; that can be accessed and manipulated through two atomic operations: &lt;strong&gt;wait (P)&lt;/strong&gt; and &lt;strong&gt;signal (V)&lt;/strong&gt;. Semaphores help solve critical section problems and manage concurrency by controlling process access to shared resources, preventing race conditions and ensuring synchronized operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Describe the term swapping as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Swapping Description&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Swapping&lt;/strong&gt; is a memory management technique where processes are &lt;strong&gt;moved between main memory (RAM) and secondary storage (disk)&lt;/strong&gt; to manage memory and enable multiprogramming. When main memory becomes full or when a process is idle, the operating system swaps out inactive processes from RAM to disk (swap space) to free up memory. When a swapped-out process needs to run again, it is swapped back into RAM. Swapping allows more processes to be loaded and executed than physical memory can hold simultaneously, increasing the degree of multiprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four major storage levels that could be found in a memory hierarchy diagram.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Registers&lt;/strong&gt;: &lt;strong&gt;Registers&lt;/strong&gt; are the &lt;strong&gt;fastest and most expensive level&lt;/strong&gt;, located within the CPU. They hold data and instructions that the CPU is currently processing. Registers have very small capacity but offer the quickest access times.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Cache Memory&lt;/strong&gt;: &lt;strong&gt;Cache memory&lt;/strong&gt; is a &lt;strong&gt;fast, relatively small memory&lt;/strong&gt; located closer to the CPU than main memory. It stores frequently accessed data and instructions from RAM to reduce average memory access time. Cache memory is typically multi-level (L1, L2, L3), with increasing size and decreasing speed at each level.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Main Memory (RAM)&lt;/strong&gt;: &lt;strong&gt;Main Memory (RAM - Random Access Memory)&lt;/strong&gt; is the &lt;strong&gt;primary working memory&lt;/strong&gt; of a computer system. It is faster and more expensive than secondary storage but slower and cheaper than cache. RAM holds the programs and data currently in use by the CPU and provides a balance between speed, cost, and capacity.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Secondary Storage (e.g., SSD, HDD)&lt;/strong&gt;: &lt;strong&gt;Secondary Storage&lt;/strong&gt;, such as Solid State Drives (SSDs) or Hard Disk Drives (HDDs), is the &lt;strong&gt;slowest and cheapest level&lt;/strong&gt;, but offers the &lt;strong&gt;largest capacity&lt;/strong&gt;. It is non-volatile and used for long-term storage of data, including the operating system, applications, and user files. Access times are significantly slower compared to RAM and cache.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Explain three ways in which a new process is created in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Creation by Parent Process (Forking)&lt;/strong&gt;: A new process can be created by an &lt;strong&gt;existing process, known as the parent process, using the fork system call&lt;/strong&gt;. When a parent process forks, the operating system creates a nearly identical copy of the parent process, which becomes the child process. The child process inherits many attributes from the parent, but has a new process ID and starts executing independently. Forking is a common method for process creation in Unix-like systems.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Creation by System Initialization (Bootstrapping)&lt;/strong&gt;: Some processes are created during &lt;strong&gt;system initialization or boot-up&lt;/strong&gt;. When the operating system starts, it launches essential system processes that are needed for system functionality. These processes are typically created directly by the kernel as part of the boot sequence and are crucial for managing system resources and services. Examples include init process (in Unix-like systems) or system daemons.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Process Creation by User Request (Command Execution)&lt;/strong&gt;: New processes are often created in response to &lt;strong&gt;user requests, such as when a user executes a command or starts an application&lt;/strong&gt;. When a user types a command in a shell or clicks on an application icon, the operating system creates a new process to run the requested program. The shell or GUI acts as a parent process that spawns new processes based on user actions. This is the primary way user applications are launched.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Derrick was required to investigate several elements of a process control block. Outline four elements that he could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process State&lt;/strong&gt;: The PCB contains the &lt;strong&gt;current state of the process&lt;/strong&gt;. This state indicates whether the process is currently running, ready to run, waiting (blocked), new, or terminated. The process state is dynamic and changes as the process executes and interacts with the system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: The PCB stores the &lt;strong&gt;Program Counter (PC) value&lt;/strong&gt; for the process. The PC holds the address of the next instruction that the process is to execute. When a process is interrupted or switched out, the PC value is saved in its PCB so that execution can resume from the correct point later.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;CPU Registers&lt;/strong&gt;: The PCB includes &lt;strong&gt;CPU registers&lt;/strong&gt;. This section saves the &lt;strong&gt;current values of all CPU registers&lt;/strong&gt; when the process is switched out. Registers hold temporary data and intermediate results that the process is actively using. Saving and restoring registers are essential for context switching to ensure correct process resumption.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Memory Management Information&lt;/strong&gt;: The PCB contains &lt;strong&gt;memory management information&lt;/strong&gt; for the process. This includes details about the process's memory allocation, such as &lt;strong&gt;pointers to page tables or segment tables&lt;/strong&gt;. This information is crucial for virtual address translation and memory protection, enabling the OS to manage the process's memory space effectively.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) Explain each of the following terms as used in operating system:&lt;/p&gt;
&lt;p&gt;(i) shell;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Shell&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In operating systems, a &lt;strong&gt;shell&lt;/strong&gt; is a &lt;strong&gt;command-line interpreter&lt;/strong&gt;. It acts as an &lt;strong&gt;interface between the user and the operating system kernel&lt;/strong&gt;. The shell takes user commands as input, interprets them, and executes them by making system calls to the kernel. It provides a command-line user interface (CLI) for users to interact with the OS, launch programs, manage files, and control system operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Thread&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;thread&lt;/strong&gt; is a &lt;strong&gt;lightweight unit of execution within a process&lt;/strong&gt;. It is a single sequential flow of control within a program. Multiple threads can coexist within a process and share the same process resources, such as memory space and files. Threads enable concurrency within a process, allowing for parallel execution of different parts of a program and improving performance and responsiveness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) AXB Company Ltd. intends to install an operating system with a friendly user interface.&lt;/p&gt;
&lt;p&gt;(i) Identify the most appropriate type of operating system for the company justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Graphical User Interface (GUI) Based Operating System&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The most appropriate type of operating system for AXB Company Ltd., focusing on a friendly user interface, is a &lt;strong&gt;Graphical User Interface (GUI) based operating system&lt;/strong&gt;. GUI-based OSs like Windows, macOS, or Linux distributions with GUI environments (GNOME, KDE) are designed to be user-friendly and intuitive, providing visual interfaces with icons, menus, and windows. GUIs make computers accessible and easier to use for a broad range of users, especially those who are not technically expert.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four drawbacks that the company could realize while using the operating system identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Higher Resource Consumption&lt;/strong&gt;: &lt;strong&gt;GUI-based operating systems&lt;/strong&gt; typically consume &lt;strong&gt;more system resources&lt;/strong&gt; (CPU, memory, disk space) compared to command-line or text-based OSs. GUIs require resources to render graphical elements, manage windows, and handle user interactions. This higher resource consumption can lead to reduced performance, especially on systems with limited hardware resources.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Complexity and Overhead&lt;/strong&gt;: GUI-based OSs are &lt;strong&gt;more complex and have higher overhead&lt;/strong&gt;. The GUI layer adds complexity to the OS kernel and system architecture. Managing graphical interfaces, windowing systems, and event handling introduces additional overhead, which can impact system performance and responsiveness, especially for low-end hardware.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Security Vulnerabilities due to Complexity&lt;/strong&gt;: The &lt;strong&gt;increased complexity of GUI-based OSs can introduce more security vulnerabilities&lt;/strong&gt;. A larger codebase and more complex system architecture can increase the potential for bugs and security flaws. GUI components, windowing systems, and graphics drivers can be targets for security exploits, potentially increasing the system's attack surface.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Less Efficient for Server Environments and Automation&lt;/strong&gt;: GUI-based OSs are generally &lt;strong&gt;less efficient for server environments and automation tasks&lt;/strong&gt;. Server environments often benefit more from lightweight, command-line oriented OSs that minimize resource overhead and are optimized for server functionalities. Automation and scripting tasks are typically more efficiently performed using command-line interfaces rather than graphical interfaces, which are designed for interactive user sessions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Explain the term dispatcher as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Dispatcher&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;dispatcher&lt;/strong&gt; is the &lt;strong&gt;module of the operating system's scheduler&lt;/strong&gt; that &lt;strong&gt;gives control of the CPU to the process selected by the short-term scheduler&lt;/strong&gt;. It is responsible for the actual context switch, which involves saving the state of the previously running process and loading the saved state of the process to be executed. The dispatcher is invoked every time a process needs to be switched in or out of the CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between block-oriented and stream-oriented I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Block-Oriented Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block-oriented devices&lt;/strong&gt; transfer data in &lt;strong&gt;fixed-size blocks or chunks&lt;/strong&gt;. Data is accessed and transferred in blocks, and each block has a unique address. These devices typically support random access, allowing access to any block directly without needing to read through preceding data. Examples include &lt;strong&gt;disk drives (HDDs, SSDs)&lt;/strong&gt; and tapes (in block mode). Block-oriented devices are suitable for storage and retrieval of structured data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream-Oriented Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream-oriented devices&lt;/strong&gt; transfer data as a &lt;strong&gt;continuous stream of bytes or characters&lt;/strong&gt;, without fixed block sizes. Data is accessed sequentially in a stream, and random access is generally not supported or efficient. Examples include &lt;strong&gt;keyboards&lt;/strong&gt;, &lt;strong&gt;mice&lt;/strong&gt;, &lt;strong&gt;printers&lt;/strong&gt;, and &lt;strong&gt;network interfaces&lt;/strong&gt;. Stream-oriented devices are used for character-based or byte-based data flow, typically for communication or sequential data processing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Block-oriented devices handle data in fixed blocks and support random access, while stream-oriented devices handle continuous streams of data and are primarily sequential access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) A lecturer described goals of I/O module during an operating system class. Outline four goals he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficiency&lt;/strong&gt;: A primary goal of an I/O module is to achieve &lt;strong&gt;efficiency in I/O operations&lt;/strong&gt;. The module should aim to &lt;strong&gt;maximize I/O throughput and minimize I/O latency&lt;/strong&gt;, ensuring that data transfer between the system and external devices is performed quickly and with minimal overhead. Efficient I/O operations are crucial for overall system performance and responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Device Independence&lt;/strong&gt;: &lt;strong&gt;Device independence&lt;/strong&gt; is a key goal. The I/O module should provide a &lt;strong&gt;uniform interface to higher-level software layers&lt;/strong&gt; (OS and applications), abstracting away the device-specific details of different I/O devices. This allows applications to work with I/O devices in a generic manner, without needing to be rewritten or modified for each specific device type. Device drivers handle device-specific operations, providing abstraction.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Error Handling&lt;/strong&gt;: &lt;strong&gt;Robust error handling&lt;/strong&gt; is an essential goal. The I/O module should be able to &lt;strong&gt;detect and handle errors that occur during I/O operations&lt;/strong&gt;, such as device failures, data corruption, or transmission errors. Error handling mechanisms should include error detection, error recovery, and error reporting to ensure data integrity and system reliability in the presence of I/O faults.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Uniform Interface&lt;/strong&gt;: Providing a &lt;strong&gt;uniform interface&lt;/strong&gt; is a goal for simplifying I/O programming. The I/O module should offer a &lt;strong&gt;consistent and standardized set of system calls and APIs&lt;/strong&gt; for applications to perform I/O operations. This uniform interface hides the complexities of device-specific control and allows programmers to interact with I/O devices in a simple, predictable, and device-independent way, improving programmer productivity and code portability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) (1) Outline two memory placement algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;First-Fit&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Best-Fit&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between short term and long term process scheduling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Short-Term Scheduling (CPU Scheduling)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Short-term scheduling&lt;/strong&gt;, also known as CPU scheduling, is the process of &lt;strong&gt;selecting one of the ready processes in memory to be executed by the CPU&lt;/strong&gt;. It is invoked very frequently (milliseconds) whenever an event occurs that may lead to process switching, such as timer interrupts, I/O completion, or system calls. The main objective of short-term scheduling is to &lt;strong&gt;maximize CPU utilization and system throughput while minimizing response time and turnaround time&lt;/strong&gt;. Short-term schedulers make fine-grained decisions about CPU allocation on a short time scale.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Long-Term Scheduling (Job Scheduling)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Long-term scheduling&lt;/strong&gt;, also known as job scheduling, is the process of &lt;strong&gt;selecting processes from a job pool and loading them into memory for execution&lt;/strong&gt;. It controls the &lt;strong&gt;degree of multiprogramming&lt;/strong&gt; – the number of processes in memory. Long-term scheduling is invoked less frequently compared to short-term scheduling, typically when a process finishes or when system load changes significantly. Its primary objective is to &lt;strong&gt;control the number of processes in memory and balance the mix of processes&lt;/strong&gt; (e.g., CPU-bound vs. I/O-bound) to optimize resource utilization and system performance over longer time scales.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Short-term scheduling is for CPU allocation and is frequent, focusing on responsiveness and throughput. Long-term scheduling is for controlling the degree of multiprogramming and is less frequent, focusing on balancing process mix and resource utilization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Define the term spatial locality as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Spatial Locality&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spatial locality&lt;/strong&gt; is a principle of locality of reference in memory management that refers to the tendency of a processor to &lt;strong&gt;access memory locations that are physically close to each other in memory&lt;/strong&gt;. If a program accesses a particular memory location, it is likely to access nearby memory locations in the near future. Spatial locality is often exploited by cache memory and block-based data transfer mechanisms to improve memory access performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Describe two limitations of dynamic memory partitioning schemes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: &lt;strong&gt;External fragmentation&lt;/strong&gt; is a primary limitation of dynamic memory partitioning. As memory is allocated and deallocated over time in variable-sized chunks, free memory becomes fragmented into &lt;strong&gt;small, non-contiguous blocks&lt;/strong&gt;. Even if the total amount of free memory is sufficient to satisfy a memory request, it may not be possible to allocate a contiguous block of the required size due to fragmentation. External fragmentation leads to wasted memory space and reduced efficiency in memory utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Complexity of Memory Management&lt;/strong&gt;: &lt;strong&gt;Dynamic memory partitioning schemes are more complex to manage&lt;/strong&gt; compared to fixed partitioning. They require more sophisticated algorithms for allocation, deallocation, and tracking free memory blocks. Managing variable-sized partitions, searching for suitable free blocks, and handling fragmentation add overhead to the memory management system, increasing the complexity of OS implementation and potentially impacting performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Figure 1 shows a directory structure in a typical operating system.&lt;/p&gt;
&lt;p&gt;Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-50-56_2015j.pdf.png&quot; alt=&quot;&quot; width=&quot;919&quot; height=&quot;367&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(i) Identify the directory structure depicted in the diagram justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Hierarchical (Tree-Structured) Directory Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The directory structure depicted in Figure 1 is a &lt;strong&gt;Hierarchical or Tree-Structured Directory Structure&lt;/strong&gt;. This is justified by the presence of a &lt;strong&gt;master file directory&lt;/strong&gt; (root-like directory) branching out into &lt;strong&gt;user directories&lt;/strong&gt; (user 1, user 2, user 3, user 4), and further branching into &lt;strong&gt;user file directories&lt;/strong&gt; (cat, bo, test, data, etc.) forming a tree-like hierarchy. This structure allows for nested directories, providing a clear and organized way to manage files and directories in a hierarchical manner, typical of modern file systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline two advantages of the directory structure identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Improved Organization and Navigation&lt;/strong&gt;: A hierarchical directory structure provides &lt;strong&gt;improved organization of files and directories&lt;/strong&gt;. It allows users to group related files and directories logically under parent directories, creating a well-structured and easy-to-navigate file system. This hierarchical organization simplifies file management and makes it easier for users to locate and access files.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Scalability and Manageability&lt;/strong&gt;: Hierarchical directory structures are &lt;strong&gt;scalable and manage large numbers of files efficiently&lt;/strong&gt;. The tree-like structure allows for creating subdirectories within directories, enabling the file system to handle a large volume of files and directories without becoming disorganized or unwieldy. Scalability and manageability are crucial for large-scale file systems and multi-user environments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (iii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) Outline four typical directory operations that could be carried out in the directory structure identified in (c) (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create Directory&lt;/strong&gt;: &lt;strong&gt;Creating a directory&lt;/strong&gt; is a fundamental operation. Users can create new directories within existing directories to organize files and create a hierarchical structure. This operation allows users to structure their files and directories logically, improving organization and manageability.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Delete Directory&lt;/strong&gt;: &lt;strong&gt;Deleting a directory&lt;/strong&gt; is used to remove a directory and its contents (files and subdirectories). This operation allows users to clean up and remove directories that are no longer needed. Deletion operations typically require appropriate permissions and may involve checks to ensure the directory is empty or to recursively delete contents.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;List Directory Contents&lt;/strong&gt;: &lt;strong&gt;Listing directory contents&lt;/strong&gt; is a common operation to view the files and subdirectories within a directory. This operation allows users to see what files and directories are present in a given location, aiding in navigation and file management. The listing typically displays file and directory names, attributes, and sizes.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Rename Directory&lt;/strong&gt;: &lt;strong&gt;Renaming a directory&lt;/strong&gt; allows users to change the name of a directory. This operation is used to reorganize or update directory names for better clarity or consistency. Renaming a directory typically preserves its contents and structure but changes its identifier within the file system hierarchy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) Figure 2 shows a NTFS volume layout diagram.&lt;/p&gt;
&lt;p&gt;Outline the function of the parts labeled (i) and (ii).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-52-38_2015j.pdf.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;318&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on a typical NTFS volume layout, assuming (i) points to the Master File Table and (ii) points to the File Area:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Master File Table (MFT)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Part labeled &lt;strong&gt;(i)&lt;/strong&gt; represents the &lt;strong&gt;Master File Table (MFT)&lt;/strong&gt;. The MFT is a &lt;strong&gt;core component of the NTFS file system&lt;/strong&gt;. It is a &lt;strong&gt;database that contains metadata about every file and directory on the NTFS volume&lt;/strong&gt;. For each file and directory, the MFT stores information such as file name, size, timestamps, permissions, data block locations, and attributes. The MFT is crucial for organizing and managing the entire file system structure and for locating and accessing files and directories. It acts as the central index and metadata repository for the NTFS volume.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) File Area&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Part labeled &lt;strong&gt;(ii)&lt;/strong&gt; represents the &lt;strong&gt;File Area&lt;/strong&gt;. The File Area is the &lt;strong&gt;region on the NTFS volume where the actual data content of files and directories is stored&lt;/strong&gt;. It is the &lt;strong&gt;largest part of the volume&lt;/strong&gt; and occupies the majority of the disk space. When files are created and data is written, the actual file data is stored in clusters within the File Area. The MFT contains pointers (metadata) that map filenames and directories to the locations of their data within the File Area. The File Area is where the user and application data resides.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Relationship:&lt;/strong&gt; The MFT (i) stores metadata and indexing information, while the File Area (ii) stores the actual file data. The MFT provides the structure and pointers to locate and manage files within the File Area.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Most CPUs have interrupt requests for operating system's operations. Explain two types of such interrupt requests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hardware Interrupts&lt;/strong&gt;: &lt;strong&gt;Hardware interrupts&lt;/strong&gt; are &lt;strong&gt;generated by hardware devices or peripherals to signal the CPU about an event that requires immediate attention&lt;/strong&gt;. These interrupts are asynchronous events triggered by hardware components outside the CPU. Examples include interrupts from I/O devices (disk, network, keyboard), timers, and hardware failures. Hardware interrupts are used for timely handling of external events and device interactions.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Software Interrupts (Traps)&lt;/strong&gt;: &lt;strong&gt;Software interrupts&lt;/strong&gt;, also known as traps or system calls, are &lt;strong&gt;generated by software, typically by a running program, to request services from the operating system kernel&lt;/strong&gt;. Software interrupts are synchronous events triggered by specific instructions within a program. They are used to invoke kernel-level functionalities, such as I/O operations, process creation, memory allocation, or inter-process communication. System calls are the primary way user-level programs request OS services.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) With the aid of a diagram, describe contiguous file allocation method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Contiguous File Allocation Method Description with Diagram&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;contiguous file allocation&lt;/strong&gt;, each file occupies a set of &lt;strong&gt;contiguous blocks&lt;/strong&gt; on the disk. This means that all disk blocks allocated to a file are physically adjacent to each other on the disk. The file system needs to know only the starting block address and the length (number of blocks) of the file to access it. Contiguous allocation is simple to implement and provides good performance for sequential file access.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Contiguous File Allocation:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;Disk Blocks:
[ Block 1 | Block 2 | Block 3 | Block 4 | Block 5 | Block 6 | Block 7 | Block 8 | Block 9 | Block 10 | ... ]
+---------+---------+---------+---------+---------+---------+---------+---------+---------+----------+-----+
| File A  | File A  | File A  | File B  | File B  | File B  | File B  | File C  | File C  |   Free   | ... |
+---------+---------+---------+---------+---------+---------+---------+---------+---------+----------+-----+
  File A: Starts at Block 1, Length 3 Blocks (Blocks 1-3)
  File B: Starts at Block 4, Length 4 Blocks (Blocks 4-7)
  File C: Starts at Block 8, Length 2 Blocks (Blocks 8-9)
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Contiguous Blocks&lt;/strong&gt;: Each file is allocated a &lt;strong&gt;contiguous set of disk blocks&lt;/strong&gt;. For example, File A occupies blocks 1, 2, and 3, which are adjacent to each other.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Directory Entry Information&lt;/strong&gt;: The directory entry for each file stores the &lt;strong&gt;starting block address and the length (number of blocks)&lt;/strong&gt; allocated to the file. For File A, the directory entry would store 'Start Block: 1, Length: 3'.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Sequential Access Efficiency&lt;/strong&gt;: Contiguous allocation is very &lt;strong&gt;efficient for sequential file access&lt;/strong&gt;. Reading a file sequentially is fast because the disk head only needs to move from the starting block to the end block of the contiguous range. There is minimal seek time or fragmentation overhead for sequential reads.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Direct Access Support&lt;/strong&gt;: Direct (random) access is also relatively straightforward. To access block 'n' of a file, the system can calculate the physical block address by adding 'n-1' to the starting block address. However, direct access is still less efficient than sequential access as it may involve disk head movement to a specific block within the contiguous range.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Juliet intends to procure an I/O device for her computer. Other than cost, outline four factors that she should consider when selecting the device.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Performance (Speed and Throughput)&lt;/strong&gt;: &lt;strong&gt;Performance&lt;/strong&gt; is a crucial factor. Juliet should consider the &lt;strong&gt;speed and throughput&lt;/strong&gt; of the I/O device. For storage devices, this is measured in data transfer rates (MB/s or GB/s) and access times. For network devices, it's bandwidth. Higher performance devices improve system responsiveness and reduce bottlenecks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Compatibility&lt;/strong&gt;: &lt;strong&gt;Compatibility&lt;/strong&gt; with her computer system is essential. Juliet needs to ensure that the I/O device is &lt;strong&gt;compatible with her computer's interfaces&lt;/strong&gt; (e.g., USB, PCIe, SATA), operating system, and drivers. Check for interface compatibility, OS support, and driver availability to avoid integration issues.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Reliability and Durability&lt;/strong&gt;: &lt;strong&gt;Reliability and durability&lt;/strong&gt; are important for long-term use. Consider the device's &lt;strong&gt;build quality, Mean Time Between Failures (MTBF), and warranty&lt;/strong&gt;. Reliable devices reduce the risk of device failures, data loss, and system downtime.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Form Factor and Interface Type&lt;/strong&gt;: Consider the &lt;strong&gt;form factor and interface type&lt;/strong&gt; of the device. Ensure that the device &lt;strong&gt;physically fits into her computer&lt;/strong&gt; (e.g., expansion slot, drive bay) and that the &lt;strong&gt;interface (e.g., USB, SATA, PCIe) is compatible&lt;/strong&gt; with her system's ports and slots. Form factor and interface compatibility are essential for physical installation and connectivity.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Solomon, a programmer with a certain company was required to explain the roles of clock software to a client. Outline four functions that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Timekeeping and System Clock Management&lt;/strong&gt;: Clock software is responsible for &lt;strong&gt;maintaining the system's time and date&lt;/strong&gt;. It updates the system clock based on hardware clock ticks and provides functions to set and retrieve the current date and time. Accurate timekeeping is crucial for many system operations and applications.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Scheduling and Time Slicing&lt;/strong&gt;: Clock software, through timer interrupts, is used to &lt;strong&gt;drive process scheduling and time-slicing mechanisms&lt;/strong&gt;. Timer interrupts at regular intervals allow the OS scheduler to preempt running processes and allocate CPU time to other processes, enabling fair CPU sharing and multitasking.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Timer Services for Applications&lt;/strong&gt;: Clock software provides &lt;strong&gt;timer services to applications&lt;/strong&gt;. Applications can use timer APIs to set timers for specific events, schedule tasks at certain times, or implement delays and timeouts. Timer services enable applications to perform time-dependent operations and manage time-based events.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Performance Monitoring and Profiling&lt;/strong&gt;: Clock software is used for &lt;strong&gt;performance monitoring and profiling&lt;/strong&gt;. High-resolution timers provided by clock software allow the OS and performance analysis tools to measure execution times of code segments, system calls, or processes. This timing information is essential for performance tuning, debugging, and identifying performance bottlenecks.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) (i) Explain the term linking as applied in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Linking in Memory Management&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linking&lt;/strong&gt; in memory management is the process of &lt;strong&gt;combining different pieces of code and data together to form a single executable program&lt;/strong&gt; that can be loaded into memory and run. It typically involves resolving symbolic references between different modules or object files, assigning memory addresses to code and data segments, and creating an executable file that the OS loader can load and execute. Linking is a crucial step in software compilation and execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between logical address and physical address as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Logical Address (Virtual Address)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Logical address&lt;/strong&gt;, also known as a virtual address, is the &lt;strong&gt;address generated by the CPU&lt;/strong&gt; during program execution. It is the address as seen by the process or program. Logical addresses are part of the process's virtual address space and are independent of the physical layout of memory. Programs use logical addresses to access memory locations, and these addresses are then translated to physical addresses by the MMU.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical Address&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical address&lt;/strong&gt; is the &lt;strong&gt;actual address in physical RAM (main memory)&lt;/strong&gt;. It is the address that is used by the memory controller to access specific locations in physical memory chips. Physical addresses represent the real locations in RAM where data is stored. Logical addresses are mapped to physical addresses by the Memory Management Unit (MMU) using page tables or segment tables to enable virtual memory management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Logical addresses are program-view addresses that are virtual and translated, while physical addresses are hardware addresses in RAM and are real locations in memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Table 1 shows details of FCFS scheduling algorithm. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Table 1&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process&lt;/th&gt;
&lt;th&gt;Arrival time&lt;/th&gt;
&lt;th&gt;Execution time&lt;/th&gt;
&lt;th&gt;Service time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P0&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;0&lt;/td&gt;
&lt;td data-label=&quot;Execution time&quot;&gt;5&lt;/td&gt;
&lt;td data-label=&quot;Service time&quot;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P1&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;1&lt;/td&gt;
&lt;td data-label=&quot;Execution time&quot;&gt;3&lt;/td&gt;
&lt;td data-label=&quot;Service time&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P2&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;2&lt;/td&gt;
&lt;td data-label=&quot;Execution time&quot;&gt;8&lt;/td&gt;
&lt;td data-label=&quot;Service time&quot;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process&quot;&gt;P3&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;3&lt;/td&gt;
&lt;td data-label=&quot;Execution time&quot;&gt;6&lt;/td&gt;
&lt;td data-label=&quot;Service time&quot;&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;(1) Calculate the wait time for each process labeled P0, P1, P2 and P3.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Wait Time Calculation for Each Process (FCFS):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion Time Calculation (FCFS - First Come First Served):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P0 completes at: Arrival Time + Service Time + Execution Time = 0 + 0 + 5 = 5&lt;/p&gt;
&lt;p&gt;P1 completes at: Completion Time of P0 + Execution Time of P1 = 5 + 3 = 8&lt;/p&gt;
&lt;p&gt;P2 completes at: Completion Time of P1 + Execution Time of P2 = 8 + 8 = 16&lt;/p&gt;
&lt;p&gt;P3 completes at: Completion Time of P2 + Execution Time of P3 = 16 + 6 = 22&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wait Time Calculation: Wait Time = Turnaround Time - Execution Time&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Turnaround Time = Completion Time - Arrival Time&lt;/p&gt;
&lt;p&gt;Wait Time = (Completion Time - Arrival Time) - Execution Time = Completion Time - (Arrival Time + Execution Time)&lt;/p&gt;
&lt;p&gt;Wait Time for P0: 5 - (0 + 5) = 0&lt;/p&gt;
&lt;p&gt;Wait Time for P1: 8 - (1 + 3) = 4&lt;/p&gt;
&lt;p&gt;Wait Time for P2: 16 - (2 + 8) = 6&lt;/p&gt;
&lt;p&gt;Wait Time for P3: 22 - (3 + 6) = 13&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wait Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;P0: 0 ms&lt;/p&gt;
&lt;p&gt;P1: 4 ms&lt;/p&gt;
&lt;p&gt;P2: 6 ms&lt;/p&gt;
&lt;p&gt;P3: 13 ms&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Calculate the average wait time for all the processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Average Wait Time Calculation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Average Wait Time = (Wait Time P0 + Wait Time P1 + Wait Time P2 + Wait Time P3) / Number of Processes&lt;/p&gt;
&lt;p&gt;Average Wait Time = (0 + 4 + 6 + 13) / 4 = 23 / 4 = 5.75 ms&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Wait Time for all processes is 5.75 ms.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) Outline two advantages of FCFS scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simplicity&lt;/strong&gt;: &lt;strong&gt;FCFS is simple to understand and implement&lt;/strong&gt;. The algorithm is straightforward and easy to program, requiring minimal overhead for scheduling decisions.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Fairness&lt;/strong&gt;: FCFS is inherently &lt;strong&gt;fair&lt;/strong&gt; as it processes jobs in the order of their arrival. Every process gets a chance to run, and there is no starvation. Processes are served based on their arrival sequence, ensuring equal opportunity for CPU access based on arrival order.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Risper was required to identify two types of memory fragmentations in operating systems. Explain two types that she was likely to have identified.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: &lt;strong&gt;External fragmentation&lt;/strong&gt; occurs when &lt;strong&gt;total free memory space is sufficient to satisfy a memory request, but it is not contiguous&lt;/strong&gt;. Free memory is scattered in small, non-adjacent blocks, making it unusable for allocating larger contiguous blocks, even when total free memory is adequate. This type of fragmentation is common in dynamic partitioning schemes.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;: &lt;strong&gt;Internal fragmentation&lt;/strong&gt; occurs when memory is allocated in fixed-size partitions or pages. If a process is allocated a partition or page that is larger than its actual memory requirement, the &lt;strong&gt;unused space within the allocated block is wasted&lt;/strong&gt;. This wasted space inside the allocated block is internal fragmentation. It's common in fixed partitioning and paging systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Javesh Company Ltd. would like to implement a client-server operating system. Outline four benefits the company will derive from this decision.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Centralized Resource Management&lt;/strong&gt;: A client-server OS allows for &lt;strong&gt;centralized management of resources&lt;/strong&gt;. Servers can manage shared resources like files, printers, databases, and applications, making them accessible to multiple clients. Centralized management simplifies administration, reduces redundancy, and improves resource utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Security&lt;/strong&gt;: Client-server architecture offers &lt;strong&gt;enhanced security&lt;/strong&gt; through centralized security management. Security policies, authentication, and access controls can be implemented and enforced centrally on servers, providing better protection for sensitive data and resources compared to decentralized systems.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Improved Scalability&lt;/strong&gt;: Client-server systems are &lt;strong&gt;scalable&lt;/strong&gt;. As the company grows, it's easier to scale server resources (e.g., upgrade servers, add more servers) to meet increasing demands. Client machines can be added without requiring significant changes to the overall system architecture, providing scalability for growing user bases and workloads.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Facilitated Data Sharing and Collaboration&lt;/strong&gt;: Client-server OSs &lt;strong&gt;facilitate data sharing and collaboration&lt;/strong&gt;. Servers act as central repositories for data and applications, enabling users to easily access and share information, collaborate on projects, and access common resources. Centralized data storage and sharing improve teamwork and data consistency across the organization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) Outline four reasons for implementing audit trail on a file system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Security Monitoring and Intrusion Detection&lt;/strong&gt;: Audit trails enable &lt;strong&gt;security monitoring and intrusion detection&lt;/strong&gt;. By logging file access attempts, modifications, permission changes, and other file system events, audit trails provide a record of activities that can be analyzed to detect suspicious or unauthorized actions. Security personnel can use audit logs to identify potential security breaches, intrusions, or policy violations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Compliance and Regulatory Requirements&lt;/strong&gt;: Many industries and regulations require organizations to maintain &lt;strong&gt;audit trails for compliance purposes&lt;/strong&gt;. Audit logs provide evidence of adherence to security policies, data protection regulations (e.g., GDPR, HIPAA), and industry standards. Compliance audits often rely on audit trails to verify that access controls and security measures are in place and effective.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Accountability and User Activity Tracking&lt;/strong&gt;: Audit trails enhance &lt;strong&gt;accountability and user activity tracking&lt;/strong&gt;. By logging user actions on files and directories, audit trails provide a record of who accessed, modified, or deleted specific files and when. This improves accountability by allowing administrators to trace actions back to specific users, investigate incidents, and enforce user responsibility for file system activities.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Troubleshooting and Forensic Analysis&lt;/strong&gt;: Audit trails are valuable for &lt;strong&gt;troubleshooting system issues and conducting forensic analysis&lt;/strong&gt;. In case of system errors, data corruption, or security incidents, audit logs provide a detailed history of file system events. This information can be used to diagnose problems, identify the causes of errors, and perform forensic investigations to understand the sequence of events leading to an incident or data loss.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between kernel and user spaces as applied in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Kernel Space&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kernel space&lt;/strong&gt; is the &lt;strong&gt;privileged memory area where the operating system kernel executes&lt;/strong&gt;. It has direct access to system hardware and all memory. Code running in kernel space can execute privileged instructions and manage system resources. Kernel space is protected from user-level processes to ensure system stability and security. The kernel, device drivers, and core OS services reside and run in kernel space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User Space&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User space&lt;/strong&gt; is the &lt;strong&gt;non-privileged memory area where user applications and processes execute&lt;/strong&gt;. Processes in user space have restricted access to system hardware and kernel memory. User-level code cannot directly execute privileged instructions or access protected memory regions. User space provides isolation and protection for user processes, preventing them from interfering with the OS or each other. Applications and user programs run in user space and interact with the kernel through system calls.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Kernel space is privileged and for OS kernel execution with full hardware access, while user space is non-privileged and for user application execution with restricted hardware access, providing system security and stability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Outline two examples of resources required in process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Figure 3 shows memory registers in an operating system.&lt;/p&gt;
&lt;p&gt;Outline the memory register labeled (i) and (ii).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-53-40_2015j.pdf.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;351&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on Figure 3, and assuming typical memory register usage in an OS context, where (i) is associated with a lower memory address and (ii) with a higher memory address relative to &quot;Process&quot; label:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Base Register&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Memory register labeled &lt;strong&gt;(i)&lt;/strong&gt; is likely representing a &lt;strong&gt;Base Register&lt;/strong&gt;. In memory management with segmentation or base-limit registers, the base register &lt;strong&gt;holds the starting physical address of a process's memory segment&lt;/strong&gt;. It defines the beginning address of the memory region allocated to the process. In Figure 3, if (i) is at a lower address (30004) relative to the &quot;Process&quot; block, it could indicate the base address for that process's memory segment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Limit Register&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Memory register labeled &lt;strong&gt;(ii)&lt;/strong&gt; is likely representing a &lt;strong&gt;Limit Register&lt;/strong&gt;. A limit register, used with a base register, &lt;strong&gt;specifies the size or limit of the memory segment&lt;/strong&gt; allocated to a process. It defines the range of valid addresses that a process can access, starting from the base address. In Figure 3, if (ii) is at a higher address (42094) relative to the &quot;Process&quot; block and the base register (i), it could indicate the upper bound or limit of the memory segment allocated to that process. The range between the base and limit registers defines the process's valid memory space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Context:&lt;/strong&gt; Together, base and limit registers are used for memory protection and segmentation, defining and enforcing the memory boundaries for each process.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Patricia was required to categorize computer I/O hardware. Describe three categories that she could have indicated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Human-Readable Devices&lt;/strong&gt;: &lt;strong&gt;Human-readable devices&lt;/strong&gt; are designed for &lt;strong&gt;interaction with human users&lt;/strong&gt;. They facilitate input from and output to humans. Examples include &lt;strong&gt;keyboards&lt;/strong&gt; and &lt;strong&gt;pointing devices (mice, touchscreens)&lt;/strong&gt; for input, and &lt;strong&gt;monitors&lt;/strong&gt;, &lt;strong&gt;printers&lt;/strong&gt;, and &lt;strong&gt;speakers&lt;/strong&gt; for output. These devices are characterized by their user-friendly interfaces and formats suitable for human perception and interaction.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Communication Devices&lt;/strong&gt;: &lt;strong&gt;Communication devices&lt;/strong&gt; are used for &lt;strong&gt;communication between computer systems or networks&lt;/strong&gt;. They enable data exchange over communication channels. Examples include &lt;strong&gt;network interface cards (NICs)&lt;/strong&gt;, &lt;strong&gt;modems&lt;/strong&gt;, and &lt;strong&gt;wireless adapters&lt;/strong&gt;. These devices facilitate networking, remote communication, and data transmission between computers, enabling distributed systems and network services.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Storage Devices&lt;/strong&gt;: &lt;strong&gt;Storage devices&lt;/strong&gt; are used for &lt;strong&gt;persistent data storage&lt;/strong&gt;. They provide non-volatile storage for data that needs to be retained even when the system is powered off. Examples include &lt;strong&gt;hard disk drives (HDDs)&lt;/strong&gt;, &lt;strong&gt;solid-state drives (SSDs)&lt;/strong&gt;, &lt;strong&gt;optical drives (CD/DVD/Blu-ray)&lt;/strong&gt;, and &lt;strong&gt;tape drives&lt;/strong&gt;. Storage devices are used to store files, applications, operating systems, and user data for long-term retention and retrieval.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;footer&gt;THIS IS THE LAST PRINTED PAGE.&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="265"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="11_133_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="56">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="53"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-50-56_2015j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-50-56_2015j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="4baf95cab366c2bfd55965199075fe55"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="54"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="266"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="11_133_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="57">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="53"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-52-38_2015j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-52-38_2015j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="94ebe928bdc6eb8bc1ae46eddffd770b"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="54"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="267"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="11_133_2.2"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="58">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="53"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-53-40_2015j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-53-40_2015j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="2230e269e41c7c9a4099f3c77b3d2401"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="54"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="54"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="3"></int>
              <string role="key" value="parentNode"></string>
              <reference key="55"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="11"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="55"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="56"></reference>
            <reference key="57"></reference>
            <reference key="58"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="11"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202015"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="61">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="Novemeber 2014"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="59">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="60">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="134_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="59"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2014&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(a) (i) Outline four resources required in a process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time&lt;/strong&gt;: The process requires &lt;strong&gt;CPU time&lt;/strong&gt; to execute its instructions and perform computations.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory&lt;/strong&gt;: &lt;strong&gt;Memory&lt;/strong&gt; is needed to store the process's code, data, and stack during execution.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;I/O Devices&lt;/strong&gt;: The process may require access to &lt;strong&gt;I/O devices&lt;/strong&gt; such as disks, network interfaces, or input devices for data transfer.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Files&lt;/strong&gt;: Access to &lt;strong&gt;files&lt;/strong&gt; may be necessary for reading input or writing output during process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between interrupt and system call as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Interrupt&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;interrupt&lt;/strong&gt; is a &lt;strong&gt;hardware-generated signal&lt;/strong&gt; that causes the CPU to &lt;strong&gt;suspend its current execution&lt;/strong&gt; and transfer control to an interrupt handler. Interrupts are &lt;strong&gt;asynchronous events&lt;/strong&gt; typically triggered by external devices or hardware components needing attention, such as I/O devices completing an operation or a timer expiring.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Call&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;system call&lt;/strong&gt; is a &lt;strong&gt;software-generated request&lt;/strong&gt; by a process to the operating system kernel to perform a &lt;strong&gt;privileged operation&lt;/strong&gt;. System calls are &lt;strong&gt;synchronous events&lt;/strong&gt; initiated by a process to request services from the kernel, such as file access, memory allocation, or process creation. They are the interface between user-level processes and the OS kernel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference&lt;/strong&gt;: Interrupts are hardware-initiated asynchronous signals for external events; system calls are software-initiated synchronous requests by processes for OS services.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Explain the term context switch as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Context Switch&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;context switch&lt;/strong&gt; is the &lt;strong&gt;process of saving the state of a currently running process and restoring the state of another process to allow the latter to run&lt;/strong&gt;. This operation enables multitasking by allowing the CPU to quickly switch between processes, giving the illusion of concurrent execution. It involves saving and restoring CPU registers, program counter, and memory management information.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) A lecturer described objectives of process scheduling to an operating systems' class. Explain two objectives that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Maximize CPU Utilization&lt;/strong&gt;: One key objective of process scheduling is to &lt;strong&gt;keep the CPU as busy as possible&lt;/strong&gt;. By efficiently managing and switching between processes, the scheduler aims to minimize CPU idle time and ensure that the CPU is always executing some process, thereby maximizing overall system throughput.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Minimize Turnaround Time&lt;/strong&gt;: Another important objective is to &lt;strong&gt;minimize the turnaround time for processes&lt;/strong&gt;. Turnaround time is the total time taken from the submission of a process to its completion. Reducing turnaround time improves system responsiveness and user satisfaction by ensuring that processes complete in a timely manner.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Bruce was required to identify the appropriate memory placement techniques for a proposed operating system. Explain three techniques that he could have considered.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;First-Fit&lt;/strong&gt;: &lt;strong&gt;First-Fit&lt;/strong&gt; is a memory placement algorithm where the allocator &lt;strong&gt;scans memory from the beginning and selects the first available partition large enough to satisfy the request&lt;/strong&gt;. It's simple and fast for allocation but can lead to fragmentation as it may not always choose the best available block.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Best-Fit&lt;/strong&gt;: &lt;strong&gt;Best-Fit&lt;/strong&gt; is a strategy where the allocator &lt;strong&gt;searches the entire memory and chooses the smallest available partition that is large enough to satisfy the request&lt;/strong&gt;. It aims to minimize wasted space and internal fragmentation, but the search for the best fit can be time-consuming.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Worst-Fit&lt;/strong&gt;: &lt;strong&gt;Worst-Fit&lt;/strong&gt; is a technique where the allocator &lt;strong&gt;selects the largest available partition to allocate memory&lt;/strong&gt;. The idea is to leave larger chunks of free memory available for future, potentially larger allocations. However, it can lead to smaller, less useful fragments over time, increasing external fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) (i) Outline two parts of a directory structure in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Directory Entry&lt;/strong&gt;: This part stores metadata about each file or subdirectory, including name, attributes, and location information.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Directory File (or Data Block)&lt;/strong&gt;: This part contains the actual list of directory entries, effectively mapping names to inodes or file descriptors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;I. access right;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Access Right&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Access rights&lt;/strong&gt; are &lt;strong&gt;permissions granted to users or groups to perform specific operations on files or directories&lt;/strong&gt;. They define what actions a user can perform, such as reading, writing, or executing a file. Access rights are a key component of file system security, controlling who can access and manipulate files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;II. flags.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;II. Flags&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In the context of file systems, &lt;strong&gt;flags&lt;/strong&gt; are &lt;strong&gt;indicators or markers associated with files or directories that represent specific attributes or states&lt;/strong&gt;. Flags can denote various properties, such as whether a file is hidden, read-only, system file, archived, or modified. Flags are used to manage file behavior and characteristics beyond basic access permissions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Figure I shows layers in computer memory hierarchy. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-58-44_2014nov.pdf.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;267&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Describe each of the layers labeled (i) and (ii).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on a typical memory hierarchy pyramid, assuming (i) is the top layer and (ii) is the bottom layer:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Cache&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Layer labeled &lt;strong&gt;(i)&lt;/strong&gt; represents &lt;strong&gt;Cache Memory&lt;/strong&gt;. Cache is the &lt;strong&gt;fastest and smallest memory level&lt;/strong&gt; in the hierarchy, located closest to the CPU. It is used to store &lt;strong&gt;frequently accessed data and instructions&lt;/strong&gt; to reduce average memory access time. Caches are typically implemented using SRAM and are significantly faster but more expensive than main memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Random Access Memory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Layer labeled &lt;strong&gt;(ii)&lt;/strong&gt; represents &lt;strong&gt;Random Access Memory (RAM)&lt;/strong&gt;, also known as main memory. RAM is the &lt;strong&gt;primary working memory&lt;/strong&gt; of the computer, located below cache in the hierarchy. It is &lt;strong&gt;slower and larger than cache&lt;/strong&gt; and is used to hold the programs and data that are currently being used by the CPU. RAM is volatile memory, meaning data is lost when power is turned off.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Petro was investigating advantages of memory segmentation in operating systems. Explain two advantages that he is likely to have identified.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simplified Memory Management for Programmers&lt;/strong&gt;: Memory segmentation &lt;strong&gt;simplifies memory management from a programmer's perspective&lt;/strong&gt;. Programmers can organize memory into logical segments (like code, data, stack) and deal with memory in terms of these segments, rather than a single linear address space. This modular view simplifies program structure and memory allocation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Protection and Sharing&lt;/strong&gt;: Segmentation provides &lt;strong&gt;memory protection and sharing at the segment level&lt;/strong&gt;. Each segment can have different access rights (read, write, execute), allowing the OS to protect segments from unauthorized access. Segments can also be shared between processes, enabling efficient data sharing and code reuse among different programs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Outline two types of files that could be found in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Files&lt;/strong&gt;: These files contain user-created or application-generated data, such as documents, images, videos, and databases.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Executable Files&lt;/strong&gt;: These files contain programs or applications that can be executed by the operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Brian intends to backup files. Explain two backup strategies he could use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Full Backup&lt;/strong&gt;: In a &lt;strong&gt;full backup&lt;/strong&gt;, all selected files and directories are &lt;strong&gt;copied to the backup medium every time a backup is performed&lt;/strong&gt;. This strategy provides a complete copy of the data and simplifies restoration, as all data is in one backup set. However, it is time-consuming and requires significant storage space as it duplicates all data in each backup.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Incremental Backup&lt;/strong&gt;: In an &lt;strong&gt;incremental backup&lt;/strong&gt;, only the &lt;strong&gt;data that has changed since the last backup (full or incremental) is copied&lt;/strong&gt;. This strategy saves backup time and storage space compared to full backups, as it only backs up changes. Restoration from incremental backups may require restoring the last full backup and then all subsequent incremental backups in sequence.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (a) Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) bootstrap;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Bootstrap&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bootstrap&lt;/strong&gt; refers to the &lt;strong&gt;initial process of starting or booting a computer system&lt;/strong&gt;. It is a sequence of operations that begins when the computer is powered on, loading and initializing the operating system kernel so that the computer can become operational. The bootstrap process typically involves loading a small initial program (bootstrap loader) from ROM or firmware, which then loads the OS kernel from storage into memory and starts its execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) firmware.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Firmware&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Firmware&lt;/strong&gt; is a type of &lt;strong&gt;software that is embedded in hardware devices&lt;/strong&gt;. It is typically stored in non-volatile memory such as ROM, EPROM, or flash memory. Firmware provides low-level control and instructions for the hardware device to function. It is often used for boot programs, device controllers, and embedded systems to provide basic operational instructions that are persistent and do not change frequently. Examples include BIOS in PCs and embedded software in devices like routers and printers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Figure 2 shows a typical process model used in operating systems. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_12-59-46_2014nov.pdf.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;310&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Identify the parts labeled (i), (ii), (iii), (iv) and (v).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on a typical process state diagram, the labels likely represent:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Ready State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Label &lt;strong&gt;(i)&lt;/strong&gt; represents the &lt;strong&gt;Ready State&lt;/strong&gt;. Processes in the ready state are &lt;strong&gt;waiting to be assigned to the CPU and are ready to run&lt;/strong&gt;. They are in memory and are waiting for their turn to be scheduled by the dispatcher.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Running State&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Label &lt;strong&gt;(ii)&lt;/strong&gt; represents the &lt;strong&gt;Running State&lt;/strong&gt;. A process in the running state is &lt;strong&gt;currently being executed by the CPU&lt;/strong&gt;. Instructions of the process are being actively processed by the processor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iii) Waiting/Blocked State (I/O Wait)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Label &lt;strong&gt;(iii)&lt;/strong&gt; represents the &lt;strong&gt;Waiting or Blocked State&lt;/strong&gt;, specifically due to &lt;strong&gt;I/O Wait&lt;/strong&gt;. Processes enter this state when they &lt;strong&gt;initiate an I/O operation and must wait for it to complete&lt;/strong&gt;. They are blocked and cannot proceed until the I/O operation finishes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iv) Dispatch&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Label &lt;strong&gt;(iv)&lt;/strong&gt; represents the &lt;strong&gt;Dispatch&lt;/strong&gt; transition. This is the action of the &lt;strong&gt;dispatcher component of the scheduler that moves a process from the ready state to the running state&lt;/strong&gt;, allocating the CPU to the selected process.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(v) Exit (Terminated State)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Label &lt;strong&gt;(v)&lt;/strong&gt; represents the &lt;strong&gt;Exit or Terminated State&lt;/strong&gt;. This is the &lt;strong&gt;final state of a process after it has completed its execution&lt;/strong&gt;. Once a process terminates, it releases its resources and is no longer active in the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Dorothy intends to design an operating system that uses swapping in memory management. Explain two constraints that are likely to be realized.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Performance Overhead of Swapping&lt;/strong&gt;: &lt;strong&gt;Swapping introduces significant performance overhead&lt;/strong&gt;. The process of swapping processes between RAM and disk is &lt;strong&gt;time-consuming&lt;/strong&gt;, especially when swap space is on a traditional HDD. Disk I/O operations are much slower than RAM access, leading to increased latency and reduced system performance. Frequent swapping, known as thrashing, can severely degrade system responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Limited Scalability with Memory Size&lt;/strong&gt;: Swapping effectiveness is &lt;strong&gt;limited by the size and speed of secondary storage&lt;/strong&gt; used for swap space. While swapping allows running programs larger than RAM, performance degrades significantly as the system relies more heavily on swapping. If the swap space is too small or slow, the system may still experience memory limitations and performance bottlenecks, especially with increasing application memory demands.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Outline three goals of I/O module.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficiency&lt;/strong&gt;: The I/O module aims to perform I/O operations &lt;strong&gt;efficiently&lt;/strong&gt;, maximizing throughput and minimizing latency to ensure fast data transfer and responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Device Independence&lt;/strong&gt;: To provide &lt;strong&gt;device independence&lt;/strong&gt;, the I/O module abstracts device-specific details, offering a uniform interface to higher layers, so applications can work with diverse devices without device-specific code.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Uniform Interface&lt;/strong&gt;: The I/O module should present a &lt;strong&gt;uniform and consistent interface&lt;/strong&gt; to the rest of the OS and applications, simplifying I/O operations and making them easier to use and manage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) A group of module II students were carrying out an assignment on I/O protection strategies in operating systems. Explain two strategies that they could identify.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Control Lists (ACLs) for I/O Devices&lt;/strong&gt;: &lt;strong&gt;Access Control Lists (ACLs)&lt;/strong&gt; can be used to control which processes or users can access specific I/O devices. ACLs define permissions for operations like read, write, and control for each device, allowing fine-grained control over device access and enhancing security.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Privileged Instructions and Kernel-Level I/O&lt;/strong&gt;: &lt;strong&gt;Restricting direct I/O hardware access to the kernel and using privileged instructions for I/O operations&lt;/strong&gt; is a key strategy. Only the OS kernel, running in a privileged mode, is allowed to directly access I/O hardware. User-level processes must use system calls to request I/O operations, which are then validated and executed by the kernel, enforcing security and preventing unauthorized device access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) Distinguish between SCAN and C-SCAN disk scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;SCAN Algorithm (Elevator Algorithm)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SCAN&lt;/strong&gt;, also known as the Elevator algorithm, moves the disk head &lt;strong&gt;in one direction across the disk, servicing all requests in its path&lt;/strong&gt;. When the head reaches one end of the disk, it reverses direction and continues servicing requests in the opposite direction. SCAN behaves like an elevator, moving up and down, servicing requests along its path in both directions. It provides better performance than FCFS and SSTF, especially under heavy load, and offers relatively fair service.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C-SCAN Algorithm (Circular SCAN)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C-SCAN (Circular SCAN)&lt;/strong&gt; is a variation of SCAN that is designed to provide more uniform wait times. C-SCAN moves the disk head &lt;strong&gt;in one direction only, from one end of the disk to the other, servicing requests along the way&lt;/strong&gt;. When the head reaches the end of the disk, it &lt;strong&gt;quickly returns to the beginning of the disk without servicing any requests during the return trip&lt;/strong&gt;. C-SCAN provides more equitable service compared to SCAN by limiting head movement to one direction during service and then quickly returning to the start.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; SCAN services requests in both directions of head movement; C-SCAN services requests only in one direction and quickly returns to the start without servicing on the return trip, leading to more uniform wait times.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Hope intends to develop a file management module for an operating system. Explain two file access methods that she should consider.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential Access&lt;/strong&gt;: &lt;strong&gt;Sequential access&lt;/strong&gt; is a method where files are accessed in a &lt;strong&gt;linear order, from the beginning to the end&lt;/strong&gt;. Data is read and written sequentially, one record after another. It's efficient for applications that process files in a linear fashion, like batch processing or streaming data. Sequential access is simple to implement and efficient for ordered data processing.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Direct Access (Random Access)&lt;/strong&gt;: &lt;strong&gt;Direct access&lt;/strong&gt;, also known as random access, allows &lt;strong&gt;accessing any record in a file directly, without needing to read through preceding records&lt;/strong&gt;. Records are accessed based on their position or a key. Direct access is efficient for applications that require frequent random data access, such as databases or index-based file retrieval. It provides flexibility in accessing specific data records quickly.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) With the aid of a diagram in each case, describe each of the following file system:&lt;/p&gt;
&lt;p&gt;(i) single-level directory;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Single-Level Directory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;single-level directory structure&lt;/strong&gt; is the simplest file organization where &lt;strong&gt;all files are placed in a single directory&lt;/strong&gt;. There is no hierarchy or subdirectories. All files reside directly under the root directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Root Directory      |
+---------------------+
| File A              |
| File B              |
| File C              |
| ...                 |
| File N              |
+---------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; All files are located in one directory. Easy to implement but leads to naming conflicts and poor organization for large numbers of files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) two-level directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Two-Level Directory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;two-level directory structure&lt;/strong&gt; introduces a hierarchy with a &lt;strong&gt;root directory and user directories under it&lt;/strong&gt;. Each user has their own directory, and files are organized within user directories.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+---------------------+
| Root Directory      |
+---------------------+
| User Directory 1    | --&amp;gt; [File 1A, File 1B, ...]
| User Directory 2    | --&amp;gt; [File 2A, File 2B, ...]
| ...                 |
| User Directory N    | --&amp;gt; [File NA, File NB, ...]
+---------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Each user has a separate directory under the root. Resolves naming conflicts between users but limited in organizational depth.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) (i) Bev was carrying out a study on benefits of multiprocessor systems. Explain two benefits that she could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Throughput&lt;/strong&gt;: &lt;strong&gt;Multiprocessor systems&lt;/strong&gt; significantly &lt;strong&gt;increase throughput&lt;/strong&gt;. By having multiple CPUs, they can execute multiple processes or threads in parallel, completing more tasks in a given time frame. This leads to higher overall system efficiency and productivity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Reliability and Fault Tolerance&lt;/strong&gt;: Multiprocessor systems offer &lt;strong&gt;enhanced reliability and fault tolerance&lt;/strong&gt;. If one processor fails, the system can continue to operate, albeit at a reduced performance level, using the remaining processors. This redundancy makes the system more resilient to hardware failures and improves overall system availability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Angie was required to investigate factors that affect performance of a storage disk Outline four factors that she could have considered.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Seek Time&lt;/strong&gt;: &lt;strong&gt;Seek time&lt;/strong&gt; is the time it takes for the disk head to move to the correct track. Lower seek times result in faster data access, significantly impacting disk performance. Algorithms and disk mechanics influence seek time.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Rotational Latency&lt;/strong&gt;: &lt;strong&gt;Rotational latency&lt;/strong&gt; is the time it takes for the desired sector to rotate under the read/write head. Disks with higher RPM (rotations per minute) have lower rotational latency, improving data access speed.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data Transfer Rate&lt;/strong&gt;: &lt;strong&gt;Data transfer rate&lt;/strong&gt; is the speed at which data can be transferred between the disk and the system. Higher transfer rates mean faster read and write operations, directly affecting disk performance. Interface type (SATA, NVMe) and disk technology influence transfer rates.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Caching&lt;/strong&gt;: &lt;strong&gt;Disk caching&lt;/strong&gt; significantly affects performance. The presence and effectiveness of disk cache (buffer in RAM) can dramatically reduce access times for frequently accessed data. Cache hit ratio and cache size are important factors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) Explain each of the following tables as used in memory management:&lt;/p&gt;
&lt;p&gt;(i) hashed;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Hashed Page Table&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;hashed page table&lt;/strong&gt; is a page table structure used in virtual memory management to handle large address spaces efficiently. In a hashed page table, the &lt;strong&gt;virtual page number is hashed into a hash table&lt;/strong&gt;. Each entry in the hash table contains a linked list of elements that hash to the same location, and each element contains the virtual page number, the corresponding page frame number, and control bits. Hashed page tables are used to reduce the size of page tables, especially for large address spaces, by providing a more compact representation compared to traditional multi-level page tables.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) clustered page.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Clustered Page Table&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;clustered page table&lt;/strong&gt; is a variation of multi-level page tables where &lt;strong&gt;page table entries are grouped into clusters&lt;/strong&gt;. Instead of a single large page table, the page table is divided into smaller, fixed-size clusters or chunks. This approach is used to &lt;strong&gt;improve the locality of reference for page table entries and reduce the memory overhead of page tables&lt;/strong&gt;, especially in systems with very large address spaces. Clustering page table entries can improve cache performance for page table accesses and reduce the overall memory footprint of page tables.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Distinguish between long-term and short-term schedulers as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Long-Term Scheduler (Job Scheduler)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;long-term scheduler&lt;/strong&gt;, or job scheduler, controls the &lt;strong&gt;degree of multiprogramming&lt;/strong&gt; by selecting processes from a job pool and loading them into memory for execution. It is invoked &lt;strong&gt;less frequently&lt;/strong&gt; and makes decisions about which programs are admitted to the ready queue. The long-term scheduler focuses on balancing the mix of jobs in the system and controlling the number of active processes in memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Short-Term Scheduler (CPU Scheduler)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;short-term scheduler&lt;/strong&gt;, or CPU scheduler, selects from the ready queue and decides &lt;strong&gt;which process should be executed by the CPU next&lt;/strong&gt;. It is invoked &lt;strong&gt;very frequently&lt;/strong&gt;, typically every few milliseconds, and makes fine-grained decisions about CPU allocation. The short-term scheduler aims to maximize CPU utilization, minimize response times, and improve overall system performance by efficiently switching between ready processes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Long-term scheduler controls the degree of multiprogramming and job admission (less frequent); short-term scheduler controls CPU allocation to ready processes (very frequent).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Loise was required to run disk management utilities during computer maintenance. Explain three examples of utilities that she could use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Disk Defragmentation Utility&lt;/strong&gt;: A &lt;strong&gt;disk defragmentation utility&lt;/strong&gt; is used to &lt;strong&gt;reorganize files on a disk to reduce fragmentation&lt;/strong&gt;. Over time, files can become fragmented, meaning their parts are scattered across non-contiguous blocks on the disk. Defragmentation utilities rearrange file blocks to make them contiguous, improving disk access speed, especially for frequently accessed files, and enhancing overall system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Disk Check Utility (e.g., CHKDSK, fsck)&lt;/strong&gt;: A &lt;strong&gt;disk check utility&lt;/strong&gt; is used to &lt;strong&gt;scan the file system for errors and repair them&lt;/strong&gt;. It checks the file system metadata, file structures, and disk surface for inconsistencies, bad sectors, or other errors. Disk check utilities can detect and fix file system corruption, logical errors, and physical disk problems, ensuring data integrity and system stability.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Disk Cleanup Utility&lt;/strong&gt;: A &lt;strong&gt;disk cleanup utility&lt;/strong&gt; is used to &lt;strong&gt;free up disk space by removing unnecessary files&lt;/strong&gt;. It can identify and delete temporary files, internet cache files, old system files, and other unnecessary data that accumulates over time. Disk cleanup utilities help to reclaim storage space, improve disk performance, and reduce clutter, optimizing disk usage and system efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Figure 3 shows a memory allocation technique. Use it to answer questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-00-28_2014nov.pdf.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;281&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(i) Explain the memory management techniques depicted in the figure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Paging&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The memory management technique depicted in Figure 3 is &lt;strong&gt;Paging&lt;/strong&gt;. The diagram illustrates a &lt;strong&gt;non-contiguous memory allocation&lt;/strong&gt;, where a process's logical address space is divided into fixed-size blocks called &lt;strong&gt;pages&lt;/strong&gt; (P), and these pages are mapped to non-contiguous, fixed-size blocks of physical memory called &lt;strong&gt;frames&lt;/strong&gt; (d) in RAM. The use of pages and frames and the non-contiguous nature of allocation are key indicators of paging.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two advantages of the memory management technique identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Eliminates External Fragmentation&lt;/strong&gt;: &lt;strong&gt;Paging eliminates external fragmentation&lt;/strong&gt;. Since memory is allocated in fixed-size pages and frames, any free frame can be used to store any page of a process. There is no issue of fragmented free space between variable-sized blocks, as in segmentation or dynamic partitioning. This leads to more efficient use of physical memory.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficient Memory Utilization and Flexible Allocation&lt;/strong&gt;: Paging allows for more &lt;strong&gt;efficient memory utilization and flexible allocation&lt;/strong&gt;. Only the necessary pages of a process need to be loaded into memory, and pages can be placed in any available frame, which can be non-contiguous. This fine-grained allocation and efficient use of frames improves memory utilization and supports a higher degree of multiprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) Explain each of the following terms as used in disk operations:&lt;/p&gt;
&lt;p&gt;(i) seek time;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Seek Time&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek time&lt;/strong&gt; is the &lt;strong&gt;time taken for the disk arm and read/write head to move to the specific track (cylinder) on the disk platter&lt;/strong&gt; where the desired data is located. It is the time required to position the head over the correct track before data can be read or written. Seek time is a major factor contributing to disk access latency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) transfer rate;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Transfer Rate&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer rate&lt;/strong&gt;, also known as data transfer rate or bandwidth, is the &lt;strong&gt;speed at which data can be transferred between the disk and the computer system&lt;/strong&gt; (typically memory or CPU). It is usually measured in megabytes per second (MB/s) or gigabytes per second (GB/s). Transfer rate indicates how quickly data can be read from or written to the disk once the read/write head is positioned correctly and rotational latency is accounted for.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) rotational latency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Rotational Latency&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rotational latency&lt;/strong&gt;, also known as rotational delay, is the &lt;strong&gt;time it takes for the desired sector on the disk to rotate under the read/write head once the head is positioned over the correct track&lt;/strong&gt;. After the seek operation is complete, rotational latency is the time spent waiting for the disk to rotate to the correct sector position before data transfer can begin. Rotational latency is dependent on the disk's rotational speed (RPM).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Stano listed several examples of I/O buses that could be used in a disk drive. Outline four examples that he could have listed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;SATA (Serial ATA)&lt;/strong&gt;: &lt;strong&gt;SATA&lt;/strong&gt; is a common interface bus used for connecting storage devices like HDDs and SSDs to the motherboard. It provides high-speed serial data transfer and is widely used for internal disk drives in desktop and laptop computers.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;NVMe (Non-Volatile Memory Express)&lt;/strong&gt;: &lt;strong&gt;NVMe&lt;/strong&gt; is a high-performance interface bus designed specifically for SSDs. It utilizes the PCIe bus for significantly faster data transfer rates and lower latency compared to SATA, making it ideal for high-speed SSDs used in demanding applications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;SAS (Serial Attached SCSI)&lt;/strong&gt;: &lt;strong&gt;SAS&lt;/strong&gt; is a bus interface used primarily for enterprise-level storage devices, such as high-performance HDDs and tape drives. SAS offers high data transfer rates, reliability, and scalability, often used in servers and storage arrays.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;IDE/ATA (Integrated Drive Electronics/Advanced Technology Attachment)&lt;/strong&gt;: &lt;strong&gt;IDE/ATA&lt;/strong&gt;, also known as Parallel ATA (PATA), is an older bus interface for connecting storage devices. While largely replaced by SATA, IDE/ATA was widely used in older systems and is still relevant in understanding legacy systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) File attributes varies from one operating system to another. Outline five examples of these attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;File Name&lt;/strong&gt;: The &lt;strong&gt;name&lt;/strong&gt; of the file, used to identify and access the file within a directory.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File Size&lt;/strong&gt;: The &lt;strong&gt;size&lt;/strong&gt; of the file, indicating the amount of storage space it occupies, typically in bytes or kilobytes.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;File Type&lt;/strong&gt;: The &lt;strong&gt;type&lt;/strong&gt; of file, indicating the format and intended use of the file (e.g., text file, executable file, directory).&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Timestamps&lt;/strong&gt;: &lt;strong&gt;Timestamps&lt;/strong&gt; such as creation time, last modification time, and last access time, recording when the file was created, last modified, and last accessed.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Access Permissions/Attributes&lt;/strong&gt;: &lt;strong&gt;Access permissions&lt;/strong&gt; controlling who can access the file and what operations they can perform (read, write, execute); attributes like read-only, hidden, system file, archive.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a diagram, outline a typical process control block (PCB) diagram as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Process Control Block (PCB) Diagram&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Process Control Block (PCB)&lt;/strong&gt; is a data structure used by the OS to manage and track each process. It contains all the necessary information about a process.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of a Process Control Block (PCB):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;+-------------------------------------+
| Process Identification              |
| ----------------------------------- |
| Process ID (PID)                    |
| User ID (UID)                       |
+-------------------------------------+
| Process State                       |
| ----------------------------------- |
| Current State (Running, Ready, ...) |
+-------------------------------------+
| Program Counter (PC)                |
| ----------------------------------- |
| Address of next instruction         |
+-------------------------------------+
| CPU Registers                       |
| ----------------------------------- |
| General Purpose Registers          |
| Stack Pointer                       |
| ...                                 |
+-------------------------------------+
| Memory Management Info              |
| ----------------------------------- |
| Page Table Base Address             |
| Segment Table Base Address          |
| ...                                 |
+-------------------------------------+
| CPU Scheduling Info                 |
| ----------------------------------- |
| Priority                            |
| Scheduling Queue Pointers           |
| ...                                 |
+-------------------------------------+
| I/O and File Management             |
| ----------------------------------- |
| List of Open Files                  |
| Allocated I/O Devices             |
| ...                                 |
+-------------------------------------+
| Accounting Information              |
| ----------------------------------- |
| CPU Time Used                       |
| Execution Time                      |
| ...                                 |
+-------------------------------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; The PCB typically includes sections for:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process Identification&lt;/strong&gt;: Contains unique identifiers like Process ID (PID) and User ID (UID).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process State&lt;/strong&gt;: Indicates the current state of the process (e.g., Running, Ready, Blocked).&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: Stores the address of the next instruction to be executed.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;CPU Registers&lt;/strong&gt;: Saves the state of CPU registers to allow process resumption after interruption.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Memory Management Info&lt;/strong&gt;: Holds pointers to page tables or segment tables for memory management.&lt;/p&gt;
&lt;p data-number=&quot;6&quot;&gt;&lt;strong&gt;CPU Scheduling Info&lt;/strong&gt;: Includes scheduling priority and queue pointers for process scheduling.&lt;/p&gt;
&lt;p data-number=&quot;7&quot;&gt;&lt;strong&gt;I/O and File Management&lt;/strong&gt;: Lists open files and allocated I/O devices.&lt;/p&gt;
&lt;p data-number=&quot;8&quot;&gt;&lt;strong&gt;Accounting Information&lt;/strong&gt;: Tracks resource usage like CPU time and execution time.&lt;/p&gt;
&lt;p&gt;The PCB is essential for the OS to manage and control each process effectively.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) (i) Define the term livelock as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Livelock&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Livelock&lt;/strong&gt; is a concurrency control issue similar to deadlock, but in livelock, processes are &lt;strong&gt;not blocked; instead, they continuously change their state in response to each other, without making progress&lt;/strong&gt;. Processes in a livelock are actively engaged in resolving a conflict but are unable to make forward progress, effectively stuck in a loop of unproductive activity. Unlike deadlock, processes in livelock are not waiting for each other to release resources but are constantly reacting to each other's actions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Distinguish between overlaying and partitioning as used memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt; is a memory management technique where a process is &lt;strong&gt;divided into segments (overlays)&lt;/strong&gt;, and only the &lt;strong&gt;currently needed segments are loaded into memory&lt;/strong&gt;. Segments are loaded into a &lt;strong&gt;fixed memory area&lt;/strong&gt;, overwriting previously loaded segments as needed. Overlaying is a manual technique requiring programmers to divide programs into overlays and manage their loading and unloading. It was used in early systems with limited memory to run programs larger than physical memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Partitioning&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Partitioning&lt;/strong&gt; is a memory management technique that &lt;strong&gt;divides main memory into fixed or variable-sized partitions&lt;/strong&gt;. Each partition can hold one process. &lt;strong&gt;Fixed partitioning&lt;/strong&gt; divides memory into static partitions at system startup, while &lt;strong&gt;dynamic partitioning&lt;/strong&gt; allocates partitions of variable size based on process needs at runtime. Partitioning is used to enable multiprogramming by allocating separate memory regions to different processes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference:&lt;/strong&gt; Overlaying is a program-centric technique where program segments are swapped in and out of a fixed memory area, managed by programmers. Partitioning is an OS-centric technique that divides memory into partitions to hold different processes, enabling multiprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Mercy, an intern student was required to discuss examples of file operations during a job interview. Outline four examples that she could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create&lt;/strong&gt;: &lt;strong&gt;Create&lt;/strong&gt; is a file operation used to &lt;strong&gt;make a new file&lt;/strong&gt; in the file system. It allocates storage space and sets up metadata for the new file, preparing it for data storage.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Read&lt;/strong&gt;: &lt;strong&gt;Read&lt;/strong&gt; is an operation to &lt;strong&gt;retrieve data from a file&lt;/strong&gt;. It involves accessing the file's contents and transferring data from the storage device to memory for processing or display.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Write&lt;/strong&gt;: &lt;strong&gt;Write&lt;/strong&gt; is a file operation used to &lt;strong&gt;store data into a file&lt;/strong&gt;. It involves transferring data from memory to the file on the storage device, modifying or adding to the file's contents.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete&lt;/strong&gt;: &lt;strong&gt;Delete&lt;/strong&gt; is an operation to &lt;strong&gt;remove a file from the file system&lt;/strong&gt;. It deallocates storage space occupied by the file and removes the file's directory entry, making the file no longer accessible.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Sayd Company Ltd. intends to replace its single-processor operating system. Outline four limitations of the existing operating system that could have influenced the decision.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Limited Performance and Throughput&lt;/strong&gt;: A single-processor OS &lt;strong&gt;limits performance and throughput&lt;/strong&gt;, especially under heavy workloads or when running multiple applications concurrently. It can only execute one process at a time, leading to bottlenecks when handling multiple tasks or user requests. Performance may degrade significantly as workload increases.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Poor Responsiveness in Multitasking Environments&lt;/strong&gt;: In multitasking environments, a single-processor OS can exhibit &lt;strong&gt;poor responsiveness&lt;/strong&gt;. When running multiple applications, users may experience delays and sluggishness as the single CPU has to time-share its resources among all processes. Responsiveness for interactive tasks may suffer, especially if CPU-intensive processes are running.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Inefficient Resource Utilization&lt;/strong&gt;: Single-processor systems can lead to &lt;strong&gt;inefficient utilization of system resources&lt;/strong&gt;. While one process is using the CPU, other system components, such as memory or I/O devices, may be underutilized. The system cannot fully leverage parallelism or concurrency to maximize resource usage, limiting overall efficiency.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Lack of Scalability for Demanding Applications&lt;/strong&gt;: A single-processor OS is &lt;strong&gt;not scalable for demanding applications or growing workloads&lt;/strong&gt;. As the company's processing needs increase, a single-processor system cannot easily scale to handle the increased load. Upgrading to a multiprocessor system and OS becomes necessary to achieve better scalability and performance for demanding applications and future growth.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Claudius was required to list advantages of dynamic linking in memory management. Explain three advantages that he is likely to have listed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Memory Footprint&lt;/strong&gt;: &lt;strong&gt;Dynamic linking reduces the memory footprint of applications&lt;/strong&gt;. With dynamic linking, shared libraries are loaded into memory only once and are shared among multiple processes that use them. This avoids redundant copies of libraries in memory for each application, saving significant memory space, especially when many applications use the same libraries.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Disk Space Savings&lt;/strong&gt;: &lt;strong&gt;Dynamic linking saves disk space&lt;/strong&gt;. Shared libraries are stored only once on disk, and multiple executables link to the same shared library file. This reduces the overall disk space occupied by applications and libraries, as shared code is not duplicated across multiple executables. Disk space savings are particularly beneficial in systems with limited storage capacity or when distributing software.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Simplified Software Updates and Patches&lt;/strong&gt;: &lt;strong&gt;Dynamic linking simplifies software updates and patching&lt;/strong&gt;. When a shared library is updated or patched (e.g., for security fixes or bug fixes), the update only needs to be applied to the shared library file. All applications that dynamically link to this library automatically benefit from the update the next time they are executed, without needing to be re-linked or recompiled. This simplifies software maintenance and deployment of updates and patches.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) (i) Define the term programmable interval timer as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Programmable Interval Timer&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;programmable interval timer (PIT)&lt;/strong&gt; is a &lt;strong&gt;hardware timer component&lt;/strong&gt; in a computer system that can be &lt;strong&gt;programmed to generate interrupts at regular intervals&lt;/strong&gt;. The interval between interrupts is programmable, allowing the OS to configure the timer to generate interrupts at desired frequencies. PITs are used by the operating system for timekeeping, scheduling, and managing time-dependent operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four services that could be provided by I/O subsystem kernel.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Driver Management&lt;/strong&gt;: The I/O subsystem kernel manages &lt;strong&gt;device drivers&lt;/strong&gt;, loading, initializing, and unloading them as needed. It provides an interface for device drivers to interact with the kernel and handle device-specific operations, abstracting hardware details from the rest of the OS.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;I/O Scheduling and Queue Management&lt;/strong&gt;: The kernel's I/O subsystem performs &lt;strong&gt;I/O scheduling&lt;/strong&gt;, managing the order and priority of I/O requests to optimize disk performance and fairness. It maintains I/O queues for different devices and uses scheduling algorithms to determine which I/O request to service next, improving overall I/O throughput and response times.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Buffering and Caching&lt;/strong&gt;: The I/O subsystem implements &lt;strong&gt;buffering and caching mechanisms&lt;/strong&gt; to improve I/O performance. It manages buffers in memory to temporarily store data during I/O transfers, handling speed mismatches and data size adaptation. Disk caching is used to cache frequently accessed disk blocks in RAM to reduce disk access latency.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Error Handling and Device Management&lt;/strong&gt;: The I/O subsystem kernel is responsible for &lt;strong&gt;handling I/O errors and managing I/O devices&lt;/strong&gt;. It detects and handles device errors, implements error recovery procedures, and reports errors to the OS and applications. Device management includes device initialization, configuration, allocation, and deallocation of I/O resources to processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Explain four circumstances that would necessitate premature termination of a process execution in an operating system&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Error Conditions and Exceptions&lt;/strong&gt;: &lt;strong&gt;Fatal errors or exceptions&lt;/strong&gt; during process execution can necessitate premature termination. If a process encounters an error it cannot handle, such as a segmentation fault, illegal instruction, division by zero, or unrecoverable system error, the OS may terminate the process to prevent further damage or instability to the system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Resource Limits Exceeded&lt;/strong&gt;: If a process &lt;strong&gt;exceeds its allocated resource limits&lt;/strong&gt;, the OS may terminate it prematurely. Resource limits can include CPU time limits, memory limits, file size limits, or I/O limits. Exceeding these limits may indicate a runaway process, resource exhaustion, or policy enforcement, leading to termination to protect system resources and other processes.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;User Intervention or Termination Request&lt;/strong&gt;: A user or administrator may &lt;strong&gt;explicitly request to terminate a process&lt;/strong&gt;. Users can use commands like 'kill' or task managers to terminate processes that are unresponsive, malfunctioning, or no longer needed. User intervention allows for manual control over process execution and termination.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Deadlock or System Hang Situations&lt;/strong&gt;: In &lt;strong&gt;deadlock or system hang situations&lt;/strong&gt;, where processes are blocked indefinitely, the OS may need to &lt;strong&gt;terminate one or more processes to break the deadlock and recover system functionality&lt;/strong&gt;. Deadlock resolution strategies may involve process abortion as a means to release resources and allow other processes to proceed. Termination is a drastic measure to resolve critical system issues like deadlocks.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) With the aid of a diagram, describe the parts of a magnetic disk&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Parts of a Magnetic Disk with Diagram&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A magnetic disk, such as a Hard Disk Drive (HDD), consists of several key components that work together to store and retrieve data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Magnetic Disk Parts:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                 _________________________
                |                         |
                |     Platter(s)          | &amp;lt;-- (1) Circular Platters coated with magnetic material
                |       _______           |
                |      /       \          |
                |     |  Spindle  |         | &amp;lt;-- (2) Spindle - Central axis for platter rotation
                |      \_______/          |
                |                         |
                +-------------------------+
                      /   |   \
                     /    |    \
    Read/Write Heads ----+-----+---- Actuator Arm  &amp;lt;-- (3) Actuator Arm &amp;amp; Read/Write Heads
      (per platter surface)         (Moves heads across platters)
           |
           V
      +-------------+
      |  Controller | &amp;lt;-- (4) Disk Controller - Interface to system bus
      +-------------+
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Parts:&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Platters&lt;/strong&gt;: &lt;strong&gt;Platters&lt;/strong&gt; are the &lt;strong&gt;circular disks made of aluminum or glass, coated with a magnetic material&lt;/strong&gt;. Data is stored magnetically on both surfaces of each platter. A hard disk typically contains multiple platters stacked on a spindle to increase storage capacity. Platters rotate at high speeds, enabling data access.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Spindle&lt;/strong&gt;: The &lt;strong&gt;Spindle&lt;/strong&gt; is the &lt;strong&gt;central axis around which the platters rotate&lt;/strong&gt;. It is driven by a motor that spins the platters at a constant speed (e.g., 5400 RPM, 7200 RPM). The spindle ensures consistent and high-speed rotation of the platters, enabling the read/write heads to access data sectors.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Read/Write Heads and Actuator Arm&lt;/strong&gt;: &lt;strong&gt;Read/Write Heads&lt;/strong&gt; are electromagnetic components that &lt;strong&gt;read and write data on the platter surfaces&lt;/strong&gt;. Each platter surface has its own read/write head, mounted on an &lt;strong&gt;Actuator Arm&lt;/strong&gt;. The actuator arm moves the heads radially across the platters to position them over different tracks or cylinders. The heads float very close to the platter surface but do not touch it during normal operation.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Disk Controller&lt;/strong&gt;: The &lt;strong&gt;Disk Controller&lt;/strong&gt; is an &lt;strong&gt;electronic circuit board&lt;/strong&gt; that controls the operation of the hard disk and provides an &lt;strong&gt;interface between the disk drive and the computer system bus&lt;/strong&gt; (e.g., SATA, NVMe). The controller manages data transfer, error correction, disk formatting, and communication with the host system. It translates high-level commands from the OS into low-level signals for the disk drive components.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;easytvet.com&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="268"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="12_134_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="62">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="59"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-58-44_2014nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-58-44_2014nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="fd20cc7ac11e545adf866695a708480f"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="60"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="269"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="12_134_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="63">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="59"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_12-59-46_2014nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_12-59-46_2014nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="b815f5211eced7406eed08fc95d36cc9"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="60"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="270"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="12_134_2.2"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="64">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="59"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-00-28_2014nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-00-28_2014nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="2a174c43b1015c17a01463a01ce2d4a8"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="60"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="60"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="3"></int>
              <string role="key" value="parentNode"></string>
              <reference key="61"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="12"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="61"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="62"></reference>
            <reference key="63"></reference>
            <reference key="64"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="12"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:Novemeber%202014"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="67">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2014"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="65">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="66">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="135_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="65"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;Operating Systems&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2014&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four resources required in a process execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Time&lt;/strong&gt;: Processes require CPU time to execute instructions. This is the fundamental resource for computation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory&lt;/strong&gt;: Processes need memory to store program code, data, and the process execution context. This includes RAM and potentially virtual memory.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Input/Output (I/O) Resources&lt;/strong&gt;: Processes often require I/O resources such as files, network connections, and devices to interact with the external environment.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Files&lt;/strong&gt;: Access to files for reading and writing data is crucial for many processes to perform their tasks and manage persistent data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between interrupt and system call as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Interrupt&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;interrupt&lt;/strong&gt; is a hardware-generated signal that alerts the operating system to an event that needs immediate attention. It is &lt;strong&gt;asynchronous&lt;/strong&gt;, meaning it can occur at any time, independent of the currently running process. Interrupts are typically triggered by external events such as I/O completion, hardware errors, or timer expirations. When an interrupt occurs, the CPU suspends the current process, saves its context, and transfers control to an &lt;strong&gt;interrupt handler&lt;/strong&gt; to deal with the event.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Call&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;system call&lt;/strong&gt; is a request from a user-level process to the operating system kernel to perform a specific task. It is &lt;strong&gt;synchronous&lt;/strong&gt; and &lt;strong&gt;intentional&lt;/strong&gt;, initiated by the process when it needs to access kernel services. System calls are used for operations like file I/O, process creation, memory allocation, and inter-process communication. When a system call is made, the process transitions to kernel mode, the kernel performs the requested operation, and then returns control back to the process in user mode.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Differences&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference lies in their origin and purpose. &lt;strong&gt;Interrupts&lt;/strong&gt; are hardware-driven, asynchronous signals for handling external events, while &lt;strong&gt;system calls&lt;/strong&gt; are software-driven, synchronous requests from processes to access OS services.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the term context switch as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;context switch&lt;/strong&gt; is the process of the operating system switching the CPU from one process to another. This involves saving the &lt;strong&gt;current state&lt;/strong&gt; of the running process (its context) and restoring the saved state of a different process to be executed. The context typically includes the &lt;strong&gt;program counter&lt;/strong&gt;, &lt;strong&gt;registers&lt;/strong&gt;, and &lt;strong&gt;memory management information&lt;/strong&gt;. Context switching is essential for multitasking, allowing multiple processes to share a single CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A lecturer described objectives of process scheduling to an operating systems' class. Explain two objectives that he could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Maximize CPU Utilization&lt;/strong&gt;: Process scheduling aims to keep the CPU as busy as possible, ensuring that there is always a process running. By efficiently switching between processes, the operating system minimizes CPU idle time, leading to better overall system performance. This is crucial for improving throughput and responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Minimize Turnaround Time&lt;/strong&gt;: Process scheduling strives to reduce the total time it takes for a process to complete execution, known as turnaround time. This includes the time spent waiting in queues, executing on the CPU, and performing I/O. Minimizing turnaround time improves the user experience by providing quicker results and faster application completion.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Bruce was required to identify the appropriate memory placement techniques for a proposed operating system. Explain three techniques that he could have considered.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;First-Fit&lt;/strong&gt;: This technique allocates the first available memory partition that is large enough to accommodate the process. The operating system scans through the memory partitions from the beginning and selects the first suitable block. &lt;strong&gt;Advantage&lt;/strong&gt;: Simple to implement. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Can lead to fragmentation and may not efficiently utilize memory space, potentially leaving larger free blocks unused at the end.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Best-Fit&lt;/strong&gt;: This technique allocates the smallest available memory partition that is large enough to hold the process. The operating system searches the entire list of free partitions and chooses the one that is closest in size to the process's requirement. &lt;strong&gt;Advantage&lt;/strong&gt;: Tends to minimize memory wastage and external fragmentation compared to first-fit. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Can be slower than first-fit due to the need to search the entire list and may lead to many small, unusable free blocks.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Worst-Fit&lt;/strong&gt;: This technique allocates the largest available memory partition to the process. The operating system searches through all free partitions and selects the largest one. &lt;strong&gt;Advantage&lt;/strong&gt;: Aims to leave larger free blocks after allocation, potentially accommodating larger future processes. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Can quickly deplete larger free blocks, leading to fragmentation and potentially making it difficult to allocate memory for large processes in the long run.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two parts of a directory structure in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Directory Entry&lt;/strong&gt;: Each directory contains entries that represent files and subdirectories within it. A directory entry typically includes the &lt;strong&gt;name&lt;/strong&gt; of the file or subdirectory and a pointer to its &lt;strong&gt;inode or file descriptor&lt;/strong&gt;, which holds metadata about the file or directory.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Inode (Index Node) or File Descriptor&lt;/strong&gt;: This part stores the &lt;strong&gt;metadata&lt;/strong&gt; associated with each file or directory. Metadata includes information such as file permissions, ownership, timestamps (creation, modification, access), file size, and pointers to the data blocks on disk where the file content is stored.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;I. access right;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Access Right&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Access rights&lt;/strong&gt;, also known as permissions, define the level of access that users or processes have to specific files or directories in an operating system. They determine what operations are allowed, such as &lt;strong&gt;read&lt;/strong&gt;, &lt;strong&gt;write&lt;/strong&gt;, and &lt;strong&gt;execute&lt;/strong&gt;. Access rights are a crucial part of security and protection, ensuring that only authorized entities can perform operations on system resources. They are typically associated with user accounts and groups.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;II. flags.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;II. Flags&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In operating systems, &lt;strong&gt;flags&lt;/strong&gt; are single-bit indicators used to represent the status or attributes of a file, process, or system component. They act as &lt;strong&gt;boolean&lt;/strong&gt; values (true or false, set or unset) to indicate specific conditions or properties. For example, file flags can indicate if a file is &lt;strong&gt;read-only&lt;/strong&gt;, &lt;strong&gt;hidden&lt;/strong&gt;, or &lt;strong&gt;system file&lt;/strong&gt;. Process flags can indicate the process's &lt;strong&gt;priority&lt;/strong&gt; or &lt;strong&gt;state&lt;/strong&gt; (running, waiting, etc.). Flags are an efficient way to store and manage binary attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure I shows layers in computer memory hierarchy. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-05-57_2014july.pdf.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;380&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure1.png&quot; alt=&quot;Figure 1 Memory Hierarchy Diagram&quot; /&gt;
&lt;p&gt;Describe each of the layers labeled (i) and (ii).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on Figure 1, which depicts a typical memory hierarchy pyramid:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Cache&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Layer (i) is labeled as &lt;strong&gt;Cache&lt;/strong&gt;. Cache memory is the &lt;strong&gt;fastest and most expensive&lt;/strong&gt; type of memory in the hierarchy. It is a small, high-speed memory that stores frequently accessed data and instructions to speed up access times for the CPU. Caches operate on the principle of locality, predicting that data recently accessed or near recently accessed data is likely to be needed again soon. There are typically multiple levels of cache (L1, L2, L3), with L1 being the fastest and smallest, closest to the CPU.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Random Access Memory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Layer (ii) is labeled as &lt;strong&gt;Random Access Memory (RAM)&lt;/strong&gt;. RAM is the &lt;strong&gt;main memory&lt;/strong&gt; of the computer system. It is faster than secondary storage (like hard drives) but slower and less expensive than cache. RAM is &lt;strong&gt;volatile&lt;/strong&gt; memory, meaning it loses its data when power is turned off. It stores the currently running programs and data that the CPU is actively using. RAM allows for random access, meaning any memory location can be accessed in the same amount of time, making it efficient for general-purpose computing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Petro was investigating advantages of memory segmentation in operating systems. Explain two advantages that he is likely to have identified.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Logical Address Space&lt;/strong&gt;: Memory segmentation allows for a &lt;strong&gt;logical view&lt;/strong&gt; of memory, where the address space is divided into logical units called segments (code, data, stack). This simplifies program organization and management, as each segment can grow or shrink independently. It also facilitates modular programming and data sharing between segments.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Protection and Sharing&lt;/strong&gt;: Segmentation enables &lt;strong&gt;protection&lt;/strong&gt; at the segment level. Each segment can have its own access rights (read, write, execute), allowing the operating system to enforce memory protection between different segments and processes. It also facilitates &lt;strong&gt;sharing&lt;/strong&gt; of specific segments between processes, such as code segments for libraries, while maintaining protection for other segments. This enhances system security and resource utilization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two types of files that could be found in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Files&lt;/strong&gt;: These files contain &lt;strong&gt;user-created data&lt;/strong&gt;, such as documents, images, audio, video, and databases. They are typically organized and interpreted by application programs. Data files can be further categorized by their format (e.g., text files, binary files, image files).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Executable Files&lt;/strong&gt;: These files contain &lt;strong&gt;program instructions&lt;/strong&gt; that can be executed by the CPU. They are the compiled form of source code and represent applications or system utilities. Executable files are typically loaded into memory and run by the operating system. They often have specific formats depending on the operating system (e.g., .exe on Windows, ELF on Linux).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Brian intends to backup files. Explain two backup strategies he could use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Full Backup&lt;/strong&gt;: A &lt;strong&gt;full backup&lt;/strong&gt; strategy involves copying &lt;strong&gt;all selected files and directories&lt;/strong&gt; every time a backup is performed. This creates a complete copy of the data set. &lt;strong&gt;Advantage&lt;/strong&gt;: Simplest to restore from, as all data is in one backup set. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Time-consuming and requires significant storage space, especially for frequent backups, as it duplicates all data each time.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Incremental Backup&lt;/strong&gt;: An &lt;strong&gt;incremental backup&lt;/strong&gt; strategy only copies the files that have been &lt;strong&gt;changed or created since the last backup&lt;/strong&gt; (which could be a full or incremental backup). This significantly reduces backup time and storage space. &lt;strong&gt;Advantage&lt;/strong&gt;: Faster backups and less storage space required compared to full backups. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Restoration is more complex and time-consuming, as it requires the last full backup and all subsequent incremental backups to be restored in sequence.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) bootstrap;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Bootstrap&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bootstrap&lt;/strong&gt; refers to the initial startup process of a computer system when it is powered on or rebooted. It is a &lt;strong&gt;self-starting process&lt;/strong&gt; where a small program, the &lt;strong&gt;bootstrap loader&lt;/strong&gt;, is loaded from non-volatile memory (like ROM or firmware). This loader then initializes the system hardware, loads the operating system kernel from storage into memory, and starts the OS execution. The bootstrap process is essential to bring the system from a powered-off state to a running state.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(ii) firmware.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Firmware&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Firmware&lt;/strong&gt; is a type of software that is &lt;strong&gt;embedded in hardware devices&lt;/strong&gt;. It is stored in non-volatile memory (like ROM, EPROM, or Flash memory) and provides low-level control and instructions for the hardware. Firmware is essential for the basic operation of hardware components, such as BIOS/UEFI in motherboards, firmware in disk drives, network cards, and embedded systems. It is &quot;firm&quot; because it is neither purely hardware nor purely software, residing in between.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows a typical process model used in operating systems. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-07-33_2014july.pdf.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;462&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure2.png&quot; alt=&quot;Figure 2 Process State Diagram&quot; /&gt;
&lt;p&gt;Identify the parts labeled (i), (ii), (iii), (iv) and (v).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on Figure 2, which depicts a typical process state diagram:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Ready&lt;/strong&gt;: This state represents processes that are &lt;strong&gt;ready to run&lt;/strong&gt; but are waiting for the CPU to be allocated to them. They are in memory and are waiting to be scheduled by the dispatcher.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Running&lt;/strong&gt;: This state represents the process that is &lt;strong&gt;currently being executed&lt;/strong&gt; by the CPU. Instructions of the process are being actively processed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iii) Waiting (or Blocked)&lt;/strong&gt;: This state represents processes that are &lt;strong&gt;waiting for some event to occur&lt;/strong&gt;, such as the completion of an I/O operation or receiving a signal. They are not ready to run and are waiting for an external event to become ready again.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iv) Scheduler Dispatch&lt;/strong&gt;: This label represents the action of the &lt;strong&gt;scheduler dispatching&lt;/strong&gt; a process from the ready queue to the running state. It's the transition from Ready to Running state.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(v) New&lt;/strong&gt;: This state represents a process that is being &lt;strong&gt;created&lt;/strong&gt;. The operating system is in the process of setting up the necessary data structures and resources for the new process. Before being admitted to the Ready queue, a process is in the New state.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Dorothy intends to design an operating system that uses swapping in memory management. Explain two constraints that are likely to be realized.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Performance Overhead (Swapping Time)&lt;/strong&gt;: Swapping processes between main memory and secondary storage (disk) is a &lt;strong&gt;time-consuming operation&lt;/strong&gt;. The time taken to swap a process out and swap another process in, known as swap time, introduces significant overhead. Frequent swapping can lead to reduced system throughput and slower response times, especially if the swap space is slow or if processes are frequently swapped in and out.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased I/O Traffic&lt;/strong&gt;: Swapping generates considerable &lt;strong&gt;disk I/O traffic&lt;/strong&gt; as processes are moved to and from secondary storage. This increased I/O load can become a bottleneck, especially if there are many processes being swapped or if disk I/O is already heavily utilized by other system activities. High I/O traffic can degrade overall system performance and reduce the efficiency of other disk-related operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three goals of I/O module.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Independence&lt;/strong&gt;: One goal is to provide a &lt;strong&gt;uniform interface&lt;/strong&gt; to the operating system and user processes, regardless of the specific characteristics of different I/O devices. This allows programs to interact with devices in a generic way without needing to know the details of each device's operation. Device drivers handle the device-specific operations, providing an abstraction layer.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Buffering and Caching&lt;/strong&gt;: I/O modules aim to improve performance by using &lt;strong&gt;buffering and caching techniques&lt;/strong&gt;. Buffering helps to smooth out data transfer rates between devices and memory, while caching stores frequently accessed data in memory to reduce the need for slow I/O operations. These techniques improve efficiency and responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Error Handling&lt;/strong&gt;: A crucial goal is to manage &lt;strong&gt;error detection and handling&lt;/strong&gt; for I/O operations. The I/O module should detect errors during data transfer, device operations, or device failures. It should implement mechanisms to handle these errors, such as retries, error reporting, or device recovery, to ensure data integrity and system reliability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A group of module II students were carrying out an assignment on I/O protection strategies in operating systems. Explain two strategies that they could identify.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Privileged Instructions&lt;/strong&gt;: Restricting direct access to I/O hardware by making I/O instructions &lt;strong&gt;privileged&lt;/strong&gt;. Only the operating system kernel, running in privileged mode, can execute these instructions. User-level processes must request I/O operations through system calls, which are then handled by the kernel. This prevents unauthorized user programs from directly manipulating I/O devices and causing system instability or security breaches.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Memory Protection for I/O Buffers&lt;/strong&gt;: Implementing &lt;strong&gt;memory protection mechanisms&lt;/strong&gt; to safeguard the memory regions used for I/O buffers. This ensures that user processes cannot directly access or modify the I/O buffers used by the kernel for device communication. Memory protection can be achieved using techniques like memory segmentation or paging with access control bits. This prevents malicious or erroneous user programs from corrupting kernel I/O operations or accessing sensitive data in I/O buffers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between SCAN and C-SCAN disk scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;SCAN Algorithm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;SCAN algorithm&lt;/strong&gt;, also known as the elevator algorithm, moves the disk head in one direction (e.g., from the innermost track to the outermost track), servicing all requests in its path. When it reaches one end of the disk, it reverses direction and continues servicing requests in the opposite direction. It's like an elevator moving up and down a building, servicing floors in its current direction of travel. SCAN provides &lt;strong&gt;moderate throughput&lt;/strong&gt; and &lt;strong&gt;fairness&lt;/strong&gt;, but waiting time can be high for requests arriving just after the head has passed them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C-SCAN Algorithm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;C-SCAN (Circular SCAN) algorithm&lt;/strong&gt; is a variation of SCAN that attempts to provide more uniform wait times. It moves the disk head in one direction (e.g., from the innermost to the outermost track), servicing requests along the way, just like SCAN. However, when it reaches the end of the disk, it &lt;strong&gt;quickly returns to the beginning&lt;/strong&gt; of the disk without servicing any requests on the return trip. Then, it starts scanning again from the beginning in the same direction. C-SCAN offers &lt;strong&gt;more uniform wait times&lt;/strong&gt; compared to SCAN, as it limits the maximum wait time for any request, but it may have slightly &lt;strong&gt;lower throughput&lt;/strong&gt; because of the head repositioning overhead on the return trip.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The primary difference is in the head movement after reaching the end of the disk. SCAN reverses direction, while C-SCAN returns to the beginning without servicing requests, aiming for more uniform service times at the cost of potentially slightly reduced throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Hope intends to develop a file management module for an operating system. Explain two file access methods that she should consider.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential Access&lt;/strong&gt;: In &lt;strong&gt;sequential access&lt;/strong&gt;, files are accessed in a &lt;strong&gt;linear order&lt;/strong&gt;, from the beginning to the end. To access a specific record, one must read through all preceding records. This method is simple to implement and efficient for applications that process data in a fixed sequence, like batch processing or tape-based systems. &lt;strong&gt;Example&lt;/strong&gt;: Reading a log file from start to finish.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Direct (Random) Access&lt;/strong&gt;: In &lt;strong&gt;direct access&lt;/strong&gt;, also known as random access, any record in a file can be accessed &lt;strong&gt;directly without needing to read through preceding records&lt;/strong&gt;. This is achieved by using a record number or a key to calculate the physical location of the desired record. Direct access is essential for applications that require fast access to specific data records, like databases, indexed file systems, and interactive applications. &lt;strong&gt;Example&lt;/strong&gt;: Accessing a specific record in a database using an index.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram in each case, describe each of the following file system:&lt;/p&gt;
&lt;p&gt;(i) single-level directory;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Single-Level Directory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;single-level directory&lt;/strong&gt; structure, there is only &lt;strong&gt;one directory&lt;/strong&gt; for all files in the system. All files are placed in this single directory. &lt;strong&gt;Conceptual Diagram&lt;/strong&gt;: Imagine a single box where all files are placed directly inside. &lt;strong&gt;Description&lt;/strong&gt;: This is the simplest directory structure. It is easy to implement but suffers from significant limitations, especially for systems with many files or multiple users. &lt;strong&gt;Limitation&lt;/strong&gt;: Naming conflicts are a major issue, as all file names must be unique system-wide. It also lacks organizational structure and is not suitable for large file systems or multi-user environments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram in each case, describe each of the following file system:&lt;/p&gt;
&lt;p&gt;(ii) two-level directory.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Two-Level Directory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;two-level directory&lt;/strong&gt; structure, there is a &lt;strong&gt;root directory&lt;/strong&gt;, and under it, each user has their own &lt;strong&gt;user directory&lt;/strong&gt;. Each user directory contains all the files belonging to that user. &lt;strong&gt;Conceptual Diagram&lt;/strong&gt;: Imagine a main box (root directory) containing smaller boxes (user directories), and each smaller box holds files for a specific user. &lt;strong&gt;Description&lt;/strong&gt;: This structure improves upon the single-level directory by providing a level of organization and resolving naming conflicts between users. Each user can have files with the same name as long as they are in different user directories. &lt;strong&gt;Limitation&lt;/strong&gt;: It still lacks flexibility for users to create their own subdirectories within their user directory for better organization of their files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following tables as used in memory management:&lt;/p&gt;
&lt;p&gt;(i) hashed;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Hashed Page Table&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;hashed page table&lt;/strong&gt; is a page table structure used in virtual memory management, especially for large address spaces. Instead of a linear array, it uses a &lt;strong&gt;hash table&lt;/strong&gt; to map virtual page numbers to page table entries. The virtual page number is hashed to get an index into the hash table. Each entry in the hash table is a linked list of page table entries that hash to the same index, resolving collisions. &lt;strong&gt;Advantage&lt;/strong&gt;: Effective in reducing the size of the page table, especially for sparse address spaces. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Lookups can be slightly slower due to hash function computation and linked list traversal in case of collisions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following tables as used in memory management:&lt;/p&gt;
&lt;p&gt;(ii) clustered page.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Clustered Page Table&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;clustered page table&lt;/strong&gt; is a variation used in memory management to handle large page tables efficiently, particularly in systems with large physical memory. Instead of a single large page table, it is divided into &lt;strong&gt;clusters or groups&lt;/strong&gt;. Each cluster is a smaller page table that manages a portion of the virtual address space. A top-level index or directory is used to locate the appropriate cluster for a given virtual address. &lt;strong&gt;Advantage&lt;/strong&gt;: Reduces the memory footprint of the page table by only keeping necessary clusters in memory. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Adds a level of indirection for address translation, potentially slightly increasing lookup time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between long-term and short-term schedulers as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Long-Term Scheduler (Job Scheduler)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;long-term scheduler&lt;/strong&gt;, also known as the job scheduler, controls the &lt;strong&gt;degree of multiprogramming&lt;/strong&gt; by selecting processes from a job pool and loading them into memory for execution. It operates relatively infrequently, typically when a process finishes or when system load changes significantly. Its primary goal is to balance the mix of processes in memory, ensuring a good balance between CPU-bound and I/O-bound processes. It influences system stability and resource utilization over a longer time scale.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Short-Term Scheduler (CPU Scheduler)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;short-term scheduler&lt;/strong&gt;, also known as the CPU scheduler, selects one of the ready processes in memory and allocates the CPU to it. It operates very frequently, typically whenever an event occurs that may lead to process switching (e.g., time slice expiration, I/O request, interrupt). Its primary goal is to maximize CPU utilization and minimize response time by quickly switching between ready processes. It makes fine-grained decisions about which process runs next, impacting system responsiveness and throughput in the short term.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference is in their frequency and scope. The &lt;strong&gt;long-term scheduler&lt;/strong&gt; controls the overall number of processes in memory over longer periods, while the &lt;strong&gt;short-term scheduler&lt;/strong&gt; makes rapid, moment-to-moment decisions about CPU allocation among ready processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Bev was carrying out a study on benefits of multiprocessor systems. Explain two benefits that she could have established.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increased Throughput&lt;/strong&gt;: Multiprocessor systems can achieve significantly &lt;strong&gt;higher throughput&lt;/strong&gt; than single-processor systems. By having multiple CPUs, they can execute multiple processes or threads concurrently, leading to more work being completed in a given time period. This is especially beneficial for CPU-intensive workloads and applications that can be parallelized. Increased throughput improves overall system efficiency and performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Reliability and Fault Tolerance&lt;/strong&gt;: Multiprocessor systems can offer &lt;strong&gt;improved reliability and fault tolerance&lt;/strong&gt;. If one processor fails, the system can continue to operate, albeit with reduced performance, using the remaining processors. This redundancy makes the system more resilient to hardware failures and reduces the risk of complete system downtime. Fault tolerance is crucial for critical applications where continuous operation is essential.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Angie was required to investigate factors that affect performance of a storage disk Outline four factors that she could have considered.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Seek Time&lt;/strong&gt;: &lt;strong&gt;Seek time&lt;/strong&gt; is the time it takes for the disk head to move to the correct cylinder or track where the desired data is located. A lower seek time means faster access to data. Seek time is influenced by the physical characteristics of the disk drive, such as the speed and inertia of the actuator arm.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Rotational Latency&lt;/strong&gt;: &lt;strong&gt;Rotational latency&lt;/strong&gt; is the time it takes for the desired sector on the disk to rotate under the read/write head once the head is positioned over the correct track. Lower rotational latency results in quicker data access. Rotational speed (RPM) of the disk directly affects rotational latency; higher RPM reduces latency.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Transfer Rate&lt;/strong&gt;: &lt;strong&gt;Transfer rate&lt;/strong&gt; is the speed at which data can be transferred between the disk and the system memory, once the head is correctly positioned and the sector is under the head. Higher transfer rates lead to faster data read and write operations. Transfer rate is influenced by the disk interface (e.g., SATA, NVMe), disk technology, and controller capabilities.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Disk Controller Overhead&lt;/strong&gt;: The &lt;strong&gt;disk controller&lt;/strong&gt;, which manages the disk drive, introduces some overhead. This includes the time for command processing, data buffering, error checking, and protocol handling. Lower controller overhead contributes to better disk performance. Efficient controller design and faster interfaces can minimize this overhead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in disk operations:&lt;/p&gt;
&lt;p&gt;(i) seek time;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Seek Time&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek time&lt;/strong&gt; is the time taken for a disk drive's read/write head to move from its current position to the cylinder or track where the requested data is located. It is a major component of disk access time, representing the mechanical movement of the head assembly. Lower seek times contribute to faster disk performance. Seek time is typically measured in milliseconds (ms).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in disk operations:&lt;/p&gt;
&lt;p&gt;(ii) transfer rate;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Transfer Rate&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer rate&lt;/strong&gt;, also known as data rate or bandwidth, is the speed at which data can be transferred between the disk drive and the computer's memory once the read/write head is positioned correctly over the data sector. It is usually measured in megabytes per second (MB/s) or gigabytes per second (GB/s). A higher transfer rate indicates faster data read and write operations, contributing to better disk performance. Transfer rate is influenced by factors like disk interface type, disk speed, and data encoding scheme.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in disk operations:&lt;/p&gt;
&lt;p&gt;(ii) rotational latency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Rotational Latency&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rotational latency&lt;/strong&gt; is the time it takes for the desired sector on a disk platter to rotate under the read/write head once the head has reached the correct track (after seek time). On average, it is half of the time for a full disk rotation. Rotational latency is a component of disk access time, representing the delay due to the disk's rotation speed. It is inversely related to the disk's RPM (revolutions per minute). Higher RPM disks have lower rotational latency, leading to faster data access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Stano listed several examples of I/O buses that could be used in a disk drive. Outline four examples that he could have listed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;SATA (Serial ATA)&lt;/strong&gt;: &lt;strong&gt;SATA&lt;/strong&gt; is a common interface for connecting disk drives (HDDs and SSDs) to the motherboard. It is a serial interface, offering good performance for general-purpose storage and is widely used in desktop and laptop computers.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;NVMe (Non-Volatile Memory Express)&lt;/strong&gt;: &lt;strong&gt;NVMe&lt;/strong&gt; is a high-performance interface designed specifically for SSDs. It uses the PCI Express (PCIe) bus to provide significantly higher transfer rates and lower latency compared to SATA. NVMe is ideal for demanding applications requiring fast storage access, such as servers, workstations, and high-end gaming PCs.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;SAS (Serial Attached SCSI)&lt;/strong&gt;: &lt;strong&gt;SAS&lt;/strong&gt; is another serial interface, primarily used in enterprise environments for server and workstation storage. It offers higher reliability, performance, and scalability compared to SATA. SAS drives often have higher rotational speeds and are designed for demanding workloads and data centers.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;IDE/ATA (Integrated Drive Electronics/Advanced Technology Attachment)&lt;/strong&gt;: &lt;strong&gt;IDE/ATA&lt;/strong&gt; is an older parallel interface for disk drives. While less common in modern systems, it was widely used in the past. Compared to SATA, IDE/ATA is slower and has limitations in cable length and device support. Modern systems primarily use SATA and NVMe interfaces.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;File attributes varies from one operating system to another. Outline five examples of these attributes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Name&lt;/strong&gt;: The &lt;strong&gt;name&lt;/strong&gt; of the file, which is used to identify and access the file within a directory structure. File naming conventions and restrictions can vary between operating systems (e.g., case sensitivity, allowed characters, maximum length).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Size&lt;/strong&gt;: The &lt;strong&gt;size&lt;/strong&gt; of the file, indicating the amount of storage space it occupies, usually measured in bytes, kilobytes, megabytes, etc. File size is crucial for storage management and resource allocation.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Type&lt;/strong&gt;: The &lt;strong&gt;type&lt;/strong&gt; of file, which indicates the file format and purpose (e.g., text file, executable file, image file, directory). File type is often indicated by a file extension or metadata and determines how the file is handled by the operating system and applications.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Permissions/Access Rights&lt;/strong&gt;: &lt;strong&gt;Permissions&lt;/strong&gt; or access rights control who can access the file and what operations they can perform (e.g., read, write, execute). Permission models vary across operating systems (e.g., ACLs, POSIX permissions) and are essential for security and data protection.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Timestamps&lt;/strong&gt;: &lt;strong&gt;Timestamps&lt;/strong&gt; record various times associated with the file, such as creation time, last modification time, and last access time. Timestamps are used for file management, tracking changes, and backup purposes. The precision and types of timestamps can differ between operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, outline a typical process control block (PCB) diagram as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;Process Control Block (PCB)&lt;/strong&gt; is a data structure used by the operating system to manage and track information about each process. While a true &quot;diagram&quot; isn't textual, conceptually, a PCB can be visualized as a structured record containing various fields.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual PCB Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    +-----------------------+
                    |  Process Identifier (PID) |
                    +-----------------------+
                    |  Process State        |
                    +-----------------------+
                    |  Program Counter (PC)  |
                    +-----------------------+
                    |  CPU Registers        |
                    +-----------------------+
                    |  Memory Management Info|
                    +-----------------------+
                    |  CPU Scheduling Info   |
                    +-----------------------+
                    |  I/O Status Info       |
                    +-----------------------+
                    |  Accounting Info       |
                    +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Key Fields&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process Identifier (PID)&lt;/strong&gt;: A unique numeric identifier assigned to each process for system-level tracking and management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process State&lt;/strong&gt;: Indicates the current state of the process (e.g., running, ready, waiting, new, terminated).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: Stores the address of the next instruction to be executed for this process.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU Registers&lt;/strong&gt;: Saves the values of CPU registers when the process is switched out, allowing the process to resume execution from the same point later.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memory Management Information&lt;/strong&gt;: Includes details about memory allocated to the process, such as page table pointers or segment table information.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU Scheduling Information&lt;/strong&gt;: Contains process priority, scheduling queue pointers, and other parameters used by the scheduler to determine process execution order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O Status Information&lt;/strong&gt;: Records details of I/O devices allocated to the process, open files, and pending I/O requests.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Accounting Information&lt;/strong&gt;: Tracks resource usage by the process, such as CPU time used, elapsed time, and account limits.&lt;/p&gt;
&lt;p&gt;The PCB is crucial for context switching, process scheduling, resource management, and inter-process communication. The OS maintains a PCB for each active process in the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term livelock as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Livelock&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Livelock&lt;/strong&gt; is a concurrency control issue similar to deadlock, where processes are continuously changing their state in response to other processes, but &lt;strong&gt;none of them make progress&lt;/strong&gt;. Unlike deadlock, processes in a livelock are not blocked; they are actively engaged in attempting to resolve a conflict, but their actions prevent any progress from being made. They are in a loop of repeated state changes, effectively wasting CPU cycles without performing useful work. It's like two people trying to pass each other in a narrow corridor, each stepping aside to let the other pass, but they both step aside in the same direction, continuing to block each other.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between overlaying and partitioning as used memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt; is a memory management technique used in older systems with limited memory. It allows a program larger than the available physical memory to run by dividing it into &lt;strong&gt;overlays&lt;/strong&gt;. Only the overlay currently needed is loaded into memory, while others are kept on disk. When a different overlay is required, the current one is replaced (overlaid) with the new one. Overlaying is a programmer-managed technique, requiring careful program design to divide it into appropriate overlays. &lt;strong&gt;Limitation&lt;/strong&gt;: Complex to implement and manage, requires programmer intervention, and is not efficient for modern systems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Partitioning&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Partitioning&lt;/strong&gt; is a memory management technique that divides main memory into &lt;strong&gt;fixed-size or variable-size partitions&lt;/strong&gt;. Each partition can hold one process. &lt;strong&gt;Fixed partitioning&lt;/strong&gt; divides memory into equal-sized partitions, while &lt;strong&gt;variable partitioning&lt;/strong&gt; creates partitions of different sizes dynamically based on process requirements. Partitioning allows for multiprogramming by running multiple processes concurrently in different partitions. &lt;strong&gt;Limitation&lt;/strong&gt;: Can suffer from internal fragmentation (in fixed partitioning) or external fragmentation (in variable partitioning), and memory utilization might not be optimal.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt; is a technique to run programs larger than physical memory by loading segments on demand, managed by the programmer, while &lt;strong&gt;partitioning&lt;/strong&gt; divides memory into sections to run multiple programs concurrently, managed by the OS, and limited by total memory size.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Mercy, an intern student was required to discuss examples of file operations during a job interview. Outline four examples that she could have mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create&lt;/strong&gt;: The &lt;strong&gt;create&lt;/strong&gt; operation is used to &lt;strong&gt;make a new file&lt;/strong&gt; in the file system. It involves allocating storage space for the file, creating a directory entry with the file name, and setting initial file attributes (e.g., permissions, timestamps). Creating a file is the first step to store data in the file system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Read&lt;/strong&gt;: The &lt;strong&gt;read&lt;/strong&gt; operation is used to &lt;strong&gt;retrieve data from an existing file&lt;/strong&gt;. It involves accessing the file's data blocks from storage and transferring the data to memory for processing. Read operations are fundamental for accessing and using the information stored in files.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Write&lt;/strong&gt;: The &lt;strong&gt;write&lt;/strong&gt; operation is used to &lt;strong&gt;store data into a file&lt;/strong&gt;. It involves transferring data from memory to the file's data blocks on storage. Write operations are essential for creating, modifying, and updating file content.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete&lt;/strong&gt;: The &lt;strong&gt;delete&lt;/strong&gt; operation is used to &lt;strong&gt;remove a file&lt;/strong&gt; from the file system. It involves freeing up the storage space occupied by the file and removing the directory entry associated with the file. Deleting files is necessary for managing storage space and removing outdated or unnecessary files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Sayd Company Ltd. intends to replace its single-processor operating system. Outline four limitations of the existing operating system that could have influenced the decision.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Limited Performance Scaling&lt;/strong&gt;: Single-processor operating systems are inherently limited in their ability to scale performance with increasing workloads. As demand grows, a single CPU can become a bottleneck, restricting overall system throughput and responsiveness. This limitation is significant for companies with growing computational needs.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Lack of True Concurrency&lt;/strong&gt;: Single-processor systems achieve concurrency through time-sharing, rapidly switching between processes. However, they cannot execute multiple processes truly simultaneously. For applications requiring parallel processing or real-time responsiveness, this lack of true concurrency can be a major limitation.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Single Point of Failure for CPU&lt;/strong&gt;: In a single-processor system, the CPU is a single point of failure. If the CPU fails, the entire system becomes inoperable. This lack of redundancy can be a critical concern for business continuity and system reliability, especially for critical operations.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Inefficient Resource Utilization for Multitasking&lt;/strong&gt;: While single-processor systems can multitask, they might not efficiently utilize resources when running multiple demanding applications concurrently. Context switching overhead and contention for the single CPU can lead to performance degradation and inefficient resource utilization compared to multiprocessor systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Claudius was required to list advantages of dynamic linking in memory management. Explain three advantages that he is likely to have listed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Memory Footprint&lt;/strong&gt;: &lt;strong&gt;Dynamic linking&lt;/strong&gt; allows multiple programs to &lt;strong&gt;share a single copy of library code&lt;/strong&gt; in memory. When programs use shared libraries, only one instance of the library needs to be loaded into memory, regardless of how many programs use it. This significantly reduces the overall memory footprint, especially when many programs utilize common libraries. Reduced memory usage can lead to better system performance and increased process capacity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Easier Library Updates and Maintenance&lt;/strong&gt;: Dynamic linking simplifies &lt;strong&gt;library updates and maintenance&lt;/strong&gt;. When a shared library is updated (e.g., for bug fixes or feature enhancements), the updated library can be replaced without needing to recompile or relink applications that use it. Applications will automatically use the updated library the next time they are run. This simplifies software distribution, patching, and maintenance, reducing administrative overhead.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Smaller Executable Size&lt;/strong&gt;: Executables that use dynamic linking are &lt;strong&gt;smaller in size&lt;/strong&gt; compared to statically linked executables. This is because they do not include the library code within themselves. Instead, they only contain references or links to the shared libraries. Smaller executables save disk space, reduce download times, and improve program loading speed. This is beneficial for storage efficiency and faster application launch times.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term programmable interval timer as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Programmable Interval Timer (PIT)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;programmable interval timer (PIT)&lt;/strong&gt; is a hardware component in a computer system that generates &lt;strong&gt;periodic interrupts&lt;/strong&gt; at programmable intervals. The operating system can program the timer to trigger interrupts after a specified duration. PITs are crucial for time-keeping, process scheduling, and implementing time-based functionalities in operating systems. They provide a reliable and precise source of timing signals for system operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four services that could be provided by I/O subsystem kernel.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Management&lt;/strong&gt;: The I/O subsystem kernel manages &lt;strong&gt;device drivers&lt;/strong&gt;, which are software modules that control specific hardware devices. This includes loading and unloading drivers, configuring devices, and handling device initialization and shutdown. Device management ensures that the operating system can communicate with and control various I/O devices.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Buffering and Caching&lt;/strong&gt;: The kernel provides &lt;strong&gt;buffering and caching services&lt;/strong&gt; for I/O operations. Buffering temporarily stores data being transferred between devices and memory to handle speed mismatches and improve efficiency. Caching stores frequently accessed data in memory to reduce the need for repeated slow I/O operations. These techniques enhance I/O performance and system responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Spooling (Simultaneous Peripheral Operations On-Line)&lt;/strong&gt;: The I/O subsystem kernel often provides &lt;strong&gt;spooling services&lt;/strong&gt;, particularly for output devices like printers. Spooling queues output requests and manages the printing process in the background, allowing applications to continue execution without waiting for I/O completion. Spooling improves system concurrency and user productivity.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Error Handling and Recovery&lt;/strong&gt;: The kernel's I/O subsystem is responsible for &lt;strong&gt;detecting and handling errors&lt;/strong&gt; during I/O operations. This includes error detection, error reporting, and implementing recovery mechanisms, such as retries or device reset. Robust error handling is crucial for data integrity and system reliability in I/O operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain four circumstances that would necessitate premature termination of a process execution in an operating system&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Error Condition/Exception&lt;/strong&gt;: If a process encounters a &lt;strong&gt;fatal error&lt;/strong&gt; or an unrecoverable exception during execution, the operating system may terminate it prematurely. Examples include &lt;strong&gt;division by zero&lt;/strong&gt;, &lt;strong&gt;illegal memory access&lt;/strong&gt; (segmentation fault), or &lt;strong&gt;invalid instruction&lt;/strong&gt;. These errors indicate that the process cannot continue execution safely or correctly, and termination is necessary to prevent system instability or data corruption. The OS typically logs the error and may provide diagnostic information.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Resource Unavailability&lt;/strong&gt;: If a process requests a &lt;strong&gt;resource that is not available&lt;/strong&gt; and cannot be granted, and if the process cannot proceed without that resource, the operating system might terminate it. This can occur in situations of &lt;strong&gt;resource deadlock&lt;/strong&gt; or when system resources are exhausted. For instance, if a process requests more memory than is available, or if it is waiting indefinitely for a resource held by another deadlocked process, termination might be the only way to resolve the situation and free up resources.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Time Limit Exceeded&lt;/strong&gt;: Operating systems often impose &lt;strong&gt;time limits&lt;/strong&gt; on process execution, especially in time-sharing or real-time systems. If a process exceeds its allocated CPU time or runtime limit, the operating system may terminate it to enforce fairness, prevent monopolization of resources, or meet real-time deadlines. This is common in batch processing systems or when implementing quality of service (QoS) policies. The time limit is typically set by the system administrator or process scheduler.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Parent Process Termination&lt;/strong&gt;: In a hierarchical process model, if a &lt;strong&gt;parent process terminates&lt;/strong&gt;, the operating system may also terminate its child processes. This is to prevent orphaned processes from running without a parent to manage them or reclaim their resources. This ensures proper process lifecycle management and resource cleanup. The termination of child processes upon parent termination can be a default behavior or configurable based on system policies.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the parts of a magnetic disk&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A magnetic disk is composed of several key parts working together to store and retrieve data. While a true &quot;diagram&quot; cannot be rendered here, we can describe the conceptual layout and components.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of Magnetic Disk Parts&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    +-----------------------+     +-----------------------+     +-----------------------+
                    | Platter(s)             | --&amp;gt; | Track(s)              | --&amp;gt; | Sector(s)             |
                    +-----------------------+     +-----------------------+     +-----------------------+
                         ^                             ^                             ^
                         |                             |                             |
                         +-----------------------+     +-----------------------+     +-----------------------+
                         | Read/Write Head(s)     |     | Cylinder(s)           |     | Inter-sector Gap      |
                         +-----------------------+     +-----------------------+     +-----------------------+
                               ^
                               |
                         +-----------------------+
                         | Actuator Arm          |
                         +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Parts&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Platter(s)&lt;/strong&gt;: Magnetic disks consist of one or more &lt;strong&gt;platters&lt;/strong&gt;, which are circular disks coated with a magnetic material. Data is stored magnetically on the surfaces of these platters. Platters spin at a constant speed, enabling read/write operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Read/Write Head(s)&lt;/strong&gt;: Each platter surface has a corresponding &lt;strong&gt;read/write head&lt;/strong&gt;, which is used to write data to and read data from the disk surface. Heads are positioned very close to the platter surface but do not touch it during normal operation. Heads are attached to an actuator arm.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actuator Arm&lt;/strong&gt;: The &lt;strong&gt;actuator arm&lt;/strong&gt; moves the read/write heads across the platters to position them over the desired track or cylinder. The actuator arm is controlled by the disk controller and is responsible for seek operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Track(s)&lt;/strong&gt;: Each platter surface is divided into concentric circles called &lt;strong&gt;tracks&lt;/strong&gt;. Data is recorded serially along these tracks. Tracks are numbered starting from the outer edge of the platter (track 0) inwards.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cylinder(s)&lt;/strong&gt;: A &lt;strong&gt;cylinder&lt;/strong&gt; is a set of tracks that are in the same vertical position across all platters. If a disk has multiple platters, tracks at the same radial distance from the center on each platter form a cylinder. Cylinders are a logical grouping of tracks used for addressing and data organization.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sector(s)&lt;/strong&gt;: Each track is further divided into &lt;strong&gt;sectors&lt;/strong&gt;, which are the smallest units of data storage on a disk, typically 512 bytes or 4KB in size. Sectors are where actual data is stored. Sectors are addressed by track and sector number.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inter-sector Gap&lt;/strong&gt;: &lt;strong&gt;Inter-sector gaps&lt;/strong&gt; are small spaces between sectors on a track. These gaps are used for synchronization, error correction codes, and sector identification information. They separate sectors and help the disk controller in reading and writing data reliably.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 [Your University/College Name]&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="271"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="13_135_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="68">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="65"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-05-57_2014july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-05-57_2014july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="1112ec6cd50565cee22821e4e587b644"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="66"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="272"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="13_135_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="69">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="65"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-07-33_2014july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-07-33_2014july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="e48d9f98b6eefdcf39efc560b227694f"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="66"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="66"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="2"></int>
              <string role="key" value="parentNode"></string>
              <reference key="67"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="13"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="67"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="68"></reference>
            <reference key="69"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="13"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202014"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="72">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2013"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="70">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="71">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="136_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="70"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;Operating Systems&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2013&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in computer operating systems.&lt;/p&gt;
&lt;p&gt;(i) shell;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;shell&lt;/strong&gt; is a command-line interpreter or user interface in an operating system. It acts as an &lt;strong&gt;intermediary between the user and the operating system kernel&lt;/strong&gt;, allowing users to execute commands, manage files, and interact with the system through textual commands. The shell interprets user commands and translates them into system calls that the kernel can understand and execute.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in computer operating systems.&lt;/p&gt;
&lt;p&gt;(ii) system call.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;system call&lt;/strong&gt; is a request made by a user-level process to the operating system kernel to perform a specific task that requires &lt;strong&gt;privileged operations&lt;/strong&gt;. It is the &lt;strong&gt;interface&lt;/strong&gt; through which processes can request services from the kernel, such as file I/O, process creation, memory allocation, and network communication. System calls are essential for processes to interact with the operating system and access system resources.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in computer operating systems.&lt;/p&gt;
&lt;p&gt;(iii) buffer&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;buffer&lt;/strong&gt; is a region of memory used for &lt;strong&gt;temporary storage&lt;/strong&gt; of data during data transfer operations, especially between different parts of a computer system or between devices. Buffers are used to handle differences in data transfer rates, optimize data flow, and improve efficiency. They are commonly used in I/O operations, network communication, and data processing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following Inter Process Communication methods:&lt;/p&gt;
&lt;p&gt;(i) semaphore;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;semaphore&lt;/strong&gt; is a synchronization primitive used for controlling access to &lt;strong&gt;shared resources&lt;/strong&gt; in a concurrent system. It is an integer variable that, apart from initialization, is accessed only through two atomic operations: &lt;strong&gt;wait (P)&lt;/strong&gt; and &lt;strong&gt;signal (V)&lt;/strong&gt;. Semaphores are used to manage critical sections and prevent race conditions by ensuring that only a limited number of processes can access a resource at any given time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following Inter Process Communication methods:&lt;/p&gt;
&lt;p&gt;(ii) signal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;signal&lt;/strong&gt; is a software interrupt used in operating systems to notify a process of the occurrence of a particular &lt;strong&gt;event&lt;/strong&gt;. Signals can be sent from the kernel to a process, or from one process to another. They are used for various purposes, such as handling errors, responding to user input (like Ctrl+C), or inter-process &lt;strong&gt;notification&lt;/strong&gt;. When a process receives a signal, it can either handle it using a signal handler or perform a default action.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the NTFS file system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;NTFS (New Technology File System)&lt;/strong&gt; is a proprietary file system developed by Microsoft, and is the primary file system for recent versions of Windows. It offers several improvements over older file systems like FAT32, including enhanced reliability, security, and features.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of NTFS Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    +---------------------+
                    |      Boot Sector    |  (Contains boot code and metadata)
                    +---------------------+
                    |      MFT (Master    |  (Main file table, index of all files and directories)
                    |    File Table)       |
                    +---------------------+
                    |      MFT Mirror     |  (Backup of critical MFT entries for redundancy)
                    +---------------------+
                    |    System Files     |  (Metadata files like log files, volume info)
                    +---------------------+
                    |     File Area       |  (Space for file and directory content)
                    +---------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Key Components&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boot Sector&lt;/strong&gt;: The first sector of an NTFS volume, containing the &lt;strong&gt;boot code&lt;/strong&gt; used to start the operating system and metadata about the file system structure.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master File Table (MFT)&lt;/strong&gt;: The core component of NTFS. It is a &lt;strong&gt;database&lt;/strong&gt; that contains metadata about every file and directory on the volume. Each entry in the MFT, called a File Record, stores attributes like file name, size, timestamps, permissions, and data block locations. The MFT is organized as an array of File Records.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MFT Mirror&lt;/strong&gt;: A backup copy of the first few entries of the MFT, used for &lt;strong&gt;redundancy&lt;/strong&gt; and recovery in case of corruption in the primary MFT.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System Files&lt;/strong&gt;: Various metadata files used by NTFS to manage the file system, including log files for &lt;strong&gt;journaling&lt;/strong&gt;, volume information, attribute definitions, and security descriptors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;File Area&lt;/strong&gt;: The remaining space on the volume, used to store the actual &lt;strong&gt;content of files and directories&lt;/strong&gt;. NTFS uses clusters as the unit of allocation, and file data can be stored in contiguous or non-contiguous clusters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Features of NTFS&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Journaling&lt;/strong&gt;: Maintains a log of file system changes to ensure &lt;strong&gt;consistency and recoverability&lt;/strong&gt; after system crashes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Security Descriptors&lt;/strong&gt;: Supports detailed &lt;strong&gt;access control lists (ACLs)&lt;/strong&gt; for file and directory permissions, enhancing security.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Compression and Encryption&lt;/strong&gt;: Provides built-in support for file &lt;strong&gt;compression&lt;/strong&gt; and &lt;strong&gt;encryption&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Large File and Volume Sizes&lt;/strong&gt;: Supports very &lt;strong&gt;large files and volumes&lt;/strong&gt;, overcoming limitations of older file systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe single streaming batch processing as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Single streaming batch processing&lt;/strong&gt; is a simple form of batch processing where jobs are processed &lt;strong&gt;sequentially, one after another&lt;/strong&gt;, in a single stream. In this method, jobs are submitted to the system and processed in the order of submission, without any user interaction during processing. Once a job starts, it runs to completion before the next job in the queue is started. It is typically &lt;strong&gt;non-interactive&lt;/strong&gt; and suitable for tasks that can be processed in a predefined sequence without manual intervention.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Lara, a database administrator used each of the following file lock mechanisms in her design. Explain the result from each lock when enforced:&lt;/p&gt;
&lt;p&gt;(i) file lock;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) File Lock&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;When a &lt;strong&gt;file lock&lt;/strong&gt; is enforced on a file, it typically grants &lt;strong&gt;exclusive access&lt;/strong&gt; to the process that holds the lock. Other processes are prevented from accessing the file in any way that could conflict with the lock holder's operations. The exact behavior depends on the type of file lock (e.g., exclusive or shared), but generally, a file lock ensures that only one process (or a controlled group of processes for shared locks) can operate on the file at a time, preventing data corruption and ensuring consistency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Lara, a database administrator used each of the following file lock mechanisms in her design. Explain the result from each lock when enforced:&lt;/p&gt;
&lt;p&gt;(ii) write lock.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Write Lock&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;When a &lt;strong&gt;write lock&lt;/strong&gt; is enforced on a file (or a portion of a file), it prevents other processes from obtaining a write lock on the same file (or overlapping portion). Processes might still be able to obtain read locks, depending on the specific locking mechanism, but &lt;strong&gt;exclusive write access&lt;/strong&gt; is granted to the lock holder. This ensures that only one process can modify the file at any given time, preventing write-write conflicts and maintaining data integrity during updates. Other processes attempting to acquire a write lock will typically be blocked until the lock is released.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between coherency and inclusion as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cache Coherency&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache coherency&lt;/strong&gt; is concerned with maintaining &lt;strong&gt;consistency of data&lt;/strong&gt; across multiple caches in a multi-processor system. When multiple processors have caches, and they share a common memory, it is possible for different caches to hold different, potentially outdated, copies of the same data. Cache coherency protocols ensure that when one processor modifies data in its cache, all other caches that hold a copy of that data are updated or invalidated to maintain a consistent view of memory across all processors. This is critical for correct parallel program execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache Inclusion&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache inclusion&lt;/strong&gt; is a property of multi-level cache hierarchies. It dictates that the data stored in a smaller, faster cache (e.g., L1 cache) must also be present in the larger, slower cache that is higher up in the hierarchy (e.g., L2 cache). In other words, the content of the L1 cache is a &lt;strong&gt;subset of the content of the L2 cache&lt;/strong&gt;, and so on for deeper cache levels. Cache inclusion simplifies cache management and coherency protocols, as it provides a containment relationship between cache levels. However, it can also lead to some redundancy and potentially reduced cache capacity utilization.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coherency&lt;/strong&gt; is about data consistency across *multiple caches* in a multiprocessor system, ensuring all processors see the same data. &lt;strong&gt;Inclusion&lt;/strong&gt; is about the hierarchical relationship *between levels of cache* within a single processor or system, requiring data in faster caches to also be present in slower, higher-level caches.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of diagrams, describe each of the following memory allocation techniques:&lt;/p&gt;
&lt;p&gt;(i) fixed partitioned allocation;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Fixed Partitioned Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;fixed partitioned allocation&lt;/strong&gt;, main memory is divided into a &lt;strong&gt;fixed number of partitions&lt;/strong&gt; at system initialization. Each partition has a &lt;strong&gt;fixed size&lt;/strong&gt;. When a process needs to be loaded into memory, it is allocated to a partition large enough to hold it. If a partition is larger than the process, the unused space within the partition is wasted (internal fragmentation). If no partition is large enough, the process cannot be loaded.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of Fixed Partitioned Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    +-------------------+-------------------+-------------------+-------------------+
                    | Partition 1 (Size S1)| Partition 2 (Size S2)| Partition 3 (Size S3)| Partition 4 (Size S4)| ...
                    +-------------------+-------------------+-------------------+-------------------+
                    | Process A         | Process B         |  Empty            | Process C         | ...
                    +-------------------+-------------------+-------------------+-------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Memory is divided into &lt;strong&gt;static partitions&lt;/strong&gt; of predefined sizes, typically at system boot time. Partitions can be of equal or unequal sizes. Each partition can hold &lt;strong&gt;one process at a time&lt;/strong&gt;. When a process arrives, the operating system tries to find an empty partition large enough for it. If found, the process is loaded into that partition. If no suitable partition is available, the process must wait. Once a process finishes, the partition becomes available for another process. &lt;strong&gt;Internal fragmentation&lt;/strong&gt; is a key issue, as processes smaller than the partition size waste memory within the partition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;: Simple to implement, easy to manage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;: Internal fragmentation, limits degree of multiprogramming due to fixed partition count, inefficient memory utilization if partition sizes are not well-matched to process sizes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of diagrams, describe each of the following memory allocation techniques:&lt;/p&gt;
&lt;p&gt;(ii) paged allocation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Paged Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;paged allocation&lt;/strong&gt;, both main memory and processes are divided into &lt;strong&gt;fixed-size blocks&lt;/strong&gt; called &lt;strong&gt;pages&lt;/strong&gt; (for processes) and &lt;strong&gt;frames&lt;/strong&gt; (for main memory). Logical addresses are divided into page numbers and page offsets. A &lt;strong&gt;page table&lt;/strong&gt; is used to map pages of a process to frames in main memory. Pages of a process can be non-contiguous in memory, allocated to any available frames. This eliminates external fragmentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of Paged Allocation&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    Process Address Space          Main Memory (Physical Address Space)
                    +----------+                  +----------+
                    | Page 0   |                  | Frame 0  |
                    +----------+                  +----------+
                    | Page 1   | ---- Page Table ----&amp;gt; Frame 3
                    +----------+                  +----------+
                    | Page 2   |                  | Frame 1  |
                    +----------+       ...        +----------+
                    | Page 3   | ---- Page Table ----&amp;gt; Frame 5
                    +----------+                  +----------+
                                                  | Frame 2  |
                                                  +----------+
                                                  | Frame 3  | &amp;lt;--- Page 1
                                                  +----------+
                                                  | Frame 4  |
                                                  +----------+
                                                  | Frame 5  | &amp;lt;--- Page 3
                                                  +----------+
                                                     ...
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Memory is divided into fixed-size &lt;strong&gt;frames&lt;/strong&gt;, and logical address space of each process is divided into fixed-size &lt;strong&gt;pages&lt;/strong&gt;. Page and frame sizes are equal (e.g., 4KB). A process's pages can be loaded into any available frames in memory. The &lt;strong&gt;page table&lt;/strong&gt;, maintained by the operating system for each process, maps virtual page numbers to physical frame numbers. When the CPU generates a virtual address, it is translated to a physical address using the page table. &lt;strong&gt;No external fragmentation&lt;/strong&gt; occurs as memory is allocated in frame units, and pages are of fixed size. &lt;strong&gt;Internal fragmentation&lt;/strong&gt; can occur if a process's last page is not fully utilized.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;: Eliminates external fragmentation, allows non-contiguous allocation, efficient memory utilization compared to partitioning.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;: Page table overhead (memory and management), internal fragmentation within the last page, complexity in address translation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;June came across the following file name extensions during a lesson. Identify the file type for each extension:&lt;/p&gt;
&lt;p&gt;(i) .bmp&lt;/p&gt;
&lt;p&gt;(ii) .xlsx&lt;/p&gt;
&lt;p&gt;(iii) .rar&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;(i) &lt;strong&gt;.bmp&lt;/strong&gt;: &lt;strong&gt;Bitmap Image File&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(ii) &lt;strong&gt;.xlsx&lt;/strong&gt;: &lt;strong&gt;Microsoft Excel Open XML Spreadsheet File&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(iii) &lt;strong&gt;.rar&lt;/strong&gt;: &lt;strong&gt;RAR Archive File (Compressed Archive)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (iv) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;June came across the following file name extensions during a lesson. Identify the file type for each extension:&lt;/p&gt;
&lt;p&gt;(iv) .exe&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;(iv) &lt;strong&gt;.exe&lt;/strong&gt;: &lt;strong&gt;Executable File&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (4marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Jeremy prefers the online method when storing his company's files. Outline two reasons for his preference.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Accessibility and Remote Access&lt;/strong&gt;: Online storage enables &lt;strong&gt;access to files from anywhere with an internet connection&lt;/strong&gt;, using various devices (computers, smartphones, tablets). This facilitates remote work, collaboration, and access to company data while traveling or from different locations. It enhances flexibility and accessibility for employees.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Backup and Disaster Recovery&lt;/strong&gt;: Online storage solutions often include &lt;strong&gt;automatic backup and data redundancy features&lt;/strong&gt;. Files are typically stored in geographically distributed data centers, providing protection against data loss due to hardware failures, local disasters (fire, flood), or theft. This ensures business continuity and data security, offering a robust disaster recovery solution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four criteria that could be used when choosing a scheduling algorithm for an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Utilization&lt;/strong&gt;: Aim to &lt;strong&gt;maximize CPU utilization&lt;/strong&gt;, keeping the CPU as busy as possible to execute processes. A good scheduling algorithm should minimize CPU idle time and ensure that the processor is actively working on tasks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Throughput&lt;/strong&gt;: Maximize the &lt;strong&gt;number of processes completed per unit of time&lt;/strong&gt;. Higher throughput indicates that the system is efficiently processing tasks. The scheduling algorithm should strive to complete as many jobs as possible in a given timeframe.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Turnaround Time&lt;/strong&gt;: Minimize the &lt;strong&gt;total time taken for a process to complete execution&lt;/strong&gt;, from submission to completion. Shorter turnaround times improve user experience and system responsiveness. This includes waiting time, execution time, and I/O time.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Response Time&lt;/strong&gt;: Minimize the &lt;strong&gt;time it takes for a process to produce its first response&lt;/strong&gt;, especially important for interactive systems. Quick response times enhance user satisfaction. This is particularly relevant for time-sharing systems where users expect immediate feedback.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Purity prefers the command line user interface over the GUI for her computer. Explain three reasons for this preference.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficiency and Speed&lt;/strong&gt;: Command Line Interfaces (CLIs) are often &lt;strong&gt;more efficient and faster&lt;/strong&gt; for many tasks, especially for experienced users. Commands can be executed quickly with minimal overhead, bypassing the graphical rendering and resource consumption of a GUI. For repetitive tasks or system administration, CLI commands can be significantly faster than navigating through graphical menus and windows.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Scripting and Automation&lt;/strong&gt;: CLIs are highly scriptable, allowing users to &lt;strong&gt;automate complex tasks&lt;/strong&gt; by writing scripts (e.g., bash scripts, PowerShell scripts). These scripts can combine multiple commands and logic to perform batch operations, system maintenance, or customized workflows. Automation through scripting is much more powerful and flexible in a CLI compared to GUIs.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Lower Resource Consumption&lt;/strong&gt;: CLIs generally consume &lt;strong&gt;fewer system resources&lt;/strong&gt; (CPU, memory, and disk space) compared to Graphical User Interfaces (GUIs). CLIs are text-based and do not require the overhead of rendering graphics, windows, and visual elements. This makes CLIs ideal for systems with limited resources or for tasks where resource efficiency is critical, such as servers or embedded systems. Using CLI can improve system performance and responsiveness, especially on older or less powerful hardware.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between reusable and consumable resources as used in inter-process communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Reusable Resources&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reusable resources&lt;/strong&gt; are resources that can be &lt;strong&gt;used by only one process at a time&lt;/strong&gt; and can be reused by another process after the current process is finished using it. These resources are not depleted or destroyed by use. Examples include &lt;strong&gt;CPU time&lt;/strong&gt;, &lt;strong&gt;memory&lt;/strong&gt;, &lt;strong&gt;files&lt;/strong&gt;, &lt;strong&gt;printers&lt;/strong&gt;, and &lt;strong&gt;database connections&lt;/strong&gt;. Processes request and are granted exclusive access to reusable resources, use them, and then release them, making them available for other processes. Improper management of reusable resources can lead to deadlocks if processes hold onto resources and prevent others from accessing them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consumable Resources&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consumable resources&lt;/strong&gt; are resources that are &lt;strong&gt;created by one process and consumed by another process&lt;/strong&gt;. Once a consumable resource is used, it is no longer available. Examples include &lt;strong&gt;messages in a message queue&lt;/strong&gt;, &lt;strong&gt;signals&lt;/strong&gt;, &lt;strong&gt;interrupts&lt;/strong&gt;, and &lt;strong&gt;data in a buffer&lt;/strong&gt;. A producer process creates consumable resources, and a consumer process uses them up. Consumable resources are typically used for synchronization and communication between processes. Mismanagement of consumable resources can lead to process starvation if producers do not create enough resources for consumers or if resources are lost.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The key difference is in their lifecycle and usage. &lt;strong&gt;Reusable resources&lt;/strong&gt; are persistent and shared among processes over time, while &lt;strong&gt;consumable resources&lt;/strong&gt; are transient, created by one process and used up by another, serving as a means of communication or signaling between processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain three reasons that could cause a process to be suspended.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;I/O Wait or Event Wait&lt;/strong&gt;: A process may be suspended when it needs to perform an &lt;strong&gt;I/O operation&lt;/strong&gt; (e.g., read from disk, receive network data) or &lt;strong&gt;wait for a specific event&lt;/strong&gt; to occur (e.g., user input, signal from another process). During these wait states, the process cannot continue executing because it is waiting for an external operation to complete. The operating system suspends the process to free up the CPU for other ready processes and will resume it when the I/O operation is complete or the event has occurred. This is a common reason for process suspension in multitasking systems to improve CPU utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Preemption by Scheduler&lt;/strong&gt;: In preemptive scheduling systems, the operating system can &lt;strong&gt;interrupt a running process&lt;/strong&gt; and suspend it to allow another process to run. This is typically done based on scheduling algorithms (e.g., round robin, priority scheduling) to ensure fairness, responsiveness, or priority enforcement. Processes may be preempted when their time slice expires, a higher-priority process becomes ready, or to maintain system responsiveness. Suspension due to preemption is a normal part of process scheduling and multitasking.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;User Request or System Call&lt;/strong&gt;: A process can be suspended due to an &lt;strong&gt;explicit request from the user&lt;/strong&gt; or through a &lt;strong&gt;system call&lt;/strong&gt;. For example, a user might pause a process using a command (e.g., Ctrl+Z in Unix-like systems), or a process might voluntarily suspend itself by making a system call (e.g., `sleep()` or `wait()`). User-initiated suspension can be for debugging, pausing execution, or managing process flow. System-call based suspension is often used for synchronization or when a process needs to wait for a specific condition before proceeding.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;List four examples of utility programs used in computers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Antivirus Software&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Disk Defragmentation Tool&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Backup and Restore Utility&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;File Manager (e.g., Windows Explorer, Finder)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between spatial locality and sequential locality as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Spatial Locality&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spatial locality&lt;/strong&gt; refers to the tendency of a processor to access memory locations that are &lt;strong&gt;physically close to each other&lt;/strong&gt; in memory. If a program accesses a particular memory location, there is a high probability that it will soon access nearby memory locations. This is often observed when accessing data structures like arrays or sequential blocks of code. Cache memory exploits spatial locality by fetching blocks of data (cache lines) that are larger than the immediate request, anticipating that nearby data will be needed soon.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequential Locality (Temporal Locality)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequential locality&lt;/strong&gt;, more accurately termed &lt;strong&gt;temporal locality&lt;/strong&gt;, refers to the tendency of a processor to &lt;strong&gt;re-access memory locations that have been recently accessed&lt;/strong&gt;. If a program accesses a particular memory location at one point in time, there is a high probability that it will access the same location again in the near future. This is common in loops, function calls, and repeated use of variables. Cache memory leverages temporal locality by keeping recently accessed data in the cache, so that subsequent accesses to the same data are faster.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spatial locality&lt;/strong&gt; is about accessing *nearby* memory locations, while &lt;strong&gt;temporal locality&lt;/strong&gt; is about *re-accessing* the *same* memory locations *over time*. Both types of locality are fundamental principles that cache memory and other memory management techniques exploit to improve performance by reducing memory access latency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following terms as used in file management:&lt;/p&gt;
&lt;p&gt;(i) alias file names;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Alias File Names&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alias file names&lt;/strong&gt;, also known as &lt;strong&gt;shortcuts&lt;/strong&gt; or &lt;strong&gt;links&lt;/strong&gt;, are alternative names or pointers that refer to an existing file or directory. They provide a way to access a file using a different name or from a different location in the directory structure, without duplicating the file itself. Alias file names are used for &lt;strong&gt;convenience&lt;/strong&gt;, organization, and to provide multiple access paths to the same data. Changes made through an alias affect the original file.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following terms as used in file management:&lt;/p&gt;
&lt;p&gt;(ii) pathnames.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Pathnames&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pathnames&lt;/strong&gt; are strings that specify the &lt;strong&gt;location of a file or directory&lt;/strong&gt; within a file system's directory hierarchy. A pathname describes the sequence of directories to traverse from a starting point (usually the root directory or the current working directory) to reach the target file or directory. Pathnames can be &lt;strong&gt;absolute&lt;/strong&gt; (starting from the root) or &lt;strong&gt;relative&lt;/strong&gt; (starting from the current directory) and use delimiters (like '/' in Unix or '\' in Windows) to separate directory names in the path.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Joss used the RAID and disk caching to help improve the performance of the disk. Describe each of these techniques as used in file management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;RAID (Redundant Array of Independent Disks)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RAID&lt;/strong&gt; is a data storage virtualization technology that combines multiple physical disk drives into a single logical unit for &lt;strong&gt;improved performance, redundancy, or both&lt;/strong&gt;. Different RAID levels (RAID 0, 1, 5, 10, etc.) offer various combinations of striping (data distribution across disks for performance), mirroring (data duplication for redundancy), and parity (error correction). RAID can enhance disk I/O performance by parallelizing read/write operations across multiple disks and improve data reliability by providing fault tolerance in case of disk failures. RAID is used to boost disk subsystem performance and data availability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk Caching&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk caching&lt;/strong&gt; is a technique that uses a portion of &lt;strong&gt;fast memory (cache)&lt;/strong&gt;, typically RAM, to store frequently accessed data from the disk. When a read request is made, the system first checks the cache. If the data is found in the cache (cache hit), it is served from the faster cache memory, significantly reducing access time. If not found (cache miss), the data is read from the slower disk and also placed in the cache for future accesses (cache fill). Disk caching exploits temporal locality to improve disk access performance by reducing the number of physical disk I/O operations. It is a key technique for speeding up file system operations and application loading times.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the structure of the I/O control system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;I/O control system&lt;/strong&gt; in an operating system is structured in layers to manage communication between applications and hardware devices. It typically involves several layers of software and hardware components working together.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of I/O Control System Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    +-----------------------+     User Applications
                    | User-Level I/O        |     (e.g., File I/O, Network Sockets)
                    +-----------------------+
                               ^ System Calls
                               |
                    +-----------------------+     Operating System Kernel
                    | Kernel I/O Subsystem  |     (e.g., File System, Network Stack)
                    +-----------------------+
                               ^ Device Driver Interface
                               |
                    +-----------------------+     Device Drivers
                    | Device Drivers        |     (Specific to Hardware Devices)
                    +-----------------------+
                               ^ Hardware Commands
                               |
                    +-----------------------+     I/O Hardware Controllers
                    | I/O Controllers       |     (e.g., Disk Controller, Network Interface Card)
                    +-----------------------+
                               ^ Physical Signals
                               |
                    +-----------------------+     I/O Devices
                    | I/O Devices           |     (e.g., Hard Disk, Network Card, Keyboard)
                    +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Layers&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User-Level I/O&lt;/strong&gt;: This is the &lt;strong&gt;highest layer&lt;/strong&gt;, where user applications interact with the I/O system. Applications use &lt;strong&gt;system calls&lt;/strong&gt; (e.g., `read()`, `write()`, `open()`) to request I/O operations in a device-independent manner. This layer provides a high-level abstraction of I/O operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kernel I/O Subsystem&lt;/strong&gt;: This layer resides within the operating system &lt;strong&gt;kernel&lt;/strong&gt; and provides core I/O services. It includes components like the &lt;strong&gt;file system&lt;/strong&gt;, &lt;strong&gt;network stack&lt;/strong&gt;, and &lt;strong&gt;device management&lt;/strong&gt;. It translates user-level I/O requests into device-specific commands and manages buffering, caching, and scheduling of I/O operations. This layer provides device independence and resource management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device Drivers&lt;/strong&gt;: &lt;strong&gt;Device drivers&lt;/strong&gt; are software modules that are &lt;strong&gt;specific to each type of hardware device&lt;/strong&gt;. They act as an interface between the kernel I/O subsystem and the hardware controllers. Device drivers translate generic I/O requests from the kernel into device-specific commands that the hardware controller can understand. They handle low-level device control, interrupt handling, and data transfer protocols. Each device type typically requires its own driver.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O Controllers&lt;/strong&gt;: &lt;strong&gt;I/O controllers&lt;/strong&gt; are hardware components that manage the physical I/O devices. Examples include &lt;strong&gt;disk controllers&lt;/strong&gt;, &lt;strong&gt;network interface cards (NICs)&lt;/strong&gt;, and &lt;strong&gt;USB controllers&lt;/strong&gt;. They interpret commands from device drivers and control the operation of the actual I/O devices. Controllers handle data transfer, error detection, and hardware-level device management. They communicate with the CPU and memory via system buses.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O Devices&lt;/strong&gt;: These are the &lt;strong&gt;physical hardware devices&lt;/strong&gt; themselves, such as &lt;strong&gt;hard disks&lt;/strong&gt;, &lt;strong&gt;network cards&lt;/strong&gt;, &lt;strong&gt;keyboards&lt;/strong&gt;, &lt;strong&gt;printers&lt;/strong&gt;, etc. They perform the actual I/O operations (data storage, communication, input/output). Devices are controlled by I/O controllers based on commands from the device drivers.&lt;/p&gt;
&lt;p&gt;This layered structure provides modularity, device independence, and abstraction, making it easier to manage and extend the I/O system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(i) thrashing;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Thrashing&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thrashing&lt;/strong&gt; is a performance problem in virtual memory systems that occurs when a system spends most of its time &lt;strong&gt;paging&lt;/strong&gt; data between main memory and secondary storage, rather than performing useful computation. It happens when the degree of multiprogramming is too high, and processes do not have enough frames in memory to meet their working set requirements. This leads to excessive page faults, disk I/O, and a significant decrease in system throughput and CPU utilization. The system becomes bogged down in paging activity.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(ii) starvation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Starvation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Starvation&lt;/strong&gt; in operating systems, particularly in process scheduling and resource allocation, refers to a situation where a process is &lt;strong&gt;indefinitely denied access to the resources&lt;/strong&gt; it needs to make progress, even though the resources are not deadlocked and are potentially available. Starvation can occur in priority scheduling if low-priority processes are continuously preempted by high-priority processes, or in resource allocation if a process is repeatedly passed over in favor of others. It results in &lt;strong&gt;indefinite postponement&lt;/strong&gt; of a process's execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the round robin scheduling algorithm as used in computer operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Round Robin Scheduling Algorithm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Round Robin (RR)&lt;/strong&gt; is a preemptive CPU scheduling algorithm designed for time-sharing systems. It gives each process a fixed amount of CPU time, called a &lt;strong&gt;time slice or quantum&lt;/strong&gt;. Processes are placed in a &lt;strong&gt;ready queue&lt;/strong&gt;. The scheduler selects the first process from the ready queue, allocates the CPU to it for one time quantum. If the process does not complete within the time quantum, it is preempted and moved to the back of the ready queue. The scheduler then picks the next process from the front of the queue. This process repeats, giving each process a fair share of CPU time in a cyclic manner.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of Round Robin Scheduling&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    Ready Queue (FIFO)
                    +---------+   +---------+   +---------+   +---------+
                    | Process A |--&amp;gt;| Process B |--&amp;gt;| Process C |--&amp;gt;| Process D |--&amp;gt; ...
                    +---------+   +---------+   +---------+   +---------+
                        ^                                       |
                        |                                       v
                        +---------------------------------------+
                                       CPU Scheduler
                                         (Time Quantum)
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Operation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Processes are maintained in a &lt;strong&gt;ready queue&lt;/strong&gt;, typically a FIFO queue. The &lt;strong&gt;scheduler&lt;/strong&gt; selects the process at the front of the queue and dispatches it to run on the CPU for a predefined &lt;strong&gt;time quantum&lt;/strong&gt; (e.g., 10-100 milliseconds). If the process completes its execution within the time quantum, it voluntarily releases the CPU. If the process is still running when the time quantum expires, it is &lt;strong&gt;preempted&lt;/strong&gt; (interrupted), its context is saved, and it is moved to the &lt;strong&gt;back of the ready queue&lt;/strong&gt;. Then, the scheduler selects the next process from the front of the queue to run. This cycle repeats continuously. The &lt;strong&gt;time quantum&lt;/strong&gt; is a critical parameter. If it's too large, RR approaches FCFS; if too small, context switching overhead becomes significant.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantages&lt;/strong&gt;: Fair allocation of CPU time to all processes, prevents starvation, relatively easy to implement, good for time-sharing systems, provides reasonable response times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadvantages&lt;/strong&gt;: Performance depends heavily on the choice of time quantum, higher context switching overhead compared to FCFS, may have longer average turnaround time compared to algorithms that prioritize shorter jobs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following terms as used in process management:&lt;/p&gt;
&lt;p&gt;(0) race condition;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Race Condition&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;race condition&lt;/strong&gt; is a situation that occurs when the outcome of a computation depends on the &lt;strong&gt;unpredictable order of execution&lt;/strong&gt; of processes or threads, especially when they are accessing &lt;strong&gt;shared resources&lt;/strong&gt;. It arises when multiple processes access and manipulate shared data concurrently, and the final result depends on which process finishes its operation first. Race conditions can lead to inconsistent data, errors, and unpredictable behavior in concurrent systems. Synchronization mechanisms are needed to prevent race conditions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following terms as used in process management:&lt;/p&gt;
&lt;p&gt;(ii) critical section.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Critical Section&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;critical section&lt;/strong&gt; is a segment of code in a process that &lt;strong&gt;accesses shared resources&lt;/strong&gt; (e.g., shared variables, data structures, files, devices) that can be manipulated by other concurrent processes. To ensure data integrity and avoid race conditions, access to critical sections must be &lt;strong&gt;mutually exclusive&lt;/strong&gt;, meaning that only one process can execute its critical section at any given time. Synchronization mechanisms like mutexes, semaphores, or monitors are used to protect critical sections and enforce mutual exclusion.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;During an operating system lesson the teacher addressed various functions of the software clock. Explain three such functions that the teacher could have discussed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Timekeeping and System Clock&lt;/strong&gt;: The software clock is used to maintain the &lt;strong&gt;system's current time and date&lt;/strong&gt;. It keeps track of elapsed time and provides time-related services to the operating system and applications. This includes setting and getting the system time, synchronizing with external time sources (e.g., NTP servers), and providing time-based information for timestamps, logs, and scheduling.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Scheduling and Time Slicing&lt;/strong&gt;: The software clock is crucial for &lt;strong&gt;time-based process scheduling algorithms&lt;/strong&gt;, such as Round Robin. It generates periodic interrupts (timer interrupts) at regular intervals, which trigger the scheduler to preempt the currently running process and switch to another ready process. This time-slicing mechanism enables multitasking and fair CPU sharing among processes. The clock's interrupt frequency determines the granularity of time slices.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Timeouts and Delays&lt;/strong&gt;: The software clock is used to implement &lt;strong&gt;timeouts and delays&lt;/strong&gt; in various system operations and applications. Timeouts are used to limit the waiting time for events or responses, preventing processes from hanging indefinitely (e.g., network timeouts, I/O timeouts). Delays are used to introduce pauses or timing control in program execution (e.g., `sleep()` function). The clock's timer functions are used to measure elapsed time and trigger actions after a specified duration.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) device independence;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Device Independence&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device independence&lt;/strong&gt; is a principle in operating system design that aims to allow user programs to interact with I/O devices without needing to know the &lt;strong&gt;specific details of the hardware&lt;/strong&gt;. The operating system provides an &lt;strong&gt;abstract interface&lt;/strong&gt; for I/O operations, so applications can perform I/O in a generic way, regardless of the type or characteristics of the underlying hardware devices. Device drivers handle the device-specific operations, providing a layer of abstraction.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(ii) virtual device.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Virtual Device&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;virtual device&lt;/strong&gt; is an &lt;strong&gt;abstraction&lt;/strong&gt; of a physical hardware device, created by the operating system to provide enhanced functionality, sharing, or device independence. It is a &lt;strong&gt;logical device&lt;/strong&gt; that may or may not have a direct one-to-one mapping to a physical device. Virtual devices can be used for various purposes, such as printer spooling (virtual printer), disk virtualization (virtual disk), or network virtualization (virtual network interface). They provide a higher-level interface and can manage access to underlying physical resources.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the circumstance under which each of the following disk system algorithms could be applicable:&lt;/p&gt;
&lt;p&gt;(i) first come first served;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) First Come First Served (FCFS)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FCFS&lt;/strong&gt; disk scheduling algorithm is applicable in scenarios where &lt;strong&gt;simplicity and fairness&lt;/strong&gt; are prioritized over performance optimization. It is straightforward to implement and ensures that disk requests are processed in the order they arrive. FCFS can be suitable for &lt;strong&gt;lightly loaded systems&lt;/strong&gt; or where request arrival patterns are relatively random and not clustered. It is also useful as a baseline algorithm for comparison with more complex scheduling methods. However, FCFS is generally not optimal in terms of minimizing seek time and may lead to inefficient disk head movement.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the circumstance under which each of the following disk system algorithms could be applicable:&lt;/p&gt;
&lt;p&gt;(ii) shortest seek time first;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Shortest Seek Time First (SSTF)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSTF&lt;/strong&gt; disk scheduling algorithm is applicable when the primary goal is to &lt;strong&gt;minimize seek time&lt;/strong&gt; and improve disk throughput. SSTF selects the disk request that requires the minimum seek distance from the current head position. It is effective in reducing average waiting time and improving overall disk performance, especially in systems with clustered disk requests. SSTF is suitable for &lt;strong&gt;systems where performance is critical&lt;/strong&gt; and fairness is less of a concern. However, SSTF can lead to starvation for requests that are far from the current head position.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the circumstance under which each of the following disk system algorithms could be applicable:&lt;/p&gt;
&lt;p&gt;(iii) SCAN.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) SCAN Algorithm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;SCAN&lt;/strong&gt; disk scheduling algorithm is applicable when a &lt;strong&gt;balance between performance and fairness&lt;/strong&gt; is desired. SCAN moves the disk head in one direction, servicing requests along the way, and reverses direction when it reaches the end of the disk. SCAN provides better performance than FCFS and offers more fairness compared to SSTF, as it prevents starvation by servicing all requests in its path in each sweep. SCAN is suitable for &lt;strong&gt;general-purpose systems&lt;/strong&gt; where reasonable performance and prevention of starvation are important. It is a good compromise between SSTF and FCFS.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between software interrupt and trap as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Software Interrupt&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;software interrupt&lt;/strong&gt;, also known as a &lt;strong&gt;synchronous interrupt&lt;/strong&gt; or an &lt;strong&gt;exception&lt;/strong&gt;, is an interrupt that is &lt;strong&gt;generated programmatically&lt;/strong&gt; by software during the execution of a program. It is typically caused by an instruction within the program itself, such as a &lt;strong&gt;system call instruction&lt;/strong&gt; (e.g., `syscall`, `int 0x80`) or a deliberate software instruction to trigger an interrupt. Software interrupts are used by user-level programs to request services from the operating system kernel (via system calls) or to handle specific software-defined events. They are synchronous because they occur at a predictable point in the program's execution flow.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Trap (Exception)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;trap&lt;/strong&gt;, also called an &lt;strong&gt;exception&lt;/strong&gt;, is a type of synchronous interrupt that is caused by an &lt;strong&gt;error condition or an exceptional event&lt;/strong&gt; detected during program execution. Traps are typically generated by the CPU in response to events like &lt;strong&gt;division by zero&lt;/strong&gt;, &lt;strong&gt;invalid memory access&lt;/strong&gt; (segmentation fault), &lt;strong&gt;illegal instruction&lt;/strong&gt;, or &lt;strong&gt;overflow conditions&lt;/strong&gt;. Traps signal abnormal or error conditions that require special handling by the operating system. When a trap occurs, the CPU transfers control to an exception handler in the kernel to deal with the error. Traps are also synchronous as they occur as a direct result of executing a specific instruction that triggers the exceptional condition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Both software interrupts and traps are synchronous interrupts initiated during program execution, but their &lt;strong&gt;purpose and origin differ&lt;/strong&gt;. &lt;strong&gt;Software interrupts&lt;/strong&gt; are intentionally triggered by programs to request OS services (system calls), while &lt;strong&gt;traps&lt;/strong&gt; are triggered by the CPU in response to error or exceptional conditions encountered during program execution. Software interrupts are for normal service requests, whereas traps are for error handling and exception management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the function of each of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(1) relocating loader;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Relocating Loader&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;relocating loader&lt;/strong&gt; is a type of loader in operating systems that is responsible for loading a program into memory and &lt;strong&gt;adjusting (relocating) the program's addresses&lt;/strong&gt; so that it can run correctly at the loaded memory location. When a program is compiled or assembled, it is often generated with starting addresses relative to zero or a fixed address. The relocating loader modifies these addresses to match the actual memory address where the program is loaded, enabling the program to execute correctly regardless of its load address. Relocation is essential for dynamic loading and memory management in multiprogramming environments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the function of each of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(ii) job control language;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Job Control Language (JCL)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Job Control Language (JCL)&lt;/strong&gt; is a scripting language used in batch processing systems, primarily in mainframe environments, to &lt;strong&gt;control the execution of batch jobs&lt;/strong&gt;. JCL scripts specify the sequence of programs to be executed, the resources required for each job step (e.g., input files, output files, memory), and control flow logic. JCL allows users to define and automate complex batch processing workflows. It is used to manage job submission, execution, and resource allocation in batch-oriented operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the function of each of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(iii) segmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) Segmentation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Segmentation&lt;/strong&gt; is a memory management technique that divides a process's logical address space into &lt;strong&gt;logical units called segments&lt;/strong&gt;. Segments typically correspond to logical program units like code, data, and stack. Each segment is of variable size and can be placed anywhere in physical memory. Segmentation provides a structured view of memory, facilitates memory protection and sharing at the segment level, and supports logical organization of programs. However, it can suffer from external fragmentation and requires segment tables for address translation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in process management:&lt;/p&gt;
&lt;p&gt;(i) Dispatch latency;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Dispatch Latency&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch latency&lt;/strong&gt; is the time it takes for the &lt;strong&gt;scheduler to stop one process and start running another process&lt;/strong&gt;. It is the delay between the context switch and the start of execution of the newly scheduled process. Dispatch latency is a critical factor in real-time systems, where minimizing response time and ensuring timely process execution are essential. Lower dispatch latency leads to better system responsiveness and more predictable real-time behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in process management:&lt;/p&gt;
&lt;p&gt;(ii) Reschedule latency.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Reschedule Latency&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reschedule latency&lt;/strong&gt; is the total time taken for the operating system to &lt;strong&gt;respond to an event and begin executing the appropriate handler&lt;/strong&gt;. It encompasses the time from the occurrence of an event (e.g., interrupt, system call) to the point when the scheduler starts executing a new process or thread in response to that event. Reschedule latency includes interrupt handling time, context switching time, and scheduler decision time. It is a measure of the overall responsiveness of the operating system to events that require process rescheduling.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Joan came across the following DOS commands when revising for her operating systems examination.&lt;/p&gt;
&lt;p&gt;CD, DIR, FORMAT, BACKUP, RESTORE, CLS.&lt;/p&gt;
&lt;p&gt;Categorize each of them as either external or internal commands.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Internal Commands (Built-in to command processor)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CD&lt;/strong&gt; (Change Directory)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DIR&lt;/strong&gt; (Directory Listing)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLS&lt;/strong&gt; (Clear Screen)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;External Commands (Separate executable files)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FORMAT&lt;/strong&gt; (Disk Formatting)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BACKUP&lt;/strong&gt; (File Backup)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RESTORE&lt;/strong&gt; (File Restore)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between independent and cooperating process as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Independent Processes&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Independent processes&lt;/strong&gt; are processes that &lt;strong&gt;do not share data or resources&lt;/strong&gt; with other processes and do not affect or get affected by the execution of other processes in the system. They operate in isolation, with their own private address space and resources. The execution of an independent process is deterministic and predictable, as it is not influenced by external factors from other processes. Examples include simple command-line utilities or standalone applications that do not communicate with other programs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cooperating Processes&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cooperating processes&lt;/strong&gt; are processes that are designed to &lt;strong&gt;share data or resources&lt;/strong&gt; with other processes and can affect or be affected by the execution of other processes. They need to communicate and synchronize their actions to achieve a common task or goal. Cooperating processes can share memory, files, or communicate through inter-process communication (IPC) mechanisms like messages, pipes, or shared memory. Cooperation is essential for complex applications, client-server systems, and parallel processing. However, it introduces challenges related to synchronization, data consistency, and potential race conditions or deadlocks.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The primary difference is in their &lt;strong&gt;interaction and resource sharing&lt;/strong&gt;. &lt;strong&gt;Independent processes&lt;/strong&gt; operate in isolation and do not interact, while &lt;strong&gt;cooperating processes&lt;/strong&gt; share resources and communicate to work together, requiring synchronization and coordination.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between each of the following replacement policies as used in memory management:&lt;/p&gt;
&lt;p&gt;(i) least recently used;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Least Recently Used (LRU)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Least Recently Used (LRU)&lt;/strong&gt; is a page replacement policy that replaces the page that has &lt;strong&gt;not been used for the longest period&lt;/strong&gt; in the past. LRU assumes that pages that have not been accessed recently are less likely to be accessed in the near future (based on temporal locality). LRU requires keeping track of the access history of pages, typically using counters or a stack. When a page fault occurs, the page with the oldest last access time is evicted. LRU is effective in reducing page faults but can be complex and costly to implement due to the overhead of tracking page access history.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between each of the following replacement policies as used in memory management:&lt;/p&gt;
&lt;p&gt;(ii) not recently used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Not Recently Used (NRU)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Not Recently Used (NRU)&lt;/strong&gt; is a page replacement policy that replaces a page that is &lt;strong&gt;not recently used&lt;/strong&gt;. NRU is a simpler approximation of LRU and is easier to implement. NRU classifies pages into categories based on their reference bit and modified bit. Pages are considered &quot;not recently used&quot; if their reference bit is not set (indicating they haven't been referenced recently). When a page fault occurs, NRU selects a page to replace based on a priority order, favoring pages that are both not recently used and not modified. NRU has lower overhead than LRU but may have a higher page fault rate.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;During an operating systems class, Peter came across the following tile attributes. Explain the function of each of the attributes.&lt;/p&gt;
&lt;p&gt;(i) archive;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Archive Attribute&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;archive attribute&lt;/strong&gt; (often represented as 'A' or 'archive bit') is a file attribute used to indicate whether a file has been &lt;strong&gt;modified since the last backup&lt;/strong&gt;. When a file is created or modified, the archive attribute is set (turned on). Backup software typically clears (turns off) the archive attribute after backing up the file. This attribute is used by incremental backup strategies to identify files that need to be backed up because they have been changed since the last backup operation. It helps optimize backup processes by only backing up modified files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;During an operating systems class, Peter came across the following tile attributes. Explain the function of each of the attributes.&lt;/p&gt;
&lt;p&gt;(ii) hidden;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Hidden Attribute&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;hidden attribute&lt;/strong&gt; is a file attribute that makes a file or directory &lt;strong&gt;invisible&lt;/strong&gt; or less visible to users in standard file listings and graphical interfaces. Files with the hidden attribute set are typically not displayed by default in file explorers or directory listings, unless the user explicitly enables the option to show hidden files. The hidden attribute is used to &lt;strong&gt;hide system files, configuration files, or files that users are not intended to directly access or modify&lt;/strong&gt;, helping to reduce clutter and prevent accidental changes to important files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;During an operating systems class, Peter came across the following tile attributes. Explain the function of each of the attributes.&lt;/p&gt;
&lt;p&gt;(iii) system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(iii) System Attribute&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;system attribute&lt;/strong&gt; is a file attribute that marks a file as a &lt;strong&gt;critical system file&lt;/strong&gt;. Files with the system attribute set are typically essential for the operating system's proper functioning. Like hidden files, system files are usually not displayed by default and are protected from accidental deletion or modification. The system attribute indicates that the file is an &lt;strong&gt;integral part of the operating system&lt;/strong&gt; and should not be tampered with by users. Modifying or deleting system files can lead to system instability or failure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) address translation;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Address Translation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Address translation&lt;/strong&gt;, also known as address mapping, is the process of &lt;strong&gt;converting a virtual address to a physical address&lt;/strong&gt; in memory management systems that use virtual memory. The CPU generates virtual addresses, which are logical addresses used by processes. The memory management unit (MMU) in the hardware, with the help of the operating system, translates these virtual addresses into physical addresses, which correspond to the actual locations in physical RAM. Address translation is essential for virtual memory, memory protection, and address space management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(ii) address exception.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(ii) Address Exception&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;address exception&lt;/strong&gt;, also known as a &lt;strong&gt;memory access violation&lt;/strong&gt; or a &lt;strong&gt;page fault&lt;/strong&gt; in virtual memory systems, is an exception that occurs when a process attempts to access a &lt;strong&gt;virtual memory address that is invalid or not currently mapped to physical memory&lt;/strong&gt;. This can happen if the virtual address is outside the process's allocated address space, refers to a protected memory region, or corresponds to a page that is not present in physical RAM (and needs to be fetched from disk). Address exceptions are handled by the operating system, which may terminate the process (in case of invalid access) or handle page faults by loading the required page from secondary storage into memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the message passing as used in inter process communication.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Message Passing for Inter-Process Communication (IPC)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message passing&lt;/strong&gt; is an inter-process communication (IPC) mechanism where processes communicate by &lt;strong&gt;sending and receiving messages&lt;/strong&gt;. Processes do not share memory directly. Communication is achieved through system calls provided by the operating system kernel. Messages are typically sent through communication channels or queues managed by the kernel. Message passing can be synchronous (blocking send/receive) or asynchronous (non-blocking send/receive).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conceptual Diagram of Message Passing&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    Process A                 Operating System Kernel                Process B
                    +---------+             +-----------------------+             +---------+
                    |         | Send        |                       | Receive     |         |
                    |         +-----------&amp;gt;| Message Queue/Channel |&amp;lt;-----------+         |
                    |         |             |                       |             |         |
                    +---------+             +-----------------------+             +---------+
                                                 (Manages Messages)
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Operation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Send Operation&lt;/strong&gt;: A &lt;strong&gt;sender process&lt;/strong&gt; (e.g., Process A) prepares a &lt;strong&gt;message&lt;/strong&gt; containing data to be communicated and uses a &lt;strong&gt;send system call&lt;/strong&gt; to send the message. The message is passed to the operating system kernel, which places it in a &lt;strong&gt;message queue or channel&lt;/strong&gt; associated with the destination process (e.g., Process B).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Receive Operation&lt;/strong&gt;: A &lt;strong&gt;receiver process&lt;/strong&gt; (e.g., Process B) uses a &lt;strong&gt;receive system call&lt;/strong&gt; to retrieve messages. The kernel checks the message queue for messages addressed to the receiver process. If a message is available, the kernel retrieves it from the queue, copies the message data to the receiver process's address space, and returns control to the receiver process. If no message is available, the receiver process may be blocked (in synchronous receive) or continue execution (in asynchronous receive).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Features&lt;/strong&gt;: No shared memory, communication via messages, kernel mediates communication, can be synchronous or asynchronous. Message passing is suitable for both shared-memory and distributed systems and provides a structured and controlled way for processes to exchange information.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;During revision for an operating systems paper, ken came across the term metaphors. Outline two functions of this facility.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Simplifying User Interaction and Understanding&lt;/strong&gt;: Metaphors in operating systems, especially in user interfaces (GUIs), are used to &lt;strong&gt;represent complex concepts and functionalities in a more intuitive and user-friendly way&lt;/strong&gt;. By using familiar real-world analogies (like &quot;desktop,&quot; &quot;folder,&quot; &quot;trash can,&quot; &quot;windows&quot;), metaphors make it easier for users to understand and interact with abstract computer concepts. They reduce the cognitive load and learning curve for users, especially for non-technical users, by relating unfamiliar digital entities to recognizable physical objects and actions.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhancing Usability and Learnability&lt;/strong&gt;: Metaphors contribute to &lt;strong&gt;improved usability and learnability&lt;/strong&gt; of operating systems. They provide a consistent and predictable mental model for users to navigate and operate the system. By leveraging existing knowledge and experiences from the real world, metaphors make it easier for users to discover and use system features. They promote intuitive interaction, reduce the need for extensive training, and make the system more accessible to a wider range of users. Metaphors help bridge the gap between the technical complexity of the operating system and the user's conceptual understanding.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (9 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure I shows a variable memory partition of the sizes in the order as indicated.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-15-07_2013nov.pdf.png&quot; alt=&quot;&quot; width=&quot;882&quot; height=&quot;144&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure1_q8d.png&quot; alt=&quot;Figure 1 Memory Partition Diagram&quot; /&gt;
&lt;p&gt;Assume that a new process of size 42KB is to be loaded in the partition, use sketch diagrams to show how the operating system would fit the new process using each of the following placement methods:&lt;/p&gt;
&lt;p&gt;(i) best fit method;&lt;/p&gt;
&lt;p&gt;(ii) worst fit method;&lt;/p&gt;
&lt;p&gt;(iii) first fit method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Best Fit Method&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;best fit&lt;/strong&gt; method selects the &lt;strong&gt;smallest partition that is large enough&lt;/strong&gt; to accommodate the process. In this case, the partitions are 40KB, 25KB, 50KB, 70KB, 25KB. The 42KB process can fit in the 50KB and 70KB partitions. The &lt;strong&gt;50KB partition is the best fit&lt;/strong&gt; as it leaves the smallest remaining fragment (8KB).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram for Best Fit&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    Initial Partitions:  [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Free   Free

                    Process Size:        42KB

                    Best Fit Allocation: [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Used   Free   Free
                                                 Process
                                                 [42KB]
                                        Fragment: 50KB - 42KB = 8KB
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(ii) Worst Fit Method&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;worst fit&lt;/strong&gt; method selects the &lt;strong&gt;largest available partition&lt;/strong&gt; to allocate the process. In this case, the largest partition is 70KB. Allocating the 42KB process to the 70KB partition leaves the &lt;strong&gt;largest remaining fragment&lt;/strong&gt; (28KB).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram for Worst Fit&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    Initial Partitions:  [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Free   Free

                    Process Size:        42KB

                    Worst Fit Allocation:[40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Used   Free
                                                     Process
                                                     [42KB]
                                        Fragment: 70KB - 42KB = 28KB
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(iii) First Fit Method&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;first fit&lt;/strong&gt; method selects the &lt;strong&gt;first partition encountered that is large enough&lt;/strong&gt; to hold the process. Scanning the partitions in order (40KB, 25KB, 50KB, 70KB, 25KB), the &lt;strong&gt;first partition large enough is the 50KB partition&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram for First Fit&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;                    Initial Partitions:  [40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Free   Free   Free

                    Process Size:        42KB

                    First Fit Allocation:[40KB] [25KB] [50KB] [70KB] [25KB]
                                        Free   Free   Used   Free   Free
                                                 Process
                                                 [42KB]
                                        Fragment: 50KB - 42KB = 8KB
                    &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 [Your University/College Name]&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="273"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="14_136_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="73">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="70"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-15-07_2013nov.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-15-07_2013nov.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="3da98790c8299dd3a39edaab9229f9a1"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="71"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="71"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="1"></int>
              <string role="key" value="parentNode"></string>
              <reference key="72"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="14"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="72"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="73"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="14"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202013"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="76">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2013"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="74">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="75">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="137_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="74"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2013&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain cach of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(i) caching:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Caching&lt;/strong&gt; in memory management is a technique used to improve system performance by storing frequently accessed data in a &lt;strong&gt;smaller, faster memory&lt;/strong&gt; called a &lt;strong&gt;cache&lt;/strong&gt;. When the CPU needs to access data, it first checks the cache. If the data is present (a &lt;strong&gt;cache hit&lt;/strong&gt;), it is accessed from the cache, which is much faster than accessing main memory. If the data is not in the cache (a &lt;strong&gt;cache miss&lt;/strong&gt;), it is retrieved from main memory and also copied into the cache for future accesses. Caching leverages the principle of locality to reduce average memory access time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain cach of the following terms as used in memory management:&lt;/p&gt;
&lt;p&gt;(ii) trashing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Thrashing&lt;/strong&gt; in memory management is a state where the system spends most of its time &lt;strong&gt;swapping pages&lt;/strong&gt; between main memory and secondary storage (disk), with very little productive work being done. This occurs when the degree of multiprogramming is too high, and processes do not have enough physical memory to hold their working sets. As a result, excessive page faults occur, leading to high disk I/O activity and a significant decrease in system performance and CPU utilization. The system becomes inefficient as it is constantly busy swapping pages rather than executing processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Two processes A and B are to be executed in a uni-processor computer. When one of the processes is being executed the other cannot proceed because of common set of data.&lt;/p&gt;
&lt;p&gt;(i) Describe the section of memory depicted in the scenario.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The section of memory depicted in the scenario is the &lt;strong&gt;critical section&lt;/strong&gt;. This is a segment of code that accesses &lt;strong&gt;shared resources&lt;/strong&gt;, in this case, a &quot;common set of data&quot;. When one process (A or B) is executing within its critical section, accessing and potentially modifying the shared data, the other process is prevented from entering its own critical section that operates on the same data. This mutual exclusion ensures that &lt;strong&gt;data consistency is maintained&lt;/strong&gt; and race conditions are avoided. Only one process can be active in the critical section at any given time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Two processes A and B are to be executed in a uni-processor computer. When one of the processes is being executed the other cannot proceed because of common set of data.&lt;/p&gt;
&lt;p&gt;(ii) A student observed that each time the processes were executed, different results were produced. Describe the condition that could lead to this observation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The condition that could lead to different results each time the processes are executed is a &lt;strong&gt;race condition&lt;/strong&gt;. This occurs when the &lt;strong&gt;outcome of the execution depends on the specific order&lt;/strong&gt; in which the instructions from processes A and B are interleaved when accessing and manipulating the shared data in the critical section. If the processes are not properly synchronized, the final value of the shared data can vary depending on which process completes its operations first or which process's instructions are executed at a particular moment. This &lt;strong&gt;unpredictability&lt;/strong&gt; in execution order results in &lt;strong&gt;inconsistent and variable outputs&lt;/strong&gt; across different runs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the two-level directory logical structure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;two-level directory structure&lt;/strong&gt; is a file system organization method that introduces a hierarchy to manage files, overcoming limitations of a single-level directory. It consists of a &lt;strong&gt;root directory&lt;/strong&gt; and &lt;strong&gt;user directories&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Two-Level Directory Structure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    +-------------------+
                    |    Root Directory   |
                    +-------------------+
                    |       / \         |
                    |        |          |
                    +--------+----------+
                    | User Directory 1 |  User Directory 2  |  User Directory 3 ...
                    +-------------------+-------------------+-------------------
                    | File 1.1 | File 1.2 |  File 2.1 | File 2.2 |  File 3.1 ...
                    +----------+----------+----------+----------+----------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At the top is the &lt;strong&gt;root directory&lt;/strong&gt;, which is the main directory. Underneath the root directory, each user has their own &lt;strong&gt;user directory&lt;/strong&gt;. Each user directory acts as a private directory for that specific user, containing all of their files. Users can create, delete, and manage their files within their own user directories. File names only need to be unique within each user directory, resolving naming conflicts that occur in single-level directories. To access a file, a &lt;strong&gt;two-part path name&lt;/strong&gt; is used, specifying the user directory and the file name (e.g., /UserDir/FileName). This structure provides better organization and isolation compared to a single flat directory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(i) Outline two functions of the clock software as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Timekeeping&lt;/strong&gt;: The clock software is responsible for maintaining the &lt;strong&gt;current time and date&lt;/strong&gt; of the system. It updates the system clock at regular intervals based on hardware timer interrupts. This function is crucial for providing timestamps for files, scheduling events, and tracking system uptime.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Scheduling&lt;/strong&gt;: The clock software is used for &lt;strong&gt;time-slicing in preemptive scheduling algorithms&lt;/strong&gt; like Round Robin. It generates timer interrupts that signal the operating system to switch between processes, ensuring fair CPU allocation and enabling multitasking. The timer interrupts trigger the scheduler to regain control and allocate the CPU to another process, preventing any single process from monopolizing the CPU.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between dumb and intelligent terminal as used in computer hardware.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Dumb Terminal&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;dumb terminal&lt;/strong&gt; is a basic type of terminal that primarily functions as an &lt;strong&gt;input/output device&lt;/strong&gt;. It has very limited processing capabilities and relies entirely on a host computer for processing. Dumb terminals can send user input (keyboard strokes) to the host and display output (text and simple graphics) received from the host. They lack local processing power, memory, and storage. Examples include older text-based terminals used with mainframe computers. &lt;strong&gt;Key features&lt;/strong&gt;: Low cost, simple functionality, no local processing, relies on host for all operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Intelligent Terminal&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;intelligent terminal&lt;/strong&gt;, also known as a smart terminal, has its own &lt;strong&gt;processing capabilities&lt;/strong&gt;, memory, and can perform some processing tasks independently of the host computer. Unlike dumb terminals, intelligent terminals can execute some applications locally, perform data validation, or format data before sending it to the host. They can also store data and run simple programs. Modern personal computers can act as intelligent terminals when connected to a server. &lt;strong&gt;Key features&lt;/strong&gt;: Higher cost, local processing power, memory, can run applications independently, reduces load on host, more functionality compared to dumb terminals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Difference&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference is in their &lt;strong&gt;processing capability&lt;/strong&gt;. Dumb terminals are essentially just display and input devices with no local processing, while intelligent terminals have their own processing power and can perform tasks independently, reducing the workload on the central host computer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(i) time sharing;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Time sharing&lt;/strong&gt; is an operating system technique that allows &lt;strong&gt;multiple users to simultaneously share a computer system&lt;/strong&gt;. It achieves this by rapidly switching the CPU between different processes, giving each user a small time slice of CPU time. This creates the illusion that each user has exclusive use of the computer, even though they are all using the same system concurrently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(ii) system call;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;system call&lt;/strong&gt; is a &lt;strong&gt;request from a user-level process to the operating system kernel&lt;/strong&gt; to perform a privileged operation. It is the interface through which processes can request services from the kernel, such as I/O operations, process management, and memory allocation. System calls are essential for user programs to interact with the operating system and access system resources in a controlled and secure manner.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (iii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;(iii) thread.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;thread&lt;/strong&gt; is a &lt;strong&gt;lightweight unit of execution within a process&lt;/strong&gt;. It is a single sequential flow of control within a program. Multiple threads can exist within the same process and share the process's resources such as memory space, code, and data segments. Threads enable concurrency within a process, allowing for parallel execution of different parts of a program and improving responsiveness and efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A hard disk with 255 tracks received requests from the disk controller for data in tracks 40, 67, 11, 240 and 87 in that order respectively. Assuming the head is currently located at track 45.&lt;/p&gt;
&lt;p&gt;(i) Sketch the order in which C-SCAN scheduling algorithm will service the requests.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;C-SCAN (Circular SCAN)&lt;/strong&gt; algorithm services requests by moving the disk head in one direction (e.g., from lower to higher track numbers), servicing requests along the path. When it reaches the highest track, it quickly returns to the lowest track without servicing any requests and starts scanning again in the same direction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Initial Head Position:&lt;/strong&gt; 45&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Requests:&lt;/strong&gt; 40, 67, 11, 240, 87&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tracks in order (ascending):&lt;/strong&gt; 11, 40, 67, 87, 240&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C-SCAN Service Order Sketch:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    Head movement direction: Ascending track numbers

                    1. Start at 45. Move upwards servicing requests in order:
                       - Service 67 (Track 67)
                       - Service 87 (Track 87)
                       - Service 240 (Track 240)

                    2. Reach highest track (255). Rapidly return to lowest track (0) without servicing.

                    3. Start scanning upwards again from lowest track (0), servicing remaining requests:
                       - Service 11 (Track 11)
                       - Service 40 (Track 40)

                    C-SCAN Service Order: 67 -&amp;gt; 87 -&amp;gt; 240 -&amp;gt; (Return to 0) -&amp;gt; 11 -&amp;gt; 40
                    &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A hard disk with 255 tracks received requests from the disk controller for data in tracks 40, 67, 11, 240 and 87 in that order respectively. Assuming the head is currently located at track 45.&lt;/p&gt;
&lt;p&gt;(ii) Determine the total seek distance in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on the C-SCAN service order determined in (i): 67 -&amp;gt; 87 -&amp;gt; 240 -&amp;gt; (Return to 0) -&amp;gt; 11 -&amp;gt; 40&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek Distances Calculation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. From 45 to 67: |67 - 45| = 22 tracks&lt;/p&gt;
&lt;p&gt;2. From 67 to 87: |87 - 67| = 20 tracks&lt;/p&gt;
&lt;p&gt;3. From 87 to 240: |240 - 87| = 153 tracks&lt;/p&gt;
&lt;p&gt;4. From 240 to 0 (Return to track 0): |0 - 240| = 240 tracks&lt;/p&gt;
&lt;p&gt;5. From 0 to 11: |11 - 0| = 11 tracks&lt;/p&gt;
&lt;p&gt;6. From 11 to 40: |40 - 11| = 29 tracks&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Total Seek Distance:&lt;/strong&gt; 22 + 20 + 153 + 240 + 11 + 29 = &lt;strong&gt;475 tracks&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Two processes Pl and P2 are running in a CPU as outlined:&lt;/p&gt;
&lt;p&gt;- P1 requests for a resource R1 and P2 requests for a resource R2. Both the resources are available and they are allocated to the requesting process.&lt;/p&gt;
&lt;p&gt;- Later process P1 requests for R2 held by P2 and P2 requests for R1 held by P1.&lt;/p&gt;
&lt;p&gt;(i) Draw a resource allocation graph to represent this scenario.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Resource Allocation Graph:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    Processes: P1, P2
                    Resources: R1, R2

                    Nodes:
                    - Circles represent processes (P1, P2)
                    - Squares represent resources (R1, R2)

                    Edges:
                    - Request edge: Process -&amp;gt; Resource (e.g., P1 -&amp;gt; R2 means P1 is requesting R2)
                    - Allocation edge: Resource -&amp;gt; Process (e.g., R1 -&amp;gt; P1 means R1 is allocated to P1)

                    Graph:

                    +-----+      +-----+
                    |  R1 |-----&amp;gt;|  P1 |-------&amp;gt;|  R2 |
                    +-----+      +-----+      +-----+
                                    ^            |
                                    |            |
                                    +------------+
                                    Request Edge (P2 requesting R1)

                    Legend:
                    -----&amp;gt; Allocation Edge
                    -------&amp;gt; Request Edge
                    &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Two processes Pl and P2 are running in a CPU as outlined:&lt;/p&gt;
&lt;p&gt;- P1 requests for a resource R1 and P2 requests for a resource R2. Both the resources are available and they are allocated to the requesting process.&lt;/p&gt;
&lt;p&gt;- Later process P1 requests for R2 held by P2 and P2 requests for R1 held by P1.&lt;/p&gt;
&lt;p&gt;(ii) State the condition depicted by the graph in (1).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The condition depicted by the graph in (i) is &lt;strong&gt;deadlock&lt;/strong&gt;. The graph shows a &lt;strong&gt;circular wait&lt;/strong&gt; condition: P1 is waiting for R2 which is held by P2, and P2 is waiting for R1 which is held by P1. This creates a cycle of dependencies where neither process can proceed, resulting in a deadlock situation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A student created a file in her new computer to store project work.&lt;/p&gt;
&lt;p&gt;(i) Outline four file attributes that could be incorporated in the file.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Name&lt;/strong&gt;: A &lt;strong&gt;name&lt;/strong&gt; for the file to identify and access it, e.g., &quot;ProjectReport.docx&quot;.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Size&lt;/strong&gt;: The &lt;strong&gt;size&lt;/strong&gt; of the file, indicating the amount of storage space it occupies, e.g., 50KB.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Type&lt;/strong&gt;: The &lt;strong&gt;type or extension&lt;/strong&gt; of the file, indicating the file format, e.g., &quot;.docx&quot; for a Word document.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Permissions&lt;/strong&gt;: &lt;strong&gt;Access permissions&lt;/strong&gt; to control who can read, write, or execute the file, e.g., read/write for owner, read-only for others.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A student created a file in her new computer to store project work.&lt;/p&gt;
&lt;p&gt;(ii) State two mechanisms that she could use to protect the file against unauthorized access.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Control Lists (ACLs) or File Permissions&lt;/strong&gt;: Set appropriate &lt;strong&gt;file permissions&lt;/strong&gt; to restrict access to the file. The student can configure permissions so that only her user account has read and write access, while other users have no access or read-only access. This prevents unauthorized users from modifying or deleting the file.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Password Protection or Encryption&lt;/strong&gt;: &lt;strong&gt;Password protect&lt;/strong&gt; the file using software features (e.g., password protection in document editing software) or &lt;strong&gt;encrypt&lt;/strong&gt; the file using encryption tools. Password protection requires a password to open the file, while encryption scrambles the file content, making it unreadable without the decryption key. Both mechanisms add a layer of security to prevent unauthorized access, even if someone gains physical access to the computer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A student shares the computer with two of her colleagues. Explain a tool that could be used to monitor the computer usage.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A tool that could be used to monitor computer usage is an &lt;strong&gt;activity monitor or system monitor&lt;/strong&gt;. Operating systems typically include built-in tools like &lt;strong&gt;Task Manager (Windows)&lt;/strong&gt; or &lt;strong&gt;Activity Monitor (macOS)&lt;/strong&gt;. These utilities display real-time information about system resource usage, including CPU usage, memory usage, disk I/O, and network activity, broken down by process. By checking these monitors, the student can track which applications are running, how much resources each user or process is consuming, and identify potential performance bottlenecks or unusual activity.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four technical factors that should be considered when choosing I/O devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Transfer Rate/Speed&lt;/strong&gt;: The &lt;strong&gt;speed at which the I/O device can transfer data&lt;/strong&gt; is a critical factor. Different devices offer varying data transfer rates (e.g., Mbps, Gbps for network cards, MB/s, GB/s for storage devices). The required data transfer rate depends on the application's needs. For example, high-performance applications like video editing or databases require fast storage devices, while basic text editing needs less demanding I/O.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Latency&lt;/strong&gt;: &lt;strong&gt;Latency&lt;/strong&gt; refers to the delay between initiating an I/O request and the start of the actual data transfer. Lower latency is crucial for interactive applications and real-time systems where quick response is essential. Devices like SSDs have significantly lower latency compared to HDDs, making them suitable for applications requiring rapid access. For devices like network interfaces, latency affects network responsiveness.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Throughput&lt;/strong&gt;: &lt;strong&gt;Throughput&lt;/strong&gt; measures the amount of data an I/O device can transfer per unit of time. Higher throughput is desirable for applications that involve bulk data transfer, such as file copying, backups, or video streaming. Device throughput is limited by factors like interface bandwidth, device speed, and controller efficiency. For storage devices, throughput affects file read/write speeds; for network devices, it dictates network bandwidth.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Interface and Compatibility&lt;/strong&gt;: The &lt;strong&gt;interface type&lt;/strong&gt; (e.g., USB, SATA, PCIe, Ethernet) and &lt;strong&gt;compatibility&lt;/strong&gt; of the I/O device with the computer system are crucial. The interface must be supported by the motherboard and system bus. Compatibility ensures that the device can physically connect, communicate, and function correctly with the system. Interface standards dictate data transfer protocols, connectors, and power requirements. Choosing a device with a compatible and appropriate interface is essential for proper operation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the effect of buffering on the performance of each of the following devices:&lt;/p&gt;
&lt;p&gt;(i) mouse;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;For a &lt;strong&gt;mouse&lt;/strong&gt;, buffering has a minimal direct effect on performance noticeable to the user. Mouse input events (movements, clicks) are typically generated at a relatively slow rate compared to the CPU and memory speeds. Buffering might be used at a low level to collect mouse events before they are processed, but the buffering &lt;strong&gt;does not significantly impact the perceived responsiveness or performance&lt;/strong&gt; of the mouse from a user perspective. The primary focus for mouse performance is low latency and accurate tracking, not buffering.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the effect of buffering on the performance of each of the following devices:&lt;/p&gt;
&lt;p&gt;(ii) graphic card.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;For a &lt;strong&gt;graphic card&lt;/strong&gt;, buffering plays a significant role in performance. Graphic cards use &lt;strong&gt;frame buffers&lt;/strong&gt; to store rendered frames before displaying them on the screen. &lt;strong&gt;Double buffering or triple buffering&lt;/strong&gt; techniques, which involve using multiple frame buffers, are employed to prevent screen tearing and improve visual smoothness. Buffering allows the graphics card to prepare the next frame while the current frame is being displayed, leading to smoother animations and video playback. &lt;strong&gt;Buffering helps to decouple the rendering rate from the display refresh rate&lt;/strong&gt;, resulting in a more consistent and visually appealing output. It enhances the perceived performance by reducing visual artifacts and improving frame delivery.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following following file organization techniques.&lt;/p&gt;
&lt;p&gt;(i) sequential;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Sequential file organization&lt;/strong&gt; stores records in a &lt;strong&gt;linear sequence&lt;/strong&gt;, one after another, in the order they were entered. Records are accessed in the same sequential order, starting from the beginning of the file. To access a specific record, one must read through all preceding records. This method is simple to implement and efficient for applications that process data in a fixed order, such as batch processing or reading log files. However, it is &lt;strong&gt;inefficient for random access&lt;/strong&gt;, as it requires sequential searching to find a specific record.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following following file organization techniques.&lt;/p&gt;
&lt;p&gt;(ii) random.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Random file organization&lt;/strong&gt;, also known as &lt;strong&gt;direct file organization&lt;/strong&gt;, allows records to be accessed in &lt;strong&gt;any order, directly&lt;/strong&gt;, without needing to read through preceding records. This is achieved by using a &lt;strong&gt;key or record number&lt;/strong&gt; to directly calculate the physical location of a record on disk. Techniques like hashing or indexing are used to map keys to disk addresses. Random file organization is efficient for applications that require frequent random access to records, such as databases, indexed file systems, and interactive applications. It provides fast access to specific records but is more complex to implement than sequential organization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Distinguish between layered and client/server Operating System structures.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Layered Operating System Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;layered operating system structure&lt;/strong&gt; organizes the OS into a &lt;strong&gt;hierarchy of layers&lt;/strong&gt;, where each layer provides services to the layer above it and uses services from the layer below it. Layer 0 is the hardware, and the highest layer is the user interface. Each layer is relatively independent and performs a well-defined set of functions. Communication between layers occurs through defined interfaces. &lt;strong&gt;Advantages&lt;/strong&gt; include modularity, simplified design and debugging, and ease of maintenance. &lt;strong&gt;Disadvantages&lt;/strong&gt; can include performance overhead due to layer interactions and difficulty in strictly defining layer boundaries. Example: Traditional Unix-like systems, though modern OSes often blend layered and modular approaches.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client-Server Operating System Structure&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;client-server operating system structure&lt;/strong&gt; distinguishes between &lt;strong&gt;servers&lt;/strong&gt;, which provide services, and &lt;strong&gt;clients&lt;/strong&gt;, which request and use those services. The kernel is often reduced to a &lt;strong&gt;microkernel&lt;/strong&gt;, providing only essential core functionalities like process management and IPC. Most OS services (file system, networking, device drivers) are implemented as user-level servers running on top of the microkernel. Clients and servers communicate via message passing. &lt;strong&gt;Advantages&lt;/strong&gt; include modularity, extensibility, fault isolation (server failure less likely to crash the kernel), and adaptability to distributed systems. &lt;strong&gt;Disadvantages&lt;/strong&gt; can include performance overhead due to message passing between clients and servers and complexity in designing microkernel and server interactions. Example: Mach, MINIX 3, and modern macOS and Windows kernels (hybrid microkernels).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layered structure&lt;/strong&gt; is based on hierarchical levels of abstraction and service provision within a monolithic kernel, while &lt;strong&gt;client-server structure&lt;/strong&gt; separates services into independent user-level servers communicating with clients through a minimal microkernel. Layered is more monolithic, client-server is more modular and distributed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Most multiprogrammed systems are designed such that user programs access memory through virtual addresses and the operating system through physical addresses. Explain two implications of this design on the initiation of I/O operations by the user program.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Need for Address Translation for I/O Buffers&lt;/strong&gt;: When a user program initiates an I/O operation (e.g., reading from a file), it typically specifies &lt;strong&gt;virtual addresses for I/O buffers&lt;/strong&gt; where data will be read into or written from. Since I/O devices and the kernel operate with physical addresses, the operating system must perform &lt;strong&gt;address translation&lt;/strong&gt; to convert these virtual buffer addresses to corresponding physical addresses. This translation is necessary for the kernel to correctly access the user program's buffers in physical memory and transfer data between the I/O device and the program's memory space. Address translation adds an extra step in the I/O path but is essential for memory protection and virtual memory management.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Kernel Involvement in I/O Operations&lt;/strong&gt;: The separation of virtual and physical addresses reinforces the operating system's &lt;strong&gt;role as an intermediary for I/O operations&lt;/strong&gt;. User programs cannot directly access physical memory or I/O devices using virtual addresses. Instead, they must make &lt;strong&gt;system calls&lt;/strong&gt; to request I/O operations. The kernel, running in privileged mode and using physical addresses, handles the actual interaction with I/O devices on behalf of the user program. This design ensures &lt;strong&gt;system security and resource management&lt;/strong&gt;, as the kernel controls and validates all I/O requests, preventing unauthorized or direct hardware access by user-level programs. It enforces protection and abstraction in I/O operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline four file operations used in file management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create&lt;/strong&gt;: The &lt;strong&gt;create&lt;/strong&gt; operation is used to &lt;strong&gt;make a new file&lt;/strong&gt;. It involves allocating storage space, creating a directory entry with the file's name, and setting initial file attributes.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Read&lt;/strong&gt;: The &lt;strong&gt;read&lt;/strong&gt; operation retrieves &lt;strong&gt;data from a file&lt;/strong&gt;. It involves accessing the file's content from storage and transferring it to memory.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Write&lt;/strong&gt;: The &lt;strong&gt;write&lt;/strong&gt; operation &lt;strong&gt;stores data into a file&lt;/strong&gt;. It involves transferring data from memory to the file's storage space, potentially creating or modifying the file's content.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete&lt;/strong&gt;: The &lt;strong&gt;delete&lt;/strong&gt; operation &lt;strong&gt;removes a file&lt;/strong&gt;. It involves freeing up the storage space occupied by the file and removing its directory entry, making the file no longer accessible.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in memory management&lt;/p&gt;
&lt;p&gt;(i) swapping:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Swapping&lt;/strong&gt; is a memory management technique used to increase the degree of multiprogramming by moving processes between main memory (RAM) and secondary storage (disk). When memory becomes full, the operating system &lt;strong&gt;swaps out&lt;/strong&gt; a process that is not currently active from RAM to disk (swap space). Later, when that process needs to be executed again, it is &lt;strong&gt;swapped in&lt;/strong&gt; back into RAM from the disk. Swapping allows more processes to be ready to run than can fit in RAM at once, but it introduces overhead due to disk I/O operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in memory management&lt;/p&gt;
&lt;p&gt;(ii) overlaying;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Overlaying&lt;/strong&gt; is a memory management technique used in older systems to run programs larger than the available physical memory. It involves dividing a program into &lt;strong&gt;overlays&lt;/strong&gt;, where only the overlay currently needed is loaded into memory. When a different overlay is required, the current one is replaced (overlaid) with the new one. Overlaying is programmer-managed, requiring careful program design to fit within limited memory. It is less common in modern systems with virtual memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in memory management&lt;/p&gt;
&lt;p&gt;(iii) paging.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Paging&lt;/strong&gt; is a memory management technique that divides both physical memory (RAM) and logical memory (process address space) into &lt;strong&gt;fixed-size blocks called pages and frames&lt;/strong&gt;, respectively. Processes are divided into pages, and these pages are loaded into available frames in RAM. Pages of a process can be non-contiguous in RAM. A &lt;strong&gt;page table&lt;/strong&gt; maps virtual page numbers to physical frame numbers. Paging allows for efficient memory utilization and eliminates external fragmentation, enabling virtual memory implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;With the aid of a diagram, describe the structure of I/O software.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;structure of I/O software&lt;/strong&gt; in an operating system is typically layered to provide abstraction, modularity, and device independence. It can be visualized in terms of layers, from user applications down to the hardware devices.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of I/O Software Structure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    +-----------------------+  Layer 4: User-Level I/O
                    | User Applications     |  (e.g., Standard Library I/O functions)
                    +-----------------------+
                    | System Call Interface |  (e.g., read(), write(), open())
                    +-----------------------+  Layer 3: Device-Independent OS I/O
                    | Device-Independent    |  (Common I/O services, buffering, caching, naming)
                    | I/O Subsystem         |
                    +-----------------------+
                    | Device Driver Interface|  (Standard interface for device drivers)
                    +-----------------------+  Layer 2: Device Drivers
                    | Device Drivers        |  (Device-specific control, interrupt handling)
                    | (per device type)     |
                    +-----------------------+
                    | Hardware Interface    |  (Registers, command queues)
                    +-----------------------+  Layer 1: Hardware Controllers
                    | I/O Controllers       |  (Disk controller, network adapter, etc.)
                    +-----------------------+
                    | Physical I/O Device   |  Layer 0: I/O Hardware
                    +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Layers:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer 4: User-Level I/O&lt;/strong&gt;: This is the &lt;strong&gt;highest layer&lt;/strong&gt;, consisting of user applications that perform I/O operations through standard library functions (e.g., `stdio` in C). These functions provide a high-level, device-independent interface to applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer 3: Device-Independent OS I/O&lt;/strong&gt;: This layer provides a &lt;strong&gt;device-independent interface&lt;/strong&gt; to the layers above and manages common I/O functionalities. It includes the &lt;strong&gt;system call interface&lt;/strong&gt; that user programs use to request I/O operations. It also handles buffering, caching, spooling, device naming, and protection, providing a uniform view of I/O to user programs regardless of the specific hardware.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer 2: Device Drivers&lt;/strong&gt;: &lt;strong&gt;Device drivers&lt;/strong&gt; are &lt;strong&gt;device-specific software modules&lt;/strong&gt; that control and manage particular types of I/O devices. Each type of device (e.g., disk, printer, network card) has its own driver. Drivers translate device-independent requests from the OS I/O subsystem into device-specific commands that the hardware controller understands. They handle hardware-level operations, interrupt handling, and data transfer for their respective devices.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer 1: Hardware Controllers&lt;/strong&gt;: &lt;strong&gt;I/O controllers&lt;/strong&gt; are hardware components that interface between the CPU and the actual I/O devices. Examples are disk controllers, network interface cards, and USB controllers. They execute commands from device drivers, manage data transfer between devices and memory, and handle low-level device control.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Layer 0: I/O Hardware&lt;/strong&gt;: This is the &lt;strong&gt;physical I/O device&lt;/strong&gt; itself, such as a hard disk, printer, keyboard, network card, etc. It performs the actual input or output operations.&lt;/p&gt;
&lt;p&gt;This layered structure allows for modularity, portability, and device independence. Changes in hardware or device drivers can be made without affecting user applications or higher layers of the OS I/O system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Two processses enter the ready queue of a system with the following properties:&lt;/p&gt;
&lt;p&gt;Process 1 needs 8 units of CPU time but after every 2 units, it must perform an I/O. Assume that there is no work to be done following the last I/O operation.&lt;/p&gt;
&lt;p&gt;Process 2 needs 20 units of CPU time and it process arrives just after Process1.&lt;/p&gt;
&lt;p&gt;Using Round Robin scheduling algorithm with a time slice of 4 units;&lt;/p&gt;
&lt;p&gt;(i) Draw a Gantt chart showing the execution of the two processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Process Properties:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Process 1 (P1): 8 CPU units, I/O after every 2 units.&lt;/p&gt;
&lt;p&gt;Process 2 (P2): 20 CPU units, arrives after P1.&lt;/p&gt;
&lt;p&gt;Time Slice: 4 units.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    Time: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| 14| 15| 16| 17| 18| 19| 20| 21| 22| 23| 24| 25| 26| 27| 28|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
                    CPU: | P1| P1| I/O|Idle| P1| P1| I/O|Idle| P1| P1| I/O|Idle| P1| P1| I/O|Idle| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2| P2|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
                    Time: 29| 30| 31| 32| 33| 34| 35| 36| 37| 38| 39| 40| 41| 42| 43| 44| 45| 46| 47| 48|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---
                    CPU: | P2| P2| P2| P2| P2| P2| P2| P2|      Idle
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---

                    Explanation:
                    0-2: P1 runs for 2 units.
                    2-3: P1 performs I/O (1 unit). CPU Idle.
                    3-5: P1 runs for next 2 units.
                    5-6: P1 performs I/O (1 unit). CPU Idle.
                    6-8: P1 runs for next 2 units.
                    8-9: P1 performs I/O (1 unit). CPU Idle.
                    9-11: P1 runs for last 2 units. P1 finishes after 8 CPU units and 3 I/O units.
                    11-15: P2 runs for time slice of 4 units.
                    15-19: P2 runs for next time slice of 4 units.
                    19-23: P2 runs for next time slice of 4 units.
                    23-27: P2 runs for next time slice of 4 units.
                    27-31: P2 runs for last 4 units. P2 finishes after 20 CPU units.
                    31-48: CPU Idle.
                    &lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Two processses enter the ready queue of a system with the following properties:&lt;/p&gt;
&lt;p&gt;Process 1 needs 8 units of CPU time but after every 2 units, it must perform an I/O. Assume that there is no work to be done following the last I/O operation.&lt;/p&gt;
&lt;p&gt;Process 2 needs 20 units of CPU time and it process arrives just after Process1.&lt;/p&gt;
&lt;p&gt;Using Round Robin scheduling algorithm with a time slice of 4 units;&lt;/p&gt;
&lt;p&gt;(ii) Determine the completion time for each process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on the Gantt chart:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion Time for Process 1 (P1): 11 units&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Completion Time for Process 2 (P2): 31 units&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following memory allocation techniques:&lt;/p&gt;
&lt;p&gt;(i) dynamic partitioning;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Dynamic partitioning&lt;/strong&gt; is a memory allocation technique where memory partitions are created &lt;strong&gt;dynamically at runtime&lt;/strong&gt;, based on the actual memory requirements of processes. When a process arrives, the operating system allocates a partition of exactly the size needed by the process from the available free memory. Partitions are not fixed in size and are created and sized as needed. This reduces internal fragmentation, but can lead to external fragmentation as memory becomes fragmented into smaller, non-contiguous blocks over time.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe each of the following memory allocation techniques:&lt;/p&gt;
&lt;p&gt;(ii) segmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Segmentation&lt;/strong&gt; is a memory management technique that divides a process's logical address space into &lt;strong&gt;variable-sized segments&lt;/strong&gt;. Each segment corresponds to a logical unit of the program, such as code, data, or stack. Segments are allocated in physical memory as contiguous blocks, but segments of a process may not be contiguous with each other. A &lt;strong&gt;segment table&lt;/strong&gt; is used to map segments to their physical memory locations. Segmentation supports logical program structure, facilitates sharing and protection at the segment level, but can suffer from external fragmentation due to variable segment sizes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Joseph would like to replace his computer card reader with a newer version.&lt;/p&gt;
&lt;p&gt;(i) Identify a principle in I/O device management that could enable him carry out this task without the programs using it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The principle in I/O device management that could enable Joseph to replace his card reader without affecting programs is &lt;strong&gt;device independence&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Joseph would like to replace his computer card reader with a newer version.&lt;/p&gt;
&lt;p&gt;(ii) Explain the implementation of the principle identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Implementation of &lt;strong&gt;device independence&lt;/strong&gt; involves using &lt;strong&gt;device drivers&lt;/strong&gt; and &lt;strong&gt;abstract I/O interfaces&lt;/strong&gt; provided by the operating system. When Joseph replaces the card reader, he only needs to &lt;strong&gt;install a new device driver&lt;/strong&gt; for the newer card reader. The operating system's I/O subsystem is designed to interact with devices through these drivers, using a standard interface. As long as the new driver correctly implements this interface, user programs, which interact with the OS through device-independent system calls, will continue to work without needing any modifications. The OS handles the device-specific details through the driver, abstracting away the hardware differences from applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the effect of each of the following on CPU utilization:&lt;/p&gt;
&lt;p&gt;(i) increase main memory capacity;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Increasing main memory capacity&lt;/strong&gt; generally leads to &lt;strong&gt;increased CPU utilization&lt;/strong&gt;. With more RAM, the operating system can load and keep more processes in memory simultaneously (higher degree of multiprogramming). This reduces the frequency of swapping and paging, as more processes can reside in RAM, reducing disk I/O for virtual memory management. With less time spent on swapping and paging, the CPU spends more time executing process instructions, thus increasing overall CPU utilization and system throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain the effect of each of the following on CPU utilization:&lt;/p&gt;
&lt;p&gt;(ii) spooling.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Spooling (Simultaneous Peripheral Operations On-Line)&lt;/strong&gt; typically leads to &lt;strong&gt;increased CPU utilization&lt;/strong&gt;, especially for I/O-bound operations like printing. Spooling involves buffering output data to a secondary storage device (e.g., disk) instead of directly sending it to a slow output device (e.g., printer). This allows processes to complete their output operations quickly and continue execution without waiting for the slow I/O device. The actual output to the slow device is handled asynchronously in the background by a spooler process, which is typically less CPU-intensive. By offloading and deferring the slow I/O operations, spooling frees up the CPU to perform other computations, thereby increasing overall CPU utilization and system throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Recently, John has realized that his personal computer keeps displaying the message 'your system is getting low on virtual memory'. Describe two ways that he could use to rectify the problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Increase RAM (Physical Memory)&lt;/strong&gt;: The most effective way to rectify low virtual memory issues is to &lt;strong&gt;increase the amount of physical RAM&lt;/strong&gt; installed in the computer. More RAM reduces the reliance on virtual memory by allowing more data and programs to reside in fast RAM, decreasing the need for paging to disk. This directly addresses the root cause of virtual memory exhaustion by providing more actual memory for the system to use. Upgrading RAM is often the best long-term solution for improving performance and resolving low virtual memory warnings.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increase Paging File Size or Relocate Paging File to a Faster Drive&lt;/strong&gt;: John can &lt;strong&gt;increase the size of the paging file&lt;/strong&gt; (swap file) on his hard drive. A larger paging file provides more space for virtual memory, allowing the system to swap more data to disk before running out of virtual memory. Alternatively, if possible, &lt;strong&gt;relocating the paging file to a faster storage drive&lt;/strong&gt;, such as an SSD, can improve the performance of virtual memory operations. While not as effective as increasing RAM, these adjustments can provide some relief from low virtual memory issues, especially in the short term or on systems where RAM upgrades are not immediately feasible.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline three advantages of coding operating system programs in a high-level language.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Improved Programmer Productivity and Development Speed&lt;/strong&gt;: High-level languages (HLLs) are &lt;strong&gt;easier to learn, write, and debug&lt;/strong&gt; compared to low-level languages like assembly language. They provide higher levels of abstraction, allowing programmers to focus on logic rather than low-level hardware details. This leads to &lt;strong&gt;faster development times&lt;/strong&gt;, increased programmer productivity, and reduced development costs for operating system components. HLLs simplify complex tasks and allow for quicker prototyping and iteration.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Portability and Maintainability&lt;/strong&gt;: Operating systems written in HLLs are &lt;strong&gt;more portable&lt;/strong&gt; across different hardware architectures. HLL code is less dependent on specific hardware details, making it easier to adapt and port the OS to new platforms. HLL code is also &lt;strong&gt;easier to read, understand, and maintain&lt;/strong&gt; compared to assembly code. This simplifies bug fixing, updates, and long-term maintenance of the operating system. Portability and maintainability are crucial for the longevity and adaptability of operating systems.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Access to Advanced Programming Features and Tools&lt;/strong&gt;: HLLs offer advanced programming features like &lt;strong&gt;structured programming constructs, data abstraction, object-oriented programming, and automatic memory management&lt;/strong&gt;. These features simplify the development of complex operating system functionalities and promote code reusability and modularity. HLLs are also supported by a wide range of &lt;strong&gt;development tools&lt;/strong&gt;, such as compilers, debuggers, and IDEs, which further enhance the development process and improve code quality. Using HLLs allows OS developers to leverage modern software engineering practices.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;State three types of fifth generation operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;AI-Based Operating Systems&lt;/strong&gt;: These operating systems integrate &lt;strong&gt;artificial intelligence (AI) and machine learning (ML)&lt;/strong&gt; to enhance system performance, security, and user experience. They can dynamically adapt to user behavior, optimize resource allocation, automate tasks, and provide intelligent assistance. Examples include research OS prototypes incorporating AI scheduling or security mechanisms.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Mobile Operating Systems (Advanced Versions)&lt;/strong&gt;: Fifth-generation mobile OSes are characterized by &lt;strong&gt;advanced AI capabilities, enhanced security, and seamless integration&lt;/strong&gt; with cloud services and IoT devices. They feature sophisticated voice assistants, predictive functionalities, and context-aware computing. Examples include latest versions of Android and iOS with advanced AI features and ecosystem integrations.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Quantum Operating Systems&lt;/strong&gt;: These are emerging operating systems designed to manage and control &lt;strong&gt;quantum computers&lt;/strong&gt;. They are fundamentally different from classical OSes, needing to handle quantum bits (qubits), quantum algorithms, and unique quantum computing architectures. Quantum OSes are in early stages of development but are crucial for harnessing the power of quantum computing. Examples are research prototypes and early quantum OS frameworks.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Describe two performance overhead associated with servicing an interrupt.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Context Switching Overhead&lt;/strong&gt;: Servicing an interrupt requires the operating system to perform a &lt;strong&gt;context switch&lt;/strong&gt;. When an interrupt occurs, the CPU must &lt;strong&gt;suspend the currently running process&lt;/strong&gt;, save its current state (CPU registers, program counter, etc.), and load the context of the &lt;strong&gt;interrupt handler&lt;/strong&gt;. After the interrupt handler finishes, the original process's context needs to be restored to resume its execution. This context switching process takes time and consumes CPU cycles, adding overhead to the system. Frequent interrupts lead to more context switches, increasing this overhead and potentially reducing overall system performance.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Interrupt Handling Latency and Processing Time&lt;/strong&gt;: There is &lt;strong&gt;latency&lt;/strong&gt; between the occurrence of an interrupt and the start of the interrupt handler execution. This includes the time for the CPU to recognize the interrupt, save the current state, and dispatch the interrupt handler. Additionally, the &lt;strong&gt;interrupt handler itself takes time to execute&lt;/strong&gt;. The handler needs to identify the source of the interrupt, perform the necessary actions (e.g., service I/O request, handle error), and acknowledge the interrupt. The total time spent in interrupt handling, including latency and processing time, is overhead. If interrupt handlers are complex or lengthy, they can consume a significant portion of CPU time, impacting system performance and responsiveness, especially if interrupts occur frequently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Assume a memory management technique of fixed partitions in order of 100K, 500K, 300K and 200K. Four processes of 417K, 195K, 112K and 96K need to be loaded to the memory. Allocate the processes using each of the following placement policies:&lt;/p&gt;
&lt;p&gt;(i) Best Fit;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Fixed Partitions:&lt;/strong&gt; 100K, 500K, 300K, 200K&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Processes:&lt;/strong&gt; P1=417K, P2=195K, P3=112K, P4=96K&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Best Fit Allocation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- P1 (417K): Best fit is 500K partition.&lt;/p&gt;
&lt;p&gt;- P2 (195K): Best fit among remaining is 200K partition.&lt;/p&gt;
&lt;p&gt;- P3 (112K): Best fit among remaining is 300K partition.&lt;/p&gt;
&lt;p&gt;- P4 (96K): Cannot fit into the 100K partition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Allocation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;500K partition: P1 (417K)&lt;/p&gt;
&lt;p&gt;200K partition: P2 (195K)&lt;/p&gt;
&lt;p&gt;300K partition: P3 (112K)&lt;/p&gt;
&lt;p&gt;100K partition: Not used (P4 cannot fit)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Assume a memory management technique of fixed partitions in order of 100K, 500K, 300K and 200K. Four processes of 417K, 195K, 112K and 96K need to be loaded to the memory. Allocate the processes using each of the following placement policies:&lt;/p&gt;
&lt;p&gt;(ii) First Fit.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Fixed Partitions:&lt;/strong&gt; 100K, 500K, 300K, 200K (in order)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Processes:&lt;/strong&gt; P1=417K, P2=195K, P3=112K, P4=96K&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First Fit Allocation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- P1 (417K): First fit is 500K partition.&lt;/p&gt;
&lt;p&gt;- P2 (195K): First fit among remaining partitions (100K, 300K, 200K) is 300K partition.&lt;/p&gt;
&lt;p&gt;- P3 (112K): First fit among remaining partitions (100K, 200K) is 200K partition.&lt;/p&gt;
&lt;p&gt;- P4 (96K): First fit among remaining partition (100K) is 100K partition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Allocation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;500K partition: P1 (417K)&lt;/p&gt;
&lt;p&gt;300K partition: P2 (195K)&lt;/p&gt;
&lt;p&gt;200K partition: P3 (112K)&lt;/p&gt;
&lt;p&gt;100K partition: P4 (96K)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between logical and physical file systems. (4 marks)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Logical File System&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;logical file system&lt;/strong&gt; is the &lt;strong&gt;user's view&lt;/strong&gt; of the file system. It defines how files and directories are organized and presented to users and applications. It deals with &lt;strong&gt;logical file and directory structures&lt;/strong&gt;, naming conventions, file types, and access methods. The logical file system provides an abstract interface to file operations, hiding the underlying physical storage details from users and programs. Examples include directory hierarchies, file pathnames, and file access permissions as seen by users. The logical file system is concerned with &lt;strong&gt;what data is accessed and how it is logically structured&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical File System&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;physical file system&lt;/strong&gt; is concerned with the &lt;strong&gt;actual storage and organization of files on physical storage devices&lt;/strong&gt; (e.g., hard disks, SSDs). It deals with &lt;strong&gt;physical storage structures&lt;/strong&gt; like disk blocks, sectors, clusters, inodes, and file allocation tables. The physical file system manages the allocation and deallocation of storage space, data block management, and physical data access mechanisms. It is responsible for &lt;strong&gt;how data is physically stored and retrieved&lt;/strong&gt; from storage devices. Examples include disk formatting, block allocation strategies, and physical addressing of data on disk. The physical file system implements the storage mechanisms that support the logical file system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The key difference is in their &lt;strong&gt;perspective and level of abstraction&lt;/strong&gt;. The &lt;strong&gt;logical file system&lt;/strong&gt; is the user-centric, abstract view of files and directories, focusing on organization and access. The &lt;strong&gt;physical file system&lt;/strong&gt; is the system-centric, low-level view focusing on the actual physical storage and management of data on storage devices. The logical file system builds upon the physical file system to provide a user-friendly interface for file management.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term Direct Memory Access as used in Operating Systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt; is a hardware mechanism that allows certain hardware subsystems (e.g., disk controllers, graphics cards, network cards) to &lt;strong&gt;access system memory (RAM) independently of the CPU&lt;/strong&gt;. DMA enables high-speed data transfer between I/O devices and memory without constant CPU intervention. Once a DMA transfer is initiated by the CPU, the DMA controller takes over and transfers data directly, freeing up the CPU to perform other tasks concurrently. DMA is crucial for improving I/O performance and reducing CPU overhead in data transfer operations.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain one advantage of using memory mapped I/O as opposed to device controller registers.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;One advantage of using &lt;strong&gt;memory-mapped I/O&lt;/strong&gt; over device controller registers is &lt;strong&gt;simpler programming and unified address space&lt;/strong&gt;. In memory-mapped I/O, device registers are mapped into the same address space as system memory. This allows device control and data transfer to be performed using the &lt;strong&gt;same memory access instructions&lt;/strong&gt; (load and store) that are used for regular memory access. Programmers do not need to use special I/O instructions; they can interact with devices using standard memory operations, simplifying programming and making device control more integrated with memory operations. This unified address space simplifies hardware and software interaction.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between semaphore and monitor as used in process management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;semaphore&lt;/strong&gt; is a &lt;strong&gt;lower-level synchronization primitive&lt;/strong&gt; used for controlling access to shared resources and process synchronization. It is an integer variable with two atomic operations: &lt;strong&gt;wait (P)&lt;/strong&gt; and &lt;strong&gt;signal (V)&lt;/strong&gt;. Semaphores can be used to implement mutual exclusion (binary semaphore) or to control access to a limited number of resources (counting semaphore). Semaphores are flexible and can be used to solve a wide range of synchronization problems, but they can be &lt;strong&gt;error-prone&lt;/strong&gt; if not used carefully, leading to issues like deadlocks and race conditions. Semaphores manage synchronization at a more basic level, requiring programmers to handle locking and unlocking explicitly.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monitor&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;monitor&lt;/strong&gt; is a &lt;strong&gt;higher-level synchronization construct&lt;/strong&gt; that provides a structured approach to mutual exclusion and condition synchronization. It is a programming language construct (e.g., in Java, C#) that encapsulates shared data and the operations that can access that data. Only one process can be active within a monitor at any given time, providing &lt;strong&gt;automatic mutual exclusion&lt;/strong&gt;. Monitors also provide &lt;strong&gt;condition variables&lt;/strong&gt; for processes to wait and signal each other based on specific conditions. Monitors simplify synchronization by encapsulating locking and condition management within a single construct, reducing the chances of synchronization errors compared to raw semaphores. They offer a more structured and safer way to manage concurrent access to shared resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Semaphores&lt;/strong&gt; are a more basic, flexible but error-prone synchronization primitive, requiring explicit lock management. &lt;strong&gt;Monitors&lt;/strong&gt; are a higher-level, structured, and safer construct that provides automatic mutual exclusion and condition variables, simplifying concurrent programming and reducing synchronization errors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Citing an example in each case, distinguish between reusable and consumable resources as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Reusable Resources&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reusable resources&lt;/strong&gt; are resources that can be used by &lt;strong&gt;only one process at a time&lt;/strong&gt; and can be reused by other processes after the current process releases them. These resources are not depleted or destroyed by their use. &lt;strong&gt;Example: CPU time.&lt;/strong&gt; CPU time is a reusable resource because only one process can use the CPU at any given instant, but after a process's time slice is over, or it voluntarily releases the CPU, the CPU resource becomes available and can be reused by another process. The CPU itself is not consumed or altered by the processes using it; it is reused repeatedly by different processes over time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consumable Resources&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consumable resources&lt;/strong&gt; are resources that are &lt;strong&gt;created by one process and consumed by another process&lt;/strong&gt;. Once a consumable resource is used, it is no longer available. &lt;strong&gt;Example: Messages in a message queue.&lt;/strong&gt; When a process sends a message to another process using message passing, the message is a consumable resource. The sending process creates the message, and the receiving process consumes it by receiving and processing it. Once the message is received, it is no longer available for further consumption. Consumable resources are typically used for communication and synchronization between processes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The key difference lies in their &lt;strong&gt;lifecycle and reusability&lt;/strong&gt;. &lt;strong&gt;Reusable resources&lt;/strong&gt; are persistent and can be reused by multiple processes over time, while &lt;strong&gt;consumable resources&lt;/strong&gt; are transient, created and then used up, serving as a means of communication or signaling between processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;ABC Ltd Company has recently installed Internet in its premises. Explain two methods it could use to protect computer systems from computer worms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Install and Maintain Antivirus Software&lt;/strong&gt;: Deploying &lt;strong&gt;reputable antivirus software&lt;/strong&gt; on all computer systems within the company is crucial. Antivirus software can &lt;strong&gt;detect, quarantine, and remove&lt;/strong&gt; known computer worms and other malware. It should be regularly updated with the latest virus definitions to recognize and protect against newly emerging worms. Real-time scanning, scheduled scans, and proactive detection features of antivirus software are essential for preventing worm infections and mitigating their spread within the network.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Implement a Firewall and Network Security Measures&lt;/strong&gt;: Employing a &lt;strong&gt;firewall&lt;/strong&gt; to control network traffic entering and leaving the company's network is a vital protection method. Firewalls can &lt;strong&gt;block unauthorized network connections&lt;/strong&gt; and filter out malicious traffic that worms might use to propagate. Additionally, implementing other network security measures such as &lt;strong&gt;intrusion detection/prevention systems (IDS/IPS), network segmentation, and regularly updating router and firewall firmware&lt;/strong&gt; can further strengthen defenses against worm attacks. Network security measures limit the entry points and spread of worms within the company's infrastructure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Employees in a certain company using personal computers connected to a central server have realized that the response time of the server reduces with the increase of the number of users.&lt;/p&gt;
&lt;p&gt;(1) Identify two techniques that could be used to solve this problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Upgrade Server Hardware&lt;/strong&gt;: &lt;strong&gt;Upgrading the server hardware&lt;/strong&gt;, particularly the CPU, RAM, and network interface card, can significantly improve server performance and response time. A more powerful CPU can handle increased processing load from more users, more RAM can reduce disk swapping and improve data access speed, and a faster network interface can handle higher network traffic. Hardware upgrades directly address server capacity limitations and improve overall server responsiveness under increased user load.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Implement Load Balancing&lt;/strong&gt;: &lt;strong&gt;Implementing load balancing&lt;/strong&gt; distributes user requests across multiple servers instead of overloading a single server. Load balancing techniques can distribute incoming traffic based on various algorithms (e.g., round robin, least connections, etc.) to ensure that no single server is overwhelmed. By distributing the load, load balancing prevents performance degradation due to increased user connections and maintains consistent response times, even with a larger number of users accessing the services.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Employees in a certain company using personal computers connected to a central server have realized that the response time of the server reduces with the increase of the number of users.&lt;/p&gt;
&lt;p&gt;(ii) The company has enforced security mechanisms to protect the shared data. Differentiate between the term security and protection.(2 marks)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Security&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Security&lt;/strong&gt;, in a broad sense, encompasses the &lt;strong&gt;overall measures and strategies taken to safeguard information and resources from unauthorized access, use, disclosure, disruption, modification, or destruction&lt;/strong&gt;. Security is a comprehensive concept that includes policies, procedures, technologies, and practices aimed at ensuring confidentiality, integrity, and availability of data and systems. It involves assessing risks, implementing controls, and continuously monitoring and adapting to evolving threats. Security is the overarching goal of maintaining a safe and trustworthy computing environment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Protection&lt;/strong&gt; is a &lt;strong&gt;specific mechanism or set of mechanisms implemented within an operating system or system architecture to enforce security policies and control access to resources&lt;/strong&gt;. Protection mechanisms are the tools and techniques used to implement security. Examples of protection mechanisms include access control lists (ACLs), firewalls, encryption, authentication systems, and authorization protocols. Protection is the &lt;strong&gt;implementation aspect of security&lt;/strong&gt;, focusing on the specific technical controls and safeguards that are put in place to achieve security goals. Protection mechanisms are the concrete means to enforce security policies and prevent unauthorized actions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Security&lt;/strong&gt; is the &lt;strong&gt;broader goal&lt;/strong&gt; of safeguarding information and resources, encompassing policies and strategies. &lt;strong&gt;Protection&lt;/strong&gt; refers to the &lt;strong&gt;specific mechanisms and technical implementations&lt;/strong&gt; used to enforce security policies and control access to resources. Protection is the means to achieve security.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Define the term disk sector sparing as used in computer hard disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Disk sector sparing&lt;/strong&gt;, also known as sector remapping, is a technique used in hard disk drives to &lt;strong&gt;handle bad sectors&lt;/strong&gt;. When a sector on a disk is detected as faulty or unreliable (e.g., due to media errors), sector sparing involves &lt;strong&gt;replacing the bad sector with a spare sector&lt;/strong&gt; from a reserved area of the disk. The disk controller automatically remaps logical addresses pointing to the bad sector to the spare sector, effectively hiding the bad sector from the operating system and maintaining data integrity and disk reliability. Sector sparing is a form of error management and fault tolerance in hard drives.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in computer magnetic disk:&lt;/p&gt;
&lt;p&gt;(1) platter;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(1) Platter:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;platter&lt;/strong&gt; is a &lt;strong&gt;circular disk&lt;/strong&gt; made of a rigid material (like aluminum or glass) coated with a magnetic material. Hard disk drives consist of one or more platters stacked on a spindle. Data is stored magnetically on both surfaces of each platter in concentric tracks and sectors. Platters rotate at high speeds, enabling read/write heads to access data stored on their surfaces.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in computer magnetic disk:&lt;/p&gt;
&lt;p&gt;(II) rotational delay;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(II) Rotational Delay:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rotational delay&lt;/strong&gt;, also known as rotational latency, is the time it takes for the desired sector on a disk platter to &lt;strong&gt;rotate under the read/write head&lt;/strong&gt; once the head has been positioned over the correct track (after seek time). It is the delay caused by the disk's rotation. On average, rotational latency is half the time for a full disk rotation. It contributes to disk access time and is inversely related to the disk's RPM (revolutions per minute).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in computer magnetic disk:&lt;/p&gt;
&lt;p&gt;(III) transfer time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(III) Transfer Time:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer time&lt;/strong&gt;, also known as data transfer time, is the time taken to &lt;strong&gt;transfer data between the disk surface and the computer's memory&lt;/strong&gt; once the read/write head is positioned over the correct sector. It depends on the disk's data transfer rate and the amount of data being transferred. Higher transfer rates result in lower transfer times. Transfer time is a component of the total disk access time, following seek time and rotational latency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Differentiate between internal and external fragmentation as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Internal Fragmentation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Internal fragmentation&lt;/strong&gt; occurs in fixed-size partitioning memory allocation schemes. It is the &lt;strong&gt;wasted memory within a partition&lt;/strong&gt; that is allocated to a process because the partition size is larger than the process's memory requirement. When a process is loaded into a fixed-size partition, if the process size is smaller than the partition size, the unused space within that partition is internal fragmentation. This memory is allocated to the process but cannot be used by any other process. Internal fragmentation is a result of allocating memory in fixed-size blocks and can lead to inefficient memory utilization, especially when many processes are smaller than the partition size.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;External fragmentation&lt;/strong&gt; occurs in dynamic memory allocation schemes (e.g., variable partitioning, segmentation). It is the condition where there is &lt;strong&gt;enough total free memory space to satisfy a process's memory request, but the free memory is non-contiguous&lt;/strong&gt;, scattered in small blocks between allocated partitions. Because the free memory is fragmented into smaller, non-adjacent chunks, a large process requiring a contiguous block of memory may not be able to be allocated, even if the total free memory is sufficient. External fragmentation arises from the allocation and deallocation of variable-sized memory blocks over time, leading to fragmentation of the memory space. Compaction techniques can be used to reduce external fragmentation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Internal fragmentation&lt;/strong&gt; is wasted memory *within* an allocated partition because the partition is larger than needed. &lt;strong&gt;External fragmentation&lt;/strong&gt; is wasted memory *outside* allocated partitions, where total free memory is sufficient but fragmented into non-contiguous blocks too small to satisfy a process request. Internal fragmentation is associated with fixed partitioning, while external fragmentation is associated with dynamic allocation schemes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Consider each of the following process scheduling algorithms:&lt;/p&gt;
&lt;p&gt;First come First Served, Last In First Out, Shortest Job First, and Shortest Job First&lt;/p&gt;
&lt;p&gt;Classify each of the algorithms as either preemptive or non-preemptive.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Non-Preemptive Algorithms:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;First Come First Served (FCFS)&lt;/strong&gt;: Non-preemptive. Once a process starts running, it continues until it completes or blocks for I/O.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Last In First Out (LIFO)&lt;/strong&gt;: Non-preemptive in its basic form. Once a process starts running, it continues until completion.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Shortest Job First (SJF)&lt;/strong&gt;: Non-preemptive in its traditional form. Once a process with the shortest estimated burst time starts, it runs to completion.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Preemptive Algorithms:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Shortest Job First (SJF) (Preemptive version, also known as Shortest Remaining Time First - SRTF)&lt;/strong&gt;: Preemptive. A running process can be preempted if a new process arrives with a shorter remaining burst time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The question lists &quot;Shortest Job First&quot; twice. It is important to note that while traditional SJF is non-preemptive, there is also a preemptive version of SJF, often called Shortest Remaining Time First (SRTF).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A certain college has campuses in several towns. Each campus meets its own computational needs but submits a report to the main campus on a daily basis.&lt;/p&gt;
&lt;p&gt;(i) Identify the appropriate Operating System to be used at the main campus.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The appropriate Operating System to be used at the main campus would be a &lt;strong&gt;Network Operating System (NOS)&lt;/strong&gt; or a &lt;strong&gt;Server Operating System&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A certain college has campuses in several towns. Each campus meets its own computational needs but submits a report to the main campus on a daily basis.&lt;/p&gt;
&lt;p&gt;(ii) Explain two characteristics of the Operating System identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Centralized Management and Administration&lt;/strong&gt;: A Network Operating System provides &lt;strong&gt;centralized management and administration capabilities&lt;/strong&gt;. This is crucial for the main campus to manage resources, user accounts, security policies, and data backups across all campuses. Centralized administration simplifies IT management, ensures consistency in policies, and facilitates monitoring and control over the entire college network. The NOS enables administrators at the main campus to efficiently manage the distributed computing environment.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Network Services and Resource Sharing&lt;/strong&gt;: A Server Operating System or NOS is designed to provide &lt;strong&gt;network services and resource sharing&lt;/strong&gt;. It allows the main campus to act as a central server providing services like file sharing, database access, web services, and print services to all campuses. Furthermore, it supports communication protocols and networking functionalities necessary for each campus to submit reports and exchange data with the main campus. Resource sharing and network services are essential for enabling collaboration and data consolidation across the distributed college environment.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows functions of a file management system. Use it to answer the question that follows.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-21-48_2013j.pdf.png&quot; alt=&quot;&quot; width=&quot;932&quot; height=&quot;548&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure2_q8d.png&quot; alt=&quot;Figure 2 File Management System Functions Diagram&quot; /&gt;
&lt;p&gt;Explain each of the process labeled (I) and (II).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on Figure 2, which depicts the functions of a file management system:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(I) Directory management&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Process (I), labeled &quot;Directory Management,&quot; refers to the &lt;strong&gt;functions related to managing the directory structure&lt;/strong&gt; of the file system. This includes operations such as &lt;strong&gt;creating directories, deleting directories, renaming directories, listing directory contents, and navigating the directory hierarchy&lt;/strong&gt;. Directory management is essential for organizing files logically, providing a structured namespace, and allowing users and programs to efficiently locate and access files. It deals with the hierarchical organization of files and directories within the file system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(II) Physical Blocks in Secondary Storage&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Process (II), labeled &quot;Physical Blocks in Secondary Storage,&quot; refers to the &lt;strong&gt;low-level operations of managing the physical storage space&lt;/strong&gt; on secondary storage devices (like hard disks or SSDs) where file data is actually stored. This includes functions such as &lt;strong&gt;allocating disk blocks to files, deallocating blocks when files are deleted, managing free space, and handling the physical layout of data on disk&lt;/strong&gt;. It is concerned with the physical organization and management of data blocks on storage devices to ensure efficient storage and retrieval of file data. This process is hidden from users and applications, being handled by the file system at a lower level.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 [Your University/College Name]&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="274"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="15_137_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="77">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="74"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-21-48_2013j.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-21-48_2013j.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="b2c8112a47f805073ebd414d451ccb7a"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="75"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="75"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="1"></int>
              <string role="key" value="parentNode"></string>
              <reference key="76"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="15"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="76"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="77"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="15"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202013"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="80">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="November 2012"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="78">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="79">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="138_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="78"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: November 2012&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two roles for each of the following computer components in operating systems:&lt;/p&gt;
&lt;p&gt;(i) processor:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Instruction Execution&lt;/strong&gt;: The &lt;strong&gt;processor&lt;/strong&gt;, or CPU, is responsible for &lt;strong&gt;executing instructions&lt;/strong&gt; of programs that constitute the operating system and user applications. It fetches instructions from memory, decodes them, and performs the operations specified, which are fundamental to all computing tasks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Process Management&lt;/strong&gt;: The processor, under the control of the operating system, &lt;strong&gt;manages and executes processes&lt;/strong&gt;. It allocates CPU time to different processes, switches between them to enable multitasking, and ensures fair and efficient utilization of the processing resource.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Outline two roles for each of the following computer components in operating systems:&lt;/p&gt;
&lt;p&gt;(ii) RAM.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Storing Running Programs and Data&lt;/strong&gt;: &lt;strong&gt;RAM (Random Access Memory)&lt;/strong&gt; serves as the &lt;strong&gt;primary memory&lt;/strong&gt; for actively running programs and the data they are currently using. The operating system loads program code and data into RAM for quick access by the processor, enabling efficient execution of applications.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Temporary Storage for OS Operations&lt;/strong&gt;: RAM provides &lt;strong&gt;temporary storage&lt;/strong&gt; for the operating system itself during its operation. The kernel, device drivers, and other OS components reside in RAM while the system is running, allowing the OS to manage system resources, handle interrupts, and perform other essential functions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A group of Module II students were carrying out research on types of operating systems. They listed the following features of a certain type of an operating system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allows multiple users to simultaneously access the system through terminals.&lt;/li&gt;
&lt;li&gt;supports collection of autonomous computers connected through network.&lt;/li&gt;
&lt;li&gt;supports sharing of data and resources.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(i) Identify the most appropriate type of operating system that exhibited these features justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The most appropriate type of operating system exhibiting these features is a &lt;strong&gt;Distributed Operating System&lt;/strong&gt;. This is justified because the features listed - support for multiple users accessing the system simultaneously, collection of autonomous computers connected through a network, and sharing of data and resources - are characteristic of distributed systems where resources and processing are spread across multiple computers working together as a single system image.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;A group of Module II students were carrying out research on types of operating systems. They listed the following features of a certain type of an operating system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allows multiple users to simultaneously access the system through terminals.&lt;/li&gt;
&lt;li&gt;supports collection of autonomous computers connected through network.&lt;/li&gt;
&lt;li&gt;supports sharing of data and resources.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(ii) Explain two advantages of the type of operating system identified in (1).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Sharing&lt;/strong&gt;: A &lt;strong&gt;Distributed Operating System&lt;/strong&gt; excels at &lt;strong&gt;resource sharing&lt;/strong&gt;. It allows users across different computers in the network to access and utilize resources such as files, printers, databases, and processing power as if they were on a single machine. This enhances efficiency and reduces redundancy by pooling resources and making them available to a wider user base, optimizing overall resource utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Enhanced Reliability and Fault Tolerance&lt;/strong&gt;: Distributed systems offer &lt;strong&gt;enhanced reliability and fault tolerance&lt;/strong&gt;. Because processing and resources are spread across multiple independent computers, the failure of one computer does not necessarily bring down the entire system. If one node fails, tasks can be redistributed to other nodes, ensuring continuous operation and minimizing downtime. This redundancy and resilience improve the overall robustness and availability of the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(i) Explain the term kernel as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;kernel&lt;/strong&gt; is the &lt;strong&gt;core component&lt;/strong&gt; of an operating system. It is the &lt;strong&gt;innermost layer&lt;/strong&gt; of the OS and has direct control over the hardware. The kernel provides essential services such as process management, memory management, device management, and system calls. It acts as a bridge between the hardware and user-level software, managing system resources and ensuring secure and efficient operation of the computer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between block-oriented and stream-oriented VO devices.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Block-Oriented I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block-oriented I/O devices&lt;/strong&gt; transfer data in &lt;strong&gt;fixed-size blocks&lt;/strong&gt;. Data is structured into blocks, and I/O operations are performed on these entire blocks at a time. These devices typically have &lt;strong&gt;addressable blocks&lt;/strong&gt;, allowing for random access to any block in the device. Examples of block-oriented devices include &lt;strong&gt;hard disks, SSDs, and tapes&lt;/strong&gt; (when used in block mode). Data transfer with block devices is usually buffered and may involve seek operations to locate specific blocks. Block devices are suitable for applications requiring structured data storage and random access, such as file systems and databases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream-Oriented I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stream-oriented I/O devices&lt;/strong&gt; transfer data as a &lt;strong&gt;continuous stream of bytes or characters&lt;/strong&gt;, without any fixed block structure. Data is processed and transferred sequentially, and there is typically no concept of addressable blocks or random access. Examples of stream-oriented devices include &lt;strong&gt;keyboards, mice, printers, and network interfaces&lt;/strong&gt;. Data transfer with stream devices is usually unbuffered or minimally buffered and is processed as a continuous flow. Stream devices are suitable for character-based input/output, communication, and real-time data streams where the sequence of data is important.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The primary difference lies in how data is organized and transferred. &lt;strong&gt;Block-oriented devices&lt;/strong&gt; use fixed-size blocks and allow random access, while &lt;strong&gt;stream-oriented devices&lt;/strong&gt; use continuous byte streams and are typically accessed sequentially. Block devices are for structured storage, and stream devices are for continuous data flow.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Susan was required to configure RAID on a computer system that contained two hard disks. Explain two most appropriate type of RAID she could use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;RAID 1 (Mirroring)&lt;/strong&gt;: &lt;strong&gt;RAID 1&lt;/strong&gt; is a highly appropriate choice for a system with two hard disks as it provides &lt;strong&gt;data redundancy and fault tolerance&lt;/strong&gt;. In RAID 1, data is mirrored across both disks, meaning an exact copy of the data is written to each disk. If one disk fails, the system can continue to operate using the remaining disk without data loss. RAID 1 is simple to implement with two disks and offers excellent data protection, making it suitable for scenarios where data reliability is paramount. However, it reduces the effective storage capacity by half, as one disk's capacity is used for mirroring.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;RAID 0 (Striping)&lt;/strong&gt;: Although RAID 0 does not provide fault tolerance, it is appropriate if Susan's primary goal is to &lt;strong&gt;improve performance&lt;/strong&gt;. RAID 0 stripes data across both disks, meaning data is split into segments and written alternately across the two disks. This allows for &lt;strong&gt;parallel read and write operations&lt;/strong&gt;, potentially doubling the data transfer rate compared to a single disk. RAID 0 is simple to implement with two disks and maximizes storage capacity and performance. However, it offers no redundancy; if either disk fails, all data is lost. Therefore, RAID 0 is suitable only if data loss is acceptable or if backups are managed separately, and performance is the main concern.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) (i) Outline two objectives of developing an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Management&lt;/strong&gt;: One primary objective is to &lt;strong&gt;manage computer hardware and software resources efficiently and effectively&lt;/strong&gt;. This includes managing the CPU, memory, I/O devices, and files. The OS aims to allocate resources fairly among different processes and users, optimize resource utilization, and prevent conflicts to ensure smooth system operation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;User Convenience and Interface&lt;/strong&gt;: Another key objective is to provide a &lt;strong&gt;user-friendly and convenient interface&lt;/strong&gt; for users to interact with the computer system. The OS should simplify complex hardware operations and provide abstractions that make it easier for users to run applications, manage files, and perform tasks. A good OS aims to enhance user productivity and experience by providing intuitive and efficient ways to use the computer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between SJF and FCFS process scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Shortest Job First (SJF) Scheduling Algorithm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SJF (Shortest Job First)&lt;/strong&gt; is a process scheduling algorithm that selects the process with the &lt;strong&gt;shortest estimated burst time&lt;/strong&gt; (CPU execution time) to run next. SJF aims to minimize the average waiting time and turnaround time of processes. It can be &lt;strong&gt;preemptive or non-preemptive&lt;/strong&gt;. In its non-preemptive version, once a process starts, it runs to completion. In the preemptive version (Shortest Remaining Time First - SRTF), a running process can be preempted if a new process arrives with a shorter remaining burst time. SJF is optimal in minimizing average waiting time but requires knowing or estimating the burst time of processes in advance, which can be challenging in practice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;First Come First Served (FCFS) Scheduling Algorithm&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FCFS (First Come First Served)&lt;/strong&gt; is the simplest process scheduling algorithm. It schedules processes in the &lt;strong&gt;order of their arrival&lt;/strong&gt; in the ready queue. The process that arrives first gets the CPU first. FCFS is &lt;strong&gt;non-preemptive&lt;/strong&gt;; once a process starts running, it continues until it completes or blocks for I/O. FCFS is easy to implement and understand but can lead to &lt;strong&gt;convoy effect&lt;/strong&gt;, where a long-running process blocks shorter processes behind it, resulting in higher average waiting and turnaround times, especially if processes arrive in a non-optimal order (e.g., long process arrives first).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference is in their scheduling criteria. &lt;strong&gt;SJF&lt;/strong&gt; prioritizes processes with the shortest burst time to minimize average waiting time, while &lt;strong&gt;FCFS&lt;/strong&gt; prioritizes processes based on their arrival order, regardless of their burst times. SJF is generally more efficient in terms of average waiting time but is more complex to implement and requires burst time estimation, whereas FCFS is simple but can be inefficient, especially with varying process lengths.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) State four process states in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;New&lt;/strong&gt;: The process is being &lt;strong&gt;created&lt;/strong&gt;.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Ready&lt;/strong&gt;: The process is &lt;strong&gt;ready to run&lt;/strong&gt; but waiting for the CPU to be allocated.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Running&lt;/strong&gt;: The process is &lt;strong&gt;currently being executed&lt;/strong&gt; by the CPU.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Waiting (or Blocked)&lt;/strong&gt;: The process is &lt;strong&gt;waiting for an event&lt;/strong&gt; to occur, such as I/O completion or resource availability.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain two benefits of using round robin scheduling algorithm in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Fairness&lt;/strong&gt;: &lt;strong&gt;Round Robin (RR)&lt;/strong&gt; provides &lt;strong&gt;fair allocation of CPU time&lt;/strong&gt; to all processes. Each process gets a fixed time slice (quantum) of CPU time in turns. This prevents starvation, ensuring that all processes, regardless of their priority or burst time, eventually get a chance to run. Fairness is particularly important in time-sharing systems where multiple users or interactive applications are running concurrently, as it ensures that no single process monopolizes the CPU.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Responsiveness and Good for Interactive Systems&lt;/strong&gt;: RR offers &lt;strong&gt;good responsiveness&lt;/strong&gt;, especially for interactive systems. Because each process gets a time slice regularly, even if it's a long process, the system remains responsive to user inputs and interactive tasks. Short processes can complete quickly, and long processes make steady progress without causing the system to become sluggish. This makes RR suitable for environments where users expect quick feedback and smooth interaction with applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) With the aid of a diagram, outline the client server structure of an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;Client-Server structure of an Operating System&lt;/strong&gt; separates the operating system functionalities into two main parts: the &lt;strong&gt;client&lt;/strong&gt; and the &lt;strong&gt;server&lt;/strong&gt;. The &lt;strong&gt;microkernel&lt;/strong&gt; acts as the core, providing minimal essential services, and other OS services are implemented as user-level servers that clients communicate with.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Client-Server OS Structure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    +-----------------------+   +-----------------------+   +-----------------------+  ... User Processes (Clients)
                    |     Client Process    |   |     Client Process    |   |     Client Process    |
                    +-----------------------+   +-----------------------+   +-----------------------+
                                  |                                   |                                   |
                                  +-----------------------------------+-----------------------------------+-------------------&amp;gt; Message Passing (Requests)
                                                        |
                                                        v
                                        +---------------------------------------+
                                        |               Microkernel               |
                                        | (Process Management, IPC, Memory Mgmt) |
                                        +---------------------------------------+
                                                        ^
                                                        | Message Passing (Responses)
                                  +-----------------------------------+-----------------------------------+-------------------
                                  |     File Server         |   |     Print Server        |   |     Network Server      | ... OS Services (Servers)
                                  +-----------------------+   +-----------------------+   +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Microkernel&lt;/strong&gt;: The &lt;strong&gt;microkernel&lt;/strong&gt; is the minimal core of the OS, containing only essential functionalities such as &lt;strong&gt;process management, inter-process communication (IPC), and basic memory management&lt;/strong&gt;. It is kept small and simple to enhance reliability and security.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User-Level Servers (OS Services)&lt;/strong&gt;: Most traditional OS services, such as &lt;strong&gt;file systems, device drivers, network services, and print services&lt;/strong&gt;, are implemented as &lt;strong&gt;user-level server processes&lt;/strong&gt; that run on top of the microkernel. These servers operate in user mode, separate from the kernel's privileged mode.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Client Processes&lt;/strong&gt;: &lt;strong&gt;User applications and processes&lt;/strong&gt; act as &lt;strong&gt;clients&lt;/strong&gt;. When a client process needs an OS service (e.g., file I/O, network access), it sends a &lt;strong&gt;request message&lt;/strong&gt; to the appropriate server process through the microkernel's IPC mechanism.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message Passing Communication&lt;/strong&gt;: Clients and servers communicate by &lt;strong&gt;exchanging messages&lt;/strong&gt; through the microkernel. The client sends a request message to the server, the server processes the request, and sends a &lt;strong&gt;response message&lt;/strong&gt; back to the client. All communication is mediated by the microkernel.&lt;/p&gt;
&lt;p&gt;This structure promotes modularity, extensibility, and fault isolation. Server failures are less likely to crash the entire system as servers run in user mode, and the microkernel remains protected.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Mary, a secretary with a certain company used operating systems to create directories for various lecturers. Outline four benefits of Mary's approach.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Organization of Files&lt;/strong&gt;: Creating directories allows for &lt;strong&gt;better organization of files&lt;/strong&gt;. Mary can categorize and group files related to each lecturer within their respective directories. This makes it easier to locate and manage files, preventing a cluttered and disorganized file system, and improving overall file management efficiency.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Reduced Naming Conflicts&lt;/strong&gt;: Directories help in &lt;strong&gt;reducing file naming conflicts&lt;/strong&gt;. Mary can use the same file names for different lecturers as long as they are within different directories. For example, she can have &quot;Notes.docx&quot; in each lecturer's directory without conflict. This is not possible in a flat, single-level directory, where all file names must be unique.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Improved Access Control and Security&lt;/strong&gt;: Directories facilitate &lt;strong&gt;better access control and security&lt;/strong&gt;. Mary can set permissions on each directory to control who can access, modify, or delete files within that directory. This allows for restricting access to lecturers' files, ensuring that only authorized personnel can access or modify specific files, enhancing data security and privacy.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Simplified File Sharing and Collaboration&lt;/strong&gt;: Directories can simplify &lt;strong&gt;file sharing and collaboration&lt;/strong&gt;. Mary can easily share a specific directory with a lecturer, granting them access to all files within that directory. This streamlines the process of sharing files related to a particular lecturer, making collaboration more efficient and organized compared to sharing individual files scattered across a flat file system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (a) Outline three file access methods that could be used in an operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential Access&lt;/strong&gt;: In &lt;strong&gt;sequential access&lt;/strong&gt;, files are accessed in a &lt;strong&gt;linear order&lt;/strong&gt;, from the beginning to the end. To access a specific record, one must read through all preceding records. This method is simple and efficient for processing files in order, like reading a log file.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Direct (Random) Access&lt;/strong&gt;: In &lt;strong&gt;direct access&lt;/strong&gt;, also known as random access, any record in a file can be accessed &lt;strong&gt;directly without reading preceding records&lt;/strong&gt;. This is achieved by using a record number or key to calculate the record's location. Direct access is suitable for applications needing quick access to specific records, like databases.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Indexed Sequential Access&lt;/strong&gt;: &lt;strong&gt;Indexed sequential access&lt;/strong&gt; combines sequential and direct access. It uses an &lt;strong&gt;index&lt;/strong&gt; to enable direct access to records, but also allows for efficient sequential processing. The index provides a lookup mechanism for direct access, while the sequential organization supports ordered processing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (7 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) With the aid of a diagram, outline the five levels of typical file systems architecture as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;five levels of a typical file system architecture&lt;/strong&gt; in operating systems represent a layered approach to file management, from the physical storage to the user interface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Five-Level File System Architecture:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    +-----------------------+  Level 5: User Application Layer
                    | User Applications     |  (File operations: read, write, open, close)
                    +-----------------------+
                    | Logical File System   |  Level 4: Logical File System Layer
                    | (File naming, directory structure, access control)
                    +-----------------------+
                    | File-Organization     |  Level 3: File Organization Layer
                    | Module                |  (Logical-to-physical address mapping, file metadata management)
                    +-----------------------+
                    | Basic File System     |  Level 2: Basic File System Layer
                    | (Generic commands to device drivers: read block, write block)
                    +-----------------------+
                    | I/O Control           |  Level 1: I/O Control Layer
                    | (Device drivers, hardware interaction)
                    +-----------------------+
                    | Storage Media         |  Level 0: Storage Media Layer
                    | (Disk, SSD, etc.)     |
                    +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Levels:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Level 5: User Application Layer&lt;/strong&gt;: This is the &lt;strong&gt;highest level&lt;/strong&gt;, where user applications interact with the file system. Applications use &lt;strong&gt;system calls&lt;/strong&gt; (e.g., `open`, `read`, `write`, `close`) to perform file operations. This layer is concerned with user-level file access and operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Level 4: Logical File System Layer&lt;/strong&gt;: This layer, also known as the &lt;strong&gt;file system interface&lt;/strong&gt;, provides the &lt;strong&gt;logical view&lt;/strong&gt; of the file system to users and applications. It handles &lt;strong&gt;file naming, directory structure, file metadata (attributes), and access control&lt;/strong&gt;. It translates user-level file operations into logical operations that the lower layers can understand.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Level 3: File Organization Module&lt;/strong&gt;: This layer is responsible for &lt;strong&gt;mapping logical file addresses to physical block addresses&lt;/strong&gt; on storage devices. It manages &lt;strong&gt;file metadata&lt;/strong&gt; (like file headers, inodes, or file allocation tables) that track the location of file blocks on disk. It deals with file allocation strategies, free space management, and logical-to-physical address translation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Level 2: Basic File System Layer&lt;/strong&gt;: This layer, sometimes called the &lt;strong&gt;file system proper&lt;/strong&gt;, provides &lt;strong&gt;basic file system commands&lt;/strong&gt; to interact with device drivers. It issues generic commands like &quot;read block,&quot; &quot;write block,&quot; and &quot;allocate block&quot; to the I/O control layer, abstracting away device-specific details. It focuses on block-level operations and management.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Level 1: I/O Control Layer&lt;/strong&gt;: This is the &lt;strong&gt;lowest software layer&lt;/strong&gt;, consisting of &lt;strong&gt;device drivers&lt;/strong&gt;. It interacts directly with the &lt;strong&gt;hardware controllers&lt;/strong&gt; of storage devices. Device drivers translate generic block-level requests from the basic file system into device-specific commands that the hardware can understand and execute. It handles hardware-specific I/O operations and interrupt handling.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Level 0: Storage Media Layer&lt;/strong&gt;: This is the &lt;strong&gt;physical storage medium&lt;/strong&gt; itself, such as &lt;strong&gt;hard disks, SSDs, or other storage devices&lt;/strong&gt;, where the actual file data is stored in physical blocks or sectors.&lt;/p&gt;
&lt;p&gt;This layered architecture provides abstraction, modularity, and device independence, making file system management organized and efficient.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) (i) Outline two goals of memory management in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficient Memory Utilization&lt;/strong&gt;: A primary goal is to &lt;strong&gt;utilize memory efficiently&lt;/strong&gt; to accommodate as many processes as possible and minimize wasted memory space. Techniques like dynamic allocation, virtual memory, and paging are used to optimize memory usage and improve system throughput by reducing fragmentation and overhead.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Address Translation and Protection&lt;/strong&gt;: Memory management aims to provide &lt;strong&gt;address translation&lt;/strong&gt; from logical to physical addresses, allowing processes to have their own virtual address space, and to implement &lt;strong&gt;memory protection&lt;/strong&gt;. Protection ensures that processes cannot access memory outside their allocated space, preventing interference and enhancing system stability and security.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between device drivers and device I/O as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Device Drivers&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device drivers&lt;/strong&gt; are &lt;strong&gt;software modules&lt;/strong&gt; that act as an &lt;strong&gt;interface between the operating system kernel and specific hardware devices&lt;/strong&gt;. They are device-specific and provide the low-level control and communication necessary for the OS to interact with hardware. Device drivers translate generic I/O requests from the kernel into device-specific commands that the hardware controller can understand. They handle hardware-specific operations, manage device registers, and handle interrupts from devices. Device drivers are essential for achieving device independence, allowing the OS to support a variety of hardware without modifying the core OS code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device I/O&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device I/O (Input/Output)&lt;/strong&gt; refers to the &lt;strong&gt;actual operations of transferring data between the computer system and external devices&lt;/strong&gt;. Device I/O encompasses the entire process of data exchange, including issuing I/O requests, device access, data transfer, and handling device status and interrupts. Device I/O operations are managed by the operating system, often initiated by user programs through system calls. The OS uses device drivers to carry out these I/O operations, controlling the hardware to perform data input or output. Device I/O is the fundamental mechanism for the computer system to interact with the external world.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device drivers&lt;/strong&gt; are the *software* components that enable communication with hardware, acting as translators between the OS and devices. &lt;strong&gt;Device I/O&lt;/strong&gt; is the *process* of data transfer itself, the actual operations performed by the system to input or output data using hardware devices, facilitated by device drivers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Paul, a programmer with a certain software company was required to design an operating system that would use segmentation to manage memory. Outline four advantages for using this memory management technique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Logical Address Space Structure&lt;/strong&gt;: Segmentation allows for a &lt;strong&gt;logical view of memory&lt;/strong&gt;, dividing the address space into logical units called segments (code, data, stack). This reflects the program's structure, making it easier to organize and manage memory logically. Programmers can work with logical segments, simplifying program design and modularity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Protection at Segment Level&lt;/strong&gt;: Segmentation enables &lt;strong&gt;fine-grained memory protection at the segment level&lt;/strong&gt;. Each segment can have its own protection attributes (read-only, read-write, execute-only), allowing the OS to enforce access control and prevent unauthorized access to specific segments. This enhances system security by providing segment-based protection boundaries.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Sharing of Segments&lt;/strong&gt;: Segmentation facilitates &lt;strong&gt;sharing of segments between processes&lt;/strong&gt;. Segments, especially code segments for libraries or shared modules, can be shared among multiple processes while maintaining protection. This reduces memory duplication, improves memory efficiency, and enables efficient code sharing between programs.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Dynamic Growth of Segments&lt;/strong&gt;: Segments can &lt;strong&gt;grow or shrink dynamically&lt;/strong&gt; as needed during program execution. This allows flexible memory allocation and efficient use of memory, as segments can adjust their size according to the program's data or code requirements, reducing wasted memory space compared to fixed-size partitions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) Explain the term pipe as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;pipe&lt;/strong&gt; in operating systems is a mechanism for &lt;strong&gt;inter-process communication (IPC)&lt;/strong&gt; that allows &lt;strong&gt;unidirectional data flow&lt;/strong&gt; between two or more processes. It acts as a &lt;strong&gt;communication channel&lt;/strong&gt; where one process can write data into one end of the pipe, and another process can read that data from the other end. Pipes are typically used for communication between related processes, like parent and child processes, or processes in a pipeline of commands. They provide a simple and efficient way for processes to exchange data sequentially.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Outline four factors that should be considered when selecting computer memory other than cost.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed (Access Time and Cycle Time)&lt;/strong&gt;: &lt;strong&gt;Memory speed&lt;/strong&gt; is a crucial factor, measured by &lt;strong&gt;access time&lt;/strong&gt; (time to retrieve data) and &lt;strong&gt;cycle time&lt;/strong&gt; (time between successive accesses). Faster memory reduces latency and improves system performance. Different memory types (e.g., DDR5, DDR4) offer varying speeds. The required speed depends on the application and system performance needs.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Capacity (Size)&lt;/strong&gt;: &lt;strong&gt;Memory capacity&lt;/strong&gt;, measured in GB or TB, determines the amount of data and programs that can be held in memory simultaneously. Higher capacity allows for running more applications and handling larger datasets without relying on slower secondary storage (disk). The needed capacity depends on the workload and expected memory usage of applications.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Latency&lt;/strong&gt;: &lt;strong&gt;Memory latency&lt;/strong&gt; is the delay between requesting data and the data becoming available. Lower latency improves system responsiveness, especially for applications that require frequent memory accesses. Memory latency affects overall CPU performance and application speed. Different memory technologies have different latency characteristics.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Power Consumption and Energy Efficiency&lt;/strong&gt;: &lt;strong&gt;Power consumption&lt;/strong&gt; is an important factor, especially for portable devices and energy-efficient systems. Memory modules vary in their power requirements and energy efficiency. Lower power consumption reduces heat generation, extends battery life in laptops, and lowers operating costs in data centers. Energy efficiency is increasingly important for sustainable computing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Explain three approaches that could be used to manage deadlocks in an operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Deadlock Prevention&lt;/strong&gt;: &lt;strong&gt;Deadlock prevention&lt;/strong&gt; aims to &lt;strong&gt;prevent deadlocks by negating one or more of the necessary conditions for deadlock&lt;/strong&gt; to occur (Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait). Techniques include: * &lt;strong&gt;Mutual Exclusion&lt;/strong&gt;: Making resources shareable (not always possible). * &lt;strong&gt;Hold and Wait&lt;/strong&gt;: Requiring processes to request all needed resources at once or not hold resources when requesting new ones. * &lt;strong&gt;No Preemption&lt;/strong&gt;: Allowing preemption of resources from a process under certain conditions. * &lt;strong&gt;Circular Wait&lt;/strong&gt;: Imposing a linear ordering of resource types and requiring processes to request resources in increasing order. Deadlock prevention is proactive but can lead to reduced resource utilization and system performance due to restrictions on resource allocation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Deadlock Avoidance&lt;/strong&gt;: &lt;strong&gt;Deadlock avoidance&lt;/strong&gt; allows the system to enter a potential deadlock state but &lt;strong&gt;makes decisions to avoid entering a deadlock&lt;/strong&gt;. It requires the system to have &lt;strong&gt;a priori information&lt;/strong&gt; about the maximum resource needs of each process. Algorithms like the &lt;strong&gt;Banker's Algorithm&lt;/strong&gt; are used to dynamically check if granting a resource request will lead to a safe state (a state where all processes can complete without deadlock). Deadlock avoidance is less restrictive than prevention but requires advance knowledge and can also limit resource utilization to ensure safety.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Deadlock Detection and Recovery&lt;/strong&gt;: &lt;strong&gt;Deadlock detection and recovery&lt;/strong&gt; allows deadlocks to occur but &lt;strong&gt;detects when a deadlock has happened and takes actions to recover&lt;/strong&gt;. The system periodically checks for deadlocks using algorithms to detect cycles in the resource allocation graph. If a deadlock is detected, recovery strategies are employed, such as &lt;strong&gt;process termination&lt;/strong&gt; (aborting one or more deadlocked processes) or &lt;strong&gt;resource preemption&lt;/strong&gt; (forcibly taking resources from processes). Deadlock detection and recovery is reactive, allowing for higher resource utilization but incurring overhead for detection and recovery, and potentially causing process restarts and data loss during recovery.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Figure 1 shows a typical a process control block diagram in an operating system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-27-13_2012n.pdf.png&quot; alt=&quot;&quot; width=&quot;519&quot; height=&quot;526&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure1_q4d.png&quot; alt=&quot;Figure 1 Process Control Block Diagram&quot; /&gt;
&lt;p&gt;(i) Identify each of the layers of the diagram labeled (i), (ii), (iii) and (iv).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;Based on Figure 1, which represents a Process Control Block (PCB) diagram:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) Process Identifier (PID) / Process Number&lt;/strong&gt;: Label (i) points to the section for &quot;Process number&quot;. This field is the &lt;strong&gt;unique identifier&lt;/strong&gt; assigned to each process by the operating system. It is used to distinguish and manage different processes within the system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Program Counter (PC)&lt;/strong&gt;: Label (ii) points to a section that would typically represent the &lt;strong&gt;Program Counter&lt;/strong&gt;. The Program Counter stores the &lt;strong&gt;address of the next instruction&lt;/strong&gt; to be executed by the process. It is crucial for process execution and context switching.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iii) Registers&lt;/strong&gt;: Label (iii) likely indicates the section for &lt;strong&gt;CPU Registers&lt;/strong&gt;. This area stores the &lt;strong&gt;current values of the CPU registers&lt;/strong&gt; for the process. Registers hold temporary data and intermediate results that the process is actively using. Saving and restoring register values is a key part of context switching.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iv) Process State&lt;/strong&gt;: Label (iv) points to &quot;Process state&quot;. This field indicates the &lt;strong&gt;current state of the process&lt;/strong&gt;, such as New, Ready, Running, Waiting, or Terminated. The process state is essential for process scheduling and management, reflecting the current activity and status of the process within the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (ii) (4marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Figure 1 shows a typical a process control block diagram in an operating system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;(ii) Outline four elements of process control information in a process control block diagram.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Process State&lt;/strong&gt;: The &lt;strong&gt;current state of the process&lt;/strong&gt; (e.g., running, ready, waiting, new, terminated) is a critical element. It indicates the current activity of the process and is used by the scheduler to manage process execution.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: The &lt;strong&gt;program counter&lt;/strong&gt;, as mentioned, stores the address of the next instruction to be executed. It is essential for resuming process execution after context switches or interruptions.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;CPU Registers&lt;/strong&gt;: The &lt;strong&gt;contents of CPU registers&lt;/strong&gt;, including general-purpose registers, stack pointer, and status registers, need to be saved in the PCB. These registers hold the process's working data and execution context and must be restored when the process resumes execution.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Memory Management Information&lt;/strong&gt;: The PCB contains &lt;strong&gt;memory management information&lt;/strong&gt;, such as pointers to page tables or segment tables. This information is necessary for the operating system to manage the process's virtual memory space and translate virtual addresses to physical addresses during execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) (i) Explain the term semaphore as used in operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;A &lt;strong&gt;semaphore&lt;/strong&gt; is a synchronization primitive used in operating systems for controlling access to &lt;strong&gt;shared resources&lt;/strong&gt; and for process synchronization. It is an integer variable that, apart from initialization, is accessed only through two atomic operations: &lt;strong&gt;wait (P)&lt;/strong&gt; and &lt;strong&gt;signal (V)&lt;/strong&gt;. Semaphores help manage critical sections and prevent race conditions in concurrent systems by controlling the number of processes that can access a resource simultaneously.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between fixed and dynamic memory partitioning.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Fixed Memory Partitioning&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;fixed memory partitioning&lt;/strong&gt;, main memory is divided into a &lt;strong&gt;fixed number of partitions&lt;/strong&gt; at system initialization. Each partition has a &lt;strong&gt;predetermined size&lt;/strong&gt;, which is set at system startup and remains constant. Partitions can be of equal size (equal-sized partitioning) or varying sizes (unequal-sized partitioning). Each partition can hold only one process at a time. &lt;strong&gt;Advantages&lt;/strong&gt;: Simple to implement and manage. &lt;strong&gt;Disadvantages&lt;/strong&gt;: Internal fragmentation (if process size is smaller than partition size), limits degree of multiprogramming due to fixed number of partitions, and inefficient memory utilization if partition sizes are not well-matched to process sizes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic Memory Partitioning&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;dynamic memory partitioning&lt;/strong&gt;, memory partitions are created &lt;strong&gt;dynamically at runtime&lt;/strong&gt;, based on the actual memory requirements of processes. When a process needs to be loaded, the operating system allocates a partition of exactly the size needed by the process from the available free memory. Partitions are created and sized as needed, and they are not fixed beforehand. &lt;strong&gt;Advantages&lt;/strong&gt;: Reduces internal fragmentation as partitions are tailored to process size, allows for more efficient memory utilization compared to fixed partitioning. &lt;strong&gt;Disadvantages&lt;/strong&gt;: External fragmentation can occur over time as memory becomes fragmented into smaller, non-contiguous blocks, and memory management is more complex compared to fixed partitioning.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The primary difference is in how partitions are created and sized. &lt;strong&gt;Fixed partitioning&lt;/strong&gt; uses pre-defined, static partitions, while &lt;strong&gt;dynamic partitioning&lt;/strong&gt; creates partitions dynamically based on process needs. Fixed partitioning is simpler but leads to internal fragmentation, while dynamic partitioning is more memory-efficient but can suffer from external fragmentation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows a typical I/O communication technique. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-28-29_2012n.pdf.png&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;599&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure2_q5b.png&quot; alt=&quot;Figure 2 I/O Communication Technique Diagram&quot; /&gt;
&lt;p&gt;(i) Identify the I/O communication technique exhibited in the diagram justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The I/O communication technique exhibited in the diagram is &lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt;. This is identified by the presence of a &quot;DMA Controller&quot; component shown in the diagram, which is responsible for managing data transfer between the I/O subsystem and Main memory, bypassing the direct involvement of the CPU for each data word transfer.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows a typical I/O communication technique. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;(ii) Outline the procedure used by the I/O communication technique identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The procedure used by &lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt; communication technique is as follows:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;CPU Initiation&lt;/strong&gt;: The CPU initiates the DMA transfer by programming the &lt;strong&gt;DMA Controller&lt;/strong&gt;. This involves providing the DMA controller with information such as the &lt;strong&gt;source address&lt;/strong&gt; (memory or I/O device), &lt;strong&gt;destination address&lt;/strong&gt; (memory or I/O device), &lt;strong&gt;data count&lt;/strong&gt; (number of bytes to transfer), and the &lt;strong&gt;direction of transfer&lt;/strong&gt; (read or write).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;DMA Transfer Execution&lt;/strong&gt;: Once programmed, the DMA controller takes over the data transfer. It &lt;strong&gt;directly transfers data&lt;/strong&gt; between the I/O device and main memory via the &lt;strong&gt;System bus&lt;/strong&gt;, without further CPU intervention for each byte or word transferred. The CPU is free to perform other tasks concurrently during this DMA transfer.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data Transfer and Memory Access&lt;/strong&gt;: The DMA controller &lt;strong&gt;requests access to the system bus&lt;/strong&gt; and main memory. It manages the data transfer process, handling addressing, bus arbitration, and data synchronization. Data is transferred in blocks or bursts for efficiency.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Transfer Completion and Notification&lt;/strong&gt;: After completing the data transfer, the DMA controller &lt;strong&gt;notifies the CPU&lt;/strong&gt;, typically through an &lt;strong&gt;interrupt&lt;/strong&gt;. This signals that the DMA operation is complete, and the CPU can then process the transferred data or initiate further I/O operations. The DMA controller relinquishes control of the bus after the transfer is done.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Tom, an intern student was required to design I/O module for a certain operating system. Explain two objectives that he could consider.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Independence&lt;/strong&gt;: One key objective is to achieve &lt;strong&gt;device independence&lt;/strong&gt;. The I/O module should be designed to provide a &lt;strong&gt;uniform interface&lt;/strong&gt; to the operating system and user programs, regardless of the specific characteristics of different I/O devices. This allows applications to perform I/O operations without needing to know the details of each device, making the system more portable and easier to maintain. Device drivers handle device-specific details, providing an abstraction layer.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Efficiency and Performance&lt;/strong&gt;: Another crucial objective is to ensure &lt;strong&gt;efficient and high-performance I/O operations&lt;/strong&gt;. The I/O module should be designed to minimize overhead, maximize data transfer rates, and optimize resource utilization. Techniques like &lt;strong&gt;buffering, caching, and DMA&lt;/strong&gt; should be considered to improve I/O performance and reduce CPU involvement in data transfer. Efficiency is essential for overall system responsiveness and throughput.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Mark, a systems consultant recommended an I/O buffering add-on module to an operating system. Explain two conditions that could justify Mark's recommendation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed Mismatch between CPU and I/O Devices&lt;/strong&gt;: A condition justifying I/O buffering is a significant &lt;strong&gt;speed mismatch between the CPU and I/O devices&lt;/strong&gt;. I/O devices, especially slower ones like hard disks or network interfaces, operate at speeds much lower than the CPU's processing speed. Buffering can &lt;strong&gt;bridge this speed gap&lt;/strong&gt; by temporarily holding data being transferred between the CPU and I/O devices. This allows the CPU to continue processing without waiting for slow I/O operations to complete, improving overall system throughput and CPU utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Transfer Size Discrepancies&lt;/strong&gt;: Another condition is when there are &lt;strong&gt;discrepancies in data transfer sizes&lt;/strong&gt; between the CPU/memory and I/O devices. For example, the CPU may process data in larger blocks, while I/O devices may transfer data in smaller units or variable sizes. Buffering provides a &lt;strong&gt;temporary storage area to accumulate or decompose data&lt;/strong&gt;, enabling efficient data transfer between components with different data handling granularities. Buffering helps to adapt data flow to match the requirements of both the CPU/memory system and the I/O devices, optimizing data transfer efficiency and reducing overhead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) Explain each of the following terms as used in I/O devices:&lt;/p&gt;
&lt;p&gt;(i) disk cache:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Disk Cache&lt;/strong&gt; is a &lt;strong&gt;portion of RAM&lt;/strong&gt; (Random Access Memory) that is used as a &lt;strong&gt;cache memory for disk I/O operations&lt;/strong&gt;. It stores frequently accessed data blocks from the hard disk to speed up subsequent accesses. When the system needs to read data from the disk, it first checks the disk cache. If the data is found in the cache (cache hit), it is retrieved from the faster RAM cache instead of the slower disk, significantly reducing access time and improving I/O performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Explain each of the following terms as used in I/O devices:&lt;/p&gt;
&lt;p&gt;(ii) cache manager.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cache Manager&lt;/strong&gt; is the &lt;strong&gt;software component&lt;/strong&gt; within the operating system that &lt;strong&gt;manages the disk cache&lt;/strong&gt;. It is responsible for implementing cache policies, such as deciding which data blocks to store in the cache, when to retrieve data from disk into the cache, and which blocks to replace when the cache is full (cache replacement policies). The cache manager aims to optimize cache hit rate and minimize cache misses, thereby maximizing the performance benefits of disk caching.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) A group of Module II students were carrying out assignment on categories of I/O devices. Explain two categories they are likely to have mentioned in the report.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Storage Devices&lt;/strong&gt;: &lt;strong&gt;Storage devices&lt;/strong&gt; form a major category of I/O devices, used for &lt;strong&gt;long-term data storage&lt;/strong&gt;. These include &lt;strong&gt;Hard Disk Drives (HDDs) and Solid State Drives (SSDs)&lt;/strong&gt;. HDDs use magnetic platters for storage and are characterized by larger capacities and lower cost per GB, but have slower access times and higher latency. SSDs use flash memory for storage, offering much faster access times, lower latency, and better durability, but are typically more expensive per GB and may have lower capacities compared to HDDs. Storage devices are crucial for persistent data storage and file systems.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Human-Interface Devices (HIDs)&lt;/strong&gt;: &lt;strong&gt;Human-Interface Devices (HIDs)&lt;/strong&gt; constitute another significant category, enabling &lt;strong&gt;human-computer interaction&lt;/strong&gt;. These include &lt;strong&gt;keyboards, mice, monitors, and touchscreens&lt;/strong&gt;. Keyboards and mice are input devices for user commands and data entry. Monitors and touchscreens are output devices for displaying visual information and, in the case of touchscreens, also for input. HIDs facilitate user interaction with the computer system, enabling input, output, and control.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Ann, an intern student was required to list elements in a file descriptor in her company's file system. Outline four elements that she could have listed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;File Permissions/Access Rights&lt;/strong&gt;: &lt;strong&gt;File permissions&lt;/strong&gt; define who can access the file and what operations they are allowed to perform (e.g., read, write, execute). Permissions typically include settings for the file owner, group, and others, controlling access for different categories of users.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;File Size&lt;/strong&gt;: &lt;strong&gt;File size&lt;/strong&gt; indicates the current size of the file in bytes or blocks. This attribute is essential for storage management, disk space allocation, and for applications to know the amount of data they are dealing with.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;File Owner and Group IDs&lt;/strong&gt;: &lt;strong&gt;Owner ID and Group ID&lt;/strong&gt; identify the user and group associated with the file. These attributes are crucial for implementing file ownership and access control, determining who has administrative rights over the file and which group it belongs to.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;File Data Block Locations&lt;/strong&gt;: &lt;strong&gt;Pointers to data blocks&lt;/strong&gt; or extent information indicating where the actual file data is stored on disk. This is critical for the file system to locate and retrieve the file's content from physical storage. The method of tracking data block locations varies depending on the file system (e.g., inodes, file allocation tables).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) For each of the following cases, explain the most appropriate disk scheduling algorithm for the following scenarios:&lt;/p&gt;
&lt;p&gt;(i) fair clustered requests;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;For &lt;strong&gt;fair clustered requests&lt;/strong&gt;, the most appropriate disk scheduling algorithm is &lt;strong&gt;SCAN (Elevator)&lt;/strong&gt; or &lt;strong&gt;C-SCAN (Circular SCAN)&lt;/strong&gt;. These algorithms provide fairness by servicing requests in a sweep across the disk, preventing starvation and ensuring that all parts of the disk get serviced. SCAN and C-SCAN are effective in handling clustered requests as they efficiently service requests in the direction of head movement, reducing seek times and providing a balance between performance and fairness.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) For each of the following cases, explain the most appropriate disk scheduling algorithm for the following scenarios:&lt;/p&gt;
&lt;p&gt;(ii) minimizes seek time;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;For the scenario where the goal is to &lt;strong&gt;minimize seek time&lt;/strong&gt;, the most appropriate disk scheduling algorithm is &lt;strong&gt;Shortest Seek Time First (SSTF)&lt;/strong&gt;. SSTF algorithm selects the disk request that requires the &lt;strong&gt;minimum seek distance&lt;/strong&gt; from the current head position. By always choosing the nearest request, SSTF minimizes the overall head movement and, consequently, the average seek time, leading to improved disk throughput and reduced response times.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) For each of the following cases, explain the most appropriate disk scheduling algorithm for the following scenarios:&lt;/p&gt;
&lt;p&gt;(iii) services requests in track order based on the movement of the head;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;For servicing requests in track order based on head movement, the most appropriate disk scheduling algorithm is &lt;strong&gt;SCAN (Elevator)&lt;/strong&gt; or &lt;strong&gt;C-SCAN (Circular SCAN)&lt;/strong&gt;. These algorithms move the disk head in one direction, servicing all requests encountered in that direction, and then reverse or reposition the head to continue servicing in the other direction (SCAN) or from the beginning (C-SCAN). They naturally service requests in track order along the path of head movement.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (iv) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) For each of the following cases, explain the most appropriate disk scheduling algorithm for the following scenarios:&lt;/p&gt;
&lt;p&gt;(iv) changes directions when read/write head reaches the last request in the current direction.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;For the scenario of changing directions when the read/write head reaches the last request in the current direction, the most appropriate disk scheduling algorithm is &lt;strong&gt;SCAN (Elevator)&lt;/strong&gt;. The SCAN algorithm specifically operates by moving the head in one direction, servicing requests, and then reversing direction when it reaches the last request in that direction (or the end of the disk), resembling the movement of an elevator servicing floors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) Outline four properties of a file system as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Data Persistence&lt;/strong&gt;: A file system provides &lt;strong&gt;persistent storage&lt;/strong&gt; for data, meaning data is stored in files on non-volatile storage devices (like hard disks or SSDs) and remains available even after the system is powered off. This property ensures that data is not lost when the system shuts down, enabling long-term data retention.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Organization and Hierarchical Structure&lt;/strong&gt;: File systems organize files into a &lt;strong&gt;hierarchical directory structure&lt;/strong&gt; (tree-like structure). This allows users to group related files into directories (folders), creating a logical and organized file system. Hierarchical structure simplifies file management, navigation, and organization, making it easier to locate and access files.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Naming and Identification&lt;/strong&gt;: A file system provides a &lt;strong&gt;naming scheme for files and directories&lt;/strong&gt;, allowing users to identify and access files using names. File names are typically human-readable and follow specific naming conventions. The file system manages the mapping between file names and their physical storage locations, enabling users to refer to files by name rather than physical addresses.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Access Control and Security&lt;/strong&gt;: File systems incorporate &lt;strong&gt;access control mechanisms&lt;/strong&gt; to regulate who can access files and directories and what operations they can perform (read, write, execute). Permissions and access rights are used to protect files from unauthorized access, modification, or deletion, ensuring data security and privacy. File system security mechanisms control and manage access based on user and group identities.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between cache memory and main memory as used in computer systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cache Memory&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache memory&lt;/strong&gt; is a &lt;strong&gt;small, fast memory&lt;/strong&gt; that is located closer to the CPU than main memory. It is used to store &lt;strong&gt;frequently accessed data and instructions&lt;/strong&gt; to speed up access times. Cache memory operates on the principles of locality (temporal and spatial locality), predicting that data recently accessed or near recently accessed data is likely to be needed again soon. There are typically multiple levels of cache (L1, L2, L3), with L1 being the fastest and smallest, closest to the CPU. Cache is &lt;strong&gt;expensive and volatile&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Main Memory (RAM)&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Main memory&lt;/strong&gt;, or &lt;strong&gt;RAM (Random Access Memory)&lt;/strong&gt;, is the &lt;strong&gt;primary memory&lt;/strong&gt; of the computer system. It is larger and slower than cache memory but faster than secondary storage (like hard drives). RAM is used to store the &lt;strong&gt;currently running programs and data&lt;/strong&gt; that the CPU is actively using. RAM is also &lt;strong&gt;volatile&lt;/strong&gt;, meaning it loses its data when power is turned off. It is less expensive per byte compared to cache memory and provides a larger capacity for working data and programs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main differences lie in &lt;strong&gt;speed, size, cost, and purpose&lt;/strong&gt;. &lt;strong&gt;Cache memory&lt;/strong&gt; is smaller, faster, more expensive, and used for temporary storage of frequently accessed data to speed up CPU access. &lt;strong&gt;Main memory (RAM)&lt;/strong&gt; is larger, slower, less expensive, and serves as the primary working memory for running programs and data.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) XWZ Software Company Ltd. intends to design an operating system that would ensure efficient memory placements. Explain three types of placement algorithms it could design.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;First-Fit&lt;/strong&gt;: The &lt;strong&gt;First-Fit algorithm&lt;/strong&gt; is a memory placement technique that allocates the &lt;strong&gt;first available memory partition&lt;/strong&gt; (or hole) that is large enough to accommodate the process. The operating system scans through the list of free memory partitions in order and selects the first one that satisfies the memory requirement. &lt;strong&gt;Advantage&lt;/strong&gt;: Simple and fast to implement as it only requires a linear scan of free partitions. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Can lead to fragmentation and may not efficiently utilize memory space, potentially leaving larger free blocks unused at the end of memory.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Best-Fit&lt;/strong&gt;: The &lt;strong&gt;Best-Fit algorithm&lt;/strong&gt; allocates the &lt;strong&gt;smallest available memory partition&lt;/strong&gt; that is large enough to hold the process. The operating system searches the entire list of free partitions and chooses the one that is closest in size to the process's requirement. &lt;strong&gt;Advantage&lt;/strong&gt;: Tends to minimize memory wastage and external fragmentation compared to first-fit by using up smaller free blocks. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Can be slower than first-fit due to the need to search the entire list to find the best fit and may lead to many small, unusable free blocks remaining.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Worst-Fit&lt;/strong&gt;: The &lt;strong&gt;Worst-Fit algorithm&lt;/strong&gt; allocates the &lt;strong&gt;largest available memory partition&lt;/strong&gt; to the process. The operating system searches through all free partitions and selects the largest one. &lt;strong&gt;Advantage&lt;/strong&gt;: Aims to leave larger free blocks after allocation, potentially accommodating larger future processes. &lt;strong&gt;Disadvantage&lt;/strong&gt;: Can quickly deplete larger free blocks, leading to fragmentation and potentially making it difficult to allocate memory for large processes in the long run, and may result in larger internal fragmentation for smaller processes allocated to very large partitions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Figure 2 shows a memory management technique used in systems. Use to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-30-13_2012n.pdf.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;665&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure2_q7d.png&quot; alt=&quot;Figure 2 Memory Management Technique Diagram&quot; /&gt;
&lt;p&gt;(i) Describe the memory management technique represented in the figure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The memory management technique represented in Figure 2 is &lt;strong&gt;Paging&lt;/strong&gt;. This is indicated by the diagram showing:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Logical Address&lt;/strong&gt; being divided into two parts: &lt;strong&gt;p (page number)&lt;/strong&gt; and &lt;strong&gt;d (page offset)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;- A &lt;strong&gt;Page Table&lt;/strong&gt;, which is used to map page numbers to frame numbers.&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Physical Address&lt;/strong&gt; being constructed from the &lt;strong&gt;frame number (f)&lt;/strong&gt; obtained from the page table and the &lt;strong&gt;page offset (d)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;- The process of address translation where a logical address is converted into a physical address using the page table to locate the physical frame in &lt;strong&gt;physical memory&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;These elements are characteristic of paged memory management, where virtual memory is divided into fixed-size pages and physical memory into frames, and a page table manages the mapping between them.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;Figure 2 shows a memory management technique used in systems. Use to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;(ii) Outline two advantages of the technique described in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Eliminates External Fragmentation&lt;/strong&gt;: &lt;strong&gt;Paging eliminates external fragmentation&lt;/strong&gt;. Because both logical and physical memory are divided into fixed-size pages and frames, any available frame can be used to load a page of a process. This prevents the situation where there is enough total free memory but it is non-contiguous and cannot be used to load a process, which is a problem in segmentation and dynamic partitioning.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Supports Virtual Memory&lt;/strong&gt;: Paging is a fundamental technique for implementing &lt;strong&gt;virtual memory&lt;/strong&gt;. It allows processes to have a logical address space larger than the physical memory. Only the currently needed pages of a process need to be in RAM, while the rest can reside on secondary storage (disk). This enables running larger programs than physical memory size and increases the degree of multiprogramming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (i) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) (i) Outline three components of processor's I/O instruction in a programmed I/O communication technique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Opcode (Operation Code)&lt;/strong&gt;: The &lt;strong&gt;opcode&lt;/strong&gt; specifies the &lt;strong&gt;type of I/O operation&lt;/strong&gt; to be performed. It indicates whether the instruction is for input (read from device) or output (write to device), and potentially other control functions. The opcode tells the processor what action to take concerning I/O.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Device Address or Port Number&lt;/strong&gt;: The I/O instruction must include the &lt;strong&gt;address or port number&lt;/strong&gt; of the specific &lt;strong&gt;I/O device&lt;/strong&gt; that the operation is intended for. This address uniquely identifies the target device (e.g., a specific peripheral controller or port). The device address ensures that the instruction is directed to the correct I/O device.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Data or Memory Address&lt;/strong&gt;: The I/O instruction typically needs to specify a &lt;strong&gt;data operand or a memory address&lt;/strong&gt;. For output operations, this may be the &lt;strong&gt;data to be written&lt;/strong&gt; to the device. For input operations, this may be a &lt;strong&gt;memory address where the data read from the device should be stored&lt;/strong&gt;. This component defines the data involved in the I/O transfer or the memory location for data exchange.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of a diagram in each case, describe the following parts of a disk:&lt;/p&gt;
&lt;p&gt;I. sector;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Sector&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;sector&lt;/strong&gt; is the &lt;strong&gt;smallest physical storage unit&lt;/strong&gt; on a disk. It is a subdivision of a track and is used to store a fixed amount of data, typically 512 bytes or 4KB. Sectors are the fundamental units for disk read and write operations. Each track on a disk is divided into multiple sectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Sector:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                       Track
                    +-----------------------+
                    | Sector 1 | Sector 2 | Sector 3 | ... | Sector N |
                    +-----------------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;: Sectors are pie-shaped segments within a track, each storing a fixed block of data and having a sector ID for addressing.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) With the aid of a diagram in each case, describe the following parts of a disk:&lt;/p&gt;
&lt;p&gt;II. track.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;II. Track&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;track&lt;/strong&gt; is a &lt;strong&gt;concentric circular path&lt;/strong&gt; on the surface of a disk platter where data is recorded. Tracks are arranged in concentric rings around the center of the platter. Data is written and read sequentially along a track. A disk platter contains many tracks, and tracks are further divided into sectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Track:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                         Disk Platter
                       +-------------+
                     /               \
                    /  Track 0 (outer)  \
                   |   -------------   |
                   |  Track 1          |
                   |   -------------   |
                   |      ...          |
                   |   -------------   |
                   \  Track N (inner)  /
                    \               /
                       +-------------+
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;: Tracks are concentric rings on the platter surface, each track storing data sequentially and being divided into sectors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (5 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Maurine, an intern system analyst with Ujuzi Company Ltd. was required to establish a file organization method for her Company's database system. Outline five criteria she could consider when selecting the file organization method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Type and Frequency&lt;/strong&gt;: Maurine should consider the &lt;strong&gt;primary access type&lt;/strong&gt; for the database. Is it mainly &lt;strong&gt;sequential access&lt;/strong&gt; (e.g., batch processing, reports) or &lt;strong&gt;random access&lt;/strong&gt; (e.g., transaction processing, queries)? Also, consider the &lt;strong&gt;frequency of access&lt;/strong&gt; for different types of operations (read-heavy vs. write-heavy). The chosen file organization should efficiently support the dominant access patterns and frequencies.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Volatility and Update Requirements&lt;/strong&gt;: Consider how frequently the database data will be &lt;strong&gt;updated or modified&lt;/strong&gt;. If updates are frequent, the file organization should efficiently support record insertion, deletion, and modification without significant performance overhead. Highly volatile data may favor organizations that handle updates efficiently. For relatively static data, update efficiency might be less critical.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Storage Efficiency and Overhead&lt;/strong&gt;: Evaluate the &lt;strong&gt;storage efficiency&lt;/strong&gt; of different file organizations. Some methods may lead to more wasted space (e.g., internal or external fragmentation), while others are more space-efficient. Also, consider the &lt;strong&gt;overhead&lt;/strong&gt; associated with metadata (indexes, headers) required by the file organization. Storage efficiency and overhead impact the overall disk space utilization and storage costs for the database.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Search and Retrieval Performance&lt;/strong&gt;: Assess the &lt;strong&gt;performance of search and retrieval operations&lt;/strong&gt;. The file organization should enable efficient retrieval of specific records based on search criteria (keys). Consider the speed of record lookup, query processing, and data retrieval for common database queries. Different file organizations offer varying search efficiencies, impacting query response times.&lt;/p&gt;
&lt;p data-number=&quot;5&quot;&gt;&lt;strong&gt;Implementation Complexity and Maintenance&lt;/strong&gt;: Consider the &lt;strong&gt;complexity of implementing and maintaining&lt;/strong&gt; the file organization method. Some methods are simpler to implement and manage, while others are more complex, requiring specialized skills and tools. Balance the performance benefits with the complexity of implementation and long-term maintenance overhead. Simpler methods may be preferred if development time and maintenance are key concerns.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Jua-kali Company Ltd. is experiencing privacy issues with confidential information in their system. Explain two logical security measures it could use to mitigate the problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Control Mechanisms&lt;/strong&gt;: Implement robust &lt;strong&gt;access control mechanisms&lt;/strong&gt;, such as &lt;strong&gt;Access Control Lists (ACLs) or Role-Based Access Control (RBAC)&lt;/strong&gt;. These mechanisms restrict access to confidential information based on user identity and roles. Configure permissions to ensure that only authorized personnel can access, modify, or delete sensitive data. Access control helps prevent unauthorized users from gaining access to confidential information, mitigating privacy issues.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Encryption&lt;/strong&gt;: Employ &lt;strong&gt;data encryption&lt;/strong&gt; to protect confidential information both &lt;strong&gt;in transit and at rest&lt;/strong&gt;. Encrypt sensitive data files and databases using strong encryption algorithms. Encryption ensures that even if unauthorized individuals gain access to the data, it remains unreadable without the decryption key. Use encryption for data stored on servers, backups, and during transmission over networks to prevent data breaches and protect privacy.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) An operating system has been designed to use memory overlay. Explain two disadvantages of this technique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Programming Complexity and Programmer Burden&lt;/strong&gt;: &lt;strong&gt;Overlay programming&lt;/strong&gt; is &lt;strong&gt;complex and places a significant burden on programmers&lt;/strong&gt;. Developers must manually divide programs into overlays and carefully manage the loading and unloading of overlays during execution. This requires detailed knowledge of memory usage and program structure, making program development and maintenance more difficult and error-prone. Programmers need to handle overlay management explicitly, increasing development time and complexity.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Reduced Performance and Overhead&lt;/strong&gt;: &lt;strong&gt;Overlaying can lead to reduced performance and introduces overhead&lt;/strong&gt;. The process of swapping overlays between main memory and secondary storage (disk) is &lt;strong&gt;time-consuming&lt;/strong&gt;. Frequent overlay swapping, especially if overlays are not designed efficiently, can result in significant disk I/O overhead and slow down program execution. The overhead of overlay management and the latency of disk access can degrade overall system performance, particularly for programs with complex overlay structures or frequent overlay switching.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 [Your University/College Name]&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="275"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="16_138_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="81">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="78"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-27-13_2012n.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-27-13_2012n.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="ebc32dfaba6cf74773734d6f98ce1b71"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="79"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="276"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="16_138_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="82">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="78"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-28-29_2012n.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-28-29_2012n.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="214d499c1c55d2d25a095eff2ed70e30"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="79"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="277"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="16_138_2.2"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="83">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="78"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-30-13_2012n.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-30-13_2012n.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="5d4770a2dacddbe09b4369daa7146c81"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="79"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="79"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="3"></int>
              <string role="key" value="parentNode"></string>
              <reference key="80"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="16"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="80"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="81"></reference>
            <reference key="82"></reference>
            <reference key="83"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="16"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:November%202012"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="86">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2012"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="84">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="85">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="139_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="84"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset and styles from previous parts - combined for single file */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; line-height: 1.6; color: #2d3748; background-color: #f7fafc; margin: 0; padding: 0; }
        header { background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%); color: white; padding: 2rem; text-align: center; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        header h1 { font-size: 2.5rem; margin-bottom: 1rem; font-weight: 600; }
        .exam-details { background: rgba(255, 255, 255, 0.1); padding: 1rem; border-radius: 8px; display: inline-block; margin-top: 1rem; }
        .exam-details p { margin: 0.5rem 0; font-size: 1.1rem; }
        main { max-width: 1200px; margin: 2rem auto; padding: 0 1.5rem; }
        .passage { background: #edf2f7; border-radius: 12px; margin-bottom: 2rem; padding: 1.5rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); }
        .passage h2 { color: #2d3748; margin-bottom: 1rem; font-size: 1.5rem; border-bottom: 2px solid #cbd5e0; padding-bottom: 0.5rem; }
        .passage-content { font-size: 1.1rem; color: #4a5568; line-height: 1.8; }
        .passage-content p { margin-bottom: 1rem; }
        .question { background: white; border-radius: 12px; margin-bottom: 2rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); overflow: hidden; }
        .question h3 { background: #4a5568; color: white; padding: 1rem 1.5rem; font-size: 1.25rem; margin: 0; border-bottom: 3px solid #2d3748; }
        .question-content { padding: 1.5rem; background: #fff; border-bottom: 2px solid #edf2f7; }
        .question-content p { font-size: 1.1rem; color: #2d3748; }
        .answer-section { background: #f8fafc; border-top: 2px solid #e2e8f0; }
        .answer-section h4 { padding: 1rem 1.5rem; color: #2d3748; font-size: 1.2rem; background: #edf2f7; margin: 0; }
        .answer-content { padding: 1.5rem; color: #4a5568; }
        .answer-content p { margin-bottom: 1rem; line-height: 1.8; }
        .answer-content strong, .answer-content b { color: #2d3748; font-weight: 700; }
        .answer-content p[data-number]:before { content: attr(data-number) &quot;.&quot;; font-weight: 600; margin-right: 0.5rem; color: #4a5568; }
        table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); overflow: hidden; border-radius: 8px; }
        thead { background-color: #4a5568; color: white; }
        th { text-align: left; padding: 0.75rem 1rem; font-weight: 600; border-bottom: 2px solid #2d3748; }
        td { padding: 0.75rem 1rem; border-bottom: 1px solid #e2e8f0; background-color: white; }
        tr:last-child td { border-bottom: none; }
        tr:nth-child(even) td { background-color: #f8fafc; }
        footer { background: #2d3748; color: white; text-align: center; padding: 1.5rem; margin-top: 3rem; }
        @media (max-width: 768px) { header h1 { font-size: 2rem; } main { padding: 0 1rem; } .passage h2 { font-size: 1.3rem; } .passage-content p { font-size: 1rem; } .question { margin-bottom: 1.5rem; } .question h3 { font-size: 1.1rem; } .question-content p, .answer-content p { font-size: 1rem; } table, thead, tbody, th, td, tr { display: block; } thead tr { position: absolute; top: -9999px; left: -9999px; } tr { border: 1px solid #e2e8f0; margin-bottom: 1rem; border-radius: 8px; overflow: hidden; } td { border: none; position: relative; padding-left: 50%; text-align: left; border-bottom: 1px solid #e2e8f0; } td:before { position: absolute; top: 0.75rem; left: 1rem; width: 45%; padding-right: 10px; white-space: nowrap; font-weight: 600; content: attr(data-label); } td:last-child { border-bottom: 0; } }
        @media print { body { background: white; } .passage, .question { break-inside: avoid; box-shadow: none; border: 1px solid #edf2f7; } header { background: white; color: black; padding: 1rem; } .exam-details { border: 1px solid #edf2f7; } table { break-inside: auto; } tr { break-inside: avoid; break-after: auto; } }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2012&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;1. (a) (i) State four objectives of operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Management&lt;/strong&gt;: To &lt;strong&gt;manage and allocate computer resources&lt;/strong&gt; (CPU, memory, I/O devices) efficiently and effectively.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;User Convenience&lt;/strong&gt;: To provide a &lt;strong&gt;user-friendly and convenient interface&lt;/strong&gt; for users to interact with the computer system.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;System Efficiency&lt;/strong&gt;: To &lt;strong&gt;maximize system throughput and minimize response time&lt;/strong&gt;, ensuring optimal performance.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Data Security and Protection&lt;/strong&gt;: To &lt;strong&gt;protect user data and system resources&lt;/strong&gt; from unauthorized access and ensure data integrity.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (a) (ii) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain the meaning of each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;I. kernel;&lt;/p&gt;
&lt;p&gt;II. shell;&lt;/p&gt;
&lt;p&gt;III. process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Kernel&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;kernel&lt;/strong&gt; is the &lt;strong&gt;core component&lt;/strong&gt; of an operating system. It is the &lt;strong&gt;lowest level of the OS&lt;/strong&gt; and has direct control over the system hardware. The kernel provides essential services such as &lt;strong&gt;process management, memory management, device management, and system calls&lt;/strong&gt;. It acts as the fundamental bridge between hardware and user-level software, managing resources and ensuring system stability and security.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. Shell&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;shell&lt;/strong&gt; is a &lt;strong&gt;command-line interpreter or user interface&lt;/strong&gt; in an operating system. It allows users to interact with the OS through &lt;strong&gt;textual commands&lt;/strong&gt;. The shell interprets user commands, translates them into system calls, and sends them to the kernel for execution. It provides a way for users to launch programs, manage files, and control the operating system. Shells can be command-line based (like bash in Linux) or graphical (like Windows Explorer, though &quot;shell&quot; typically refers to the command-line interface).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;III. Process&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;process&lt;/strong&gt; is an &lt;strong&gt;instance of a computer program that is being executed&lt;/strong&gt;. It is a fundamental unit of execution in an operating system. A process includes the &lt;strong&gt;program code, current activity (program counter, processor registers), and resources&lt;/strong&gt; such as memory, open files, and I/O devices. The operating system manages processes, allocating resources, scheduling execution, and providing isolation and protection between different processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between monolithic and non-monolithic operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Monolithic Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monolithic operating systems&lt;/strong&gt; have a &lt;strong&gt;single, large kernel&lt;/strong&gt; structure where all operating system services (e.g., process management, memory management, file system, device drivers) run within the &lt;strong&gt;kernel space&lt;/strong&gt; as a single process. There is minimal separation between different OS components. &lt;strong&gt;Advantages&lt;/strong&gt;: Can be more efficient due to tight integration and less overhead for inter-process communication within the kernel. &lt;strong&gt;Disadvantages&lt;/strong&gt;: Less modular, a failure in one component can potentially crash the entire system, harder to maintain and extend, and less portable. Example: Traditional Unix, Linux (though modern Linux is somewhat modularized).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-Monolithic Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-monolithic operating systems&lt;/strong&gt;, primarily &lt;strong&gt;Microkernels&lt;/strong&gt;, have a &lt;strong&gt;small, minimal kernel&lt;/strong&gt; that provides only essential core functionalities (e.g., process management, IPC, memory management). Most OS services (file system, device drivers, network stack) are implemented as &lt;strong&gt;user-level processes&lt;/strong&gt; (servers) running outside the kernel. Communication between clients (user applications or servers) and servers occurs through &lt;strong&gt;message passing&lt;/strong&gt; via the microkernel. &lt;strong&gt;Advantages&lt;/strong&gt;: More modular, easier to maintain and extend, better fault isolation (server failure less likely to crash the kernel), and more adaptable to distributed systems. &lt;strong&gt;Disadvantages&lt;/strong&gt;: Can have performance overhead due to message passing for inter-process communication, and more complex design. Example: Mach, MINIX 3, QNX, and hybrid kernels like Windows NT kernel and macOS kernel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference lies in the &lt;strong&gt;kernel structure and service implementation&lt;/strong&gt;. &lt;strong&gt;Monolithic OS&lt;/strong&gt; has a large, single kernel containing all services, while &lt;strong&gt;Non-monolithic (Microkernel) OS&lt;/strong&gt; has a small kernel with most services running as user-level servers. Monolithic is more integrated but less modular and fault-tolerant, while Microkernel is more modular and fault-tolerant but can have performance overhead.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) The following are characteristics of different file systems:&lt;/p&gt;
&lt;p&gt;(i) supports very large disk capacity; NTFS&lt;/p&gt;
&lt;p&gt;(ii) supports a block size of between 4KB-32KB; FAT&lt;/p&gt;
&lt;p&gt;(iii) supports compression and encryption of entire disk partition; NTFS&lt;/p&gt;
&lt;p&gt;(iv) formats floppy diskette. NTFS&lt;/p&gt;
&lt;p&gt;For each of the characteristic, identify the most appropriate file system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;(i) &lt;strong&gt;Supports very large disk capacity&lt;/strong&gt;: &lt;strong&gt;NTFS (New Technology File System)&lt;/strong&gt; is the most appropriate file system. NTFS is designed to handle very large disk volumes and files, supporting capacities far beyond the limitations of older file systems like FAT32.&lt;/p&gt;
&lt;p&gt;(ii) &lt;strong&gt;Supports a block size of between 4KB-32KB&lt;/strong&gt;: &lt;strong&gt;FAT32 (File Allocation Table 32)&lt;/strong&gt; is more appropriate for this characteristic. While NTFS also supports these block sizes, FAT32, especially FAT16 and FAT32 variants, are traditionally associated with and optimized for smaller block sizes and were commonly used in systems with less storage capacity.&lt;/p&gt;
&lt;p&gt;(iii) &lt;strong&gt;Supports compression and encryption of entire disk partition&lt;/strong&gt;: &lt;strong&gt;NTFS (New Technology File System)&lt;/strong&gt; is the most appropriate. NTFS has built-in features for both file system compression and encryption at the partition level, offering advanced data protection and storage efficiency.&lt;/p&gt;
&lt;p&gt;(iv) &lt;strong&gt;Formats floppy diskette&lt;/strong&gt;: &lt;strong&gt;FAT16 or FAT12 (File Allocation Table 16 or 12)&lt;/strong&gt; are the most appropriate. FAT file systems, particularly FAT12 and FAT16, were historically used for floppy diskettes due to their simplicity and compatibility with older systems and smaller storage capacities of floppy disks. While NTFS can technically format floppy disks, it is not designed or optimized for such small, removable media.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;1. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) Ann, a system analyst with a certain company created a system file using an operating system. Explain two file properties she could have used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Hidden Attribute&lt;/strong&gt;: Ann could have used the &lt;strong&gt;Hidden attribute&lt;/strong&gt;. Setting a file as hidden makes it &lt;strong&gt;invisible by default&lt;/strong&gt; in file listings and graphical interfaces. This property is often used for system files to prevent users from accidentally modifying or deleting them. By setting the hidden attribute, Ann can make the system file less visible and reduce the risk of accidental user interference.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;System Attribute&lt;/strong&gt;: Ann could have used the &lt;strong&gt;System attribute&lt;/strong&gt;. Marking a file with the System attribute indicates that it is a &lt;strong&gt;critical system file&lt;/strong&gt; essential for the operating system's functioning. System files are typically protected and hidden to prevent accidental or malicious modification or deletion, which could lead to system instability or failure. The System attribute provides an added layer of protection and signifies the file's importance to the OS.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;2. (a) (i) State four file organization methods used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential File Organization&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Direct (Random) File Organization&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Indexed Sequential File Organization&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Hashed File Organization&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline four typical operations that could be performed on files in a computer system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Create File&lt;/strong&gt;: Operation to &lt;strong&gt;create a new file&lt;/strong&gt; in the file system.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Read File&lt;/strong&gt;: Operation to &lt;strong&gt;read data from an existing file&lt;/strong&gt;.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Write File&lt;/strong&gt;: Operation to &lt;strong&gt;write data to a file&lt;/strong&gt;, creating or modifying its content.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Delete File&lt;/strong&gt;: Operation to &lt;strong&gt;delete or remove a file&lt;/strong&gt; from the file system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (a) (iii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) Outline two file attributes used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Read-Only Attribute&lt;/strong&gt;: Indicates if a file is &lt;strong&gt;read-only&lt;/strong&gt;, preventing modifications.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hidden Attribute&lt;/strong&gt;: Makes a file &lt;strong&gt;hidden&lt;/strong&gt; from normal directory listings.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (i) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) (i) Explain each of the following terms as used in operating systems:&lt;/p&gt;
&lt;p&gt;I. disk caching;&lt;/p&gt;
&lt;p&gt;II. volume.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;I. Disk Caching&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk caching&lt;/strong&gt; is a technique used to improve disk I/O performance by using a &lt;strong&gt;cache memory&lt;/strong&gt; (a portion of RAM) to store frequently accessed data blocks from the hard disk. When data is needed, the system first checks the cache. If the data is in the cache (cache hit), it is retrieved from the faster RAM cache instead of the slower disk, significantly reducing access time and improving I/O performance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;II. Volume&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In operating systems, a &lt;strong&gt;volume&lt;/strong&gt; is a &lt;strong&gt;logical storage unit&lt;/strong&gt; that is typically a single accessible storage area within a file system. It can correspond to an entire physical disk, a partition of a disk, or span across multiple disks (in volume management systems). A volume is usually formatted with a file system and is identified by a volume label or mount point. Users and applications interact with volumes as logical units for file storage and access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (b) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Differentiate between low-level and high-level formatting as used in disk operations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Low-Level Formatting&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Low-level formatting&lt;/strong&gt;, also known as physical formatting, is the process of &lt;strong&gt;physically structuring the disk surface&lt;/strong&gt; into tracks and sectors. It is typically performed at the factory or as a last resort for disk recovery. Low-level formatting creates the physical structure for data storage on the disk, including sector headers, inter-sector gaps, and track and sector identification. It is a hardware-specific operation and is rarely performed by end-users. Low-level formatting essentially prepares the disk for use by defining its physical organization.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;High-Level Formatting&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;High-level formatting&lt;/strong&gt;, also known as logical formatting or quick format, is the process of &lt;strong&gt;creating a file system structure on a disk partition or volume&lt;/strong&gt;, making it ready for use by the operating system. High-level formatting writes the &lt;strong&gt;file system metadata&lt;/strong&gt; (e.g., boot sector, file allocation table, root directory) onto the disk, without altering the underlying sector and track structure created by low-level formatting. It sets up the logical organization for file storage and management, allowing the OS to store and retrieve files. High-level formatting is commonly performed by users to prepare a disk or partition for use with a specific operating system and file system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference is in the &lt;strong&gt;level of operation and purpose&lt;/strong&gt;. &lt;strong&gt;Low-level formatting&lt;/strong&gt; is a physical process that structures the disk hardware, while &lt;strong&gt;high-level formatting&lt;/strong&gt; is a logical process that creates a file system structure on top of the physical disk, making it usable for file storage by an OS.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (i) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) During data input using a keyboard, the operating system temporarily stores keyboard key strokes on the keyboard memory.&lt;/p&gt;
&lt;p&gt;(i) Identify this I/O communication technique.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The I/O communication technique identified is &lt;strong&gt;Buffering&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (ii) (1 mark)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) During data input using a keyboard, the operating system temporarily stores keyboard key strokes on the keyboard memory.&lt;/p&gt;
&lt;p&gt;(ii) State one advantage of the technique identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;One advantage of using buffering in this scenario is &lt;strong&gt;smoothing out the data flow&lt;/strong&gt;. Buffering helps to handle the speed mismatch between the slow input from the keyboard and the faster processing speed of the CPU, ensuring that keystrokes are not lost and are processed efficiently.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;2. (c) (iii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) During data input using a keyboard, the operating system temporarily stores keyboard key strokes on the keyboard memory.&lt;/p&gt;
&lt;p&gt;(iii) Explain two purposes of using the I/O technique identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Speed Mismatch Handling&lt;/strong&gt;: Buffering is used to &lt;strong&gt;handle the speed mismatch&lt;/strong&gt; between the input device (keyboard) and the CPU. Key presses from a keyboard are typically slow and sporadic, while the CPU operates at a much higher speed. Buffering allows the operating system to collect keystrokes in a buffer at the keyboard's pace and then process them in larger chunks or at a rate suitable for the CPU. This prevents the CPU from being idle while waiting for each keystroke and improves overall system efficiency.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Data Smoothing and Flow Control&lt;/strong&gt;: Buffering helps in &lt;strong&gt;smoothing out the flow of data&lt;/strong&gt; from the keyboard to the application. It provides a temporary storage area to hold keystrokes, allowing the application to read data at its own pace without being directly tied to the timing of keyboard input. Buffering also facilitates &lt;strong&gt;flow control&lt;/strong&gt;, preventing data loss when the input rate from the keyboard temporarily exceeds the processing rate of the application or the operating system. It ensures reliable and orderly data transfer from the keyboard to the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (a) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;3. (a) State four types of disk-arm scheduling algorithms.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;First-Come, First-Served (FCFS)&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Shortest Seek Time First (SSTF)&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;SCAN (Elevator)&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;C-SCAN (Circular SCAN)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) During an operating systems lesson in a certain college, a lecturer mentioned various kernel components that facilitates the I/O manager. Outline four kernel components that could have been mentioned.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Device Drivers&lt;/strong&gt;: &lt;strong&gt;Device drivers&lt;/strong&gt; are kernel components that are &lt;strong&gt;essential for the I/O manager&lt;/strong&gt;. They act as interfaces to specific hardware devices, providing device-specific control and handling. The I/O manager relies on device drivers to communicate with and control various I/O devices, translating generic I/O requests into device-specific commands.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Interrupt Handlers&lt;/strong&gt;: &lt;strong&gt;Interrupt handlers&lt;/strong&gt; are kernel routines that &lt;strong&gt;respond to hardware interrupts&lt;/strong&gt; generated by I/O devices. The I/O manager depends on interrupt handlers to be notified of I/O events, such as device completion or errors. Interrupt handlers are crucial for asynchronous I/O operations and for efficient handling of device events.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;I/O Scheduling and Queuing Mechanisms&lt;/strong&gt;: The kernel includes &lt;strong&gt;I/O scheduling algorithms and queuing mechanisms&lt;/strong&gt; that the I/O manager uses to &lt;strong&gt;manage and prioritize I/O requests&lt;/strong&gt;. These components determine the order in which I/O requests are serviced, optimize disk arm movement, and ensure fair allocation of I/O resources.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Memory Management Subsystem&lt;/strong&gt;: The &lt;strong&gt;memory management subsystem&lt;/strong&gt; of the kernel is vital for I/O operations. The I/O manager uses memory management services for &lt;strong&gt;buffering data, managing DMA transfers, and allocating memory for I/O buffers&lt;/strong&gt;. Efficient memory management is crucial for optimizing I/O data transfer and overall I/O performance.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Figure 1 shows a memory allocation technique used by an operating system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-37-30_2012july.pdf.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;396&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;figure1_q3c.png&quot; alt=&quot;Figure 1 Memory Allocation Technique Diagram&quot; /&gt;
&lt;p&gt;(1) Identify the memory allocation technique used justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The memory allocation technique used in Figure 1 is &lt;strong&gt;Paging&lt;/strong&gt;. This is evident from the diagram because:&lt;/p&gt;
&lt;p&gt;- It shows the &lt;strong&gt;virtual address&lt;/strong&gt; being divided into a &lt;strong&gt;page number (p)&lt;/strong&gt; and &lt;strong&gt;page offset (d)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;- There is a &lt;strong&gt;page table&lt;/strong&gt; used for translation.&lt;/p&gt;
&lt;p&gt;- The &lt;strong&gt;physical address&lt;/strong&gt; is formed by combining a &lt;strong&gt;frame number (f)&lt;/strong&gt; from the page table and the &lt;strong&gt;page offset (d)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;- This mapping from virtual pages to physical frames via a page table is the defining characteristic of paging.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Figure 1 shows a memory allocation technique used by an operating system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;(ii) Explain the procedure that could be used for address transition.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The procedure for &lt;strong&gt;address translation in paging&lt;/strong&gt;, as depicted in Figure 1, involves the following steps:&lt;/p&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Virtual Address Decomposition&lt;/strong&gt;: The &lt;strong&gt;CPU generates a virtual address&lt;/strong&gt;, which is divided into two parts: the &lt;strong&gt;page number (p)&lt;/strong&gt; and the &lt;strong&gt;page offset (d)&lt;/strong&gt;. The page number identifies the virtual page within the process's address space, and the page offset specifies the location within that page.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Page Table Lookup&lt;/strong&gt;: The &lt;strong&gt;page number (p) is used as an index into the page table&lt;/strong&gt;. The page table is a data structure maintained by the operating system for each process, and it contains entries that map virtual page numbers to physical frame numbers. The page table entry corresponding to the virtual page number is accessed.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Frame Number Retrieval&lt;/strong&gt;: From the page table entry, the operating system &lt;strong&gt;retrieves the corresponding physical frame number (f)&lt;/strong&gt;. The frame number indicates the physical frame in RAM where the virtual page is stored. If the virtual page is not in RAM (page fault), the page table entry will indicate this, and a page fault handling process will be initiated.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Physical Address Construction&lt;/strong&gt;: The &lt;strong&gt;physical address is constructed by combining the retrieved frame number (f) with the page offset (d)&lt;/strong&gt;. The frame number becomes the high-order bits of the physical address, and the page offset becomes the low-order bits. This physical address points to the actual memory location in RAM where the data is stored, and it is used to access the data in physical memory.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (c) (iii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Figure 1 shows a memory allocation technique used by an operating system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;(iii) Explain two benefits of the memory allocation techniques identified in (i).&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Elimination of External Fragmentation&lt;/strong&gt;: &lt;strong&gt;Paging eliminates external fragmentation&lt;/strong&gt;. Since memory is allocated in fixed-size pages and frames, any available frame can be used to load a page of a process. This prevents the problem of having sufficient total free memory but not being able to allocate it to a process because it is fragmented into non-contiguous blocks. This leads to more efficient memory utilization.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Support for Virtual Memory and Larger Address Spaces&lt;/strong&gt;: Paging is essential for implementing &lt;strong&gt;virtual memory&lt;/strong&gt;. It allows processes to have a virtual address space that is larger than the physical memory available. Only the actively used pages need to be in RAM, while the rest can be stored on disk. This enables running programs that are larger than physical memory, increases the degree of multiprogramming, and improves memory management flexibility. Virtual memory enhances system capabilities and resource utilization.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;3. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) A group of ICT Module 1 students in a certain college were carrying out an assignment about causes of process termination in operating systems. Explain two possible causes they could have written in their report.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Normal Completion&lt;/strong&gt;: A common cause of process termination is &lt;strong&gt;normal completion&lt;/strong&gt;. This occurs when a process has finished executing all of its instructions and has completed its intended task. In this case, the process exits voluntarily by making an exit system call or by reaching the end of its program code. Normal termination is a natural and expected part of process lifecycle, indicating successful execution.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Error Condition or Exception&lt;/strong&gt;: Another possible cause is &lt;strong&gt;termination due to an error condition or exception&lt;/strong&gt;. This happens when a process encounters a fatal error during execution, such as &lt;strong&gt;division by zero, illegal memory access, or an unrecoverable system error&lt;/strong&gt;. In such cases, the operating system or the process itself may terminate the process prematurely to prevent further damage or system instability. Error termination is a way to handle abnormal or faulty program behavior.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;4. (a) Explain each of the following terms as used in operation systems:&lt;/p&gt;
&lt;p&gt;(i) semaphore;&lt;/p&gt;
&lt;p&gt;(ii) monitor.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;(i) Semaphore&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;semaphore&lt;/strong&gt; is a synchronization primitive used in operating systems for controlling access to &lt;strong&gt;shared resources&lt;/strong&gt; and process synchronization. It is an integer variable that is accessed through two atomic operations: &lt;strong&gt;wait (P)&lt;/strong&gt; and &lt;strong&gt;signal (V)&lt;/strong&gt;. Semaphores are used to manage critical sections and prevent race conditions by controlling the number of processes that can access a resource concurrently. They can be binary (mutex) or counting semaphores.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) Monitor&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;monitor&lt;/strong&gt; is a &lt;strong&gt;higher-level synchronization construct&lt;/strong&gt; that provides a structured way to achieve mutual exclusion and condition synchronization. It encapsulates shared data and the procedures or methods that operate on that data. Only one process can be active inside a monitor at any time, providing &lt;strong&gt;automatic mutual exclusion&lt;/strong&gt;. Monitors also include &lt;strong&gt;condition variables&lt;/strong&gt; that allow processes to wait inside the monitor until a specific condition is met, and to signal other waiting processes when a condition changes. Monitors simplify concurrent programming and reduce synchronization errors.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between symmetric and asymmetric multiprocessing operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Symmetric Multiprocessing (SMP) Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Symmetric Multiprocessing (SMP) operating systems&lt;/strong&gt;, &lt;strong&gt;multiple processors&lt;/strong&gt; in the system are treated &lt;strong&gt;equally&lt;/strong&gt;. Each processor can run any process or task, including kernel-level and user-level processes. Process scheduling and resource allocation are distributed across all processors. SMP systems typically share a single main memory and I/O subsystem, and processors communicate through shared memory. &lt;strong&gt;Advantages&lt;/strong&gt;: Balanced workload distribution, improved performance and throughput, and increased system reliability. &lt;strong&gt;Disadvantages&lt;/strong&gt;: More complex to design and implement, and can suffer from memory contention and cache coherence issues as the number of processors increases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asymmetric Multiprocessing (AMP) Operating Systems&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;In &lt;strong&gt;Asymmetric Multiprocessing (AMP) operating systems&lt;/strong&gt;, processors are &lt;strong&gt;not treated equally&lt;/strong&gt;. Typically, one processor is designated as the &lt;strong&gt;master processor&lt;/strong&gt; (or primary processor), which runs the kernel and manages system-level tasks, including scheduling and I/O operations. Other processors are designated as &lt;strong&gt;slave processors&lt;/strong&gt; (or secondary processors) and are typically assigned to run user-level processes or specific tasks under the master processor's control. &lt;strong&gt;Advantages&lt;/strong&gt;: Simpler to implement compared to SMP, and less prone to cache coherence issues. &lt;strong&gt;Disadvantages&lt;/strong&gt;: Potential for workload imbalance and bottleneck at the master processor, and less efficient utilization of multiple processors compared to SMP. AMP is often used in specialized or embedded systems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference is in &lt;strong&gt;processor treatment and task distribution&lt;/strong&gt;. In &lt;strong&gt;SMP&lt;/strong&gt;, all processors are equal and can run any task, providing balanced processing. In &lt;strong&gt;AMP&lt;/strong&gt;, processors are unequal, with a master processor managing the system and assigning tasks to slave processors, leading to a less balanced and potentially less efficient system but simpler implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Paul, a Module I student in a certain college was carrying out a term project which involved developing an interactive operating system. He decided to use preemptive scheduling algorithm.&lt;/p&gt;
&lt;p&gt;(i) Explain one reason that could have influenced his choice of this scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;One reason Paul might have chosen a &lt;strong&gt;preemptive scheduling algorithm&lt;/strong&gt; for an interactive operating system is to ensure &lt;strong&gt;responsiveness and fairness&lt;/strong&gt;. Preemptive scheduling allows the operating system to interrupt a running process and allocate the CPU to another process, typically based on time slices or priorities. This is crucial for interactive systems because it prevents a single process from monopolizing the CPU and ensures that the system remains responsive to user inputs and interactive tasks, providing a better user experience.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (c) (ii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Paul, a Module I student in a certain college was carrying out a term project which involved developing an interactive operating system. He decided to use preemptive scheduling algorithm.&lt;/p&gt;
&lt;p&gt;(ii) Explain two limitations of this scheduling algorithm.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Context Switching Overhead&lt;/strong&gt;: &lt;strong&gt;Preemptive scheduling&lt;/strong&gt; introduces &lt;strong&gt;context switching overhead&lt;/strong&gt;. Frequent preemption and context switching between processes consume CPU time, as the system needs to save the state of the preempted process and load the state of the next process. If the time slice (quantum) is too small, excessive context switching can reduce overall system efficiency, as the CPU spends more time on context switching than on actual process execution. This overhead can impact performance, especially if context switching is not optimized.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Complexity and Implementation Overhead&lt;/strong&gt;: &lt;strong&gt;Preemptive scheduling algorithms&lt;/strong&gt; are generally &lt;strong&gt;more complex to implement&lt;/strong&gt; compared to non-preemptive algorithms. They require mechanisms for time slicing, interrupt handling, and managing process priorities. The operating system needs to handle preemption points, timer interrupts, and ensure that context switching is performed correctly and efficiently. This added complexity increases the implementation and maintenance overhead for the OS kernel, making it more intricate to design and debug preemptive schedulers.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;4. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) A certain organization uses a distributed operating system. Assuming you are hired as an IT consultant, explain three file access control methods you could recommend to safeguard the organizational data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Access Control Lists (ACLs)&lt;/strong&gt;: Implement &lt;strong&gt;Access Control Lists (ACLs)&lt;/strong&gt; for file access control. ACLs allow for &lt;strong&gt;fine-grained control&lt;/strong&gt; over file and directory permissions, specifying access rights (read, write, execute) for individual users or groups. In a distributed system, ACLs can be managed centrally to enforce consistent access policies across all nodes. ACLs provide flexibility and granularity in defining who can access specific files and what operations they are permitted to perform, enhancing data security and confidentiality.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Role-Based Access Control (RBAC)&lt;/strong&gt;: Implement &lt;strong&gt;Role-Based Access Control (RBAC)&lt;/strong&gt;. RBAC simplifies access management by assigning permissions based on &lt;strong&gt;roles&lt;/strong&gt; within the organization (e.g., manager, employee, guest) rather than individual users. Users are assigned to roles, and roles are granted specific file access permissions. RBAC is easier to manage in larger organizations and distributed systems, as it simplifies permission administration and ensures that users have appropriate access based on their organizational roles. RBAC enhances security and reduces administrative overhead.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Authentication and Authorization Mechanisms&lt;/strong&gt;: Ensure strong &lt;strong&gt;authentication and authorization mechanisms&lt;/strong&gt; are in place across the distributed system. Implement &lt;strong&gt;multi-factor authentication&lt;/strong&gt; for user login and access to sensitive data. Use robust authorization protocols to verify user permissions before granting access to files and resources. Centralized authentication services (e.g., Kerberos, LDAP) can be used to manage user identities and access credentials consistently across all nodes in the distributed system. Strong authentication and authorization are fundamental for securing file access and preventing unauthorized data access.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;5. (a) (i) Outline two strategies that could be used to prevent deadlock in computer systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Ordering (Circular Wait Prevention)&lt;/strong&gt;: Impose a &lt;strong&gt;linear ordering on resource types&lt;/strong&gt; and require processes to request resources in an &lt;strong&gt;increasing order&lt;/strong&gt; of this hierarchy. This strategy prevents the circular wait condition, one of the necessary conditions for deadlock, as processes will not be able to form a cycle of resource dependencies. Resource ordering ensures that resource requests are made in a consistent order, avoiding circular dependencies and thus preventing deadlocks.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Hold and Wait Prevention&lt;/strong&gt;: Implement a strategy to &lt;strong&gt;prevent the &quot;hold and wait&quot; condition&lt;/strong&gt;. This can be achieved by requiring processes to &lt;strong&gt;request all the resources they need before starting execution&lt;/strong&gt;. If all resources are available, they are allocated to the process. If not, the process waits and cannot hold any resources while waiting. Alternatively, processes can be required to release all currently held resources before making a new resource request. Preventing &quot;hold and wait&quot; ensures that processes do not hold some resources while waiting to acquire others, breaking another necessary condition for deadlock.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Explain the term virtual memory as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual memory&lt;/strong&gt; is a memory management technique that creates an &lt;strong&gt;abstraction of memory&lt;/strong&gt;, providing each process with a &lt;strong&gt;virtual address space&lt;/strong&gt; that is larger than the available physical RAM. It allows processes to access memory locations that may not be physically present in RAM. The operating system manages virtual memory by using secondary storage (disk) as an extension of RAM, swapping pages between RAM and disk as needed. Virtual memory enables running programs larger than physical memory, increases multiprogramming, and improves memory utilization and efficiency.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (a) (iii) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(iii) Explain two objectives of memory management as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Efficient Utilization of Memory&lt;/strong&gt;: One key objective is to &lt;strong&gt;utilize memory efficiently&lt;/strong&gt;. Memory management techniques aim to maximize the number of processes that can reside in memory concurrently and minimize wasted memory space (fragmentation). Efficient memory utilization improves system throughput and allows for running more applications simultaneously, making better use of the available RAM.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Address Space Abstraction and Protection&lt;/strong&gt;: Memory management seeks to provide each process with its own &lt;strong&gt;private virtual address space&lt;/strong&gt;, creating an abstraction that isolates processes from each other's memory. This abstraction ensures &lt;strong&gt;memory protection&lt;/strong&gt;, preventing processes from interfering with or corrupting each other's memory or the operating system's memory. Address space abstraction and protection are crucial for system stability, security, and preventing application crashes from affecting the entire system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between virtual and physical memory addressing as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual Memory Addressing&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Virtual memory addressing&lt;/strong&gt; refers to the &lt;strong&gt;logical or virtual addresses&lt;/strong&gt; used by processes when they access memory. Virtual addresses are part of a process's virtual address space and are independent of the physical memory layout. Each process has its own virtual address space, which can be much larger than the available physical memory. Virtual addresses are &lt;strong&gt;translated to physical addresses&lt;/strong&gt; by the memory management unit (MMU) using page tables or segment tables. Virtual addressing provides memory abstraction, protection, and allows for virtual memory techniques like paging and segmentation. Virtual addresses are the addresses seen and used by programs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical Memory Addressing&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Physical memory addressing&lt;/strong&gt; refers to the &lt;strong&gt;actual hardware addresses&lt;/strong&gt; of memory locations in RAM (Random Access Memory). Physical addresses are used to &lt;strong&gt;directly access physical memory&lt;/strong&gt;. They are the addresses used by the hardware, memory controllers, and the operating system kernel to locate and access data in RAM chips. Physical addresses are typically linear and correspond to the physical organization of memory modules. Physical addresses are the addresses used by the hardware to access RAM.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The main difference is in their &lt;strong&gt;level of abstraction and usage&lt;/strong&gt;. &lt;strong&gt;Virtual addresses&lt;/strong&gt; are logical addresses used by processes, providing abstraction and protection, and are translated to physical addresses. &lt;strong&gt;Physical addresses&lt;/strong&gt; are the actual hardware addresses used to access physical RAM. Virtual addresses are program-centric, while physical addresses are hardware-centric.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;5. (c) (8 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) The following are file management. operations that could be carried out using operating systems.&lt;/p&gt;
&lt;p&gt;(i) File re-organization.&lt;/p&gt;
&lt;p&gt;(ii) Create volume label.&lt;/p&gt;
&lt;p&gt;(iii) Create file allocation table.&lt;/p&gt;
&lt;p&gt;(iv) Assign quota to users.&lt;/p&gt;
&lt;p&gt;For each of the operations, outline the appropriate system utility that could be used to perform the task justifying your answer.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;Appropriate System Utility&lt;/th&gt;
&lt;th&gt;Justification&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Operation&quot;&gt;&lt;strong&gt;File re-organization&lt;/strong&gt;&lt;/td&gt;
&lt;td data-label=&quot;Appropriate System Utility&quot;&gt;&lt;strong&gt;Disk Defragmenter&lt;/strong&gt; (e.g., `defrag` on Windows, `defragfs` on Linux)&lt;/td&gt;
&lt;td data-label=&quot;Justification&quot;&gt;Disk defragmenter is designed to &lt;strong&gt;reorganize files on disk&lt;/strong&gt; to reduce fragmentation and improve disk access performance. It consolidates fragmented files into contiguous blocks, improving sequential read speeds and overall file system efficiency, which is the core purpose of file re-organization.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Operation&quot;&gt;&lt;strong&gt;Create volume label&lt;/strong&gt;&lt;/td&gt;
&lt;td data-label=&quot;Appropriate System Utility&quot;&gt;&lt;strong&gt;Volume Label Utility&lt;/strong&gt; (e.g., `label` command in Windows, `mlabel` in Linux)&lt;/td&gt;
&lt;td data-label=&quot;Justification&quot;&gt;Volume label utilities are specifically used to &lt;strong&gt;create or modify volume labels&lt;/strong&gt;, which are names assigned to disk partitions or volumes for easy identification. These utilities directly address the task of labeling volumes, allowing users to set or change volume names for better organization and management.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Operation&quot;&gt;&lt;strong&gt;Create file allocation table&lt;/strong&gt;&lt;/td&gt;
&lt;td data-label=&quot;Appropriate System Utility&quot;&gt;&lt;strong&gt;Format Utility&lt;/strong&gt; (e.g., `format` command in Windows, `mkfs` command family in Linux)&lt;/td&gt;
&lt;td data-label=&quot;Justification&quot;&gt;Format utilities are used to &lt;strong&gt;format disk partitions or volumes&lt;/strong&gt;, which includes creating the file system structure, including the &lt;strong&gt;File Allocation Table (FAT)&lt;/strong&gt; in FAT-based file systems or equivalent metadata structures in other file systems. Formatting is essential for setting up a new file system or re-initializing an existing one, and creating the FAT is a key part of this process for FAT file systems.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Operation&quot;&gt;&lt;strong&gt;Assign quota to users&lt;/strong&gt;&lt;/td&gt;
&lt;td data-label=&quot;Appropriate System Utility&quot;&gt;&lt;strong&gt;Disk Quota Management Tools&lt;/strong&gt; (e.g., Disk Quota in Windows, `quota` command in Linux)&lt;/td&gt;
&lt;td data-label=&quot;Justification&quot;&gt;Disk quota management tools are designed to &lt;strong&gt;set and manage disk quotas&lt;/strong&gt;, which limit the amount of disk space that individual users or groups can consume. These utilities allow administrators to enforce storage limits, manage disk space usage, and prevent individual users from monopolizing disk resources, directly addressing the task of assigning quotas to users.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;6. (a) (i) List four files access methods in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Sequential Access&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Direct (Random) Access&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Indexed Sequential Access&lt;/strong&gt;&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Keyed Access&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (a) (ii) (3 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline three characteristics of the 4th generation operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Graphical User Interfaces (GUIs)&lt;/strong&gt;: 4th generation OSes are characterized by the widespread adoption of &lt;strong&gt;Graphical User Interfaces (GUIs)&lt;/strong&gt;. GUIs provide a user-friendly, visual way to interact with the computer using windows, icons, menus, and pointers, replacing command-line interfaces for most user interactions. GUIs made computers more accessible and user-friendly for non-technical users.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Personal Computing and Desktop Focus&lt;/strong&gt;: 4th generation OSes were primarily designed for &lt;strong&gt;personal computers and desktop environments&lt;/strong&gt;. They focused on supporting individual users, productivity applications, and desktop-centric tasks. These OSes emphasized user-friendliness, application compatibility, and personal computing features.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Networking and Distributed Computing Features&lt;/strong&gt;: 4th generation OSes started to incorporate &lt;strong&gt;networking capabilities and features for distributed computing&lt;/strong&gt;. They included support for local area networks (LANs), client-server computing, and basic network services. Networking became an increasingly important aspect, enabling file sharing, printer sharing, and basic network communication in desktop environments.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Differentiate between block oriented and character oriented I/O devices giving an example in cach case:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;Block-Oriented I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Block-oriented I/O devices&lt;/strong&gt; transfer data in &lt;strong&gt;fixed-size blocks&lt;/strong&gt;. Data is organized into blocks, and I/O operations are performed on entire blocks. These devices support &lt;strong&gt;random access&lt;/strong&gt; to data blocks using block addresses. &lt;strong&gt;Example: Hard Disk Drive (HDD).&lt;/strong&gt; HDDs are block-oriented devices where data is stored and accessed in fixed-size blocks (sectors). The OS can read or write data blocks at any location on the disk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Character-Oriented I/O Devices&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Character-oriented I/O devices&lt;/strong&gt; transfer data as a &lt;strong&gt;stream of individual characters or bytes&lt;/strong&gt;. Data is processed and transferred sequentially, and there is typically no concept of fixed blocks or random access. &lt;strong&gt;Example: Keyboard.&lt;/strong&gt; A keyboard is a character-oriented device that inputs data as a stream of characters (keystrokes). Data is processed character by character as it is typed, and there is no block-based structure or random access involved in keyboard input.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Distinction&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The key difference is in the &lt;strong&gt;unit of data transfer and access method&lt;/strong&gt;. &lt;strong&gt;Block-oriented devices&lt;/strong&gt; use fixed blocks and support random access, while &lt;strong&gt;character-oriented devices&lt;/strong&gt; use character streams and are accessed sequentially. Block devices are for structured data storage, and character devices are for sequential character-based I/O.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (c) (7 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) With the aid of a diagram, describe the process life cycle as used in operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;process life cycle&lt;/strong&gt; describes the different states a process goes through from its creation to termination in an operating system. A typical process life cycle includes states and transitions between them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Process Life Cycle:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    +-------+     +----------+     +---------+     +---------+     +----------+
                    |  New  | --&amp;gt; |  Ready   | --&amp;gt; | Running | --&amp;gt; | Waiting | --&amp;gt; | Terminated |
                    +-------+     +----------+     +---------+     +---------+     +----------+
                       ^            |     ^         |       |         |       ^         |
                       |            |     |         |       |         |       |         |
                       +------------+     +---------+     +---------+     +-----------+
                         Admission       Scheduler Dispatch    I/O or Event Wait   Completion or Termination

                    States:
                    - New: Process is being created.
                    - Ready: Process is ready to run, waiting for CPU.
                    - Running: Process is executing on the CPU.
                    - Waiting (Blocked): Process is waiting for some event (I/O, resource).
                    - Terminated (Completed): Process has finished execution.

                    Transitions:
                    - New to Ready: Admission - Process is admitted to the ready queue.
                    - Ready to Running: Scheduler Dispatch - Scheduler selects a process to run.
                    - Running to Ready: Time Slice Expiry or Preemption - Process time slice expires, or higher priority process becomes ready.
                    - Running to Waiting: I/O Request or Event Wait - Process requests I/O or waits for an event.
                    - Waiting to Ready: Event Occurs or I/O Completion - Event process was waiting for occurs or I/O operation completes.
                    - Running to Terminated: Completion - Process finishes execution.
                    - Waiting to Terminated: Termination (e.g., process killed) - Process is terminated while waiting.
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of States:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;New State&lt;/strong&gt;: The initial state where a process is being &lt;strong&gt;created&lt;/strong&gt;. The OS is setting up the necessary structures for the process.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ready State&lt;/strong&gt;: Processes that are &lt;strong&gt;ready to run&lt;/strong&gt; and are waiting for their turn to be allocated to the CPU. They are in memory and waiting in a ready queue.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Running State&lt;/strong&gt;: The state where the process is &lt;strong&gt;currently executing&lt;/strong&gt; on the CPU. Only one process can be in the running state per CPU core at any given time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting (Blocked) State&lt;/strong&gt;: Processes that are &lt;strong&gt;waiting for some event to occur&lt;/strong&gt;, such as completion of an I/O operation, resource availability, or a signal. They are not ready to run and are blocked until the event occurs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Terminated (Completed) State&lt;/strong&gt;: The final state where the process has &lt;strong&gt;finished its execution&lt;/strong&gt; and is no longer active. Resources allocated to the process are released by the OS.&lt;/p&gt;
&lt;p&gt;The process life cycle diagram illustrates the transitions between these states, showing how processes progress through their execution lifecycle under the management of the operating system.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;6. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a diagram, describe the memory hierarchy in computer systems&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;memory hierarchy in computer systems&lt;/strong&gt; is a multi-level structure designed to provide a balance between memory speed and cost. It typically consists of several levels of memory, arranged in a hierarchy from the fastest and most expensive to the slowest and least expensive.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Memory Hierarchy:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                                        Speed (Fastest to Slowest)
                        +-------------+        +---------------+       +---------------------+      +-----------------------+    +---------------------+
                        |   Registers   | &amp;lt;---- |    Cache      | &amp;lt;---- |     Main Memory     | &amp;lt;---- |    Secondary Storage  | &amp;lt;---- |    Tertiary Storage   |
                        +-------------+        +---------------+       +---------------------+      +-----------------------+    +---------------------+
                                        ^          ^                   ^                        ^          ^
                                        |          |                   |                        |          |
                                        |          |                   |                        |          |
                                    Smallest     |                   |                        Largest    |
                                                 |                   |
                                                 +-------------------+
                                                       Cost (Most Expensive to Least Expensive)

                    Levels:
                    - Registers: Fastest, most expensive, smallest, CPU-internal.
                    - Cache (L1, L2, L3): Very fast, expensive, small, CPU-integrated or close.
                    - Main Memory (RAM): Moderately fast, moderately expensive, medium size, system RAM.
                    - Secondary Storage (SSD, HDD): Slow, less expensive, large size, persistent storage.
                    - Tertiary Storage (Tape, Optical Disk): Very slow, least expensive, very large size, archival storage.

                    Key Characteristics:
                    - Speed: Speed decreases as you go down the hierarchy.
                    - Cost: Cost per bit decreases as you go down the hierarchy.
                    - Size: Size increases as you go down the hierarchy.
                    - Frequency of Access: Frequency of access decreases as you go down the hierarchy.
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Levels:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Registers&lt;/strong&gt;: &lt;strong&gt;Registers&lt;/strong&gt; are the &lt;strong&gt;fastest and most expensive&lt;/strong&gt; level, located within the CPU itself. They are used to hold data and instructions that the CPU is currently processing. Registers have the smallest capacity but the quickest access times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache Memory&lt;/strong&gt;: &lt;strong&gt;Cache memory&lt;/strong&gt; is a &lt;strong&gt;fast and relatively expensive&lt;/strong&gt; memory level, used to store frequently accessed data and instructions from main memory. There are often multiple levels of cache (L1, L2, L3), with increasing size and decreasing speed as you move away from the CPU. Cache reduces average memory access time by exploiting locality of reference.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Main Memory (RAM)&lt;/strong&gt;: &lt;strong&gt;Main memory (RAM)&lt;/strong&gt; is the &lt;strong&gt;primary working memory&lt;/strong&gt; of the computer. It is larger and less expensive than cache but slower than cache and registers. RAM stores currently running programs and data that the CPU is actively using. It provides a balance between speed, cost, and capacity for general-purpose computing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Secondary Storage (SSD, HDD)&lt;/strong&gt;: &lt;strong&gt;Secondary storage&lt;/strong&gt; (Solid State Drives and Hard Disk Drives) is used for &lt;strong&gt;long-term, non-volatile storage&lt;/strong&gt; of data and programs. It is much slower and less expensive per byte than main memory but offers much larger capacities. Secondary storage is used to store the operating system, applications, and user data persistently.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tertiary Storage (Tape, Optical Disk)&lt;/strong&gt;: &lt;strong&gt;Tertiary storage&lt;/strong&gt; is the &lt;strong&gt;slowest and least expensive&lt;/strong&gt; level, used for &lt;strong&gt;archival storage and backups&lt;/strong&gt;. It typically includes tape drives, optical disks, or large-capacity storage systems. Tertiary storage is used for infrequently accessed data that needs to be stored long-term, emphasizing capacity and cost-effectiveness over speed.&lt;/p&gt;
&lt;p&gt;The memory hierarchy works by moving data between levels as needed, leveraging caching and locality principles to provide fast access to frequently used data while managing large amounts of data cost-effectively.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) (i) State four examples of network operating systems from other different families.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Windows Server Family&lt;/strong&gt; (e.g., Windows Server 2019, Windows Server 2022)&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Linux Family&lt;/strong&gt; (e.g., Red Hat Enterprise Linux, Ubuntu Server, CentOS)&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;UNIX Family&lt;/strong&gt; (e.g., Solaris, HP-UX, AIX)&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;macOS Server Family&lt;/strong&gt; (macOS Server)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline two advantages of distributed operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Sharing&lt;/strong&gt;: &lt;strong&gt;Distributed operating systems&lt;/strong&gt; enable efficient &lt;strong&gt;resource sharing&lt;/strong&gt; across a network of computers. Users can access and utilize resources (files, printers, processing power) located on different machines as if they were local, improving resource utilization and reducing redundancy.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Reliability and Fault Tolerance&lt;/strong&gt;: Distributed systems offer &lt;strong&gt;enhanced reliability and fault tolerance&lt;/strong&gt;. If one computer in the system fails, the overall system can continue to operate, as tasks can be redistributed to other available nodes. This redundancy minimizes downtime and increases system robustness compared to centralized systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Table 1 shows details of processes in a computer system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;Table 1&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process ID&lt;/th&gt;
&lt;th&gt;Arrival time&lt;/th&gt;
&lt;th&gt;Run time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;W&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;0&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;X&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;2&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;Y&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;2&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;Z&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;3&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Assuming that the system uses the SJF scheduling algorithm.&lt;/p&gt;
&lt;p&gt;(i) Determine the average waiting time for the processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;To determine the average waiting time using SJF (Shortest Job First), we need to schedule the processes based on their run time, considering their arrival times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scheduling with SJF (Non-Preemptive):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. At time 0, Process W arrives and runs (shortest job available).&lt;/p&gt;
&lt;p&gt;2. At time 2, Processes X and Y arrive. Process W completes at time 2.&lt;/p&gt;
&lt;p&gt;3. At time 2, choose the shortest job among X, Y, and Z (which arrives at time 3). Process X has the shortest run time (7).&lt;/p&gt;
&lt;p&gt;4. At time 3, Process Z arrives. Process X continues to run (non-preemptive).&lt;/p&gt;
&lt;p&gt;5. Process X runs for 7 units, completing at time 2 + 7 = 9.&lt;/p&gt;
&lt;p&gt;6. At time 9, choose the shortest job among Y and Z. Process Z has the shortest run time (3).&lt;/p&gt;
&lt;p&gt;7. Process Z runs for 3 units, completing at time 9 + 3 = 12.&lt;/p&gt;
&lt;p&gt;8. Process Y runs for the remaining 20 units, completing at time 12 + 20 = 32.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    Time: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| ... | 31| 32|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|-----|---|---|
                    CPU: | W | W | X | X | X | X | X | X | X | Z | Z | Z | Y | Y | ... | Y | Y |
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|-----|---|---|
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Completion Times and Turnaround Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;W: Completion Time = 2, Turnaround Time = 2 - 0 = 2&lt;/p&gt;
&lt;p&gt;X: Completion Time = 9, Turnaround Time = 9 - 2 = 7&lt;/p&gt;
&lt;p&gt;Z: Completion Time = 12, Turnaround Time = 12 - 3 = 9&lt;/p&gt;
&lt;p&gt;Y: Completion Time = 32, Turnaround Time = 32 - 2 = 30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Waiting Time = Turnaround Time - Run Time&lt;/p&gt;
&lt;p&gt;W: Waiting Time = 2 - 2 = 0&lt;/p&gt;
&lt;p&gt;X: Waiting Time = 7 - 7 = 0&lt;/p&gt;
&lt;p&gt;Z: Waiting Time = 9 - 3 = 6&lt;/p&gt;
&lt;p&gt;Y: Waiting Time = 30 - 20 = 10&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Waiting Time:&lt;/strong&gt; (0 + 0 + 6 + 10) / 4 = 16 / 4 = &lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Waiting Time for the processes is 4 units.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Table 1 shows details of processes in a computer system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;resources/Screenshot_2025-03-12_at_13-53-51_2012july.pdf.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;210&quot; /&gt;&lt;/p&gt;
&lt;p&gt;(ii) Explain one disadvantage of the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;One disadvantage of using the &lt;strong&gt;non-preemptive SJF scheduling algorithm&lt;/strong&gt; in this system is the potential for &lt;strong&gt;starvation or longer waiting times for longer processes&lt;/strong&gt;. If there is a continuous arrival of short processes, longer processes may get delayed indefinitely or experience very long waiting times as SJF always prioritizes shorter jobs. In this example, Process Y, being the longest job, has a significantly higher waiting time compared to shorter jobs, illustrating this potential disadvantage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A certain software company developed an operating system but during testing, the results showed that the system has a problem with memory segmentation. Outline four causes of the problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: Memory segmentation can suffer from &lt;strong&gt;external fragmentation&lt;/strong&gt;. Over time, as segments are allocated and deallocated, the free memory space can become fragmented into smaller, non-contiguous holes. This can lead to a situation where there is enough total free memory, but it is not contiguous enough to allocate larger segments, causing allocation failures even when sufficient memory exists in aggregate.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Segment Table Overhead and Complexity&lt;/strong&gt;: Managing &lt;strong&gt;segment tables&lt;/strong&gt; adds overhead. Each process needs a segment table to map logical addresses to physical addresses. Segment tables consume memory space and require management by the operating system. Furthermore, address translation using segment tables can be more complex and potentially slower than simpler techniques like paging, adding processing overhead.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Variable Segment Sizes and Management Complexity&lt;/strong&gt;: The &lt;strong&gt;variable size of segments&lt;/strong&gt;, while offering flexibility, also adds to management complexity. The operating system needs to keep track of segments of different sizes, manage allocation and deallocation of variable-sized blocks, and handle the fragmentation issues that arise from variable-sized allocations. Managing variable-sized segments is more intricate than managing fixed-size pages in paging.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Overhead of Segment Swapping (if used)&lt;/strong&gt;: If the segmentation-based system uses swapping (moving segments to disk), &lt;strong&gt;swapping variable-sized segments&lt;/strong&gt; can be more complex and potentially less efficient than swapping fixed-size pages. Managing and swapping segments of different sizes can introduce additional overhead in terms of disk I/O and memory management, especially if segment sizes are not optimally managed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) James, a student with a certain college was carrying out an assignment about memory registers in computer systems. Describe two types of registers James would include in his report.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;General-Purpose Registers (GPRs)&lt;/strong&gt;: &lt;strong&gt;General-Purpose Registers (GPRs)&lt;/strong&gt; are &lt;strong&gt;versatile registers&lt;/strong&gt; used for a variety of purposes by the CPU. They are used to hold &lt;strong&gt;operands for arithmetic and logical operations, memory addresses, loop counters, and temporary data&lt;/strong&gt; during program execution. GPRs are fundamental for data manipulation and processing within the CPU. Examples include registers like EAX, EBX, ECX, EDX (in x86 architecture) or R0, R1, R2, etc. (in ARM architecture). James should include GPRs as they are essential for general-purpose computation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Special-Purpose Registers&lt;/strong&gt;: &lt;strong&gt;Special-Purpose Registers&lt;/strong&gt; have &lt;strong&gt;specific, predefined functions&lt;/strong&gt; within the CPU architecture. They are used for particular tasks and operations, and their usage is often restricted or controlled by the CPU. Examples include: * &lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: Holds the address of the next instruction to be executed. * &lt;strong&gt;Stack Pointer (SP)&lt;/strong&gt;: Points to the top of the current stack in memory. * &lt;strong&gt;Instruction Register (IR)&lt;/strong&gt;: Holds the current instruction being decoded and executed. * &lt;strong&gt;Status Register (Flags Register)&lt;/strong&gt;: Contains status flags that reflect the result of arithmetic and logical operations (e.g., zero flag, carry flag, overflow flag). James should describe special-purpose registers as they are critical for controlling CPU operation, instruction flow, and managing program execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) Explain two advantages of dynamic linking as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Memory Footprint&lt;/strong&gt;: &lt;strong&gt;Dynamic linking&lt;/strong&gt; leads to a &lt;strong&gt;reduced memory footprint&lt;/strong&gt; because shared libraries are loaded into memory only once, and &lt;strong&gt;shared among multiple processes&lt;/strong&gt; that use them. Instead of each program having its own copy of library code, they all link to a single shared library in memory. This significantly saves memory, especially when many programs use the same libraries, resulting in more efficient memory utilization and allowing more programs to run concurrently.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Easier Library Updates and Maintenance&lt;/strong&gt;: Dynamic linking simplifies &lt;strong&gt;library updates and maintenance&lt;/strong&gt;. When a shared library is updated (e.g., for bug fixes or security patches), the updated library can be replaced in one location, and &lt;strong&gt;all applications that use it automatically benefit from the update&lt;/strong&gt; the next time they are executed, without needing to be recompiled or relinked. This simplifies software distribution, patching, and maintenance, reducing administrative overhead and ensuring consistency across applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) A certain company intends to deploy RAID technology as a backup strategy on their distributed system. Outline four levels of RAID technology the company could use to accomplish the task.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;RAID 1 (Mirroring)&lt;/strong&gt;: &lt;strong&gt;RAID 1&lt;/strong&gt; mirrors data across two or more disks, providing &lt;strong&gt;data redundancy&lt;/strong&gt;. Every piece of data is written to two or more disks simultaneously. If one disk fails, data is preserved on the other disk(s). RAID 1 is suitable for backup as it ensures data availability in case of disk failure and provides good read performance, but it reduces storage capacity by half (or more, depending on the number of mirrors).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;RAID 5 (Striping with Parity)&lt;/strong&gt;: &lt;strong&gt;RAID 5&lt;/strong&gt; stripes data across three or more disks and includes &lt;strong&gt;parity information&lt;/strong&gt;. Parity data allows for data reconstruction if one disk fails. RAID 5 provides a balance between redundancy and storage efficiency, offering fault tolerance and good read performance, although write performance is slightly reduced due to parity calculations. It's a common choice for backup and general-purpose storage.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;RAID 6 (Striping with Double Parity)&lt;/strong&gt;: &lt;strong&gt;RAID 6&lt;/strong&gt; is similar to RAID 5 but includes &lt;strong&gt;double parity&lt;/strong&gt;, meaning it can tolerate the failure of up to two disks simultaneously without data loss. RAID 6 provides higher fault tolerance than RAID 5, making it suitable for critical backup systems where data availability is paramount, but it has slightly lower write performance and higher overhead due to double parity.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;RAID 10 (RAID 1+0, Mirroring and Striping)&lt;/strong&gt;: &lt;strong&gt;RAID 10&lt;/strong&gt; combines &lt;strong&gt;mirroring (RAID 1) and striping (RAID 0)&lt;/strong&gt;. It creates mirrored pairs of disks (RAID 1) and then stripes data across these mirrored pairs (RAID 0). RAID 10 offers both high performance (due to striping) and high redundancy (due to mirroring). It provides excellent fault tolerance and fast read/write speeds, making it suitable for high-performance backup systems, but it is more expensive as it requires at least twice the storage capacity compared to the usable space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Alex, a systems analyst with a certain company was given a task of designing an operating system that would work with different hardware vendors. Describe three types of 1/0 communication techniques that he would use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Programmed I/O (PIO)&lt;/strong&gt;: &lt;strong&gt;Programmed I/O (PIO)&lt;/strong&gt; is a simple I/O communication technique where data transfer between the CPU and I/O devices is &lt;strong&gt;directly controlled by the CPU&lt;/strong&gt;. For each data byte or word transferred, the CPU executes I/O instructions to read or write data to device registers. PIO is straightforward to implement but is &lt;strong&gt;CPU-intensive&lt;/strong&gt;, as the CPU is actively involved in every data transfer, limiting CPU parallelism and system performance, especially for high-speed I/O devices. PIO is suitable for low-data-rate devices or simple systems where CPU overhead is not a major concern.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Interrupt-Driven I/O&lt;/strong&gt;: &lt;strong&gt;Interrupt-Driven I/O&lt;/strong&gt; improves upon PIO by allowing the &lt;strong&gt;CPU to perform other tasks while waiting for I/O operations to complete&lt;/strong&gt;. When an I/O device is ready to transfer data or has completed an operation, it sends an &lt;strong&gt;interrupt signal&lt;/strong&gt; to the CPU. The CPU then suspends its current task, executes an &lt;strong&gt;interrupt handler&lt;/strong&gt; to transfer data or handle the I/O event, and then resumes the interrupted task. Interrupt-driven I/O reduces CPU waiting time compared to PIO and improves system concurrency, but still involves CPU intervention for each data transfer, although less directly than PIO.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt;: &lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt; is the most efficient I/O communication technique for high-speed data transfer. DMA allows I/O devices to &lt;strong&gt;transfer data directly to or from main memory without constant CPU involvement&lt;/strong&gt;. A &lt;strong&gt;DMA Controller&lt;/strong&gt; manages the data transfer, freeing up the CPU to perform other tasks concurrently. The CPU initiates the DMA transfer by programming the DMA controller, and the controller then handles the data transfer independently. DMA significantly reduces CPU overhead for I/O operations, improving system performance, especially for high-bandwidth devices like disks and network interfaces. DMA is essential for efficient high-speed I/O in modern systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a diagram, outline the internal structure of a hard disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;internal structure of a hard disk drive (HDD)&lt;/strong&gt; consists of several key components working together to store and retrieve data magnetically.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Hard Disk Internal Structure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                                                +---------------------+
                                                |    Actuator Arm     |-------+
                                                +---------------------+       |  (Moves Heads)
                                                      /       \             |
                                                     /         \            v
                    +-------------+   +-------------+   +-------------+     +---------------+
                    |   Platter   |   |   Platter   |   |   Platter   | ... | Read/Write Head |
                    | (Top Surface)|   | (Bottom Surface)|   | (Top Surface)|     +---------------+
                    +-------------+   +-------------+   +-------------+     | Read/Write Head |
                    |   ...         |   |   ...         |   |   ...         |     +---------------+
                    +-------------+   +-------------+   +-------------+ ... | Read/Write Head |
                    |   Platter   |   |   Platter   |   |   Platter   |     +---------------+
                    |(Bottom Surface)|   |(Top Surface)|   |(Bottom Surface)|
                    +-------------+   +-------------+   +-------------+
                                              |   |   |
                                              \   |   /
                                               \  |  /
                                                \ | /
                                                 V
                                        +---------------------+
                                        |      Spindle        | (Rotates Platters)
                                        +---------------------+
                    Components:
                    - Platter(s): Circular disks coated with magnetic material, store data.
                    - Spindle: Central axis that platters rotate around.
                    - Read/Write Heads: Read and write data to/from platters.
                    - Actuator Arm: Positions read/write heads across platters.

                    Additional elements not shown in simple diagram but part of internal structure:
                    - Disk Controller: Electronic circuitry to control disk operations, interface with computer.
                    - Enclosure: Protective casing.
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Components:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Platters&lt;/strong&gt;: Hard disks contain one or more &lt;strong&gt;platters&lt;/strong&gt;, which are rigid, circular disks coated with a magnetic material. Data is stored on both surfaces of each platter in concentric tracks and sectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spindle&lt;/strong&gt;: The &lt;strong&gt;spindle&lt;/strong&gt; is a central shaft that &lt;strong&gt;holds and rotates the platters&lt;/strong&gt; at a constant speed. The platters spin around the spindle, enabling the read/write heads to access different parts of the disk surface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Read/Write Heads&lt;/strong&gt;: &lt;strong&gt;Read/write heads&lt;/strong&gt; are electromagnetic components that &lt;strong&gt;read data from and write data to the platters&lt;/strong&gt;. Each platter surface has a corresponding read/write head. Heads are mounted on an actuator arm and float very close to the platter surface without touching it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actuator Arm&lt;/strong&gt;: The &lt;strong&gt;actuator arm&lt;/strong&gt; is a mechanism that &lt;strong&gt;positions the read/write heads&lt;/strong&gt; across the platters. It moves the heads radially across the disk surface to access different tracks and cylinders. The actuator arm is responsible for seek operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk Controller&lt;/strong&gt;: The &lt;strong&gt;disk controller&lt;/strong&gt; is electronic circuitry that &lt;strong&gt;controls the operation of the hard disk&lt;/strong&gt;. It interprets commands from the host computer, controls the actuator arm and spindle motor, manages data transfer, and performs error checking and correction. The controller acts as an interface between the disk and the computer's system bus.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enclosure&lt;/strong&gt;: The &lt;strong&gt;enclosure&lt;/strong&gt; is the protective casing that &lt;strong&gt;houses all the internal components&lt;/strong&gt; of the hard disk, protecting them from dust, damage, and external interference.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 [Your University/College Name]&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="278"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="17_139_2.0"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="87">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="84"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-37-30_2012july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-37-30_2012july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="42ab7a6d1fc801bbb62dfd350fcb3b0b"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="85"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                 <instance class="exe.engine.galleryidevice.GalleryImage">
                  <dictionary>
                   <string role="key" value="_caption"></string>
                   <instance class="exe.engine.field.TextField">
                    <dictionary>
                     <string role="key" value="_id"></string>
                     <int value="279"></int>
                     <string role="key" value="_idevice"></string>
                     <none></none>
                     <string role="key" value="_instruc"></string>
                     <string value=""></string>
                     <string role="key" value="_name"></string>
                     <string value=""></string>
                     <string role="key" value="content"></string>
                     <string value=""></string>
                     <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
                     <int value="4"></int>
                    </dictionary>
                   </instance>
                   <string role="key" value="_id"></string>
                   <unicode value="17_139_2.1"></unicode>
                   <string role="key" value="_imageResource"></string>
                   <instance class="exe.engine.resource.Resource" reference="88">
                    <dictionary>
                     <string role="key" value="_idevice"></string>
                     <reference key="84"></reference>
                     <string role="key" value="_package"></string>
                     <reference key="4"></reference>
                     <string role="key" value="_storageName"></string>
                     <string value="Screenshot_2025-03-12_at_13-53-51_2012july.pdf.png"></string>
                     <string role="key" value="_userName"></string>
                     <string value="/tmp/tmpyyoAlB.eXe/previews/allyourbase/Screenshot_2025-03-12_at_13-53-51_2012july.pdf.png"></string>
                     <string role="key" value="checksum"></string>
                     <string value="53e440026e075715d6e37d3e4b9e1e4a"></string>
                     <string role="key" value="exe.engine.resource.Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="exe.engine.resource._Resource.persistenceVersion"></string>
                     <int value="2"></int>
                     <string role="key" value="warningMsg"></string>
                     <string value=""></string>
                    </dictionary>
                   </instance>
                   <string role="key" value="_parent"></string>
                   <reference key="85"></reference>
                   <string role="key" value="_thumbnailResource"></string>
                   <none></none>
                   <string role="key" value="exe.engine.galleryidevice.GalleryImage.persistenceVersion"></string>
                   <int value="3"></int>
                   <string role="key" value="makeThumbnail"></string>
                   <bool value="0"></bool>
                  </dictionary>
                 </instance>
                </list>
                <string role="key" value="idevice"></string>
                <reference key="85"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="2"></int>
              <string role="key" value="parentNode"></string>
              <reference key="86"></reference>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="17"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="86"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list>
            <reference key="87"></reference>
            <reference key="88"></reference>
           </list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="17"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202012"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
      <instance class="exe.engine.node.Node" reference="91">
       <dictionary>
        <string role="key" value="_title"></string>
        <unicode value="July 2011"></unicode>
        <string role="key" value="idevices"></string>
        <list>
         <instance class="exe.engine.jsidevice.JsIdevice" reference="89">
          <dictionary>
           <string role="key" value="_title"></string>
           <unicode value=""></unicode>
           <string role="key" value="_attributes"></string>
           <list>
            <tuple>
             <string value="title"></string>
             <list>
              <string value="Title"></string>
              <int value="0"></int>
              <int value="0"></int>
             </list>
            </tuple>
            <tuple>
             <string value="category"></string>
             <list>
              <string value="Category"></string>
              <int value="0"></int>
              <int value="1"></int>
             </list>
            </tuple>
            <tuple>
             <string value="css-class"></string>
             <list>
              <string value="CSS class"></string>
              <int value="0"></int>
              <int value="2"></int>
             </list>
            </tuple>
            <tuple>
             <string value="icon"></string>
             <list>
              <string value="Icon"></string>
              <int value="0"></int>
              <int value="3"></int>
             </list>
            </tuple>
           </list>
           <string role="key" value="_author"></string>
           <string value=""></string>
           <string role="key" value="_iDeviceDir"></string>
           <string value="text"></string>
           <string role="key" value="_purpose"></string>
           <string value=""></string>
           <string role="key" value="_tip"></string>
           <string value=""></string>
           <string role="key" value="_typeName"></string>
           <unicode value="Text"></unicode>
           <string role="key" value="_valid"></string>
           <bool value="1"></bool>
           <string role="key" value="class_"></string>
           <unicode value="text"></unicode>
           <string role="key" value="edit"></string>
           <bool value="0"></bool>
           <string role="key" value="emphasis"></string>
           <int value="0"></int>
           <string role="key" value="exe.engine.jsidevice.JsIdevice.persistenceVersion"></string>
           <int value="1"></int>
           <string role="key" value="fields"></string>
           <list>
            <instance class="exe.engine.field.TextAreaField" reference="90">
             <dictionary>
              <string role="key" value="_id"></string>
              <unicode value="140_2"></unicode>
              <string role="key" value="_idevice"></string>
              <reference key="89"></reference>
              <string role="key" value="_instruc"></string>
              <string value=""></string>
              <string role="key" value="_name"></string>
              <string value=""></string>
              <string role="key" value="anchor_names"></string>
              <list></list>
              <string role="key" value="content_w_resourcePaths"></string>
              <unicode content="true" value="&lt;div class=&quot;exe-text&quot;&gt;&lt;p&gt;&lt;/p&gt;
&lt;style&gt;
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Bold Answers */
        .answer-content strong, .answer-content b {
            color: #2d3748;
            font-weight: 700;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) &quot;.&quot;;
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background-color: #4a5568;
            color: white;
        }

        th {
            text-align: left;
            padding: 0.75rem 1rem;
            font-weight: 600;
            border-bottom: 2px solid #2d3748;
        }

        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: white;
        }

        tr:last-child td {
            border-bottom: none;
        }

        tr:nth-child(even) td {
            background-color: #f8fafc;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
            
            table, thead, tbody, th, td, tr {
                display: block;
            }
            
            thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            
            tr {
                border: 1px solid #e2e8f0;
                margin-bottom: 1rem;
                border-radius: 8px;
                overflow: hidden;
            }
            
            td {
                border: none;
                position: relative;
                padding-left: 50%;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }
            
            td:before {
                position: absolute;
                top: 0.75rem;
                left: 1rem;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: 600;
                content: attr(data-label);
            }
            
            td:last-child {
                border-bottom: 0;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
            
            table {
                break-inside: auto;
            }
            
            tr {
                break-inside: avoid;
                break-after: auto;
            }
        }
    &lt;/style&gt;
&lt;header&gt;
&lt;h1&gt;OPERATING SYSTEMS&lt;/h1&gt;
&lt;div class=&quot;exam-details&quot;&gt;
&lt;p&gt;Exam Code: 2920/105&lt;/p&gt;
&lt;p&gt;Duration: 3 hours&lt;/p&gt;
&lt;p&gt;Period: July 2011&lt;/p&gt;
&lt;/div&gt;
&lt;/header&gt;
&lt;p&gt;&lt;main&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (i) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;7. (a) (i) State four examples of network operating systems from other different families.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Windows Server Family&lt;/strong&gt; (e.g., Windows Server 2019, Windows Server 2022)&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Linux Family&lt;/strong&gt; (e.g., Red Hat Enterprise Linux, Ubuntu Server, CentOS)&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;UNIX Family&lt;/strong&gt; (e.g., Solaris, HP-UX, AIX)&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;macOS Server Family&lt;/strong&gt; (macOS Server)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (a) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(ii) Outline two advantages of distributed operating systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Resource Sharing&lt;/strong&gt;: &lt;strong&gt;Distributed operating systems&lt;/strong&gt; enable efficient &lt;strong&gt;resource sharing&lt;/strong&gt; across a network of computers. Users can access and utilize resources (files, printers, processing power) located on different machines as if they were local, improving resource utilization and reducing redundancy.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Increased Reliability and Fault Tolerance&lt;/strong&gt;: Distributed systems offer &lt;strong&gt;enhanced reliability and fault tolerance&lt;/strong&gt;. If one computer in the system fails, the overall system can continue to operate, as tasks can be redistributed to other available nodes. This redundancy minimizes downtime and increases system robustness compared to centralized systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (i) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Table 1 shows details of processes in a computer system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;Table 1&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Process ID&lt;/th&gt;
&lt;th&gt;Arrival time&lt;/th&gt;
&lt;th&gt;Run time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;W&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;0&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;X&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;2&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;Y&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;2&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td data-label=&quot;Process ID&quot;&gt;Z&lt;/td&gt;
&lt;td data-label=&quot;Arrival time&quot;&gt;3&lt;/td&gt;
&lt;td data-label=&quot;Run time&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Assuming that the system uses the SJF scheduling algorithm.&lt;/p&gt;
&lt;p&gt;(i) Determine the average waiting time for the processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;To determine the average waiting time using SJF (Shortest Job First), we need to schedule the processes based on their run time, considering their arrival times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scheduling with SJF (Non-Preemptive):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. At time 0, Process W arrives and runs (shortest job available).&lt;/p&gt;
&lt;p&gt;2. At time 2, Processes X and Y arrive. Process W completes at time 2.&lt;/p&gt;
&lt;p&gt;3. At time 2, choose the shortest job among X, Y, and Z (which arrives at time 3). Process X has the shortest run time (7).&lt;/p&gt;
&lt;p&gt;4. At time 3, Process Z arrives. Process X continues to run (non-preemptive).&lt;/p&gt;
&lt;p&gt;5. Process X runs for 7 units, completing at time 2 + 7 = 9.&lt;/p&gt;
&lt;p&gt;6. At time 9, choose the shortest job among Y and Z. Process Z has the shortest run time (3).&lt;/p&gt;
&lt;p&gt;7. Process Z runs for 3 units, completing at time 9 + 3 = 12.&lt;/p&gt;
&lt;p&gt;8. Process Y runs for the remaining 20 units, completing at time 12 + 20 = 32.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gantt Chart:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                    Time: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12| 13| ... | 31| 32|
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|-----|---|---|
                    CPU: | W | W | X | X | X | X | X | X | X | Z | Z | Z | Y | Y | ... | Y | Y |
                    -----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|-----|---|---|
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Completion Times and Turnaround Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;W: Completion Time = 2, Turnaround Time = 2 - 0 = 2&lt;/p&gt;
&lt;p&gt;X: Completion Time = 9, Turnaround Time = 9 - 2 = 7&lt;/p&gt;
&lt;p&gt;Z: Completion Time = 12, Turnaround Time = 12 - 3 = 9&lt;/p&gt;
&lt;p&gt;Y: Completion Time = 32, Turnaround Time = 32 - 2 = 30&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Waiting Times:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Waiting Time = Turnaround Time - Run Time&lt;/p&gt;
&lt;p&gt;W: Waiting Time = 2 - 2 = 0&lt;/p&gt;
&lt;p&gt;X: Waiting Time = 7 - 7 = 0&lt;/p&gt;
&lt;p&gt;Z: Waiting Time = 9 - 3 = 6&lt;/p&gt;
&lt;p&gt;Y: Waiting Time = 30 - 20 = 10&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Waiting Time:&lt;/strong&gt; (0 + 0 + 6 + 10) / 4 = 16 / 4 = &lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Average Waiting Time for the processes is 4 units.&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (b) (ii) (2 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) Table 1 shows details of processes in a computer system. Use it to answer the questions that follow.&lt;/p&gt;
&lt;p&gt;(ii) Explain one disadvantage of the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;One disadvantage of using the &lt;strong&gt;non-preemptive SJF scheduling algorithm&lt;/strong&gt; in this system is the potential for &lt;strong&gt;starvation or longer waiting times for longer processes&lt;/strong&gt;. If there is a continuous arrival of short processes, longer processes may get delayed indefinitely or experience very long waiting times as SJF always prioritizes shorter jobs. In this example, Process Y, being the longest job, has a significantly higher waiting time compared to shorter jobs, illustrating this potential disadvantage.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (c) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) A certain software company developed an operating system but during testing, the results showed that the system has a problem with memory segmentation. Outline four causes of the problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;External Fragmentation&lt;/strong&gt;: Memory segmentation can suffer from &lt;strong&gt;external fragmentation&lt;/strong&gt;. Over time, as segments are allocated and deallocated, the free memory space can become fragmented into smaller, non-contiguous holes. This can lead to a situation where there is enough total free memory, but it is not contiguous enough to allocate larger segments, causing allocation failures even when sufficient memory exists in aggregate.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Segment Table Overhead and Complexity&lt;/strong&gt;: Managing &lt;strong&gt;segment tables&lt;/strong&gt; adds overhead. Each process needs a segment table to map logical addresses to physical addresses. Segment tables consume memory space and require management by the operating system. Furthermore, address translation using segment tables can be more complex and potentially slower than simpler techniques like paging, adding processing overhead.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Variable Segment Sizes and Management Complexity&lt;/strong&gt;: The &lt;strong&gt;variable size of segments&lt;/strong&gt;, while offering flexibility, also adds to management complexity. The operating system needs to keep track of segments of different sizes, manage allocation and deallocation of variable-sized blocks, and handle the fragmentation issues that arise from variable-sized allocations. Managing variable-sized segments is more intricate than managing fixed-size pages in paging.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;Overhead of Segment Swapping (if used)&lt;/strong&gt;: If the segmentation-based system uses swapping (moving segments to disk), &lt;strong&gt;swapping variable-sized segments&lt;/strong&gt; can be more complex and potentially less efficient than swapping fixed-size pages. Managing and swapping segments of different sizes can introduce additional overhead in terms of disk I/O and memory management, especially if segment sizes are not optimally managed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;7. (d) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) James, a student with a certain college was carrying out an assignment about memory registers in computer systems. Describe two types of registers James would include in his report.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;General-Purpose Registers (GPRs)&lt;/strong&gt;: &lt;strong&gt;General-Purpose Registers (GPRs)&lt;/strong&gt; are &lt;strong&gt;versatile registers&lt;/strong&gt; used for a variety of purposes by the CPU. They are used to hold &lt;strong&gt;operands for arithmetic and logical operations, memory addresses, loop counters, and temporary data&lt;/strong&gt; during program execution. GPRs are fundamental for data manipulation and processing within the CPU. Examples include registers like EAX, EBX, ECX, EDX (in x86 architecture) or R0, R1, R2, etc. (in ARM architecture). James should include GPRs as they are essential for general-purpose computation.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Special-Purpose Registers&lt;/strong&gt;: &lt;strong&gt;Special-Purpose Registers&lt;/strong&gt; have &lt;strong&gt;specific, predefined functions&lt;/strong&gt; within the CPU architecture. They are used for particular tasks and operations, and their usage is often restricted or controlled by the CPU. Examples include: * &lt;strong&gt;Program Counter (PC)&lt;/strong&gt;: Holds the address of the next instruction to be executed. * &lt;strong&gt;Stack Pointer (SP)&lt;/strong&gt;: Points to the top of the current stack in memory. * &lt;strong&gt;Instruction Register (IR)&lt;/strong&gt;: Holds the current instruction being decoded and executed. * &lt;strong&gt;Status Register (Flags Register)&lt;/strong&gt;: Contains status flags that reflect the result of arithmetic and logical operations (e.g., zero flag, carry flag, overflow flag). James should describe special-purpose registers as they are critical for controlling CPU operation, instruction flow, and managing program execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (a) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;8. (a) Explain two advantages of dynamic linking as used in memory management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Reduced Memory Footprint&lt;/strong&gt;: &lt;strong&gt;Dynamic linking&lt;/strong&gt; leads to a &lt;strong&gt;reduced memory footprint&lt;/strong&gt; because shared libraries are loaded into memory only once, and &lt;strong&gt;shared among multiple processes&lt;/strong&gt; that use them. Instead of each program having its own copy of library code, they all link to a single shared library in memory. This significantly saves memory, especially when many programs use the same libraries, resulting in more efficient memory utilization and allowing more programs to run concurrently.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Easier Library Updates and Maintenance&lt;/strong&gt;: Dynamic linking simplifies &lt;strong&gt;library updates and maintenance&lt;/strong&gt;. When a shared library is updated (e.g., for bug fixes or security patches), the updated library can be replaced in one location, and &lt;strong&gt;all applications that use it automatically benefit from the update&lt;/strong&gt; the next time they are executed, without needing to be recompiled or relinked. This simplifies software distribution, patching, and maintenance, reducing administrative overhead and ensuring consistency across applications.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (b) (4 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(b) A certain company intends to deploy RAID technology as a backup strategy on their distributed system. Outline four levels of RAID technology the company could use to accomplish the task.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;RAID 1 (Mirroring)&lt;/strong&gt;: &lt;strong&gt;RAID 1&lt;/strong&gt; mirrors data across two or more disks, providing &lt;strong&gt;data redundancy&lt;/strong&gt;. Every piece of data is written to two or more disks simultaneously. If one disk fails, data is preserved on the other disk(s). RAID 1 is suitable for backup as it ensures data availability in case of disk failure and provides good read performance, but it reduces storage capacity by half (or more, depending on the number of mirrors).&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;RAID 5 (Striping with Parity)&lt;/strong&gt;: &lt;strong&gt;RAID 5&lt;/strong&gt; stripes data across three or more disks and includes &lt;strong&gt;parity information&lt;/strong&gt;. Parity data allows for data reconstruction if one disk fails. RAID 5 provides a balance between redundancy and storage efficiency, offering fault tolerance and good read performance, although write performance is slightly reduced due to parity calculations. It's a common choice for backup and general-purpose storage.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;RAID 6 (Striping with Double Parity)&lt;/strong&gt;: &lt;strong&gt;RAID 6&lt;/strong&gt; is similar to RAID 5 but includes &lt;strong&gt;double parity&lt;/strong&gt;, meaning it can tolerate the failure of up to two disks simultaneously without data loss. RAID 6 provides higher fault tolerance than RAID 5, making it suitable for critical backup systems where data availability is paramount, but it has slightly lower write performance and higher overhead due to double parity.&lt;/p&gt;
&lt;p data-number=&quot;4&quot;&gt;&lt;strong&gt;RAID 10 (RAID 1+0, Mirroring and Striping)&lt;/strong&gt;: &lt;strong&gt;RAID 10&lt;/strong&gt; combines &lt;strong&gt;mirroring (RAID 1) and striping (RAID 0)&lt;/strong&gt;. It creates mirrored pairs of disks (RAID 1) and then stripes data across these mirrored pairs (RAID 0). RAID 10 offers both high performance (due to striping) and high redundancy (due to mirroring). It provides excellent fault tolerance and fast read/write speeds, making it suitable for high-performance backup systems, but it is more expensive as it requires at least twice the storage capacity compared to the usable space.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (c) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(c) Alex, a systems analyst with a certain company was given a task of designing an operating system that would work with different hardware vendors. Describe three types of 1/0 communication techniques that he would use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p data-number=&quot;1&quot;&gt;&lt;strong&gt;Programmed I/O (PIO)&lt;/strong&gt;: &lt;strong&gt;Programmed I/O (PIO)&lt;/strong&gt; is a simple I/O communication technique where data transfer between the CPU and I/O devices is &lt;strong&gt;directly controlled by the CPU&lt;/strong&gt;. For each data byte or word transferred, the CPU executes I/O instructions to read or write data to device registers. PIO is straightforward to implement but is &lt;strong&gt;CPU-intensive&lt;/strong&gt;, as the CPU is actively involved in every data transfer, limiting CPU parallelism and system performance, especially for high-speed I/O devices. PIO is suitable for low-data-rate devices or simple systems where CPU overhead is not a major concern.&lt;/p&gt;
&lt;p data-number=&quot;2&quot;&gt;&lt;strong&gt;Interrupt-Driven I/O&lt;/strong&gt;: &lt;strong&gt;Interrupt-Driven I/O&lt;/strong&gt; improves upon PIO by allowing the &lt;strong&gt;CPU to perform other tasks while waiting for I/O operations to complete&lt;/strong&gt;. When an I/O device is ready to transfer data or has completed an operation, it sends an &lt;strong&gt;interrupt signal&lt;/strong&gt; to the CPU. The CPU then suspends its current task, executes an &lt;strong&gt;interrupt handler&lt;/strong&gt; to transfer data or handle the I/O event, and then resumes the interrupted task. Interrupt-driven I/O reduces CPU waiting time compared to PIO and improves system concurrency, but still involves CPU intervention for each data transfer, although less directly than PIO.&lt;/p&gt;
&lt;p data-number=&quot;3&quot;&gt;&lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt;: &lt;strong&gt;Direct Memory Access (DMA)&lt;/strong&gt; is the most efficient I/O communication technique for high-speed data transfer. DMA allows I/O devices to &lt;strong&gt;transfer data directly to or from main memory without constant CPU involvement&lt;/strong&gt;. A &lt;strong&gt;DMA Controller&lt;/strong&gt; manages the data transfer, freeing up the CPU to perform other tasks concurrently. The CPU initiates the DMA transfer by programming the DMA controller, and the controller then handles the data transfer independently. DMA significantly reduces CPU overhead for I/O operations, improving system performance, especially for high-bandwidth devices like disks and network interfaces. DMA is essential for efficient high-speed I/O in modern systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section class=&quot;question&quot;&gt;
&lt;h3&gt;8. (d) (6 marks)&lt;/h3&gt;
&lt;div class=&quot;question-content&quot;&gt;
&lt;p&gt;(d) With the aid of a diagram, outline the internal structure of a hard disk.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;answer-section&quot;&gt;
&lt;h4&gt;Answer&lt;/h4&gt;
&lt;div class=&quot;answer-content&quot;&gt;
&lt;p&gt;The &lt;strong&gt;internal structure of a hard disk drive (HDD)&lt;/strong&gt; consists of several key components working together to store and retrieve data magnetically.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Diagram of Hard Disk Internal Structure:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;                                                +---------------------+
                                                |    Actuator Arm     |-------+
                                                +---------------------+       |  (Moves Heads)
                                                      /       \             |
                                                     /         \            v
                    +-------------+   +-------------+   +-------------+     +---------------+
                    |   Platter   |   |   Platter   |   |   Platter   | ... | Read/Write Head |
                    | (Top Surface)|   | (Bottom Surface)|   | (Top Surface)|     +---------------+
                    +-------------+   +-------------+   +-------------+     | Read/Write Head |
                    |   ...         |   |   ...         |   |   ...         |     +---------------+
                    +-------------+   +-------------+   +-------------+ ... | Read/Write Head |
                    |   Platter   |   |   Platter   |   |   Platter   |     +---------------+
                    |(Bottom Surface)|   |(Top Surface)|   |(Bottom Surface)|
                    +-------------+   +-------------+   +-------------+
                                              |   |   |
                                              \   |   /
                                               \  |  /
                                                \ | /
                                                 V
                                        +---------------------+
                                        |      Spindle        | (Rotates Platters)
                                        +---------------------+
                    Components:
                    - Platter(s): Circular disks coated with magnetic material, store data.
                    - Spindle: Central axis that platters rotate around.
                    - Read/Write Heads: Read and write data to/from platters.
                    - Actuator Arm: Positions read/write heads across platters.

                    Additional elements not shown in simple diagram but part of internal structure:
                    - Disk Controller: Electronic circuitry to control disk operations, interface with computer.
                    - Enclosure: Protective casing.
                    &lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Description of Components:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Platters&lt;/strong&gt;: Hard disks contain one or more &lt;strong&gt;platters&lt;/strong&gt;, which are rigid, circular disks coated with a magnetic material. Data is stored on both surfaces of each platter in concentric tracks and sectors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spindle&lt;/strong&gt;: The &lt;strong&gt;spindle&lt;/strong&gt; is a central shaft that &lt;strong&gt;holds and rotates the platters&lt;/strong&gt; at a constant speed. The platters spin around the spindle, enabling the read/write heads to access different parts of the disk surface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Read/Write Heads&lt;/strong&gt;: &lt;strong&gt;Read/write heads&lt;/strong&gt; are electromagnetic components that &lt;strong&gt;read data from and write data to the platters&lt;/strong&gt;. Each platter surface has a corresponding read/write head. Heads are mounted on an actuator arm and float very close to the platter surface without touching it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Actuator Arm&lt;/strong&gt;: The &lt;strong&gt;actuator arm&lt;/strong&gt; is a mechanism that &lt;strong&gt;positions the read/write heads&lt;/strong&gt; across the platters. It moves the heads radially across the disk surface to access different tracks and cylinders. The actuator arm is responsible for seek operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk Controller&lt;/strong&gt;: The &lt;strong&gt;disk controller&lt;/strong&gt; is electronic circuitry that &lt;strong&gt;controls the operation of the hard disk&lt;/strong&gt;. It interprets commands from the host computer, controls the actuator arm and spindle motor, manages data transfer, and performs error checking and correction. The controller acts as an interface between the disk and the computer's system bus.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enclosure&lt;/strong&gt;: The &lt;strong&gt;enclosure&lt;/strong&gt; is the protective casing that &lt;strong&gt;houses all the internal components&lt;/strong&gt; of the hard disk, protecting them from dust, damage, and external interference.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/main&gt;&lt;/p&gt;
&lt;footer&gt;© 2023 [Your University/College Name]&lt;/footer&gt;&lt;/div&gt;"></unicode>
              <string role="key" value="exe.engine.field.Field.persistenceVersion"></string>
              <int value="4"></int>
              <string role="key" value="exe.engine.field.FieldWithResources.persistenceVersion"></string>
              <int value="2"></int>
              <string role="key" value="exe.engine.field.TextAreaField.persistenceVersion"></string>
              <int value="3"></int>
              <string role="key" value="htmlTag"></string>
              <string value="div"></string>
              <string role="key" value="images"></string>
              <instance class="exe.engine.galleryidevice.GalleryImages">
               <dictionary>
                <string role="key" value=".listitems"></string>
                <list></list>
                <string role="key" value="idevice"></string>
                <reference key="90"></reference>
               </dictionary>
              </instance>
              <string role="key" value="intlinks_to_anchors"></string>
              <dictionary></dictionary>
              <string role="key" value="nextImageId"></string>
              <int value="0"></int>
              <string role="key" value="parentNode"></string>
              <none></none>
             </dictionary>
            </instance>
           </list>
           <string role="key" value="icon"></string>
           <unicode value=""></unicode>
           <string role="key" value="id"></string>
           <unicode value="18"></unicode>
           <string role="key" value="ideviceCategory"></string>
           <unicode value="Text and Tasks"></unicode>
           <string role="key" value="lastIdevice"></string>
           <bool value="0"></bool>
           <string role="key" value="nextFieldId"></string>
           <int value="3"></int>
           <string role="key" value="originalicon"></string>
           <string value=""></string>
           <string role="key" value="parentNode"></string>
           <reference key="91"></reference>
           <string role="key" value="systemResources"></string>
           <list></list>
           <string role="key" value="undo"></string>
           <bool value="1"></bool>
           <string role="key" value="userResources"></string>
           <list></list>
           <string role="key" value="version"></string>
           <int value="0"></int>
          </dictionary>
         </instance>
        </list>
        <string role="key" value="_id"></string>
        <unicode value="18"></unicode>
        <string role="key" value="_package"></string>
        <reference key="4"></reference>
        <string role="key" value="anchor_fields"></string>
        <list></list>
        <string role="key" value="exe.engine.node.Node.persistenceVersion"></string>
        <int value="2"></int>
        <string role="key" value="exportType"></string>
        <string value="website"></string>
        <string role="key" value="last_full_node_path"></string>
        <string value="exe-node:Home:July%202011"></string>
        <string role="key" value="parent"></string>
        <reference key="3"></reference>
        <string role="key" value="top_anchors_linked_from_fields"></string>
        <list></list>
        <string role="key" value="children"></string>
        <list></list>
       </dictionary>
      </instance>
     </list>
    </dictionary>
   </instance>
   <unicode role="key" value="1"></unicode>
   <reference key="7"></reference>
   <unicode role="key" value="10"></unicode>
   <reference key="49"></reference>
   <unicode role="key" value="11"></unicode>
   <reference key="55"></reference>
   <unicode role="key" value="12"></unicode>
   <reference key="61"></reference>
   <unicode role="key" value="13"></unicode>
   <reference key="67"></reference>
   <unicode role="key" value="14"></unicode>
   <reference key="72"></reference>
   <unicode role="key" value="15"></unicode>
   <reference key="76"></reference>
   <unicode role="key" value="16"></unicode>
   <reference key="80"></reference>
   <unicode role="key" value="17"></unicode>
   <reference key="86"></reference>
   <unicode role="key" value="18"></unicode>
   <reference key="91"></reference>
   <unicode role="key" value="2"></unicode>
   <reference key="13"></reference>
   <unicode role="key" value="3"></unicode>
   <reference key="19"></reference>
   <unicode role="key" value="4"></unicode>
   <reference key="24"></reference>
   <unicode role="key" value="5"></unicode>
   <reference key="28"></reference>
   <unicode role="key" value="6"></unicode>
   <reference key="33"></reference>
   <unicode role="key" value="7"></unicode>
   <reference key="36"></reference>
   <unicode role="key" value="8"></unicode>
   <reference key="40"></reference>
   <unicode role="key" value="9"></unicode>
   <reference key="44"></reference>
  </dictionary>
  <string role="key" value="_objectives"></string>
  <unicode value=""></unicode>
  <string role="key" value="_preknowledge"></string>
  <unicode value=""></unicode>
  <string role="key" value="_templateFile"></string>
  <string value="Base"></string>
  <string role="key" value="backgroundImgTile"></string>
  <bool value="0"></bool>
  <string role="key" value="currentNode"></string>
  <reference key="91"></reference>
  <string role="key" value="dublinCore"></string>
  <instance class="exe.engine.package.DublinCore">
   <dictionary>
    <string role="key" value="contributors"></string>
    <unicode value=""></unicode>
    <string role="key" value="coverage"></string>
    <unicode value=""></unicode>
    <string role="key" value="creator"></string>
    <unicode value=""></unicode>
    <string role="key" value="date"></string>
    <unicode value=""></unicode>
    <string role="key" value="description"></string>
    <unicode value=""></unicode>
    <string role="key" value="format"></string>
    <unicode value=""></unicode>
    <string role="key" value="identifier"></string>
    <unicode value="4a7d755e-34a5-410a-a7d4-601881136623"></unicode>
    <string role="key" value="language"></string>
    <unicode value="en"></unicode>
    <string role="key" value="publisher"></string>
    <unicode value=""></unicode>
    <string role="key" value="relation"></string>
    <unicode value=""></unicode>
    <string role="key" value="rights"></string>
    <unicode value=""></unicode>
    <string role="key" value="source"></string>
    <unicode value=""></unicode>
    <string role="key" value="subject"></string>
    <unicode value=""></unicode>
    <string role="key" value="title"></string>
    <unicode value=""></unicode>
    <string role="key" value="type"></string>
    <unicode value=""></unicode>
   </dictionary>
  </instance>
  <string role="key" value="exe.engine.package.Package.persistenceVersion"></string>
  <int value="16"></int>
  <string role="key" value="exportMetadataType"></string>
  <unicode value="LOMES"></unicode>
  <string role="key" value="exportSource"></string>
  <bool value="1"></bool>
  <string role="key" value="footer"></string>
  <unicode value=""></unicode>
  <string role="key" value="isLoading"></string>
  <bool value="0"></bool>
  <string role="key" value="license"></string>
  <unicode value="None"></unicode>
  <string role="key" value="lom"></string>
  <instance class="exe.engine.lom.lomsubs.lomSub">
   <dictionary>
    <string role="key" value="__index__"></string>
    <dictionary></dictionary>
    <string role="key" value="__oldchild__"></string>
    <none></none>
    <string role="key" value="annotation"></string>
    <list></list>
    <string role="key" value="classification"></string>
    <list></list>
    <string role="key" value="educational"></string>
    <list>
     <instance class="exe.engine.lom.lomsubs.educationalSub">
      <dictionary>
       <string role="key" value="cognitiveProcess"></string>
       <list></list>
       <string role="key" value="context"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.contextSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOMv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.contextValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="other"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
        <instance class="exe.engine.lom.lomsubs.contextSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOMv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.contextValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="school"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="description"></string>
       <list></list>
       <string role="key" value="difficulty"></string>
       <none></none>
       <string role="key" value="intendedEndUserRole"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.intendedEndUserRoleSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOMv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.intendedEndUserRoleValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="learner"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="interactivityLevel"></string>
       <none></none>
       <string role="key" value="interactivityType"></string>
       <none></none>
       <string role="key" value="language"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="en"></string>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="learningResourceType"></string>
       <list></list>
       <string role="key" value="semanticDensity"></string>
       <none></none>
       <string role="key" value="typicalAgeRange"></string>
       <list></list>
       <string role="key" value="typicalLearningTime"></string>
       <none></none>
      </dictionary>
     </instance>
    </list>
    <string role="key" value="general"></string>
    <instance class="exe.engine.lom.lomsubs.generalSub">
     <dictionary>
      <string role="key" value="aggregationLevel"></string>
      <instance class="exe.engine.lom.lomsubs.aggregationLevelSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOMv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="aggregationLevel"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.aggregationLevelValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="2"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="coverage"></string>
      <list></list>
      <string role="key" value="description"></string>
      <list></list>
      <string role="key" value="identifier"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.identifierSub">
        <dictionary>
         <string role="key" value="catalog"></string>
         <instance class="exe.engine.lom.lomsubs.catalogSub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="catalog"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="My Catalog"></unicode>
          </dictionary>
         </instance>
         <string role="key" value="entry"></string>
         <instance class="exe.engine.lom.lomsubs.entrySub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="entry"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="4a7d755e-34a5-410a-a7d4-601881136623"></unicode>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="keyword"></string>
      <list></list>
      <string role="key" value="language"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
        <dictionary>
         <string role="key" value="extensiontype_"></string>
         <none></none>
         <string role="key" value="valueOf_"></string>
         <string value="en"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="structure"></string>
      <none></none>
      <string role="key" value="title"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <string value="general"></string>
     </dictionary>
    </instance>
    <string role="key" value="lifeCycle"></string>
    <none></none>
    <string role="key" value="metaMetadata"></string>
    <instance class="exe.engine.lom.lomsubs.metaMetadataSub">
     <dictionary>
      <string role="key" value="contribute"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.contributeMetaSub">
        <dictionary>
         <string role="key" value="date"></string>
         <instance class="exe.engine.lom.lomsubs.dateSub">
          <dictionary>
           <string role="key" value="dateTime"></string>
           <instance class="exe.engine.lom.lomsubs.DateTimeValueSub">
            <dictionary>
             <string role="key" value="uniqueElementName"></string>
             <string value="dateTime"></string>
             <string role="key" value="valueOf_"></string>
             <string value="2025-03-11T13:48:06.00+03:00"></string>
            </dictionary>
           </instance>
           <string role="key" value="description"></string>
           <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list>
              <instance class="exe.engine.lom.lomsubs.LangStringSub">
               <dictionary>
                <string role="key" value="language"></string>
                <string value="en"></string>
                <string role="key" value="valueOf_"></string>
                <string value="Metadata creation date"></string>
               </dictionary>
              </instance>
             </list>
            </dictionary>
           </instance>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="uniqueElementName"></string>
           <none></none>
           <string role="key" value="valueOf_"></string>
           <none></none>
          </dictionary>
         </instance>
         <string role="key" value="entity"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.entitySub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="BEGIN:VCARD VERSION:3.0 FN: EMAIL;TYPE=INTERNET: ORG: END:VCARD"></string>
           </dictionary>
          </instance>
         </list>
         <string role="key" value="role"></string>
         <instance class="exe.engine.lom.lomsubs.roleSub">
          <dictionary>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="source"></string>
           <instance class="exe.engine.lom.lomsubs.sourceValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list></list>
             <string role="key" value="uniqueElementName"></string>
             <string value="source"></string>
             <string role="key" value="valueOf_"></string>
             <string value="LOMv1.0"></string>
            </dictionary>
           </instance>
           <string role="key" value="uniqueElementName"></string>
           <string value="role"></string>
           <string role="key" value="value"></string>
           <instance class="exe.engine.lom.lomsubs.roleValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="source"></string>
             <none></none>
             <string role="key" value="uniqueElementName"></string>
             <string value="value"></string>
             <string role="key" value="value"></string>
             <none></none>
             <string role="key" value="valueOf_"></string>
             <string value="creator"></string>
            </dictionary>
           </instance>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="identifier"></string>
      <list></list>
      <string role="key" value="language"></string>
      <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="valueOf_"></string>
        <string value="en"></string>
       </dictionary>
      </instance>
      <string role="key" value="metadataSchema"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.metadataSchemaSub">
        <dictionary>
         <string role="key" value="valueOf_"></string>
         <string value="LOMv1.0"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="uniqueElementName"></string>
      <string value="metaMetadata"></string>
     </dictionary>
    </instance>
    <string role="key" value="relation"></string>
    <list></list>
    <string role="key" value="rights"></string>
    <instance class="exe.engine.lom.lomsubs.rightsSub">
     <dictionary>
      <string role="key" value="access"></string>
      <none></none>
      <string role="key" value="copyrightAndOtherRestrictions"></string>
      <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOMv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="copyrightAndOtherRestrictions"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="yes"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="cost"></string>
      <none></none>
      <string role="key" value="description"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <none></none>
     </dictionary>
    </instance>
    <string role="key" value="technical"></string>
    <none></none>
   </dictionary>
  </instance>
  <string role="key" value="lomEs"></string>
  <instance class="exe.engine.lom.lomsubs.lomSub">
   <dictionary>
    <string role="key" value="__index__"></string>
    <dictionary></dictionary>
    <string role="key" value="__oldchild__"></string>
    <none></none>
    <string role="key" value="annotation"></string>
    <list></list>
    <string role="key" value="classification"></string>
    <list></list>
    <string role="key" value="educational"></string>
    <list>
     <instance class="exe.engine.lom.lomsubs.educationalSub">
      <dictionary>
       <string role="key" value="cognitiveProcess"></string>
       <list></list>
       <string role="key" value="context"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.contextSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOM-ESv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.contextValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="presencial"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
        <instance class="exe.engine.lom.lomsubs.contextSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOM-ESv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.contextValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="classroom"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="description"></string>
       <list></list>
       <string role="key" value="difficulty"></string>
       <none></none>
       <string role="key" value="intendedEndUserRole"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.intendedEndUserRoleSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOM-ESv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.intendedEndUserRoleValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="learner"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="interactivityLevel"></string>
       <none></none>
       <string role="key" value="interactivityType"></string>
       <none></none>
       <string role="key" value="language"></string>
       <list>
        <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="en"></string>
         </dictionary>
        </instance>
       </list>
       <string role="key" value="learningResourceType"></string>
       <list></list>
       <string role="key" value="semanticDensity"></string>
       <none></none>
       <string role="key" value="typicalAgeRange"></string>
       <list></list>
       <string role="key" value="typicalLearningTime"></string>
       <none></none>
      </dictionary>
     </instance>
    </list>
    <string role="key" value="general"></string>
    <instance class="exe.engine.lom.lomsubs.generalSub">
     <dictionary>
      <string role="key" value="aggregationLevel"></string>
      <instance class="exe.engine.lom.lomsubs.aggregationLevelSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOM-ESv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="aggregationLevel"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.aggregationLevelValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="2"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="coverage"></string>
      <list></list>
      <string role="key" value="description"></string>
      <list></list>
      <string role="key" value="identifier"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.identifierSub">
        <dictionary>
         <string role="key" value="catalog"></string>
         <instance class="exe.engine.lom.lomsubs.catalogSub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="catalog"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="My Catalog"></unicode>
          </dictionary>
         </instance>
         <string role="key" value="entry"></string>
         <instance class="exe.engine.lom.lomsubs.entrySub">
          <dictionary>
           <string role="key" value="uniqueElementName"></string>
           <string value="entry"></string>
           <string role="key" value="valueOf_"></string>
           <unicode value="4a7d755e-34a5-410a-a7d4-601881136623"></unicode>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="keyword"></string>
      <list></list>
      <string role="key" value="language"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
        <dictionary>
         <string role="key" value="extensiontype_"></string>
         <none></none>
         <string role="key" value="valueOf_"></string>
         <string value="en"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="structure"></string>
      <none></none>
      <string role="key" value="title"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <string value="general"></string>
     </dictionary>
    </instance>
    <string role="key" value="lifeCycle"></string>
    <none></none>
    <string role="key" value="metaMetadata"></string>
    <instance class="exe.engine.lom.lomsubs.metaMetadataSub">
     <dictionary>
      <string role="key" value="contribute"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.contributeMetaSub">
        <dictionary>
         <string role="key" value="date"></string>
         <instance class="exe.engine.lom.lomsubs.dateSub">
          <dictionary>
           <string role="key" value="dateTime"></string>
           <instance class="exe.engine.lom.lomsubs.DateTimeValueSub">
            <dictionary>
             <string role="key" value="uniqueElementName"></string>
             <string value="dateTime"></string>
             <string role="key" value="valueOf_"></string>
             <string value="2025-03-11T13:48:06.00+03:00"></string>
            </dictionary>
           </instance>
           <string role="key" value="description"></string>
           <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list>
              <instance class="exe.engine.lom.lomsubs.LangStringSub">
               <dictionary>
                <string role="key" value="language"></string>
                <string value="en"></string>
                <string role="key" value="valueOf_"></string>
                <string value="Metadata creation date"></string>
               </dictionary>
              </instance>
             </list>
            </dictionary>
           </instance>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="uniqueElementName"></string>
           <none></none>
           <string role="key" value="valueOf_"></string>
           <none></none>
          </dictionary>
         </instance>
         <string role="key" value="entity"></string>
         <list>
          <instance class="exe.engine.lom.lomsubs.entitySub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="BEGIN:VCARD VERSION:3.0 FN: EMAIL;TYPE=INTERNET: ORG: END:VCARD"></string>
           </dictionary>
          </instance>
         </list>
         <string role="key" value="role"></string>
         <instance class="exe.engine.lom.lomsubs.roleSub">
          <dictionary>
           <string role="key" value="extensiontype_"></string>
           <none></none>
           <string role="key" value="source"></string>
           <instance class="exe.engine.lom.lomsubs.sourceValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="string"></string>
             <list></list>
             <string role="key" value="uniqueElementName"></string>
             <string value="source"></string>
             <string role="key" value="valueOf_"></string>
             <string value="LOM-ESv1.0"></string>
            </dictionary>
           </instance>
           <string role="key" value="uniqueElementName"></string>
           <string value="role"></string>
           <string role="key" value="value"></string>
           <instance class="exe.engine.lom.lomsubs.roleValueSub">
            <dictionary>
             <string role="key" value="extensiontype_"></string>
             <none></none>
             <string role="key" value="source"></string>
             <none></none>
             <string role="key" value="uniqueElementName"></string>
             <string value="value"></string>
             <string role="key" value="value"></string>
             <none></none>
             <string role="key" value="valueOf_"></string>
             <string value="creator"></string>
            </dictionary>
           </instance>
          </dictionary>
         </instance>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="identifier"></string>
      <list></list>
      <string role="key" value="language"></string>
      <instance class="exe.engine.lom.lomsubs.LanguageIdSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="valueOf_"></string>
        <string value="en"></string>
       </dictionary>
      </instance>
      <string role="key" value="metadataSchema"></string>
      <list>
       <instance class="exe.engine.lom.lomsubs.metadataSchemaSub">
        <dictionary>
         <string role="key" value="valueOf_"></string>
         <string value="LOM-ESv1.0"></string>
        </dictionary>
       </instance>
      </list>
      <string role="key" value="uniqueElementName"></string>
      <string value="metaMetadata"></string>
     </dictionary>
    </instance>
    <string role="key" value="relation"></string>
    <list></list>
    <string role="key" value="rights"></string>
    <instance class="exe.engine.lom.lomsubs.rightsSub">
     <dictionary>
      <string role="key" value="access"></string>
      <instance class="exe.engine.lom.lomsubs.accessSub">
       <dictionary>
        <string role="key" value="accessType"></string>
        <instance class="exe.engine.lom.lomsubs.accessTypeSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <instance class="exe.engine.lom.lomsubs.sourceValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="string"></string>
            <list></list>
            <string role="key" value="uniqueElementName"></string>
            <string value="source"></string>
            <string role="key" value="valueOf_"></string>
            <string value="LOM-ESv1.0"></string>
           </dictionary>
          </instance>
          <string role="key" value="uniqueElementName"></string>
          <string value="accessType"></string>
          <string role="key" value="value"></string>
          <instance class="exe.engine.lom.lomsubs.accessTypeValueSub">
           <dictionary>
            <string role="key" value="extensiontype_"></string>
            <none></none>
            <string role="key" value="source"></string>
            <none></none>
            <string role="key" value="uniqueElementName"></string>
            <string value="value"></string>
            <string role="key" value="value"></string>
            <none></none>
            <string role="key" value="valueOf_"></string>
            <string value="universal"></string>
           </dictionary>
          </instance>
         </dictionary>
        </instance>
        <string role="key" value="description"></string>
        <instance class="exe.engine.lom.lomsubs.LanguageStringSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list>
           <instance class="exe.engine.lom.lomsubs.LangStringSub">
            <dictionary>
             <string role="key" value="language"></string>
             <string value="en"></string>
             <string role="key" value="valueOf_"></string>
             <unicode value="Default"></unicode>
            </dictionary>
           </instance>
          </list>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="access"></string>
       </dictionary>
      </instance>
      <string role="key" value="copyrightAndOtherRestrictions"></string>
      <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsSub">
       <dictionary>
        <string role="key" value="extensiontype_"></string>
        <none></none>
        <string role="key" value="source"></string>
        <instance class="exe.engine.lom.lomsubs.sourceValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="string"></string>
          <list></list>
          <string role="key" value="uniqueElementName"></string>
          <string value="source"></string>
          <string role="key" value="valueOf_"></string>
          <string value="LOM-ESv1.0"></string>
         </dictionary>
        </instance>
        <string role="key" value="uniqueElementName"></string>
        <string value="copyrightAndOtherRestrictions"></string>
        <string role="key" value="value"></string>
        <instance class="exe.engine.lom.lomsubs.copyrightAndOtherRestrictionsValueSub">
         <dictionary>
          <string role="key" value="extensiontype_"></string>
          <none></none>
          <string role="key" value="source"></string>
          <none></none>
          <string role="key" value="uniqueElementName"></string>
          <string value="value"></string>
          <string role="key" value="value"></string>
          <none></none>
          <string role="key" value="valueOf_"></string>
          <string value="None"></string>
         </dictionary>
        </instance>
       </dictionary>
      </instance>
      <string role="key" value="cost"></string>
      <none></none>
      <string role="key" value="description"></string>
      <none></none>
      <string role="key" value="uniqueElementName"></string>
      <string value="rights"></string>
     </dictionary>
    </instance>
    <string role="key" value="technical"></string>
    <none></none>
   </dictionary>
  </instance>
  <string role="key" value="mxmlforcemediaonly"></string>
  <bool value="0"></bool>
  <string role="key" value="mxmlheight"></string>
  <string value=""></string>
  <string role="key" value="mxmlprofilelist"></string>
  <string value=""></string>
  <string role="key" value="mxmlwidth"></string>
  <string value=""></string>
  <string role="key" value="release"></string>
  <string value="2.9"></string>
  <string role="key" value="resources"></string>
  <dictionary>
   <string role="key" value="06ec51036307a0c6b513f6b8627e64a0"></string>
   <list>
    <reference key="16"></reference>
   </list>
   <string role="key" value="1112ec6cd50565cee22821e4e587b644"></string>
   <list>
    <reference key="68"></reference>
   </list>
   <string role="key" value="1e6eb86fceff856121bd3a0cb65a8d76"></string>
   <list>
    <reference key="37"></reference>
   </list>
   <string role="key" value="1f8d509306fa209f2c2f3f38c581c1c0"></string>
   <list>
    <reference key="29"></reference>
   </list>
   <string role="key" value="214d499c1c55d2d25a095eff2ed70e30"></string>
   <list>
    <reference key="82"></reference>
   </list>
   <string role="key" value="2230e269e41c7c9a4099f3c77b3d2401"></string>
   <list>
    <reference key="58"></reference>
   </list>
   <string role="key" value="2a174c43b1015c17a01463a01ce2d4a8"></string>
   <list>
    <reference key="64"></reference>
   </list>
   <string role="key" value="3da98790c8299dd3a39edaab9229f9a1"></string>
   <list>
    <reference key="73"></reference>
   </list>
   <string role="key" value="42ab7a6d1fc801bbb62dfd350fcb3b0b"></string>
   <list>
    <reference key="87"></reference>
   </list>
   <string role="key" value="4baeecabeac90d45f90d0105add085cf"></string>
   <list>
    <reference key="21"></reference>
   </list>
   <string role="key" value="4baf95cab366c2bfd55965199075fe55"></string>
   <list>
    <reference key="56"></reference>
   </list>
   <string role="key" value="5358ef71b276e08378cbffb1322b6dda"></string>
   <list>
    <reference key="45"></reference>
   </list>
   <string role="key" value="53e440026e075715d6e37d3e4b9e1e4a"></string>
   <list>
    <reference key="88"></reference>
   </list>
   <string role="key" value="5c46784f5453126618a52f94e1ead9f5"></string>
   <list>
    <reference key="51"></reference>
   </list>
   <string role="key" value="5d4770a2dacddbe09b4369daa7146c81"></string>
   <list>
    <reference key="83"></reference>
   </list>
   <string role="key" value="66226ec92ff28e7fe8ea7866c5c2b015"></string>
   <list>
    <reference key="41"></reference>
   </list>
   <string role="key" value="8e96791daffb2fde15586baeabc58e8e"></string>
   <list>
    <reference key="10"></reference>
   </list>
   <string role="key" value="94405e368980a223a14410c2308288d4"></string>
   <list>
    <reference key="8"></reference>
   </list>
   <string role="key" value="94ebe928bdc6eb8bc1ae46eddffd770b"></string>
   <list>
    <reference key="57"></reference>
   </list>
   <string role="key" value="ad4825a3b0ad1e5342a3abe53059e827"></string>
   <list>
    <reference key="9"></reference>
   </list>
   <string role="key" value="afa2aace01081ab5ba1b5b2182b64732"></string>
   <list>
    <reference key="46"></reference>
   </list>
   <string role="key" value="b2c8112a47f805073ebd414d451ccb7a"></string>
   <list>
    <reference key="77"></reference>
   </list>
   <string role="key" value="b815f5211eced7406eed08fc95d36cc9"></string>
   <list>
    <reference key="63"></reference>
   </list>
   <string role="key" value="bf2488e175bb0704b02d7ae754f3b9d3"></string>
   <list>
    <reference key="50"></reference>
   </list>
   <string role="key" value="c8830fefff9ec1c3b202b551daf13eaa"></string>
   <list>
    <reference key="52"></reference>
   </list>
   <string role="key" value="d0f94fb492fe672cb8bb24a2e880f148"></string>
   <list>
    <reference key="20"></reference>
   </list>
   <string role="key" value="da0bf12bec7289f5442532a1c0d569e5"></string>
   <list>
    <reference key="25"></reference>
   </list>
   <string role="key" value="da1f04d04b3704187a6b38e5391be8a5"></string>
   <list>
    <reference key="30"></reference>
   </list>
   <string role="key" value="e48d9f98b6eefdcf39efc560b227694f"></string>
   <list>
    <reference key="69"></reference>
   </list>
   <string role="key" value="ebc32dfaba6cf74773734d6f98ce1b71"></string>
   <list>
    <reference key="81"></reference>
   </list>
   <string role="key" value="f07445838ec7a9862b523e65adc5302b"></string>
   <list>
    <reference key="15"></reference>
   </list>
   <string role="key" value="f75ffbd09efc4300548fcdb7bc4c6385"></string>
   <list>
    <reference key="14"></reference>
   </list>
   <string role="key" value="fd20cc7ac11e545adf866695a708480f"></string>
   <list>
    <reference key="62"></reference>
   </list>
  </dictionary>
  <string role="key" value="root"></string>
  <reference key="3"></reference>
  <string role="key" value="scolinks"></string>
  <bool value="0"></bool>
  <string role="key" value="scowsinglepage"></string>
  <bool value="0"></bool>
  <string role="key" value="scowwebsite"></string>
  <bool value="0"></bool>
  <string role="key" value="style"></string>
  <unicode value="INTEF"></unicode>
  <string role="key" value="sugaractivityname"></string>
  <string value=""></string>
  <string role="key" value="sugarservicename"></string>
  <string value=""></string>
  <string role="key" value="tempFile"></string>
  <bool value="0"></bool>
 </dictionary>
</instance>