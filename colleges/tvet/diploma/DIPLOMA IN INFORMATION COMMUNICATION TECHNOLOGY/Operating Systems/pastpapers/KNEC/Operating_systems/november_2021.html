<!doctype html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>November 2021 </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.9 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body class="exe-web-site" id="exe-node-2"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Skip navigation</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Home</a></li>
   <li><a href="july_2023.html" class="no-ch">July 2023</a></li>
   <li id="active"><a href="november_2021.html" class="active no-ch">November 2021</a></li>
   <li><a href="july_2021.html" class="no-ch">July 2021</a></li>
   <li><a href="july_2019.html" class="no-ch">July 2019</a></li>
   <li><a href="november_2018.html" class="no-ch">November 2018</a></li>
   <li><a href="november_2017.html" class="no-ch">November 2017</a></li>
   <li><a href="july_2017.html" class="no-ch">July 2017</a></li>
   <li><a href="november_2016.html" class="no-ch">November 2016</a></li>
   <li><a href="july_2016.html" class="no-ch">July 2016</a></li>
   <li><a href="november_2015.html" class="no-ch">November 2015</a></li>
   <li><a href="july_2015.html" class="no-ch">July 2015</a></li>
   <li><a href="novemeber_2014.html" class="no-ch">Novemeber 2014</a></li>
   <li><a href="july_2014.html" class="no-ch">July 2014</a></li>
   <li><a href="november_2013.html" class="no-ch">November 2013</a></li>
   <li><a href="july_2013.html" class="no-ch">July 2013</a></li>
   <li><a href="november_2012.html" class="no-ch">November 2012</a></li>
   <li><a href="july_2012.html" class="no-ch">July 2012</a></li>
   <li><a href="july_2011.html" class="no-ch">July 2011</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="july_2023.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2021.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">November 2021</h1></header>
<article class="iDevice_wrapper textIdevice" id="id2">
<div class="iDevice emphasis0" >
<div id="ta2_129_2" class="block iDevice_content">
<div class="exe-text"><p></p>
<style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base Styles */
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2d3748;
            background-color: #f7fafc;
            margin: 0;
            padding: 0;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #1a365d 0%, #2c5282 100%);
            color: white;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .exam-details {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            display: inline-block;
            margin-top: 1rem;
        }

        .exam-details p {
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        /* Main Content */
        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Passage Styles */
        .passage {
            background: #edf2f7;
            border-radius: 12px;
            margin-bottom: 2rem;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .passage h2 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            border-bottom: 2px solid #cbd5e0;
            padding-bottom: 0.5rem;
        }

        .passage-content {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.8;
        }

        .passage-content p {
            margin-bottom: 1rem;
        }

        /* Question Styles */
        .question {
            background: white;
            border-radius: 12px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .question h3 {
            background: #4a5568;
            color: white;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            margin: 0;
            border-bottom: 3px solid #2d3748;
        }

        .question-content {
            padding: 1.5rem;
            background: #fff;
            border-bottom: 2px solid #edf2f7;
        }

        .question-content p {
            font-size: 1.1rem;
            color: #2d3748;
        }

        /* Answer Styles */
        .answer-section {
            background: #f8fafc;
            border-top: 2px solid #e2e8f0;
        }

        .answer-section h4 {
            padding: 1rem 1.5rem;
            color: #2d3748;
            font-size: 1.2rem;
            background: #edf2f7;
            margin: 0;
        }

        .answer-content {
            padding: 1.5rem;
            color: #4a5568;
        }

        .answer-content p {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* Numbered Lists in Answers */
        .answer-content p[data-number]:before {
            content: attr(data-number) ".";
            font-weight: 600;
            margin-right: 0.5rem;
            color: #4a5568;
        }

        /* Footer Styles */
        footer {
            background: #2d3748;
            color: white;
            text-align: center;
            padding: 1.5rem;
            margin-top: 3rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            main {
                padding: 0 1rem;
            }

            .passage h2 {
                font-size: 1.3rem;
            }

            .passage-content p {
                font-size: 1rem;
            }

            .question {
                margin-bottom: 1.5rem;
            }

            .question h3 {
                font-size: 1.1rem;
            }

            .question-content p,
            .answer-content p {
                font-size: 1rem;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            .passage,
            .question {
                break-inside: avoid;
                box-shadow: none;
                border: 1px solid #edf2f7;
            }

            header {
                background: white;
                color: black;
                padding: 1rem;
            }

            .exam-details {
                border: 1px solid #edf2f7;
            }
        }
    </style>
<header>
<h1>OPERATING SYSTEMS</h1>
<div class="exam-details">
<p>Exam Code: 2920/105</p>
<p>Duration: 3 hours</p>
<p>Period: November 2021</p>
</div>
</header>
<p></p>
<p></p>
<p><main>
<section class="question">
<h3>1 (a) (i) (1) (2 marks)</h3>
<div class="question-content">
<p>Explain the role played by operating systems in the following services: program development;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Operating systems provide essential tools and environments that facilitate program development. These include compilers, debuggers, text editors, and integrated development environments (IDEs). They also offer libraries and APIs that programmers can use to build applications, managing system resources and providing a consistent interface to hardware.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (a) (i) (II) (2 marks)</h3>
<div class="question-content">
<p>system access.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Operating systems manage and control system access, ensuring secure and efficient resource utilization. They handle user authentication and authorization, control access to files and directories through permissions, and manage network connections. By mediating access to hardware and software resources, OSs maintain system integrity and prevent unauthorized operations.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>Outline two typical characteristics of microkernel architecture operating systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Minimal Kernel Size: Microkernels have a very small kernel that only includes essential functionalities like inter-process communication (IPC), basic scheduling, and memory management. Most other OS services are implemented as user-level processes.</p>
<p data-number="2">Service Modularity: Services in a microkernel architecture, such as file systems, device drivers, and networking stacks, are designed as independent modules running in user space. This modularity enhances system flexibility and makes it easier to modify or extend services without affecting the kernel.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (b) (8 marks)</h3>
<div class="question-content">
<p>The operating system controls the execution of processes depending on various existing conditions in the system. Explain four reasons that could necessitate termination of a running process.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Normal Completion: A process terminates normally when it has completed its intended task and reaches its natural endpoint. The process exits gracefully, releasing all resources it held.</p>
<p data-number="2">Time Limit Exceeded: If a process runs longer than a predefined time limit set by the system or user, the OS may terminate it to prevent resource monopolization. This is common in time-sharing systems to ensure fair CPU allocation.</p>
<p data-number="3">Resource Unavailability: A process may be terminated if it requests resources that the system cannot provide, such as memory, files, or I/O devices. This can occur due to system overload or hardware limitations.</p>
<p data-number="4">Fatal Error: Processes can be terminated due to fatal errors such as division by zero, illegal memory access, or invalid instructions. These errors indicate that the process cannot continue execution safely or correctly and must be terminated to prevent system instability.</p>
</div>
</div>
</section>
<section class="question">
<h3>1 (c) (6 marks)</h3>
<div class="question-content">
<p>Figure 1 shows cross-sectional organization of a disk system. Use it to answer the question that follows.</p>
<p><img src="Screenshot_2025-03-11_at_14-13-32_2021n.pdf.png" alt="" width="507" height="415" /></p>
<p>Explain the function of the parts labeled (i), (ii) and (iii).</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Part (i) - Track:</p>
<p>A track is a concentric circular path on the surface of a disk platter where data is recorded. Disks are formatted into tracks, and data is stored sequentially along these tracks. Each track is further divided into sectors.</p>
<p>Part (ii) - Sector:</p>
<p>A sector is the smallest unit of data storage on a disk drive, representing a segment of a track. Sectors are typically of a fixed size (e.g., 512 bytes or 4KB) and are used to read and write data. The OS addresses and manages data in units of sectors.</p>
<p>Part (iii) - Platter:</p>
<p>A platter is a circular magnetic disk on which data is stored. Hard disk drives usually consist of multiple platters stacked on a spindle. Each platter surface is coated with a magnetic material that can store data. Read/write heads access data on both surfaces of each platter.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (a) (2 marks)</h3>
<div class="question-content">
<p>Outline two typical attributes associated with computer files.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Name: A file has a name that uniquely identifies it within a directory. The name is used by users and the operating system to access and manage the file.</p>
<p data-number="2">Type: A file has a type that indicates the kind of data it contains (e.g., text, image, executable). The file type is often indicated by a file extension and helps the OS and applications determine how to handle the file.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (b) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between memory paging and memory segmentation.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Memory Paging:</p>
<p>Memory paging is a memory management technique that divides the computer's memory into fixed-size blocks called pages. Both virtual and physical memory are divided into pages of the same size. Paging provides a way to implement virtual memory, allowing non-contiguous allocation and efficient memory utilization.</p>
<p>Memory Segmentation:</p>
<p>Memory segmentation divides memory into logical units called segments, which are of variable size and correspond to logical parts of a program (e.g., code, data, stack). Segmentation supports a user-centric view of memory organization, allowing logical structuring of programs and data, but can lead to external fragmentation.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (c) (i) (2 marks)</h3>
<div class="question-content">
<p>Gijo Consultants have advised Youl Technical Institute to consider installing a multiprocessor system for its server room. Describe the system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A multiprocessor system is a computer system with two or more central processing units (CPUs) within a single computer. These CPUs share system resources such as memory, I/O devices, and the system bus. Multiprocessor systems are designed to improve processing speed and system throughput by enabling parallel processing.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (c) (ii) (4 marks)</h3>
<div class="question-content">
<p>Explain two advantages of the system that could have influenced the advice.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Increased Throughput: Multiprocessor systems can execute multiple processes or threads concurrently, significantly increasing the overall throughput and processing speed of the system. This is particularly beneficial for server environments that handle numerous requests simultaneously.</p>
<p data-number="2">Enhanced Reliability and Fault Tolerance: In a multiprocessor system, if one processor fails, the system can continue to operate, albeit at a reduced performance level. This redundancy enhances system reliability and fault tolerance, making it more robust for critical server applications.</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (d) Evaluate: (3 marks)</h3>
<div class="question-content">
<p>Table 1 shows execution information of four processes in a system using SRTN scheduling algorithm.</p>
<p><img src="Screenshot_2025-03-11_at_14-14-37_2021n.pdf.png" alt="" width="749" height="337" /></p>
<p>Use it to answer the questions that follow. (i) the average waiting time for the processes;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>To evaluate the average waiting time using SRTN, we need to trace the execution:</p>
<p>At time 0, Process W arrives (Service time 1). W starts.</p>
<p>At time 1, Process X arrives (Service time 10). Remaining time for W is 0. W finishes. X starts (SRTN).</p>
<p>At time 2, Process Y arrives (Service time 3). Remaining time for X is 9. Y preempts X (SRTN).</p>
<p>At time 3, Process Z arrives (Service time 7). Remaining time for Y is 2. Y continues.</p>
<p>At time 5, Y finishes. Remaining time for X is 9, Remaining time for Z is 7. Z starts (SRTN).</p>
<p>At time 12, Z finishes. Remaining time for X is 9. X starts.</p>
<p>At time 21, X finishes.</p>
<p>Completion Times: W: 1, Y: 5, Z: 12, X: 21</p>
<p>Turnaround Times: W: 1-0=1, Y: 5-2=3, Z: 12-3=9, X: 21-1=20</p>
<p>Waiting Times: W: 1-1=0, Y: 3-3=0, Z: 9-7=2, X: 20-10=10</p>
<p>Average Waiting Time = (0 + 0 + 2 + 10) / 4 = 12 / 4 = 3</p>
<p>Average Waiting Time: 3</p>
</div>
</div>
</section>
<section class="question">
<h3>2 (d) Evaluate: (5 marks)</h3>
<div class="question-content">
<p>(ii) the average turn-around time for the system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Turnaround Times (calculated above): W: 1, Y: 3, Z: 9, X: 20</p>
<p>Average Turnaround Time = (1 + 3 + 9 + 20) / 4 = 33 / 4 = 8.25</p>
<p>Average Turnaround Time: 8.25</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the following terms as used in operating systems: multithreading:</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Multithreading is a programming and execution technique that allows a single process to have multiple threads of control within the same address space. These threads run concurrently, sharing the process's resources like memory and files, but operate independently in terms of execution flow.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>process.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>A process is an instance of a computer program that is being executed. It is an independent unit of execution and resource allocation managed by the operating system. A process has its own address space, program code, data, and system resources such as file handles and network connections.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (b) (4 marks)</h3>
<div class="question-content">
<p>Outline four typical functions of the operating system kernel during process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Process Creation and Termination: The kernel is responsible for creating new processes, allocating necessary resources, and terminating processes when they complete execution or encounter errors. This includes managing process IDs and process control blocks (PCBs).</p>
<p data-number="2">Process Scheduling: The kernel implements scheduling algorithms to decide which process should be executed by the CPU at any given time. It manages process states (ready, running, waiting) and performs context switching to allocate CPU time among processes efficiently.</p>
<p data-number="3">Inter-Process Communication (IPC): The kernel provides mechanisms for processes to communicate and synchronize with each other. These mechanisms include pipes, message queues, shared memory, and semaphores, enabling cooperation and data exchange between processes.</p>
<p data-number="4">Resource Allocation and Management: The kernel manages system resources such as memory, CPU time, and I/O devices. It allocates resources to processes upon creation and reclaims them upon termination, ensuring fair and efficient resource utilization and preventing resource conflicts.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (c) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between block-oriented and stream-oriented I/O devices.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Block-Oriented I/O Devices:</p>
<p>Block-oriented I/O devices transfer data in fixed-size blocks. Data is accessed in discrete blocks, each with its own address. Examples include hard disks, SSDs, and tapes. Operations on block devices typically involve reading or writing entire blocks of data. They support random access to data blocks.</p>
<p>Stream-Oriented I/O Devices:</p>
<p>Stream-oriented I/O devices transfer data as a continuous stream of bytes or characters, without a block structure. Data is accessed sequentially. Examples include keyboards, mice, serial ports, and network interfaces. Operations involve reading or writing a stream of bytes. They are typically used for communication or sequential data flow.</p>
</div>
</div>
</section>
<section class="question">
<h3>3 (d) (8 marks)</h3>
<div class="question-content">
<p>Memory management is a key function that should be carefully addressed when designing an operating system. Explain four requirements that the memory management design of an operating system should endeavor to satisfy.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Efficiency and Performance: Memory management should aim for efficient utilization of memory resources to maximize system performance. It should minimize overhead associated with memory allocation, deallocation, and address translation, ensuring fast access to memory and reducing latency.</p>
<p data-number="2">Protection and Security: Memory management must provide memory protection to prevent processes from accessing memory regions that do not belong to them. This is crucial for system stability and security, preventing unauthorized data access and interference between processes. Mechanisms like address space isolation and access control are essential.</p>
<p data-number="3">Virtual Memory Support: Modern operating systems require virtual memory capabilities to allow processes to access more memory than physically available. Memory management should implement virtual memory techniques like paging or segmentation, enabling efficient use of physical RAM and disk space for memory extension. This includes demand paging and page replacement algorithms.</p>
<p data-number="4">Fair Allocation and Resource Management: Memory management should ensure fair allocation of memory resources among competing processes, preventing starvation and ensuring that all processes get a reasonable share of memory. It needs to manage memory allocation and deallocation dynamically, adapting to changing process needs and system load. Mechanisms for managing memory fragmentation and compaction may be necessary.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (a) (i) (4 marks)</h3>
<div class="question-content">
<p>Outline four criteria that should be considered when selecting a file organization method.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Access Pattern: The typical way files will be accessed (sequential, random, indexed). If files are mostly accessed sequentially, sequential organization might be efficient. For random access, indexed or direct file organization is better.</p>
<p data-number="2">Data Volume and File Size: The size and number of files to be stored. For large volumes of data, methods that efficiently manage space and access large files are needed. For many small files, directory structure and overhead become important.</p>
<p data-number="3">Performance Requirements: The required speed for file operations (read, write, search, update). Performance considerations will dictate whether simpler, faster methods or more complex, feature-rich methods are needed.</p>
<p data-number="4">Application Needs: The specific requirements of the applications that will use the files. Different applications may have different needs in terms of data structure, access methods, and file operations. For example, database systems have different needs than text editors or multimedia applications.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (a) (ii) (6 marks)</h3>
<div class="question-content">
<p>Describe three types of operations commonly performed on file directories.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Search: Searching a directory involves locating a specific file or subdirectory within the directory structure. This operation is crucial for users and applications to find files by name. Efficient search operations are essential for quick file retrieval, and directory structures are often optimized for fast searching, such as using hash tables or tree-based indices.</p>
<p data-number="2">Create/Delete: Operations to create new directories or files within a directory and to delete existing directories or files. Creating a directory involves allocating space and updating directory metadata to include the new entry. Deleting a directory involves removing its entry from the parent directory and deallocating space. These operations are fundamental for managing the file system hierarchy.</p>
<p data-number="3">List/Enumerate: Listing or enumerating directory contents involves retrieving a list of all files and subdirectories contained within a directory. This operation allows users and applications to view the contents of a directory, often used in file browsers or command-line interfaces. The operation needs to efficiently access and present directory entries in a readable format.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (b) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between demand cleaning and precleaning as used in virtual memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Demand Cleaning:</p>
<p>Demand cleaning is a page cleaning policy in virtual memory management where dirty pages (pages that have been modified and differ from their disk copy) are written back to disk only when a page frame is needed for allocation to a new page. Cleaning is triggered by page faults and memory pressure. It aims to minimize disk I/O by writing pages back only when necessary.</p>
<p>Precleaning:</p>
<p>Precleaning, also known as anticipatory cleaning, is a page cleaning policy where dirty pages are written back to disk proactively, before they are needed to be replaced or when system load is low. This policy anticipates future page faults and attempts to reduce page fault service time by having clean pages readily available in memory. It can improve responsiveness but may increase disk I/O if precleaning is too aggressive.</p>
</div>
</div>
</section>
<section class="question">
<h3>4 (c) (6 marks)</h3>
<div class="question-content">
<p>Fred is designing an input device for his mini laptop that would use the DMA I/O technique. Describe the process of reading a block of data from the device.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Process of Reading Data using DMA:</p>
<p data-number="1">CPU Initialization: The CPU initiates the DMA transfer by programming the DMA controller. It provides the DMA controller with details such as the source device address, the destination memory address, the amount of data to be transferred (block size), and the direction of transfer (read from device to memory).</p>
<p data-number="2">DMA Request and Grant: The DMA controller requests control of the system bus from the CPU. The CPU grants the bus to the DMA controller, typically after the current bus cycle is complete. This process is known as bus arbitration.</p>
<p data-number="3">Data Transfer by DMA Controller: Once the DMA controller has bus control, it directly transfers data from the input device to main memory without CPU intervention. For each word or block of data, the DMA controller:</p>
<p>a. Sends a read request to the input device.</p>
<p>b. Receives the data from the device.</p>
<p>c. Writes the data to the specified memory address.</p>
<p>d. Increments the memory address and decrements the byte count.</p>
<p data-number="4">Transfer Completion and Notification: After transferring the entire block of data, the DMA controller relinquishes control of the system bus and notifies the CPU that the transfer is complete. Notification can be through an interrupt.</p>
<p data-number="5">CPU Resumes Processing: The CPU, upon receiving the DMA completion notification, can now access the data in main memory. The CPU is free to perform other tasks during the DMA transfer, enhancing system concurrency.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two RAID configurations.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">RAID 0 (Striping): Data is striped across multiple disks to increase performance. It provides no redundancy, so failure of one disk results in data loss.</p>
<p data-number="2">RAID 1 (Mirroring): Data is mirrored across two disks, providing redundancy. If one disk fails, data is still available from the mirror disk. It improves read performance but write performance is not significantly improved.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (a) (ii) (1) (2 marks)</h3>
<div class="question-content">
<p>Explain the following terms as used in disk systems: head;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Head: In disk systems, a head is a component of the disk drive that reads and writes data to and from the disk platter. Each platter typically has two heads, one for each surface. The head contains read/write elements that detect and modify the magnetic orientation on the disk surface to store and retrieve data.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (a) (ii) (II) (2 marks)</h3>
<div class="question-content">
<p>density.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Density: In disk systems, density refers to the amount of data that can be stored per unit area on the disk platter. It's typically measured in bits per inch (BPI) along a track (linear density) and tracks per inch (TPI) across the radius of the disk (areal density). Higher density allows for greater storage capacity in the same physical space.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (b) (i) (4 marks)</h3>
<div class="question-content">
<p>Deric would like to implement an index-sequential file organization system is an operating system he is designing. Explain two types of indexes he could apply in the system.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Primary Index: A primary index is based on the primary key of the file, which uniquely identifies each record. In an index-sequential file system, the primary index typically points to the physical location of records sorted by the primary key. This index facilitates fast access to records based on their primary key value and maintains the sequential order of records.</p>
<p data-number="2">Secondary Index: A secondary index is created on non-key attributes of the file, allowing for efficient searching and access based on these attributes. Secondary indexes provide an alternative access path to the data, without requiring sorting of the main data file on the secondary key. They are used to improve query performance for searches based on attributes other than the primary key.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (b) (ii) (2 marks)</h3>
<div class="question-content">
<p>Outline two application areas where the file system in most appropriate.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Library Catalog Systems: In systems like library catalogs, where books are accessed by ISBN (primary key) and also frequently searched by title or author (secondary keys), index-sequential file organization is effective. It allows for sequential processing for catalog updates and indexed access for search queries.</p>
<p data-number="2">Inventory Management Systems: For inventory systems, where items are primarily identified by a product ID (primary key) and need to be searched by name or category (secondary keys), index-sequential file organization is suitable. It supports efficient retrieval based on product IDs and allows for flexible querying using secondary indexes for stock checks and reports.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (c) Identify the condition depicted in the figure justifying your answer. (2 marks)</h3>
<div class="question-content">
<p>Figure 2 shows allocation of resources to two processes. Use it to answer the questions that follow.</p>
<p><img src="Screenshot_2025-03-11_at_14-15-19_2021n.pdf.png" alt="" width="968" height="339" /></p>
<p>(i) Identify the condition depicted in the figure justifying your answer.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Deadlock. The figure shows Process X holding Resource A and requesting Resource B, while Process Y is holding Resource B and requesting Resource A. This circular wait condition, where each process is waiting for a resource held by the other, is the defining characteristic of a deadlock.</p>
</div>
</div>
</section>
<section class="question">
<h3>5 (c) Explain three measures that could have prevented the condition. (6 marks)</h3>
<div class="question-content">
<p>(ii) Explain three measures that could have prevented the condition.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Resource Ordering (Prevent Circular Wait): Impose a total ordering on all resource types and require each process to request resources in an increasing order of enumeration. For example, if resources A and B are ordered such that A &lt; B, a process requesting both must request A before B. This prevents the circular wait condition necessary for deadlock.</p>
<p data-number="2">Resource Preemption (Allow Preemption): Allow the operating system to preempt resources from a process. If a process is holding some resources and requests another resource that cannot be immediately allocated, the OS can preempt some of the resources already held by the process, release them, and allocate them to other processes, breaking the hold-and-wait condition. Preemption is feasible for resources whose state can be easily saved and restored, like memory and CPU registers.</p>
<p data-number="3">Hold-and-Wait Prevention (Prevent Hold and Wait): Ensure that whenever a process requests a resource, it does not hold any other resources. One way to implement this is to require processes to request all the resources they need before starting execution. Alternatively, if a process needs a new resource, it must release all resources it currently holds. These strategies prevent processes from holding a resource while waiting to acquire another, thereby preventing the hold-and-wait condition necessary for deadlock.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (a) (4 marks)</h3>
<div class="question-content">
<p>Distinguish between a clock interrupt and an I/O interrupt as used in process management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Clock Interrupt:</p>
<p>A clock interrupt is a periodic interrupt generated by a hardware timer at regular intervals. It is used by the operating system for timekeeping, scheduling processes, and enforcing time limits. Clock interrupts drive time-sharing and preemptive multitasking, allowing the OS to regain control periodically and manage process execution.</p>
<p>I/O Interrupt:</p>
<p>An I/O interrupt is generated by an I/O device to signal the completion of an I/O operation or to indicate an event requiring attention. I/O interrupts allow the OS to handle I/O events asynchronously and efficiently. When an I/O operation completes (e.g., data arrival, device ready), the device sends an interrupt to the CPU, prompting the OS to handle the event, such as transferring data or resuming a waiting process.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the principle of locality as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>The principle of locality, also known as the locality of reference, is the tendency of a processor to access the same set of memory locations repeatedly over a short period of time (temporal locality) and to access memory locations that are physically close to each other (spatial locality). This principle is fundamental to the effectiveness of caching and virtual memory systems, as it allows for predicting future memory accesses based on past access patterns.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>Outline four typical contents of page frame data table as applied in memory management systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Page State: Indicates the current status of the page frame, such as whether it is free, allocated to a process, or part of the operating system. The state may also indicate if the page is valid (present in physical memory) or invalid (not in physical memory).</p>
<p data-number="2">Virtual Page Number: Stores the virtual page number that is currently mapped to this physical page frame. This mapping is essential for translating virtual addresses to physical addresses during memory access.</p>
<p data-number="3">Reference Count: Tracks the number of virtual pages or processes that are currently sharing this page frame. This is important for shared pages and copy-on-write mechanisms in virtual memory.</p>
<p data-number="4">Dirty Bit: A flag that indicates whether the page frame has been modified since it was loaded into memory. The dirty bit is used by page replacement algorithms to determine if a page needs to be written back to disk before being replaced. If the dirty bit is set, the page must be written to disk; otherwise, it can be discarded if needed.</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (c) Evaluate: (3 marks)</h3>
<div class="question-content">
<p>A particular hard disk has a total of 200 tracks. Six processes make requests for data from the following tracks respectively: 60 70 50 30 98 130 For each of the following disk scheduling algorithms, determine the average seek length assuming that the starting track is 100. (i) FIFO;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>FIFO (First-Come, First-Served):</p>
<p>Request sequence: 60, 70, 50, 30, 98, 130. Starting position: 100.</p>
<p>Seek lengths: |100-60| + |60-70| + |70-50| + |50-30| + |30-98| + |98-130|</p>
<p>= 40 + 10 + 20 + 20 + 68 + 32 = 190</p>
<p>Average seek length = 190 / 6 = 31.67 tracks</p>
<p>Average Seek Length (FIFO): 31.67 tracks</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (c) Evaluate: (3 marks)</h3>
<div class="question-content">
<p>(ii) SSTF.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>SSTF (Shortest Seek Time First):</p>
<p>Requests: 60, 70, 50, 30, 98, 130. Starting position: 100.</p>
<p>1. From 100, closest is 98. Seek to 98 (length 2). Requests left: 60, 70, 50, 30, 130.</p>
<p>2. From 98, closest is 70. Seek to 70 (length 28). Requests left: 60, 50, 30, 130.</p>
<p>3. From 70, closest is 60. Seek to 60 (length 10). Requests left: 50, 30, 130.</p>
<p>4. From 60, closest is 50. Seek to 50 (length 10). Requests left: 30, 130.</p>
<p>5. From 50, closest is 30. Seek to 30 (length 20). Requests left: 130.</p>
<p>6. From 30, only request is 130. Seek to 130 (length 100).</p>
<p>Total seek length = 2 + 28 + 10 + 10 + 20 + 100 = 170</p>
<p>Average seek length = 170 / 6 = 28.33 tracks</p>
<p>Average Seek Length (SSTF): 28.33 tracks</p>
</div>
</div>
</section>
<section class="question">
<h3>6 (d) (4 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe the contiguous file allocation method.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Contiguous File Allocation:</p>
<p>In contiguous file allocation, each file occupies a set of contiguous blocks on the disk. The disk space is allocated in a single continuous section of blocks. The file system only needs to store the starting block address and the length (number of blocks) of the file to locate all its blocks. This method simplifies file access and management.</p>
<p><img src="diagram_contiguous_allocation.png" alt="Diagram of Contiguous File Allocation" /></p>
<p>Diagram Description:</p>
<p>The diagram would visually represent a disk divided into blocks. A file, say "File A", is shown occupying a contiguous set of blocks (e.g., blocks 10-15). The File Directory entry for "File A" would store the starting block number (10) and the length (6 blocks). Other files would similarly be allocated contiguous blocks of disk space. Free space would be represented as unallocated blocks. This illustrates how contiguous allocation stores files in adjacent disk blocks.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (a) (i) (2 marks)</h3>
<div class="question-content">
<p>Explain the following terms as used in memory management: virtual address;</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Virtual Address: A virtual address is a logical address used by a process in a virtual memory system. It is an address within the process's virtual address space. Virtual addresses are translated by the memory management unit (MMU) into physical addresses to access actual physical memory. This abstraction allows processes to have their own private address spaces and use more memory than physically available.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (a) (ii) (2 marks)</h3>
<div class="question-content">
<p>thrashing.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Thrashing: Thrashing is a condition in virtual memory systems where the system spends more time swapping pages between memory and disk than executing processes. This occurs when the system is overloaded, and the working set size of active processes exceeds the available physical memory. Frequent page faults and disk I/O operations lead to a significant decrease in system performance.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (b) (i) (3 marks)</h3>
<div class="question-content">
<p>Outline three lists that are maintained to manage the buffer cache in UNIX systems.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Free List: A list of buffer blocks in the cache that are currently not in use and are available for allocation. When the system needs a new buffer block, it is taken from the free list. When a buffer block is no longer needed, it is returned to the free list.</p>
<p data-number="2">Hash Queue: A set of hash queues that are used to quickly locate buffer blocks based on the device number and block number. When the system needs to access a specific disk block, it calculates a hash value based on the device and block number and searches the corresponding hash queue for the buffer block. This speeds up buffer lookup.</p>
<p data-number="3">LRU (Least Recently Used) List: A list of buffer blocks in the cache, ordered by their last time of use, with the least recently used block at the head of the list and the most recently used block at the tail. When the cache is full and a new buffer block needs to be allocated, the block at the head of the LRU list (least recently used) is typically chosen for replacement.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (b) (ii) (7 marks)</h3>
<div class="question-content">
<p>With the aid of a diagram, describe a typical organization of I/O subsystem.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>Typical Organization of I/O Subsystem:</p>
<p>The I/O subsystem in an operating system typically involves several layers and components that work together to manage data transfer between the system and external devices. It is designed to handle a variety of devices with different characteristics efficiently and abstract device-specific details from the rest of the OS.</p>
<p><img src="diagram_io_subsystem.png" alt="Diagram of I/O Subsystem Organization" /></p>
<p>Diagram Description:</p>
<p>The diagram would depict a layered structure:</p>
<p>User Processes at the top, making I/O requests through System Calls.</p>
<p>System Call Interface: Handles system call requests and routes them to appropriate I/O modules.</p>
<p>Device-Independent I/O Layer: Provides a uniform interface for I/O operations, independent of device types. Includes functions for buffering, caching, and error handling.</p>
<p>Device Drivers: Device-specific modules that communicate directly with hardware devices. Each driver manages a specific type of device (e.g., disk driver, network driver, keyboard driver), translating general I/O requests into device-specific commands and handling device interrupts.</p>
<p>Interrupt Handlers: Routines that respond to hardware interrupts from I/O devices, signaling completion of operations or device events.</p>
<p>Hardware Controllers and Devices: Physical I/O devices and their controllers, responsible for the actual data transfer and device operations.</p>
<p>Data flow is shown from User Processes down through the layers to Hardware and back up, illustrating the path of an I/O request and response. This layered approach provides modularity, device independence, and efficient I/O management.</p>
</div>
</div>
</section>
<section class="question">
<h3>7 (c) (6 marks)</h3>
<div class="question-content">
<p>Free space management is important for efficient file management. Explain three techniques applied by operating systems to manage space on disks.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Bitmaps: A bitmap or bit vector is used to track the allocation status of disk blocks. Each bit in the bitmap corresponds to a disk block. If a bit is 0, the block is free; if it's 1, the block is allocated. Bitmaps are efficient for finding contiguous free blocks and are relatively simple to implement. They require space proportional to the disk size, but this overhead is usually acceptable for modern disks.</p>
<p data-number="2">Linked Lists: Free disk blocks are linked together in a linked list. Each free block contains a pointer to the next free block. To allocate space, the OS traverses the list to find enough contiguous blocks. To free space, blocks are added back to the list. Linked lists can suffer from fragmentation and can be less efficient for finding contiguous blocks compared to bitmaps.</p>
<p data-number="3">Grouping: This technique improves linked list approach by storing the addresses of multiple free blocks in one free block, effectively creating groups of free blocks. This reduces the number of disk accesses needed to find free space. A free block now contains pointers to a group of subsequent free blocks, and the last pointer in the group points to another block containing pointers to more free blocks, and so on. This hierarchical grouping helps in managing larger chunks of free space more efficiently.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (a) (4 marks)</h3>
<div class="question-content">
<p>Differentiate between best-fit and first-fit policies as used in memory management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p>First-Fit:</p>
<p>First-fit is a dynamic memory allocation algorithm that allocates the first available memory partition (hole) that is large enough to satisfy the request. The algorithm searches the list of free partitions from the beginning and stops as soon as it finds a suitable partition. It is simple and fast but can lead to external fragmentation over time, as larger free partitions might be broken into smaller ones and scattered across memory.</p>
<p>Best-Fit:</p>
<p>Best-fit is a dynamic memory allocation algorithm that allocates the smallest available memory partition (hole) that is just large enough to satisfy the request. The algorithm searches the entire list of free partitions to find the smallest suitable one. Best-fit aims to minimize memory wastage and reduce external fragmentation by leaving the largest possible remaining free partition after allocation. However, it is slower than first-fit because it requires searching the entire list.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (b) (i) (2 marks)</h3>
<div class="question-content">
<p>Outline two categories of user access rights used in file management.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Read Access: Read access right allows a user to view or copy the contents of a file. Users with read access can open and read the file data but cannot modify or delete it.</p>
<p data-number="2">Write Access: Write access right allows a user to modify or delete a file. Users with write access can change the file content, rename the file, or delete it entirely. Write access typically implies read access as well.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (b) (ii) (4 marks)</h3>
<div class="question-content">
<p>The extent to which user requirements are met by a file management system depends on the application and environment. Outline four such requirements for an interactive and networked environment.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Fast Access and Response Time: In interactive environments, users expect quick response times when accessing or manipulating files. The file management system should provide fast file access, directory navigation, and file operations to ensure a smooth and efficient user experience. Low latency for file operations is crucial for interactive applications.</p>
<p data-number="2">Concurrent Access and Sharing: In networked environments, multiple users often need to access and share files concurrently. The file management system must support concurrent access, allowing multiple users to read and write files simultaneously without data corruption or conflicts. Mechanisms for file locking and concurrency control are necessary.</p>
<p data-number="3">Security and Access Control: Security is paramount in networked environments. The file management system must provide robust security features, including user authentication, access control lists (ACLs), and encryption, to protect files from unauthorized access, modification, or deletion. Fine-grained permissions and secure file sharing are essential.</p>
<p data-number="4">Reliability and Data Integrity: Reliability and data integrity are critical in both interactive and networked environments. The file management system should ensure data durability, protecting against data loss due to system failures, hardware errors, or power outages. Features like journaling, redundancy, and backup/restore mechanisms are important to maintain data integrity and system robustness.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (c) (i) (4 marks)</h3>
<div class="question-content">
<p>Prince intends to use semaphores for process control in the operating system that he is developing. Outline four typical elements that should constitute the semaphore module.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Semaphore Data Structure: A data structure to represent the semaphore itself. This typically includes an integer value (the semaphore count) and a waiting queue (or list) to hold processes that are blocked on the semaphore.</p>
<p data-number="2">P (Wait or Acquire) Operation: A function or system call that decrements the semaphore value. If the value becomes negative, the process is blocked and added to the semaphore's waiting queue. The P operation attempts to acquire or wait for a resource.</p>
<p data-number="3">V (Signal or Release) Operation: A function or system call that increments the semaphore value. If there are processes waiting in the queue, one process is unblocked and allowed to proceed. The V operation signals or releases a resource, potentially waking up a waiting process.</p>
<p data-number="4">Initialization Function: A function to initialize the semaphore data structure, setting the initial semaphore value (usually non-negative) and initializing the waiting queue to be empty. Initialization is necessary before a semaphore can be used for process synchronization and mutual exclusion.</p>
</div>
</div>
</section>
<section class="question">
<h3>8 (c) (ii) (6 marks)</h3>
<div class="question-content">
<p>A computer laboratory technician has been instructed to install a new hard disk with three logical partitions in the HOD's computer. Describe three activities that he/she would carry out before installing the operating system and other applications into the hard disk.</p>
</div>
<div class="answer-section">
<h4>Answer</h4>
<div class="answer-content">
<p data-number="1">Physical Installation: Install the new hard disk into the computer. This involves opening the computer case, locating an available drive bay, physically mounting the hard disk securely, and connecting the necessary data and power cables (SATA or IDE). Ensure proper grounding and handling to avoid electrostatic discharge damage.</p>
<p data-number="2">BIOS/UEFI Configuration: Access the computer's BIOS or UEFI settings upon startup. Verify that the new hard disk is recognized by the system BIOS/UEFI. If necessary, adjust the boot order settings to ensure the system can boot from installation media (like USB or DVD) if needed for OS installation. Check for any disk-related settings and confirm correct detection.</p>
<p data-number="3">Partitioning and Formatting: Boot from a live OS environment or installation media. Use disk partitioning tools (like fdisk, gparted, or disk management utilities in Windows PE) to partition the new hard disk into three logical partitions as required. For each partition, choose a file system (like NTFS, FAT32, ext4) and format the partitions. Formatting prepares the partitions for file storage by creating the file system structure on each partition. Label partitions for easy identification (e.g., OS, Data, Backup).</p>
</div>
</div>
</section>
</main></p>
<p></p>
<p></p>
<footer> 2021 The Kenya National Examinations Council.</footer></div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="july_2023.html" class="prev"><span><span>&laquo; </span>Previous</span></a> <span class="sep">| </span><a href="july_2021.html" class="next"><span>Next<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="_intef_js.js"></script></body></html>