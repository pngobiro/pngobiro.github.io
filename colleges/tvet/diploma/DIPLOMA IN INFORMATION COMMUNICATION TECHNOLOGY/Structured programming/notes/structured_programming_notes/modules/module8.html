<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 8: Advanced Data Structures and File Handling - Structured Programming Notes</title>
    <meta name="description" content="Advanced Data Structures and File Handling Module">
    <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
    <article class="learning-module" data-module="8">
        <nav class="module-nav">
            <div class="nav-links">
                <a href="../index.html" class="nav-button">
                    <span>‚Üê</span> Home
                </a>
                <a href="module7.html" class="nav-button">
                    <span>‚Üê</span> Previous
                </a>
                <div class="module-progress">
                    <span>Module 8 of 8</span>
                </div>
                <a href="../index.html" class="nav-button" style="visibility: hidden;">
                    Next <span>‚Üí</span>
                </a>
            </div>
        </nav>

        <header class="module-header">
            <h1>Module 8: Advanced Data Structures and File Handling</h1>
            <section class="module-objectives">
                <h2>üéØ Learning Objectives</h2>
                <ul>
                    <li>Learn about searching arrays using Serial Search and Binary Search.</li>
                    <li>Understand Linked Lists and their advantages over arrays.</li>
                    <li>Introduce Pointers in C and their usage.</li>
                    <li>Learn about C Strings, their initialization and reading strings from user.</li>
                    <li>Understand Queues and Stacks as abstract data types.</li>
                    <li>Master File Handling in C, including opening, closing, writing and reading files.</li>
                    <li>Understand the importance of Software Documentation and its types.</li>
                </ul>
            </section>
        </header>

        <main class="module-content">

            <section class="content-section">
                <h2>üìö SORT TECHNIQUES (Continued)</h2>
                <div class="content-block">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Array at beginning:</th>
                                <th>84</th>
                                <th>69</th>
                                <th>76</th>
                                <th>86</th>
                                <th>94</th>
                                <th>91</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th rowspan="6">Bubble Sort</th>
                                <td>Array at beginning:</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                            </tr>
                            <tr>
                                <td>After Pass #1:</td>
                                <td>84</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #2:</td>
                                <td>84</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #3:</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #4:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #5 (done):</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                        </tbody>
                    </table>
                     <pre><code>// Bubble Sort Function for Descending Order
#include&lt;stdio.h&gt;
main()
{
    int control, control2, marks, total=0, temp;float meanmark;
    int allmarks[5];

    for (control = 0; control <= 4; control++)
    {
        printf("Please enter student's marks:");
        scanf("%d", & marks);
        allmarks[control]=marks;
        total = total + marks;
    }

    meanmark = (float) total/control;

    for (control = 0; control < 4; control++) {
        for (control2 = 0; control2 < 4; control2++) {
            if (allmarks[control2] > allmarks[control2+1])
            {
                temp = allmarks[control2];
                allmarks[control2]= allmarks[control2+1];
                allmarks[control2+1] = temp;
            }
        }
    }

    printf("\\nThe sorted list of marks is:\\n");
    for (control=0; control&lt;=4;control++)
    {
        printf("%d\\n", allmarks[control]);
    }

    printf("\\nThe total marks is %d\\n", total);
    printf("Mean marks is %f\\n", meanmark);
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SORT TECHNIQUES (Continued)</h2>
                <div class="content-block">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Array at beginning:</th>
                                <th>84</th>
                                <th>69</th>
                                <th>76</th>
                                <th>86</th>
                                <th>94</th>
                                <th>91</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th rowspan="6">Exchange Sort</th>
                                <td>Array at beginning:</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                            </tr>
                            <tr>
                                <td>After Pass #1:</td>
                                <td>94</td>
                                <td>69</td>
                                <td>76</td>
                                <td>84</td>
                                <td>86</td>
                                <td>91</td>
                            </tr>
                            <tr>
                                <td>After Pass #2:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>69</td>
                                <td>76</td>
                                <td>84</td>
                                <td>86</td>
                            </tr>
                            <tr>
                                <td>After Pass #3:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>69</td>
                                <td>76</td>
                                <td>84</td>
                            </tr>
                            <tr>
                                <td>After Pass #4:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                            </tr>
                            <tr>
                                <td>After Pass #5 (done):</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                        </tbody>
                    </table>
                     <pre><code>//Exchange Sort Function for Descending Order
#include &lt;stdio.h&gt;
void main()
{
    int i, j;
    int temp; // holding variable
    int num[5];

    //intialize array
    for(i=0; i<=4; i++){
        printf("Enter a number:");
        scanf("%d", &num[i]);
    }

    //sort array
    for (i=0; i< (4); i++) // element to be compared
    {
        for(j = (i+1); j < 5; j++) // rest of the elements
        {
            if (num[i] < num[j])
            // descending order
            {
                temp= num[i];
                // swap
                num[i] = num[j];
                num[j] = temp;
            }
        }
    }

    //print sorted array
    printf("\\nSorted array:\\n");
    for(i =0; i<=4; i++){
        printf("\\t%d\\n", num[i]);
    }
    return;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SORT TECHNIQUES (Continued)</h2>
                <div class="content-block">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Array at beginning:</th>
                                <th>84</th>
                                <th>69</th>
                                <th>76</th>
                                <th>86</th>
                                <th>94</th>
                                <th>91</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th rowspan="6">Selection Sort</th>
                                <td>Array at beginning:</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                            </tr>
                            <tr>
                                <td>After Pass #1:</td>
                                <td>84</td>
                                <td>91</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #2:</td>
                                <td>84</td>
                                <td>91</td>
                                <td>94</td>
                                <td>86</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #3:</td>
                                <td>86</td>
                                <td>91</td>
                                <td>94</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #4:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                            <tr>
                                <td>After Pass #5 (done):</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                            </tr>
                        </tbody>
                    </table>
                     <pre><code>// Selection Sort Function for Descending Order
void main()
{
    int i, j, first, temp;
    int num[5]
    for (i= 4; i > 0; i--)
    {
        first = 0;   // initialize to subscript of first element
        for (j=1; j<=i; j++) // locate smallest between positions 1 and i.
        {
            if (num[j] < num[first])
            first = j;
        }
        temp = num[first];   // Swap smallest found with element in position i.
        num[first] = num[i];
        num[i] = temp;
    }
    return;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SORT TECHNIQUES (Continued)</h2>
                <div class="content-block">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Array at beginning:</th>
                                <th>84</th>
                                <th>69</th>
                                <th>76</th>
                                <th>86</th>
                                <th>94</th>
                                <th>91</th>
                                <th>d</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th rowspan="3">Shell Sort</th>
                                <td>Array at beginning:</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>After Pass #1:</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>After Pass #2:</td>
                                <td>91</td>
                                <td>94</td>
                                <td>86</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>2</td>
                            </tr>
                             <tr>
                                <td>After Pass #3:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                                <td>1</td>
                            </tr>
                            <tr>
                                <td>After Pass #4 (done):</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>76</td>
                                <td>69</td>
                                <td>1</td>
                            </tr>
                        </tbody>
                    </table>
                     <pre><code>//Shell Sort Function for Descending Order
void main()
{
    int I,d, temp, length[5];

    while( (d > 1))   // boolean flag (true when not equal to 0)
    {
        d = (d+1) / 2;
        for (i = 0; i < (5 - d); i++)
        {
            if (num[i + d] > num[i])
            {
                temp = num[i + d];   // swap positions i+d and i
                num[i + d] = num[i];
                num[i] = temp;
                flag = 1;   // tells swap has occurred
            }
        }
    }
    return;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SORT TECHNIQUES (Continued)</h2>
                <div class="content-block">
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Array at beginning:</th>
                                <th>84</th>
                                <th>69</th>
                                <th>76</th>
                                <th>86</th>
                                <th>94</th>
                                <th>91</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th rowspan="4">Quick Sort</th>
                                <td>Array at beginning:</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                            </tr>
                            <tr>
                                <td>= 1st partition</td>
                                <td>86</td>
                                <td>94</td>
                                <td>91</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                            </tr>
                            <tr>
                                <td>= 2nd partition</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                            </tr>
                             <tr>
                                <td>Done:</td>
                                <td>94</td>
                                <td>91</td>
                                <td>86</td>
                                <td>84</td>
                                <td>69</td>
                                <td>76</td>
                            </tr>
                        </tbody>
                    </table>
                     <pre><code>//Quick Sort Functions for Descending Order
// (2 Functions)
void main()
{
    // top = subscript of beginning of array
    // bottom = subscript of end of array
    int middle;

    if (top < bottom)
    {
        middle = partition(num, top, bottom);
        quicksort(num, top, middle);   // sort first section
        quicksort(num, middle+1, bottom);  // sort second section
    }
    return;
}

//Function to determine the partitions
// partitions the array and returns the middle subscript
int main()
{
    int x = array[top];
    int i = top - 1;
    int j = bottom + 1;
    int temp;

    do
    {
        do
        {
            j--;
        }while (x >array[j]);

        do
        {
            i++;
        } while (x <array[i]);

        if (i < j)
        {
            temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }while (i < j);

    return j;   // returns middle subscript
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SORT TECHNIQUES (Continued)</h2>
                <div class="content-block">
                    <p><b>Merge Sort</b></p>
                    <p>The <b>merge sort</b> combines two <b>sorted</b> arrays into one larger sorted array.
As the diagram below shows, Array A and Array B merge to form Array C.</p>
                    <p><b>Arrays to be merged MUST be SORTED FIRST!!</b></p>
                    <p>Be sure to declare Array C in <code>main()</code> and establish its size.</p>
                    <p><b>Example: Ascending Order</b></p>
                    <p>Array A: {7.12}</p>
                    <p>Array B: {5, 7,8}</p>
                    <p>Array C: {5, 7, 7, 8, 12} after merge</p>
                    <p><b>Here is how it works:</b> The first element of array A is compared with the first element
of array B. If the first element of array A is smaller than the first element of array B,
the element from array A is moved to the new array C. The subscript of array A is
now increased since the first element is now set and we move on.</p>
                    <p>If the element from array B should be smaller, it is moved to the new array C. The
subscript of array B is increased. This process of comparing the elements in the two
arrays continues until either array A or array B is empty. When one array is empty,
any elements remaining in the other (non-empty) array are "pushed" into the end of
array C and the merge is complete.</p>
                     <pre><code>//Function to merge two pre-sorted arrays
void main()
{
    int indexA = 0;  // initialize variables for the subscripts
    int indexB = 0;
    int indexC = 0;
    Int arrayC[5];

    while((indexA < 5) && (indexB < 5)
    {
        if (arrayA[indexA] < arrayB[indexB])
        {
            arrayC[indexC] = arrayA[indexA];
            indexA++;   //increase the subscript
        }
        else
        {
            arrayC[indexC] = arrayB[indexB];
            indexB++;   //increase the subscript
        }
        indexC++;  //move to the next position in the new array
    }

    // Move remaining elements to end of new array when one merging array is empty
    while (indexA < 5)
    {
        arrayC[indexC] = arrayA[indexA];
        indexA++;
        indexC++;
    }

    while (indexB < 5)
    {
        arrayC[indexC] = arrayB[indexB];
        indexB++;
        indexC++;
    }
    return;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SEARCHING ARRAYS</h2>
                <div class="content-block">
                    <p>When working with arrays, it is often necessary to perform a search or "lookup" to
determine whether an array contains a value that matches a certain <b>key value</b> The
process of locating a particular element value in an array is called <b>searching</b>. There are
two types of search mechanisms: <b>serial/linear search</b> and <b>binary search</b></p>
                    <p><b>a) Serial Search</b></p>
                    <p>The technique used here is called a <b>serial search</b>, because the integer elements of the
array are compared one by one to the user input being looked for (<code>userValue</code>) until
either a match is found or all elements of the array are examined without finding a
match.</p>
                    <p>In the code below, if a match is found, the text ‚ÄúThere is a match‚Äù is printed on the
form and the execution of the procedure is terminated (Exit Sub). If no match is
found, the program exits the loop and prints the text ‚ÄúNo match found‚Äù.</p>
                     <pre><code>#include &lt;stdio.h&gt;
int main()
{
    int array[5]={10,7,8,2,5}, searchvalue, c;

    printf("\\tEnter the number to search: ");
    scanf("%d", &searchvalue);

    for (c = 0; c < 5; c++)
    {
        if (array[c] == searchvalue)
        // if required element found
        {
            printf("\\n\\t%d is present at location %d.\\n",
                   searchvalue, c+1);
            break;
        }
    }
    if (c == 5)
    // if looped more than 5 times ie 6 times
        printf("\\n\\t%d_is_not present in the array.\\n",
               searchvalue);
    return 0;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö SEARCHING ARRAYS (Continued)</h2>
                <div class="content-block">
                    <p><b>Binary Search</b></p>
                    <p><b>Binary search</b> uses the concept of splitting your searchable array in two, discarding the half
that does not have the element for which you are looking.</p>
                    <p>You place your items in an array and sort them. Then you simply get the middle element and
test if it is <code>&lt;</code>, <code>></code>, or <code>=</code> to the element for which you are searching. If it is less than, you discard
the greater half, get the middle index of the remaining elements and do it again. Binary search
divides your problem in half every time you execute your loop.</p>
                     <pre><code>#include &lt;stdio.h&gt;
int main()
{
    int c, first, last, middle, n, search, array [100];

    printf("Enter number of elements\\n");
    scanf("%d",&n);

    printf("Enter %d integers\\n", n);

    for ( c = 0 ; c < n ; c++)
        scanf("%d",&array[c]);

    printf("Enter value to find\\n");
    scanf("%d", &search);

    first = 0;
    last = n - 1;
    middle = (first+last)/2;

    while(first <= last )
    {
        if (array [middle] < search )
            first = middle + 1;
        else if ( array [middle] == search )
        {
            printf("%d found at location %d.\\n", search, middle+1);
            break;
        }
        else
            last = middle - 1;

        middle = (first + last)/2;
    }
    if (first > last )
        printf("Not found! %d is not present in the list.\\n", search);

    return 0;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö LINKED LISTS</h2>
                <div class="content-block">
                    <p>A <b>linked list</b> is a <b>dynamic data structure</b> whose length can be increased or decreased at
run time.</p>
                    <p><b>How Linked lists are different from arrays?</b> Consider the following points :</p>
                    <ul>
                        <li>An array is a <b>static data structure</b>. This means the length of array cannot be
altered at run time. While, a linked list is a <b>dynamic data structure</b>.</li>
                        <li>In an array, all the elements are kept at <b>consecutive memory locations</b> while in
a linked list the elements (or nodes) may be kept at <b>any location</b> but still
connected to each other.</li>
                    </ul>
                    <p><b>When to prefer linked lists over arrays?</b> Linked lists are preferred mostly when you
don't know the volume of data to be stored. For example, In an employee
management system, one cannot use arrays as they are of fixed length while any
number of new employees can join. In scenarios like these, linked lists (or other
dynamic data structures) are used as their capacity can be increased (or decreased) at
run time (as an when required).</p>
                    <p><b>How linked lists are arranged in memory?</b></p>
                    <p>Linked list basically consists of memory blocks that are located at random memory
locations. Linked lists are connected through <b>pointers</b>.</p>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö POINTERS</h2>
                <div class="content-block">
                    <p>A <b>pointer</b> is a variable whose value is the address of another variable, i.e., direct
address of the memory location. Like any variable or constant, you must declare a
pointer before you can use it to store any variable address. The general form of a
pointer variable declaration is:</p>
                     <pre><code>type *var-name;
</code></pre>
                    <p>Here, <b>type</b> is the pointer's base type; it must be a valid C data type and <b>var-name</b> is
the name of the pointer variable. The asterisk <code>*</code> you used to declare a pointer is the</p>
                     <figure class="content-image">
                        <img src="../assets/images/pointers_diagram.png"
                             alt="Pointers Diagram"
                             width="600" height="300">
                        <figcaption>Pointers at work</figcaption>
                    </figure>
                    <p>same asterisk that you use for multiplication. However, in this statement the asterisk
is being used to designate a variable as a pointer. Following are the valid pointer
declaration:</p>
                     <pre><code>int *ip;    /* pointer to an integer */
double *dp; /* pointer to a double */
float *fp;  /* pointer to a float */
char *ch   /* pointer to a character */
</code></pre>
                    <p>The actual data type of the value of all pointers, whether integer, float, character, or
otherwise, is the same, a long hexadecimal number that represents a memory address.
The only difference between pointers of different data types is the data type of the
variable or constant that the pointer points to.</p>
                    <p><b>HOW TO USE POINTERS?</b></p>
                    <p>There are few important operations, which we will do with the help of pointers very
frequently. <b>(a)</b> we define a pointer variable <b>(b)</b> assign the address of a variable to a
pointer and <b>(c)</b> finally access the value at the address available in the pointer variable.
This is done by using <b>unary operator <code>*</code></b> that returns the value of the variable located at
the address specified by its operand. Following example makes use of these
operations:</p>
                     <pre><code>#include &lt;stdio.h&gt;

int main ()
{
    int var = 20;   /* actual variable declaration */
    int *ip;        /* pointer variable declaration */

    ip = &var;  /* store address of var in pointer variable*/

    printf("Address of var variable: %x\\n", &var  );

    /* address stored in pointer variable */
    printf("Address stored in ip variable: %x\\n", ip );

    /* access the value using the pointer */
    printf("Value of *ip variable: %d\\n", *ip );

    return 0;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö C STRINGS</h2>
                <div class="content-block">
                    <p>In C, one or more characters enclosed between double quotes is called a <b>string</b>. C does
not have built-in string data type. Instead, C supports strings using one-dimensional
arrays. A string is defined as a <b>null terminated array</b> i.e. <code>\0</code>. This means that you must
define the array that is going to hold a string to be one byte larger than the largest
string it is going to hold, in order to make room for the null.</p>
                    <p>To read a string from the keyboard, you must use another of C's standard library
functions, <code>gets()</code>, which requires the <code>stdio.h</code> header file. The <code>gets ()</code> function reads
characters until you presss <b>&lt;ENTER&gt;</b>. The carriage return is not stored, but it is
replaced by a null, wich terminates the string. E.g.</p>
                     <pre><code>#include&lt;stdio.h&gt;
Main ()
Char str [80];
Int I;
Printf (√ãNter a string: \\n‚Äù);
gets(str);

for (I = 0; str[i]; i++)
printf("%c", str[i]);
}
</code></pre>
                    <p>The following declaration and initialization create a string consisting of the word
"Hello". To hold the null character at the end of the array, the size of the character
array containing the string is one more than the number of characters in the word
"Hello".</p>
                     <pre><code>char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};
</code></pre>
                    <p><b>Initialization of strings</b></p>
                    <p>In C, string can be initialized in a different number of ways.</p>
                     <pre><code>char c[]="abcd";
OR,
char c[5]="abcd";
char c[]={'a','b','c','d','\\0'};
OR,
OR;
char c[5]={'a','b','c','d','\\0'};
</code></pre>
                     <figure class="content-image">
                        <img src="../assets/images/c_string_memory.png"
                             alt="C String in Memory"
                             width="400" height="200">
                        <figcaption>C String Memory Layout</figcaption>
                    </figure>
                    <p>String can also be initialized using pointers</p>
                     <pre><code>char *c="abcd";
</code></pre>
                    <p><b>Reading Strings from user.</b></p>
                    <p><b>Reading words from user.</b></p>
                     <pre><code>char c[20];
scanf("%s",c);
</code></pre>
                    <p>String variable <code>c</code> can only take a word. It is beacause when white space is
encountered, the <code>scanf()</code> function terminates.</p>
                    <p><b>Write a C program to illustrate how to read string from terminal.</b></p>
                     <pre><code>#include &lt;stdio.h&gt;
int main() {
    char name [20];
    printf("Enter name: ");
    scanf("%s",name);
    printf("Your name is %s.",name);
    return 0;
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö QUEUES</h2>
                <div class="content-block">
                    <p><b>Queue</b> is a specialized data storage structure (Abstract data type). Unlike arrays,
access of elements in a Queue is restricted. It has two main operations <b>enqueue</b> and
<b>dequeue</b>. Insertion in a queue is done using enqueue function and removal from a
queue is done using dequeue function. An item can be inserted at the end (‚Äò<b>rear</b>') of
the queue and removed from the front (‚Äò<b>front</b>') of the queue. It is therefore, also called
<b>First-In-First-Out (FIFO) list</b>. Queue has five properties - capacity stands for the
maximum number of elements Queue can hold, size stands for the current size of the
Queue, elements is the array of elements, front is the index of first element (the index
at which we remove the element) and rear is the index of last element (the index at
which we insert the element).</p>
                    <p><b>Primitive operations</b></p>
                    <ol type="a">
                        <li><b>enqueue (q, x):</b> inserts item <code>x</code> at the rear of the queue <code>q</code></li>
                        <li><b>x = dequeue (q):</b> removes the front element from <code>q</code> and returns its value.</li>
                        <li><b>isEmpty(q)</b> : true if the queue is empty, otherwise false.</li>
                    </ol>
                    <p><b>Example</b></p>
                     <pre><code>enqueue(q, 'A');
enqueue(q, 'B');
enqueue(q, 'C');
x = dequeue(q);
enqueue(q, 'D');
enqueue(q, 'E');
</code></pre>
                     <figure class="content-image">
                        <img src="../assets/images/queue_example.png"
                             alt="Queue Example Diagram"
                             width="600" height="300">
                        <figcaption>Queue Operation Example</figcaption>
                    </figure>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö STACKS</h2>
                <div class="content-block">
                    <p>A <b>stack</b> is a data structure that allows adding and removing elements in a particular
order. Every time an element is added, it goes on the <b>top</b> of the stack; the only
element that can be removed is the element that was at the <b>top</b> of the stack.
Consequently, a stack is said to have <b>"first in last out"</b> behavior (or "last in, first out").
The first item added to a stack will be the last item removed from a stack.</p>
                     <figure class="content-image">
                        <img src="../assets/images/stack_diagram.png"
                             alt="Stack Data Structure Diagram"
                             width="400" height="300">
                        <figcaption>Stack Data Structure</figcaption>
                    </figure>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö CHAPTER 7 FILE HANDLING</h2>
                <div class="content-block">
                    <p>This chapter explains how C programmers can create, open and close text or binary files
for their data storage. A file represents a sequence of bytes, does not matter if it is a text
file or binary file.</p>
                    <p><b>OPENING FILES</b></p>
                    <p>You can use the <code>fopen()</code> function to create a new file or to open an existing file, this call
will initialize an object of the type <code>FILE</code>, which contains all the information necessary to
control the stream. Following is the prototype of this function call:</p>
                     <pre><code>FILE *fopen( const char * filename, const char * mode );
</code></pre>
                    <p>Here, <code>filename</code> is string literal, which you will use to name your file and <b>access mode</b>
can have one of the following values:</p>
                     <table>
                        <thead>
                            <tr>
                                <th>Mode</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>r</code></td>
                                <td>Opens an existing text file for reading purpose.</td>
                            </tr>
                            <tr>
                                <td><code>w</code></td>
                                <td>Opens a text file for writing, if it does not exist then a new file is created. Here your program will start writing content from the beginning of the file.</td>
                            </tr>
                            <tr>
                                <td><code>a</code></td>
                                <td>Opens a text file for writing in appending mode, if it does not exist then a new file is created. Here your program will start appending content in the existing file content.</td>
                            </tr>
                            <tr>
                                <td><code>r+</code></td>
                                <td>Opens a text file for reading and writing both.</td>
                            </tr>
                             <tr>
                                <td><code>w+</code></td>
                                <td>Opens a text file for reading and writing both. It first truncate the file to zero length if it exists otherwise create the file if it does not exist.</td>
                            </tr>
                            <tr>
                                <td><code>a+</code></td>
                                <td>Opens a text file for reading and writing both. It creates the file if it does not exist. The reading will start from the beginning but writing can only be appended.</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>If you are going to handle binary files then you will use below mentioned access modes
instead of the above mentioned:</p>
                     <pre><code>"rb", "wb", "ab", "ab+", "a+b", "wb+", "w+b", "ab+", "a+b"
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö CLOSING A FILE</h2>
                <div class="content-block">
                    <p>To close a file, use the <code>fclose()</code> function. The prototype of this function is:</p>
                     <pre><code>int fclose( FILE *fp);
</code></pre>
                    <p>The <code>fclose()</code> function returns zero on success, or <code>EOF</code> if there is an error in closing the
file. This function actually, flushes any data still pending in the buffer to the file, closes
the file, and releases any memory used for the file. The <code>EOF</code> is a constant defined in the
header file <code>stdio.h</code>.</p>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö WRITING A FILE</h2>
                <div class="content-block">
                    <p>Following is the simplest function to write individual characters to a stream:</p>
                     <pre><code>int fputc( int c, FILE *fp);
</code></pre>
                    <p>The function <code>fputc()</code> writes the character value of the argument <code>c</code> to the output stream
referenced by <code>fp</code>. It returns the written character written on success otherwise <code>EOF</code> if
there is an error. You can use the following functions to write a null-terminated string to
a stream:</p>
                     <pre><code>int fputs(const char *s, FILE *fp);
</code></pre>
                    <p>The function <code>fputs()</code> writes the string <code>s</code> to the output stream referenced by <code>fp</code>. It returns a
non-negative value on success, otherwise <code>EOF</code> is returned in case of any error. You can
use <code>int fprintf(FILE *fp,const char *format, ...)</code> function as well to write a string into a
file. Try the following example:</p>
                     <pre><code>#include &lt;stdio.h&gt;
main()
{
    FILE *fp;

    fp = fopen("/tmp/test.txt", "w+");
    fprintf(fp, "This is testing for fprintf...\\n");
    fputs("This is testing for fputs...\\n", fp);
    fclose(fp);
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö READING A FILE</h2>
                <div class="content-block">
                    <p>Following is the simplest function to read a single character from a file:</p>
                     <pre><code>int fgetc(FILE * fp);
</code></pre>
                    <p>The <code>fgetc()</code> function reads a character from the input file referenced by <code>fp</code>. The return
value is the character read, or in case of any error it returns <code>EOF</code>. The following
functions allow you to read a string from a stream:</p>
                     <pre><code>char *fgets(char *buf, int n, FILE *fp);
</code></pre>
                    <p>The functions <code>fgets()</code> reads up to <code>n - 1</code> characters from the input stream referenced by <code>fp</code>.
It copies the read string into the buffer <code>buf</code>, appending a <b>null character</b> to terminate the
string.</p>
                    <p>If this function encounters a newline character <code>'\n'</code> or the end of the file <code>EOF</code> before they
have read the maximum number of characters, then it returns only the characters read up
to that point including new line character. You can also use <code>int fscanf(FILE *fp, const
char *format, ...)</code> function to read strings from a file but it stops reading after the first
space character encounters.</p>
                     <pre><code>#include &lt;stdio.h&gt;
main()
{
    FILE *fp;
    char buff[255];

    fp = fopen("/tmp/test.txt", "r");

    fscanf(fp, "%s", buff);
    printf("1 : %s\\n", buff );

    fgets (buff, 255, (FILE*)fp);
    printf("2: %s\\n", buff );

    fgets (buff, 255, (FILE*)fp);
    printf("3: %s\\n", buff );
    fclose(fp);
}
</code></pre>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö BINARY I/O FUNCTIONS</h2>
                <div class="content-block">
                    <p>There are following two functions, which can be used for binary input and output:</p>
                     <pre><code>size_t fread(void *ptr, size_t size_of_elements,
             size_t number_of_elements, FILE *a_file);

size_t fwrite(const void *ptr, size_t size_of_elements,
              size_t number_of_elements, FILE *a_file);
</code></pre>
                    <p>Both of these functions should be used to read or write blocks of memories - usually
arrays or structures.</p>
                </div>
            </section>

             <section class="content-section">
                <h2>üìö CHAPTER 8 SOFTWARE DOCUMENTATION</h2>
                <div class="content-block">
                    <p><b>Software documentation</b> is written text that accompanies computer software. It both
explains how the software operates or how to use it and may mean different things to
people in different roles.</p>
                    <p><b>Importance of software documentation</b></p>
                    <ol>
                        <li>Provide for communication among team members</li>
                        <li>They should provide information for management to help them plan, budget and
schedule the software development process.</li>
                        <li>It acts as an information repository to be used by maintenance engineers</li>
                        <li>Describe to users how to operate and administer the system</li>
                        <li>In all software projects some amount of documentation should be created prior to
any code being written for example Design docs, etc.</li>
                        <li>Documentation should continue after the code has been completed for example
User's manuals, etc.</li>
                    </ol>
                    <p>The two main types of documentation created are <b>Process</b> and <b>Product</b> documents</p>
                    <p><b>PROCESS DOCUMENTATION</b></p>
                    <ol type="a">
                        <li><b>Used to record and track the development process</b>
                            <ul>
                                <li>Planning documentation</li>
                                <li>Cost, Schedule, Funding tracking</li>
                                <li>Schedules</li>
                                <li>Standards e.t.c.</li>
                            </ul>
                        </li>
                        <li>This documentation is created to allow for successful management of a software
product</li>
                        <li>Has a relatively short lifespan</li>
                        <li>Only important to internal development process</li>
                        <li>Except in cases where the customer requires a view into this data</li>
                        <li>Some items, such as papers that describe design decisions should be extracted and
moved into the product documentation category when they become implemented</li>
                    </ol>
                    <p><b>PRODUCT DOCUMENTATION</b></p>
                    <p>Describes the delivered product</p>
                    <p>Must evolve with the development of the software product</p>
                    <p>There are two main categories of process documentation:</p>
                    <p><b>1. System Documentation</b></p>
                    <p>This describes how the system works, but not how to operate it</p>
                    <p><b>Examples:</b></p>
                    <ul>
                        <li>Requirements Spec</li>
                        <li>Architectural Design</li>
                        <li>Detailed Design</li>
                        <li>Commented Source Code</li>
                        <li>Including output such as JavaDoc</li>
                        <li>Test Plans</li>
                        <li>Including test cases</li>
                        <li>V&V plan and results</li>
                        <li>List of Known Bugs</li>
                    </ul>
                    <p><b>2. User Documentation</b></p>
                    <p>User Documentation has two main types</p>
                    <ul>
                        <li>End User</li>
                        <li>System Administrator</li>
                    </ul>
                    <p>In some cases these are the same people. The target audience must be well understood.</p>
                    <p>There are five important areas that should be documented for a formal release of a
software application. These do not necessarily each have to have their own document, but
the topics should be covered thoroughly. These include:</p>
                    <ul>
                        <li>Functional Description of the Software</li>
                        <li>Installation Instructions</li>
                        <li>Introductory Manual</li>
                        <li>Reference Manual</li>
                        <li>System Administrator's Guide</li>
                    </ul>
                    <p><b>Document Quality</b></p>
                    <p>Providing thorough and professional documentation is important for any size product
development team</p>
                    <p><b>Document Structure</b></p>
                    <p>All documents for a given product should have a similar structure</p>
                    <p>The authors "best practices" are:</p>
                    <ul>
                        <li>Put a cover page on all documents</li>
                        <li>Divide documents into chapters with sections and subsections</li>
                        <li>Add an index if there is lots of reference information</li>
                        <li>Add a glossary to define ambiguous terms</li>
                    </ul>
                </div>
            </section>
        </main>

        <footer class="module-footer">
            <section class="key-takeaways">
                <h2>üìù Key Takeaways</h2>
                <ul>
                    <li>Arrays can be searched using Serial Search (linear) or Binary Search (efficient for sorted arrays).</li>
                    <li>Linked Lists are dynamic data structures, offering flexibility in size compared to static arrays.</li>
                    <li>Pointers in C store memory addresses, enabling dynamic memory management and efficient data manipulation.</li>
                    <li>C Strings are character arrays terminated by a null character, with library functions for string operations.</li>
                    <li>Queues (FIFO) and Stacks (LIFO) are abstract data types with specific rules for element access.</li>
                    <li>File handling in C involves opening, closing, reading, and writing files using functions like fopen, fclose, fgetc, fputc, fgets, fputs, fread, fwrite.</li>
                    <li>Software documentation is crucial for communication, management, maintenance, and user guidance, categorized into Process and Product documentation.</li>
                </ul>
            </section>

            <section class="knowledge-check">
                <h2>‚ö° Knowledge Check</h2>
                <div class="quiz-content">
                    <p><b>Question 1:</b> What is the main advantage of Binary Search over Serial Search?</p>
                    <p><b>Question 2:</b> How do Linked Lists differ from Arrays in terms of memory allocation?</p>
                    <p><b>Question 3:</b> Explain the purpose of pointers in C programming.</p>
                    <p><b>Question 4:</b> What are the key operations for Queues and Stacks?</p>
                    <p><b>Question 5:</b> Describe the difference between Process and Product documentation.</p>
                </div>
            </section>

            <nav class="module-nav">
                <div class="nav-links">
                    <a href="../index.html" class="nav-button">
                        <span>‚Üê</span> Home
                    </a>
                    <a href="module7.html" class="nav-button">
                        <span>‚Üê</span> Previous
                    </a>
                    <div class="module-progress">
                        <span>Module 8 of 8</span>
                    </div>
                    <a href="../index.html" class="nav-button" style="visibility: hidden;">
                        Next <span>‚Üí</span>
                    </a>
                </div>
            </nav>
        </footer>
    </article>
</body>
</html>