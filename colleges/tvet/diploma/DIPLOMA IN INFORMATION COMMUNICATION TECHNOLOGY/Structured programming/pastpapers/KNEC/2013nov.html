<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structured Programming - November 2013 | KNEC Past Papers</title>
    <link rel="stylesheet" href="styles.css">
    <script src="js/sidebar-navigation.js" defer></script>
    <!-- Add MathJax scripts if needed -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>STRUCTURED PROGRAMMING</h1>
            <h2>November 2013</h2>
            <div class="exam-details">
                <p>Paper Code: 2920/103</p>
                <p>Duration: 3 hours</p>
                <p>Module: MODULE I</p>
            </div>
        </div>
    </header>

    <div class="container main-content">
        <div class="sidebar">
            <div class="sidebar-header"><h3>Past Papers</h3></div>
            <nav class="sidebar-nav">
                <ul>
                    <li>
                        <h4>2022</h4>
                        <ul><li><a href="2022j.html">July 2022</a></li></ul>
                    </li>
                    <li>
                        <h4>2021</h4>
                        <ul>
                            <li><a href="2021n.html">November 2021</a></li>
                            <li><a href="2021j.html">July 2021</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2019</h4>
                        <ul><li><a href="2019july.html">July 2019</a></li></ul>
                    </li>
                    <li>
                        <h4>2018</h4>
                        <ul><li><a href="2018j.html">July 2018</a></li></ul>
                    </li>
                    <li>
                        <h4>2017</h4>
                        <ul>
                            <li><a href="2017nov.html">November 2017</a></li>
                            <li><a href="2017july.html">July 2017</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2016</h4>
                        <ul>
                            <li><a href="2016nov.html">November 2016</a></li>
                            <li><a href="2016july.html">July 2016</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2015</h4>
                        <ul><li><a href="2015nov.html">November 2015</a></li></ul>
                    </li>
                    <li>
                        <h4>2014</h4>
                        <ul>
                            <li><a href="2014n.html">November 2014</a></li>
                            <li><a href="2014july.html">July 2014</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2013</h4>
                        <ul><li><a href="2013nov.html">November 2013</a></li></ul>
                    </li>
                    <li>
                        <h4>2012</h4>
                        <ul><li><a href="2012july.html">July 2012</a></li></ul>
                    </li>
                    <li>
                        <h4>2011</h4>
                        <ul>
                            <li><a href="2011n.html">November 2011</a></li>
                            <li><a href="2011july.html">July 2011</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </div>
        <main>
            <div class="paper-navigation top"><a href="2012july.html" class="btn">Previous Paper</a><a href="index.html" class="btn">Home</a><a href="2014july.html" class="btn">Next Paper</a></div>

            <section class="paper-intro">
                <h3>INSTRUCTIONS TO CANDIDATES</h3>
                <p>Write your name and index number in the spaces provided above.</p>
                <p>Sign and write the date of examination in the spaces provided above.</p>
                <p>Answer any FIVE of the EIGHT questions in this paper in the spaces provided after each question.</p>
                <p>Candidates should answer the questions in English.</p>
                <!-- Note: Number of pages might be incorrect based on OCR -->
            </section>

            <section class="paper-content">
                <div class="question">
                    <h3>Question 1 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) Explain the term parameter passing as used in programming. (2 marks)</p>
                        <p>(ii) Write a C program that prompts the user to enter an integer. The program should then determine whether the input is odd or even and output appropriate message. (4 marks)</p>
                        <p>(b) (i) James entered an integer in a Pascal program during execution and the following output was displayed 3.08000E+0.155000E.</p> <!-- OCR seems garbled here -->
                        <ul>
                            <li>I. Outline the cause of the output as displayed. (1 mark)</li>
                            <li>II. State a possible solution that could make the output easy to read. (1 mark)</li>
                        </ul>
                        <p>(ii) Figure 1 shows a flowchart of a program designed by a student in a programming class. Use it to answer the question that follows.</p>
                        <figure class="question-figure">
                           <!-- Placeholder for Figure 1 -->
                           <pre class="diagram-code">
START
│
▼
Input x, y
│
▼
Is x > y ? ─── YES ───► Display x
│ NO
▼
Display y
│
▼
END
                           </pre>
                           <figcaption>Figure 1 (Interpreted from OCR)</figcaption>
                        </figure>
                        <p>Write a Pascal program that could be used to implement the program logic. (4 marks)</p>
                        <p>(c) Differentiate between an interpreter and an assembler as used in programming. (4 marks)</p>
                        <p>(d) Write a C program that would prompt the user to enter the length and breadth of a rectangle. The program should then compute and output the area and perimeter of the rectangle. (4 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) (i) Parameter Passing</h5>
                            <p>Parameter passing refers to the mechanism by which data (arguments) is transferred from the calling part of a program (e.g., the main program or another function) to a function or procedure when it is invoked. Common methods include:</p>
                            <ul>
                                <li><strong>Pass by Value:</strong> A copy of the argument's value is passed to the function. Changes made to the parameter inside the function do not affect the original argument.</li>
                                <li><strong>Pass by Reference:</strong> The memory address of the argument is passed to the function. Changes made to the parameter inside the function directly affect the original argument. (Often implemented using pointers or specific language constructs like VAR in Pascal).</li>
                            </ul>

                            <h5>(a) (ii) C Program: Odd or Even</h5>
                            <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    int number;

    // Prompt user for input
    printf("Enter an integer: ");
    scanf("%d", &number);

    // Check if the number is odd or even
    if (number % 2 == 0) {
        printf("%d is an even number.\n", number);
    } else {
        printf("%d is an odd number.\n", number);
    }

    return 0;
}
                            </code></pre>

                            <h5>(b) (i) Pascal Output Explanation</h5>
                            <ul>
                                <li><strong>I. Cause:</strong> The output `3.08000E+0.155000E` appears garbled, likely due to incorrect formatting or attempting to display a very large number (or potentially two numbers concatenated) using the default scientific notation (E-notation) format for real numbers in Pascal, possibly with incorrect field width specifiers or data type mismatch during output. Standard E-notation would look like `3.08000E+15`. The extra `5000E` suggests a potential issue with how `Write` or `WriteLn` was used.</li>
                                <li><strong>II. Solution:</strong> Use formatted output specifiers in the `Write` or `WriteLn` statement to control the display format. For example, `WriteLn(myRealNumber:10:2)` would display the real number `myRealNumber` in a field of width 10 with 2 decimal places, avoiding scientific notation if the number fits. If it was intended to be an integer, ensure the variable is declared as `Integer` or `LongInt` and printed without formatting specifiers or using `:0`.</li>
                            </ul>

                            <h5>(b) (ii) Pascal Program for Flowchart (Find Max)</h5>
                            <pre><code class="language-pascal">
program FindMaximum;

var
  x, y: integer; // Or real, depending on expected input

begin
  // Prompt user for input
  write('Enter the first number (x): ');
  readln(x);
  write('Enter the second number (y): ');
  readln(y);

  // Determine and display the larger number
  if x > y then
    writeln('The larger number is: ', x)
  else
    writeln('The larger number is: ', y);

  readln; // Optional: pause to see output before closing console
end.
                            </code></pre>

                            <h5>(c) Interpreter vs. Assembler</h5>
                            <ul>
                                <li><strong>Interpreter:</strong> Translates and executes a high-level programming language source code line by line. It does not produce a separate machine code file. Execution is generally slower than compiled code because translation happens during runtime. Errors are reported as they are encountered, often making debugging easier for beginners. Examples: Python (often), BASIC.</li>
                                <li><strong>Assembler:</strong> Translates assembly language (a low-level language using mnemonics for machine instructions) directly into machine code (binary instructions). It produces an executable file specific to the target processor architecture. Assembly language is closer to the hardware, offering fine control but is less portable and harder to write than high-level languages.</li>
                            </ul>

                            <h5>(d) C Program: Rectangle Area and Perimeter</h5>
                            <pre><code class="language-c">
#include &lt;stdio.h&gt;

int main() {
    float length, breadth, area, perimeter;

    // Prompt user for input
    printf("Enter the length of the rectangle: ");
    scanf("%f", &length);

    printf("Enter the breadth of the rectangle: ");
    scanf("%f", &breadth);

    // Calculate area and perimeter
    area = length * breadth;
    perimeter = 2 * (length + breadth);

    // Output the results
    printf("\nRectangle Details:\n");
    printf("Length: %.2f\n", length);
    printf("Breadth: %.2f\n", breadth);
    printf("Area: %.2f\n", area);
    printf("Perimeter: %.2f\n", perimeter);

    return 0;
}
                            </code></pre>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 2 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) List two inbuilt Pascal functions that could be used to store the results of a real expression as an integer. (1 mark)</p>
                        <p>(ii) With the aid of an example outline the structure of a compound statement as used in Pascal Programming. (1 mark)</p>
                        <p>(iii) Distinguish between object oriented programming and visual programming paradigms. (4 marks)</p>
                        <p>(b) Write a Pascal program that would be used to read 10 scores into an array named D. The program should then compute the average score and display average score and the scores greater than the average. Use a while...do loop to read data. (6 marks)</p>
                        <p>(c) Write a Pascal program that would prompt the user to input values of m, n, p, q and then computes the value of z which is the product of m and n and value of t which is the sum of p and q through a procedure beta. Then program display the results from beta procedure. (4 marks)</p> <!-- Corrected variable 'g' to 'q' -->
                        <p>(d) With the aid of an example in each case, differentiate between prefix and postfix decrement operators as used in C programming. (4 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) (i) Pascal Functions: Real to Integer</h5>
                            <ol>
                                <li><code>Trunc(real_number)</code>: Truncates the real number towards zero, returning the integer part. Example: `Trunc(5.7)` returns 5, `Trunc(-5.7)` returns -5.</li>
                                <li><code>Round(real_number)</code>: Rounds the real number to the nearest integer. Example: `Round(5.7)` returns 6, `Round(5.2)` returns 5.</li>
                            </ol>

                            <h5>(a) (ii) Pascal Compound Statement</h5>
                            <p>A compound statement groups multiple individual statements together so they can be treated as a single statement, typically used within control structures like `if`, `for`, or `while`. It starts with the keyword `begin` and ends with the keyword `end;` (or `end.` if it's the end of the main program block).</p>
                            <p><strong>Example:</strong></p>
                            <pre><code class="language-pascal">
if x > 10 then
begin // Start of compound statement
  y := x * 2;
  writeln('x is greater than 10, y is now ', y);
end; // End of compound statement
                            </code></pre>

                            <h5>(a) (iii) Object-Oriented vs. Visual Programming</h5>
                            <ul>
                                <li><strong>Object-Oriented Programming (OOP):</strong> A programming paradigm based on the concept of "objects", which encapsulate data (attributes) and code (methods) that operate on that data. Key principles include encapsulation, inheritance, polymorphism, and abstraction. It focuses on modeling real-world entities and their interactions. Examples: Java, C++, Python, C#.</li>
                                <li><strong>Visual Programming:</strong> A programming paradigm where programs are created by manipulating graphical elements (like icons, buttons, forms) rather than primarily writing text-based code. It often involves using a graphical user interface (GUI) builder and connecting components visually. It simplifies GUI development but might be less flexible for complex logic compared to pure text-based coding. Examples: Visual Basic (classic), LabVIEW, Scratch, parts of modern IDEs like Visual Studio.</li>
                            </ul>
                            <p>Note: These paradigms are not mutually exclusive; many visual programming environments support object-oriented languages (e.g., Visual C#).</p>

                            <h5>(b) Pascal Program: Array Scores and Average</h5>
                            <pre><code class="language-pascal">
program ScoreAnalysis;

const
  NumScores = 10;

type
  ScoreArray = array[1..NumScores] of integer; // Or real if scores can have decimals

var
  D: ScoreArray;
  i, sum, countAboveAvg: integer;
  average: real;

begin
  sum := 0;
  i := 1;

  // Read scores using while...do loop
  writeln('Enter ', NumScores, ' scores:');
  while i <= NumScores do
  begin
    write('Score ', i, ': ');
    readln(D[i]);
    sum := sum + D[i];
    i := i + 1; // Increment counter
  end;

  // Calculate average
  if NumScores > 0 then
    average := sum / NumScores
  else
    average := 0; // Avoid division by zero

  writeln; // Blank line for spacing
  writeln('Average score: ', average:0:2); // Display average formatted

  // Find and display scores greater than average
  writeln('Scores greater than average:');
  countAboveAvg := 0;
  for i := 1 to NumScores do
  begin
    if D[i] > average then
    begin
      write(D[i], ' ');
      countAboveAvg := countAboveAvg + 1;
    end;
  end;

  if countAboveAvg = 0 then
    writeln('None');
  else
    writeln; // New line after scores

  readln; // Pause
end.
                            </code></pre>

                            <h5>(c) Pascal Program: Procedure for Calculation</h5>
                            <pre><code class="language-pascal">
program ProcedureExample;

var
  m, n, p, q: integer;
  z_result, t_result: integer; // Variables to hold results from procedure

// Procedure beta calculates z and t and returns them via VAR parameters
procedure beta(m_in, n_in, p_in, q_in: integer; var z_out, t_out: integer);
begin
  z_out := m_in * n_in; // Calculate product
  t_out := p_in + q_in; // Calculate sum
end;

begin
  // Prompt user for input
  write('Enter value for m: ');
  readln(m);
  write('Enter value for n: ');
  readln(n);
  write('Enter value for p: ');
  readln(p);
  write('Enter value for q: ');
  readln(q);

  // Call the procedure, passing input values and result variables
  beta(m, n, p, q, z_result, t_result);

  // Display the results obtained from the procedure
  writeln; // Blank line
  writeln('Results from procedure beta:');
  writeln('Value of z (m * n) = ', z_result);
  writeln('Value of t (p + q) = ', t_result);

  readln; // Pause
end.
                            </code></pre>

                            <h5>(d) C Prefix vs. Postfix Decrement</h5>
                            <p>Both prefix (`--x`) and postfix (`x--`) decrement operators decrease the value of the variable `x` by 1. The difference lies in the value returned by the expression in which they are used.</p>
                            <ul>
                                <li><strong>Prefix Decrement (`--x`):</strong> The variable `x` is first decremented by 1, and then the *new* (decremented) value of `x` is returned as the result of the expression.
                                    <br><strong>Example:</strong>
                                    <pre><code class="language-c">
int x = 5;
int y = --x; // x becomes 4, then y is assigned the value 4
// Now x is 4, y is 4
                                    </code></pre>
                                </li>
                                <li><strong>Postfix Decrement (`x--`):</strong> The *original* value of `x` is returned as the result of the expression, and *then* the variable `x` is decremented by 1.
                                    <br><strong>Example:</strong>
                                    <pre><code class="language-c">
int x = 5;
int y = x--; // y is assigned the original value 5, then x becomes 4
// Now x is 4, y is 5
                                    </code></pre>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 3 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) State three file handling commands that are used in C programming. (3 marks)</p>
                        <p>(ii) Differentiate between reset and rewrite procedures as used in Pascal text files. (4 marks)</p>
                        <p>(b) Explain two advantages of a loop control structure as used in programming. (4 marks)</p>
                        <p>(c) Write an algorithm that could be used to remove an element from a stack. (4 marks)</p>
                        <p>(d) Write a C program that would accept an integer. If the integer has one digit, the total sum is the integer otherwise the total sum is the digits in the integer. Use a recursive function. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) (i) C File Handling Commands/Functions</h5>
                            <ol>
                                <li><code>fopen()</code>: Opens a file and returns a file pointer. Requires the filename and mode (e.g., "r" for read, "w" for write, "a" for append).</li>
                                <li><code>fclose()</code>: Closes a file associated with a given file pointer, flushing any buffered data.</li>
                                <li><code>fprintf()</code> / <code>fscanf()</code>: Used for formatted I/O to/from files, similar to `printf`/`scanf` but operate on a file stream.</li>
                                <li>(Other examples: `fgetc`, `fputc`, `fgets`, `fputs`, `fread`, `fwrite`, `fseek`, `rewind`)</li>
                            </ol>

                            <h5>(a) (ii) Pascal `Reset` vs. `Rewrite`</h5>
                            <ul>
                                <li><strong><code>Reset(fileVariable)</code>:</strong> Opens an *existing* file for reading. It positions the file pointer at the beginning of the file. If the file does not exist, an error occurs.</li>
                                <li><strong><code>Rewrite(fileVariable)</code>:</strong> Creates a *new*, empty file for writing. If a file with the same name already exists, its contents are discarded (deleted). It positions the file pointer at the beginning of the new, empty file.</li>
                            </ul>

                            <h5>(b) Advantages of Loop Control Structures</h5>
                            <ol>
                                <li><strong>Code Reusability/Reduction:</strong> Loops allow a block of code to be executed multiple times without rewriting it, making the code shorter, cleaner, and easier to maintain.</li>
                                <li><strong>Automation of Repetitive Tasks:</strong> They automate tasks that need to be performed repeatedly, such as processing elements in an array, reading multiple inputs, or iterating until a condition is met.</li>
                                <li><strong>Efficiency:</strong> Processing data iteratively within a loop is generally more efficient in terms of code size and sometimes execution speed compared to manually repeating code blocks.</li>
                            </ol>
                            *(Note: Only two advantages were required)*

                            <h5>(c) Algorithm to Remove Element from Stack (Pop)</h5>
                            <p>Assuming a stack implemented with an array `stackArray` of size `MAX_SIZE` and a `top` pointer indicating the index of the top element (or -1 if empty).</p>
                            <pre><code class="language-plaintext">
Algorithm Pop(stackArray, top):
1. Check for Stack Underflow:
   IF top < 0 THEN
      PRINT "Stack Underflow: Cannot remove element from empty stack."
      RETURN error_indicator (e.g., null or a special value)
   END IF

2. Retrieve Top Element:
   elementToRemove = stackArray[top]

3. Decrement Top Pointer:
   top = top - 1

4. Return Removed Element:
   RETURN elementToRemove
End Algorithm
                            </code></pre>

                            <h5>(d) C Program: Sum of Digits (Recursive)</h5>
                            <pre><code class="language-c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; // For abs()

// Recursive function to calculate sum of digits
int sumDigits(int n) {
    n = abs(n); // Handle potential negative input

    // Base case: if the number has only one digit
    if (n < 10) {
        return n;
    }
    // Recursive step: sum the last digit with the sum of the rest
    else {
        return (n % 10) + sumDigits(n / 10);
    }
}

int main() {
    int number;
    int totalSum;

    // Prompt user for input
    printf("Enter an integer: ");
    scanf("%d", &number);

    // Calculate the sum using the recursive function
    totalSum = sumDigits(number);

    // Output the result
    printf("The total sum of the digits is: %d\n", totalSum);

    return 0;
}
                            </code></pre>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 4 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) Outline four properties of an array data structure. (2 marks)</p> <!-- Mark allocation seems low -->
                        <p>(ii) The following is a C program segment. Use it answer the question that follows.</p>
                        <pre><code class="language-c">#include&lt;stdio.h&gt; // Assumed header

// Function signature seems incorrect C syntax (references '&' in return and params)
// Interpreting as intent to find max of two integers passed by reference
int max(int *x, int *y) { // Corrected signature using pointers
    if (*x > *y)
        return *x;
    else
        return *y;
}

int main() { // Added main function
    int a, b; // Assume a and b are initialized/read
    // max(a,b); // Calling max without pointers and ignoring return value
    int result = max(&a, &b); // Corrected call passing addresses
    // Use result...
    return 0;
}</code></pre>
                        <p>Interpret the program. (3 marks)</p>
                        <p>(b) Tom, an IT student was given a task to test a Pascal program under development. Explain two characteristics that could help him ascertain that the program contains a function. (4 marks)</p>
                        <p>(c) (i) Write a Pascal program that could be used to generate squares of even integers between 12 and 30. Use Repeat .... Until loop. (4 marks)</p>
                        <p>(ii) Explain a circumstance that makes goto statement unpopular. (2 marks)</p>
                        <p>(d) (i) Construct a binary tree for the following nodes 20, 10, 21, 5, 9, 4, 17. (2 marks)</p>
                        <p>(ii) With reference to the binary tree constructed in (i), explain each of the following terms:</p>
                        <ul>
                            <li>I. siblings; (1 mark)</li>
                            <li>II. ancestors; (1 mark)</li>
                            <li>III. terminal. (1 mark)</li>
                        </ul>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) (i) Properties of Array Data Structure</h5>
                            <ol>
                                <li><strong>Homogeneous Elements:</strong> All elements stored in an array must be of the same data type (e.g., all integers, all characters).</li>
                                <li><strong>Fixed Size:</strong> In many languages (like standard Pascal and C arrays), the size of the array is fixed at the time of declaration and cannot be changed during program execution.</li>
                                <li><strong>Contiguous Memory:</strong> Array elements are stored in adjacent memory locations, allowing for efficient access based on index.</li>
                                <li><strong>Indexed Access:</strong> Elements are accessed directly using a numerical index (or subscript), typically starting from 0 or 1 depending on the language.</li>
                            </ol>
                            *(Note: Mark allocation of 2 marks for four properties seems low)*

                            <h5>(a) (ii) Interpretation of C Program Segment</h5>
                            <p>The C code defines a function named `max` that takes pointers to two integers (`*x` and `*y`) as input. It compares the values stored at the memory locations pointed to by `x` and `y`. It returns the larger of the two integer values. The `main` function demonstrates how to call this `max` function: it declares two integer variables `a` and `b`, then calls `max` by passing the memory addresses of `a` and `b` (using the `&` operator). The return value (the maximum of the values stored in `a` and `b`) is stored in the `result` variable. The original code had syntax issues in the function signature and call, which have been interpreted and corrected in the provided segment to reflect the likely intent of finding the maximum of two integers passed by reference (using pointers).</p>

                            <h5>(b) Characteristics of a Pascal Function</h5>
                            <ol>
                                <li><strong>Return Value Type Declaration:</strong> A function declaration explicitly specifies the data type of the value it will return using a colon (`:`) followed by the type after the parameter list (e.g., `function CalculateSum(a, b: integer): integer;`). Procedures, in contrast, do not have a return type specified in their header.</li>
                                <li><strong>Assignment to Function Name:</strong> Inside the function's body, there must be at least one assignment statement where the function's identifier (its name) is assigned the value that the function is intended to return (e.g., `CalculateSum := a + b;`). Procedures do not assign values to their own names.</li>
                            </ol>
                            *(Note: Only two characteristics were required)*

                            <h5>(c) (i) Pascal Program: Squares of Even Integers (12-30)</h5>
                            <pre><code class="language-pascal">
program EvenSquares;

var
  number, square: integer;

begin
  writeln('Squares of even integers between 12 and 30:');
  number := 12; // Start with the first even number in the range

  repeat
    square := number * number;
    writeln(number, '^2 = ', square);
    number := number + 2; // Move to the next even number
  until number > 30; // Continue until the number exceeds 30

  readln; // Pause
end.
                            </code></pre>

                            <h5>(c) (ii) Unpopularity of `goto` Statement</h5>
                            <p>The `goto` statement is unpopular primarily because it leads to unstructured code, often referred to as "spaghetti code". It allows unconditional jumps to arbitrary points (labels) within a program, making the program flow difficult to follow, debug, and maintain. Overuse of `goto` breaks the principles of structured programming (sequence, selection, iteration) and can easily create complex, tangled logic that is prone to errors.</p>

                            <h5>(d) (i) Binary Tree Construction</h5>
                            <p>Nodes: 20, 10, 21, 5, 9, 4, 17</p>
                            <p>Assuming standard Binary Search Tree (BST) insertion rules (left < parent, right >= parent):</p>
                            <pre class="diagram-code">
        20
       /  \
      10   21
     /  \
    5    17
   / \
  4   9
                            </pre>

                            <h5>(d) (ii) Binary Tree Terms</h5>
                            <ul>
                                <li><strong>I. Siblings:</strong> Nodes that share the same parent node. In the tree above, nodes 10 and 21 are siblings (parent 20). Nodes 5 and 17 are siblings (parent 10). Nodes 4 and 9 are siblings (parent 5).</li>
                                <li><strong>II. Ancestors:</strong> The ancestors of a node are all the nodes on the path from the root to that node (excluding the node itself). For example, the ancestors of node 9 are node 5, node 10, and node 20. The ancestor of node 17 is node 10 and node 20.</li>
                                <li><strong>III. Terminal (Leaf) Node:</strong> A node that has no children. In the tree above, the terminal nodes are 4, 9, 17, and 21.</li>
                            </ul>
                        </div>
                    </div>
                </div>

                 <div class="question">
                    <h3>Question 5 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Explain the function of default statement in a C programming language. (2 marks)</p>
                        <p>(b) With the aid of a flowchart, describe the REPEAT...UNTIL loop as used in Pascal programming. (4 marks)</p>
                        <p>(c) (i) Outline four characteristics of assembly programming language. (4 marks)</p>
                        <p>(ii) Explain three reasons for developing a computer program. (6 marks)</p>
                        <p>(d) The following is a program written by a student using C programming language. The program could not run due to errors.</p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt; // Corrected header name

void main() { // Standard C uses int main()
    float i, j;
    printf ("input two integers"); // Prompting for integers but using float
    scanf ("%f %f", &i, &j); // Corrected format specifiers and added &
    printf("\n addition=%f subtraction=%f\n", i + j, i - j); // Corrected format specifiers
    // Missing return 0; for int main()
}</code></pre>
                        <p>Identify eight errors in the program. (4 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) Function of `default` Statement in C</h5>
                            <p>The `default` statement is used within a `switch` control structure in C. It provides a block of code (case) that will be executed if none of the other `case` labels match the value of the expression being evaluated in the `switch`. It acts as a catch-all for values not explicitly handled by other cases. It is optional, but recommended for handling unexpected values.</p>

                            <h5>(b) REPEAT...UNTIL Loop Flowchart</h5>
                            <pre class="diagram-code">
+---------------------+
│ START LOOP          │
+----------+----------+
           │
           ▼
+----------+----------+
│ Execute Loop Body   │
│ (Statements)        │
+----------+----------+
           │
           ▼
+----------+----------+ Yes
│ Condition Met?      │◄----┐
│ (UNTIL condition)   │    │ No
+---------------------+    │
           │                 │
           └-----------------┘
           │ Yes
           ▼
+----------+----------+
│ END LOOP            │
+---------------------+
                            </pre>
                            <p>Description: The `REPEAT...UNTIL` loop first executes the block of statements within its body *at least once*. After executing the body, it evaluates the specified `UNTIL` condition. If the condition is `FALSE`, the loop repeats, executing the body again. If the condition is `TRUE`, the loop terminates, and program execution continues with the statement following the `UNTIL` keyword.</p>

                            <h5>(c) (i) Characteristics of Assembly Language</h5>
                            <ol>
                                <li><strong>Low-Level:</strong> It is very close to machine code, representing processor instructions directly using mnemonics.</li>
                                <li><strong>Machine-Dependent:</strong> Assembly language is specific to a particular processor architecture (e.g., x86, ARM); code written for one processor is generally not compatible with another.</li>
                                <li><strong>Mnemonic Opcodes:</strong> Uses symbolic names (mnemonics like `MOV`, `ADD`, `JMP`) for machine instructions, making it more readable than raw machine code.</li>
                                <li><strong>Symbolic Addressing:</strong> Allows the use of labels (symbols) to represent memory addresses and jump targets, simplifying coding compared to using absolute addresses.</li>
                            </ol>

                            <h5>(c) (ii) Reasons for Developing a Computer Program</h5>
                            <ol>
                                <li><strong>Automation:</strong> To automate repetitive, time-consuming, or complex tasks, increasing efficiency and reducing manual effort (e.g., calculating payroll, processing large datasets).</li>
                                <li><strong>Problem Solving:</strong> To solve specific problems that are difficult or impossible to solve manually or with existing tools (e.g., simulating complex systems, optimizing routes, analyzing scientific data).</li>
                                <li><strong>Innovation/New Capabilities:</strong> To create new functionalities, services, or products that were not previously possible (e.g., new communication methods, entertainment software, data analysis tools).</li>
                                <li><strong>Efficiency/Optimization:</strong> To perform tasks faster, more accurately, or using fewer resources than manual methods or older software.</li>
                                <li><strong>Data Management:</strong> To store, retrieve, organize, and process large amounts of information effectively.</li>
                            </ol>
                            *(Note: Only three reasons were required)*

                            <h5>(d) Errors in C Program</h5>
                            <ol>
                                <li><strong>Line 169 (`#include &lt;stdio.h&gt;`):</strong> Missing `#` before `include`. (Corrected in provided code comment).</li>
                                <li><strong>Line 171 (`void main()`):</strong> Standard C main function should return `int`, not `void`. Should be `int main()`.</li>
                                <li><strong>Line 172 (`float i, j;`):</strong> Variables declared as `float`.</li>
                                <li><strong>Line 173 (`printf ("input two integers");`):</strong> Prompt asks for integers, but variables are floats.</li>
                                <li><strong>Line 174 (`scanf ("%f %f", i, j);`):</strong> Missing `&` before `i` and `j`. `scanf` requires addresses to store the input values. Should be `scanf("%f %f", &i, &j);`.</li>
                                <li><strong>Line 174 (Data Type Mismatch):</strong> Using `%f` format specifiers which match the `float` variables, but the prompt asked for integers. If integers were intended, variables should be `int` and specifiers `%d`.</li>
                                <li><strong>Line 175 (`printf("\n addition=%f subtraction=%f\n", i + j, i - j);`):</strong> Correct format specifiers (`%f`) used for the float results. (This line is technically correct given the float variables, but inconsistent with the prompt).</li>
                                <li><strong>Line 176 (Missing `return 0;`):</strong> Since `main` should return `int`, it needs a `return 0;` statement at the end to indicate successful execution.</li>
                            </ol>
                            *(Note: Identified 8 potential issues based on standard C practices and inconsistency)*
                        </div>
                    </div>
                </div>

                 <div class="question">
                    <h3>Question 6 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline two similarities between a procedure and a function as used in programming. (2 marks)</p>
                        <p>(b) Explain three typical errors that are likely to occur during file I/O operations in a program. (6 marks)</p>
                        <p>(c) Differentiate between merge sort and quick sort techniques as used in programming. (4 marks)</p>
                        <p>(d) (i) The following are names of students in a programming class: Leonard, Bancy, Faith, Olive, Quinter, Alice, Patrick, Grace, Helen and Mercy.</p>
                        <p>Represent them in a binary tree. (5 mark)</p>
                        <p>(ii) State the result generated when the tree is traversed using the post order strategy. (3 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) Similarities between Procedure and Function</h5>
                            <ol>
                                <li><strong>Subprograms:</strong> Both are named blocks of code (subprograms or subroutines) designed to perform a specific task, promoting modularity and code reuse.</li>
                                <li><strong>Parameter Passing:</strong> Both can accept input parameters (arguments) passed from the calling code, allowing them to operate on different data.</li>
                                <li><strong>Local Variables:</strong> Both can declare their own local variables that exist only within the scope of the procedure or function.</li>
                            </ol>
                            *(Note: Only two similarities were required)*

                            <h5>(b) Typical File I/O Errors</h5>
                            <ol>
                                <li><strong>File Not Found:</strong> Attempting to open a file for reading (e.g., using `Reset` in Pascal or `fopen` with "r" mode in C) when the specified file does not exist in the expected location.</li>
                                <li><strong>Permission Denied:</strong> Trying to open or write to a file for which the program does not have the necessary operating system permissions (e.g., trying to write to a read-only file or a protected directory).</li>
                                <li><strong>End-of-File (EOF) Reached Unexpectedly:</strong> Attempting to read data from a file after the end of the file has already been reached, often leading to errors or unpredictable behavior if not handled correctly (e.g., using `EOF()` function in Pascal or checking `feof()`/return values in C).</li>
                                <li><strong>Disk Full:</strong> Trying to write data to a file when the storage device (disk) has run out of space.</li>
                                <li><strong>Invalid File Operation:</strong> Attempting an operation inappropriate for the mode the file was opened in (e.g., trying to write to a file opened only for reading).</li>
                            </ol>
                            *(Note: Only three errors were required)*

                            <h5>(c) Merge Sort vs. Quick Sort</h5>
                            <ul>
                                <li><strong>Merge Sort:</strong>
                                    <ul>
                                        <li><strong>Strategy:</strong> A "Divide and Conquer" algorithm. It recursively divides the list into halves until sublists of size 1 are reached, then merges these sorted sublists back together.</li>
                                        <li><strong>Performance:</strong> Guaranteed O(n log n) time complexity in all cases (worst, average, best).</li>
                                        <li><strong>Space:</strong> Requires additional memory (typically O(n)) for the merging process (not in-place).</li>
                                        <li><strong>Stability:</strong> Stable sort (maintains the relative order of equal elements).</li>
                                    </ul>
                                </li>
                                <li><strong>Quick Sort:</strong>
                                    <ul>
                                        <li><strong>Strategy:</strong> Also "Divide and Conquer". It picks a 'pivot' element and partitions the other elements into two sub-arrays according to whether they are less than or greater than the pivot. It then recursively sorts the sub-arrays.</li>
                                        <li><strong>Performance:</strong> Average time complexity is O(n log n), but worst-case is O(n²), which can occur if the pivot selection is poor (e.g., always picking the smallest/largest element in an already sorted list).</li>
                                        <li><strong>Space:</strong> Typically uses O(log n) auxiliary space for the recursion stack (more in-place than merge sort).</li>
                                        <li><strong>Stability:</strong> Not inherently stable.</li>
                                    </ul>
                                </li>
                            </ul>

                            <h5>(d) (i) Binary Tree Representation of Names</h5>
                            <p>Names: Leonard, Bancy, Faith, Olive, Quinter, Alice, Patrick, Grace, Helen, Mercy.</p>
                            <p>Assuming insertion order determines structure (not alphabetical BST):</p>
                            <pre class="diagram-code">
          Leonard
         /       \
      Bancy       Faith
     /     \     /     \
  Alice   Grace Olive   Patrick
         /     \       /
      Helen   Mercy Quinter

(This is one possible structure based on sequential insertion, filling level by level. Other structures are possible depending on insertion rules.)
</pre>
                            <p>Alternatively, if building a Binary Search Tree (alphabetical order):</p>
                            <pre class="diagram-code">
          Leonard
         /       \
      Bancy       Olive
     /     \     /     \
  Alice   Faith Mercy   Patrick
         /     \         \
      Grace   Helen       Quinter
</pre>

                            <h5>(d) (ii) Post Order Traversal</h5>
                            <p>Post order traversal visits Left subtree, then Right subtree, then the Root node.</p>
                            <p>For the BST structure:</p>
                            <pre class="diagram-code">
Traversal Order:
1. Left subtree of Bancy: Alice -> Grace -> Helen -> Faith -> Bancy
2. Right subtree of Olive: Mercy -> Quinter -> Patrick -> Olive
3. Root: Leonard

Result: Alice, Grace, Helen, Faith, Bancy, Mercy, Quinter, Patrick, Olive, Leonard
</pre>
                        </div>
                    </div>
                </div>

                 <div class="question">
                    <h3>Question 7 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Patrick, a programmer, developed a program for his client. Outline four ways that he could make the program easy to read and understandable. (4 marks)</p>
                        <p>(b) Maria decided to use a compiler rather than an interpreter during program translation. Outline four reasons that could have led her to make this decision. (4 marks)</p>
                        <p>(c) A student is to develop a program that would prompt a user to enter two integers. The program should then compute the difference between the two integers. The program displays the results when it is positive, otherwise it displays the message “Negative Result”.</p>
                        <p>Write the pseudocode that the student would use to design this program. (5 marks)</p>
                        <p>(d) James, an ICT student, was given a program to write using Pascal programming language.</p>
                        <ul>
                            <li>(i) Outline the order in which he would declare the categories of variables in the program. (3 marks)</li>
                            <li>(ii) Outline four rules that he should observe when composing the identifiers in the program. (4 marks)</li>
                        </ul>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) Making Programs Easy to Read/Understandable</h5>
                            <ol>
                                <li><strong>Meaningful Identifier Names:</strong> Use descriptive names for variables, constants, functions, and procedures (e.g., `studentScore` instead of `s`, `calculateAverage` instead of `calc`).</li>
                                <li><strong>Comments:</strong> Add comments to explain complex logic, the purpose of code sections, or assumptions made. Avoid over-commenting obvious code.</li>
                                <li><strong>Consistent Indentation and Formatting:</strong> Use consistent indentation (e.g., spaces or tabs) and formatting (e.g., spacing around operators, brace placement) to visually structure the code and make blocks clear.</li>
                                <li><strong>Modularity (Functions/Procedures):</strong> Break down large programs into smaller, reusable functions or procedures, each responsible for a specific task. This improves organization and makes code easier to test and debug.</li>
                                <li><strong>Avoid "Magic Numbers":</strong> Use named constants instead of embedding literal values directly in the code (e.g., `const MaxStudents = 30;` instead of using `30` directly).</li>
                            </ol>
                            *(Note: Only four ways were required)*

                            <h5>(b) Reasons for Using a Compiler over Interpreter</h5>
                            <ol>
                                <li><strong>Execution Speed:</strong> Compilers translate the entire source code into machine code (or an intermediate code) *before* execution. This resulting machine code runs directly on the processor, generally leading to much faster execution compared to interpreters, which translate and execute line by line at runtime.</li>
                                <li><strong>Standalone Executable:</strong> Compilers typically produce a standalone executable file that can be distributed and run on target machines without needing the compiler or the original source code. Interpreters usually require the interpreter itself to be present along with the source code to run the program.</li>
                                <li><strong>Code Optimization:</strong> Compilers often perform various optimizations on the code during the compilation process (e.g., removing redundant code, optimizing loops) which can further improve performance and efficiency.</li>
                                <li><strong>Error Detection (Compile-time):</strong> Compilers check the entire source code for syntax errors and some type errors before producing an executable. This allows many errors to be caught early in the development cycle, before the program is even run. Interpreters usually find errors only when the specific line containing the error is executed.</li>
                            </ol>

                            <h5>(c) Pseudocode: Difference of Two Integers</h5>
                            <pre><code class="language-plaintext">
BEGIN
  DECLARE integer1, integer2, difference AS Integer

  DISPLAY "Enter the first integer: "
  INPUT integer1

  DISPLAY "Enter the second integer: "
  INPUT integer2

  difference = integer1 - integer2

  IF difference > 0 THEN
    DISPLAY "The difference is: ", difference
  ELSE
    DISPLAY "Negative Result"
  END IF
END
                            </code></pre>

                            <h5>(d) (i) Pascal Variable Declaration Order</h5>
                            <p>In standard Pascal, the declaration section (`VAR`) typically follows a specific order, although strict enforcement might vary slightly between compilers. The general convention is:</p>
                            <ol>
                                <li><strong>Constants (`CONST`):</strong> Declared first, before types or variables.</li>
                                <li><strong>Types (`TYPE`):</strong> User-defined types (like arrays, records, enumerations) are declared after constants.</li>
                                <li><strong>Variables (`VAR`):</strong> Variables are declared last, using either standard types (Integer, Real, Char, Boolean) or previously defined custom types.</li>
                            </ol>
                            <p>Example Structure:</p>
                            <pre><code class="language-pascal">
PROGRAM Example;
CONST
  MaxVal = 100;
TYPE
  NumArray = array[1..MaxVal] of Integer;
VAR
  count: Integer;
  isValid: Boolean;
  scores: NumArray;
BEGIN
  { ... program logic ... }
END.
                            </code></pre>
                            *(Note: The question asks for categories of *variables*, but the standard Pascal declaration order includes CONST and TYPE before VAR)*

                            <h5>(d) (ii) Rules for Composing Identifiers (Pascal)</h5>
                            <ol>
                                <li><strong>Start with a Letter:</strong> Identifiers must begin with an alphabetical character (A-Z, a-z).</li>
                                <li><strong>Subsequent Characters:</strong> After the first letter, identifiers can consist of letters (A-Z, a-z), digits (0-9), and often the underscore character (`_`). Spaces and other special symbols are not allowed.</li>
                                <li><strong>No Reserved Words:</strong> Identifiers cannot be the same as Pascal's reserved words (keywords) like `BEGIN`, `END`, `IF`, `THEN`, `WHILE`, `VAR`, `PROGRAM`, etc.</li>
                                <li><strong>Case Insensitivity (Usually):</strong> Standard Pascal is generally case-insensitive, meaning `myVariable`, `MyVariable`, and `myvariable` refer to the same identifier. However, maintaining consistent capitalization is good practice.</li>
                                <li><strong>Length Limit (Compiler Dependent):</strong> While standard Pascal didn't specify a strict limit, practical limits exist depending on the compiler (often very long, e.g., 63 or more characters are significant).</li>
                            </ol>
                            *(Note: Only four rules were required)*
                        </div>
                    </div>
                </div>

                 <div class="question">
                    <h3>Question 8 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Cynthia tested a program and she encountered an error when she entered a zero value as input for a mathematical expression.</p>
                        <ul>
                            <li>(i) Describe the type of error that occurred. (2 marks)</li>
                            <li>(ii) State the possible consequence when the error occurs. (1 mark)</li>
                        </ul>
                        <p>(b) Outline two functions of technical documentation in programming. (4 marks)</p>
                        <p>(c) Outline the procedure that would be followed before performing each of the following in data structures:</p>
                        <ul>
                            <li>(i) Adding an element in a stack; (3 marks)</li>
                            <li>(ii) Removing an element from a queue. (3 marks)</li>
                        </ul>
                        <p>(d) The interest accrued I for a principal amount P after period of time T at the rate R is given by the formula I = P × R × T.</p>
                        <p>Write a Pascal program that prompts a user to enter the principal amount in the main program and then pass this value to a procedure named compute. The procedure calculates the interest at a rate of 12% per annum for a period of 5 years. The procedure then returns the interest to main program for output. (7 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                            <h5>(a) Error with Zero Input</h5>
                            <ul>
                                <li><strong>(i) Type of Error:</strong> This is likely a <strong>runtime error</strong>, specifically a logical error related to division by zero. If the mathematical expression involved dividing by the input value, entering zero would cause this error.</li>
                                <li><strong>(ii) Consequence:</strong> The most common consequence of a division-by-zero error is that the program will <strong>crash</strong> or terminate abnormally, often displaying an error message like "Floating point error" or "Division by zero".</li>
                            </ul>

                            <h5>(b) Functions of Technical Documentation</h5>
                            <ol>
                                <li><strong>System Understanding:</strong> Provides detailed information about the program's architecture, design, algorithms, data structures, and APIs, enabling developers (including future maintainers) to understand how the system works internally.</li>
                                <li><strong>Maintenance and Debugging:</strong> Serves as a reference guide for developers maintaining or debugging the software, helping them locate issues, understand dependencies, and make modifications correctly without introducing new problems.</li>
                                <li><strong>Integration:</strong> Describes how the software component interacts with other systems or components, facilitating integration efforts.</li>
                                <li><strong>Knowledge Transfer:</strong> Helps transfer knowledge about the system to new team members or stakeholders.</li>
                            </ol>
                            *(Note: Only two functions were required)*

                            <h5>(c) Procedures for Stack and Queue Operations</h5>
                            <ul>
                                <li><strong>(i) Adding an Element to a Stack (Push):</strong>
                                    <ol>
                                        <li>Check for Stack Overflow: Verify if the stack is already full (e.g., if `top` pointer is at `MAX_SIZE - 1`). If full, report an error and stop.</li>
                                        <li>Increment Top Pointer: Increase the `top` pointer by 1 (e.g., `top = top + 1`).</li>
                                        <li>Insert Element: Place the new element at the array index indicated by the updated `top` pointer (e.g., `stackArray[top] = newElement`).</li>
                                    </ol>
                                </li>
                                <li><strong>(ii) Removing an Element from a Queue (Dequeue):</strong>
                                    <ol>
                                        <li>Check for Queue Underflow: Verify if the queue is empty (e.g., if `front` pointer is invalid or `size` is 0). If empty, report an error and stop.</li>
                                        <li>Retrieve Front Element: Get the element at the `front` of the queue (e.g., `elementToRemove = queueArray[front]`).</li>
                                        <li>Update Front Pointer: Advance the `front` pointer to the next position (often using modular arithmetic for circular queues, e.g., `front = (front + 1) % MAX_SIZE`).</li>
                                        <li>(Optional: Decrement size counter if used).</li>
                                        <li>Return Removed Element.</li>
                                    </ol>
                                </li>
                            </ul>

                            <h5>(d) Pascal Program: Interest Calculation with Procedure</h5>
                            <pre><code class="language-pascal">
program InterestCalculator;

var
  principal: real;
  calculatedInterest: real;

// Procedure to compute interest
// Takes principal as input (value parameter)
// Returns interest via output (VAR parameter)
procedure compute(P: real; var I: real);
const
  Rate = 0.12; // 12% per annum
  Time = 5;    // 5 years
begin
  I := P * Rate * Time; // Calculate interest
end;

begin
  // Prompt user for principal amount
  write('Enter the principal amount: ');
  readln(principal);

  // Call the procedure to calculate interest
  compute(principal, calculatedInterest); // Pass principal, receive interest in calculatedInterest

  // Output the result from the main program
  writeln; // Blank line
  writeln('Principal Amount: ', principal:0:2);
  writeln('Interest Rate: 12% per annum');
  writeln('Time Period: 5 years');
  writeln('Calculated Interest: ', calculatedInterest:0:2);

  readln; // Pause to see output
end.
                            </code></pre>
                        </div>
                    </div>
                </div>

            </section>

            <div class="paper-navigation bottom"><a href="2012july.html" class="btn">Previous Paper</a><a href="index.html" class="btn">Home</a><a href="2014july.html" class="btn">Next Paper</a></div>
        </main>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 Subject Past Papers Collection | Kenya National Examinations Council</p>
        </div>
    </footer>
</body>
</html>