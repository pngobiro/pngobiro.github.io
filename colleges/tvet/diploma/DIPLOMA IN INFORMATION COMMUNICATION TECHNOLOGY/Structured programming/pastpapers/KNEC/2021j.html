<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structured Programming - July 2021 | KNEC Past Papers</title>
    <link rel="stylesheet" href="styles.css">
    <script src="js/sidebar-navigation.js" defer></script>
    <!-- Add MathJax scripts if needed -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>STRUCTURED PROGRAMMING</h1>
            <h2>July 2021</h2>
            <div class="exam-details">
                <p>Paper Code: 2920/103</p>
                <p>Duration: 3 hours</p>
                <p>Module: MODULE I</p>
            </div>
        </div>
    </header>

    <div class="container main-content">
        <div class="sidebar">
            <div class="sidebar-header"><h3>Past Papers</h3></div>
            <nav class="sidebar-nav">
                <ul>
                    <li>
                        <h4>2022</h4>
                        <ul><li><a href="2022j.html">July 2022</a></li></ul>
                    </li>
                    <li>
                        <h4>2021</h4>
                        <ul>
                            <li><a href="2021n.html">November 2021</a></li>
                            <li><a href="2021j.html">July 2021</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2019</h4>
                        <ul><li><a href="2019july.html">July 2019</a></li></ul>
                    </li>
                    <li>
                        <h4>2018</h4>
                        <ul><li><a href="2018j.html">July 2018</a></li></ul>
                    </li>
                    <li>
                        <h4>2017</h4>
                        <ul>
                            <li><a href="2017nov.html">November 2017</a></li>
                            <li><a href="2017july.html">July 2017</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2016</h4>
                        <ul>
                            <li><a href="2016nov.html">November 2016</a></li>
                            <li><a href="2016july.html">July 2016</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2015</h4>
                        <ul><li><a href="2015nov.html">November 2015</a></li></ul>
                    </li>
                    <li>
                        <h4>2014</h4>
                        <ul>
                            <li><a href="2014n.html">November 2014</a></li>
                            <li><a href="2014july.html">July 2014</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2013</h4>
                        <ul><li><a href="2013nov.html">November 2013</a></li></ul>
                    </li>
                    <li>
                        <h4>2012</h4>
                        <ul><li><a href="2012july.html">July 2012</a></li></ul>
                    </li>
                    <li>
                        <h4>2011</h4>
                        <ul>
                            <li><a href="2011n.html">November 2011</a></li>
                            <li><a href="2011july.html">July 2011</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </div>
        <main>
            <div class="paper-navigation top"><a href="2019july.html" class="btn">Previous Paper</a><a href="2021n.html" class="btn">Next Paper</a></div>

            <section class="paper-intro">
                <h3>INSTRUCTIONS TO THE CANDIDATES</h3>
                <p>This paper consists of EIGHT questions.</p>
                <p>Answer any FIVE questions in the answer booklet provided.</p>
                <p>Candidates should answer all questions in English.</p>
                <p>This paper consists of 4 printed pages.</p>
                <p>Candidates should check the question paper to ascertain that all the pages are printed as indicated and that no questions are missing.</p>
            </section>

            <section class="paper-content">
                <div class="question">
                    <h3>Question 1 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Study the following program and then answer the questions that follow.</p>
                        <pre><code>INC COUNT
MOVE TOTAL 20
ADD A, B</code></pre>
                        <p>(i) Identify the programming language used in this program. (1 mark)</p>
                        <p>(ii) Outline two advantages of the language identified in (i). (2 marks)</p>
                        <p>(b) Distinguish between local and global variables as used in programming. (4 marks)</p>
                        <p>(c) Write a program in Pascal language that computes and displays the product of two assigned values 20 and 40. (4 marks)</p>
                        <p>(d) (i) A college intends to store the following student’s details in a computer; name, age and address. Declare a Pascal language record that would store these details. (4 marks)</p>
                        <p>(ii) Write a program in C language that prompts a user to enter a student’s name and age. The program then writes the name and age into a text file. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) (i) Programming Language Identification:</strong></p>
                        <p>The language used is <strong>Assembly Language</strong>. Keywords like `INC` (increment), `MOVE` (move data), and `ADD` (addition) operating directly on registers or memory locations (like COUNT, TOTAL, A, B) are characteristic of assembly languages.</p>

                        <p><strong>(a) (ii) Advantages of Assembly Language:</strong></p>
                        <ul>
                            <li><strong>Speed/Efficiency:</strong> Code written in assembly can be highly optimized for a specific processor, often resulting in faster execution speed and smaller program size compared to high-level languages.</li>
                            <li><strong>Direct Hardware Access:</strong> Provides direct control over system hardware (processor registers, memory addresses, I/O ports), which is necessary for tasks like writing device drivers or low-level system programming.</li>
                            <li><strong>Resource Usage:</strong> Can be used to write programs that consume minimal memory and processing power, suitable for embedded systems or performance-critical applications.</li>
                        </ul>
                        <em>(Any two distinct advantages)</em>

                        <p><strong>(b) Local vs. Global Variables:</strong></p>
                        <ul>
                            <li><strong>Local Variables:</strong> Declared inside a specific function, procedure, or block of code. Their scope is limited to that block; they are only accessible and exist while that block is executing. They do not interfere with variables of the same name in other blocks.</li>
                            <li><strong>Global Variables:</strong> Declared outside of any specific function or procedure (often at the beginning of the program file). Their scope is typically the entire program file or even the whole program (depending on linkage rules). They can be accessed and potentially modified from any function within their scope, but this can lead to maintainability issues.</li>
                        </ul>

                        <p><strong>(c) Pascal Program (Product of 20 and 40):</strong></p>
                        <pre><code class="language-pascal">program CalculateProduct;
var
  num1, num2: Integer;
  product: Integer;
begin
  num1 := 20;
  num2 := 40;
  product := num1 * num2;

  Writeln('The product of ', num1, ' and ', num2, ' is: ', product);

  Readln; // Keep console window open
end.</code></pre>

                        <p><strong>(d) (i) Pascal Record Declaration (Student Details):</strong></p>
                        <pre><code class="language-pascal">TYPE
  TStudentRecord = record
    name: string[50]; // Or just 'string' in modern Pascal dialects
    age: Integer;
    address: string[100];
  end;

VAR
  student1: TStudentRecord;</code></pre>

                        <p><strong>(d) (ii) C Program (Write Student Name/Age to File):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; // For exit()
#include &lt;string.h&gt; // For strcspn

int main() {
    FILE *outFile;
    char name[100];
    int age;

    // Open the file for writing (creates or overwrites)
    outFile = fopen("student_info.txt", "w");
    if (outFile == NULL) {
        perror("Error opening file");
        return 1;
    }

    // Prompt user for input
    printf("Enter student's name: ");
    // Read name, potentially including spaces, safely
    if (fgets(name, sizeof(name), stdin) == NULL) {
         printf("Error reading name.\n");
         fclose(outFile);
         return 1;
    }
    // Remove trailing newline character from fgets if present
    name[strcspn(name, "\n")] = 0;


    printf("Enter student's age: ");
    if (scanf("%d", &age) != 1) {
        printf("Invalid age input.\n");
        // Clear input buffer before closing file
        int c;
        while ((c = getchar()) != '\n' && c != EOF);
        fclose(outFile);
        return 1;
    }

    // Write data to the file
    fprintf(outFile, "Name: %s\n", name);
    fprintf(outFile, "Age: %d\n", age);

    // Close the file
    fclose(outFile);

    printf("Student information written to student_info.txt\n");

    return 0;
}
</code></pre>
                        <p><em>Note: Using `fgets` for reading the name is safer than `scanf("%s", ...)` as it prevents buffer overflows and handles spaces. The `strcspn` part removes the newline that `fgets` often includes. Added string.h include and basic input buffer clearing after failed scanf.</em></p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 2 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) The following are program statements in C language. Use them to answer the question that follows: (2 marks)</p>
                        <p>(i) <code>x *= 5;</code></p>
                        <p>(ii) <code>x %= 3;</code></p>
                        <p>Given that the value of x is 60. State the output generated when each of the statement is executed.</p>
                        <p>(b) Differentiate between rewind() and getw() as used in C programming. (4 marks)</p>
                        <p>(c) Write a program in Pascal language that prompts a user to enter a character. Then the program determines whether the character input is a vowel or not and displays an appropriate message. Use case statement. (5 marks)</p>
                        <p>(d) (i) Explain two statements used to change the flow of execution in a C program loop. (4 marks)</p>
                        <p>(ii) Write a program in C language that displays even numbers up to a given number input. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) C Statement Execution (x = 60):</strong></p>
                        <ul>
                            <li><strong>(i) <code>x *= 5;</code></strong>
                                <ul>
                                    <li>This is shorthand for <code>x = x * 5;</code></li>
                                    <li>Calculation: <code>x = 60 * 5 = 300</code></li>
                                    <li>Output (if printed): <strong>300</strong></li>
                                </ul>
                            </li>
                            <li><strong>(ii) <code>x %= 3;</code></strong> (Assuming this executes *after* (i), so x is now 300)
                                <ul>
                                    <li>This is shorthand for <code>x = x % 3;</code> (Modulo operator gives the remainder of a division).</li>
                                    <li>Calculation: <code>x = 300 % 3 = 0</code> (300 divided by 3 has a remainder of 0).</li>
                                    <li>Output (if printed): <strong>0</strong></li>
                                </ul>
                                <em>(If statement (ii) executes independently with x=60: <code>x = 60 % 3 = 0</code>. Output: 0)</em>
                            </li>
                        </ul>

                        <p><strong>(b) `rewind()` vs. `getw()` (C File I/O):</strong></p>
                        <ul>
                            <li><strong><code>rewind(FILE *stream)</code>:</strong> This function repositions the file pointer associated with the given `stream` back to the beginning of the file. It's equivalent to `fseek(stream, 0L, SEEK_SET)` but also clears the end-of-file and error indicators for the stream. It does not read any data.</li>
                            <li><strong><code>getw(FILE *stream)</code>:</strong> This function reads the next binary integer (typically `int` size) from the specified input `stream`. It returns the integer read. It advances the file pointer past the integer read. It's generally considered less portable than using `fread` for binary integer input because the size and byte order of an `int` can vary between systems.</li>
                        </ul>

                        <p><strong>(c) Pascal Program (Vowel Check using Case):</strong></p>
                        <pre><code class="language-pascal">program CheckVowel;
uses
  SysUtils; // For UpperCase function

var
  inputChar: Char;
  isVowel: Boolean;

begin
  Write('Enter a single character: ');
  Readln(inputChar);

  // Convert to uppercase for easier checking
  inputChar := UpCase(inputChar);

  // Use Case statement to check if it's a vowel
  case inputChar of
    'A', 'E', 'I', 'O', 'U':
      isVowel := True;
  else
      isVowel := False;
  end; // end case

  // Display the result
  if isVowel then
    Writeln(inputChar, ' is a vowel.')
  else
    Writeln(inputChar, ' is not a vowel.');

  Readln; // Keep console window open
end.
</code></pre>

                        <p><strong>(d) (i) C Loop Flow Control Statements:</strong></p>
                        <ul>
                            <li><strong><code>break;</code>:</strong> Immediately terminates the innermost loop (<code>for</code>, <code>while</code>, <code>do...while</code>) or <code>switch</code> statement it is contained within. Program execution continues with the statement immediately following the terminated loop/switch.</li>
                            <li><strong><code>continue;</code>:</strong> Skips the rest of the current iteration of the innermost loop (<code>for</code>, <code>while</code>, <code>do...while</code>) it is contained within. Execution proceeds to the next iteration's condition check (for <code>while</code>/<code>do...while</code>) or the update expression (for <code>for</code> loops).</li>
                            <li><strong><code>goto label;</code>:</strong> Unconditionally transfers control to the statement marked with the specified `label` within the same function. Its use is strongly discouraged in structured programming as it makes code hard to follow and maintain.</li>
                        </ul>
                         <em>(Any two, typically break and continue)</em>

                        <p><strong>(d) (ii) C Program (Display Even Numbers):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int limit;
    int i;

    // Prompt user for the upper limit
    printf("Enter a positive integer limit: ");
    if (scanf("%d", &limit) != 1 || limit < 0) {
        printf("Invalid input. Please enter a positive integer.\n");
        return 1; // Indicate error
    }

    printf("Even numbers up to %d are:\n", limit);

    // Loop from 0 or 2 up to the limit, incrementing by 2
    // Start from 2 if 0 is not considered an even number for this context
    for (i = 2; i <= limit; i += 2) {
        printf("%d ", i);
    }
    // Alternatively, check each number:
    // for (i = 0; i <= limit; ++i) {
    //     if (i % 2 == 0) {
    //         printf("%d ", i);
    //     }
    // }

    printf("\n"); // Print a final newline

    return 0;
}
</code></pre>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 3 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) State four sorting techniques used in programming. (4 marks)</p>
                        <p>(b) (i) Describe the purpose of writeln; statement as used in Pascal programming language. (2 marks)</p>
                        <p>(ii) Write a program in Pascal language that prompts a user to enter the amount of money borrowed and the repayment period. The program then passes these values to a procedure, computes and displays the simple interest at rate of 14% per annum. Hint: interest = money borrowed x period x rate. (5 marks)</p>
                        <p>(c) Distinguish between call by reference and call by value as used in programming. (4 marks)</p>
                        <p>(d) The following Pascal program was created by a student during a practical lesson. Use it to answer the question that follows.</p>
                        <pre><code class="language-pascal">Program alpha (input, output);
Var
  X: char;
  y: integer;

Procedure beta(var x: char; var y: integer);
Begin
  y := ORD(x);
End;

Begin // Main program block
  x := 'A';
  Beta(x, y); // Call procedure beta
  Writeln('ASCII code for ', x, ' is ', y); // Corrected Writeln syntax
End.</code></pre>
                        <p>Interpret the program. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Sorting Techniques:</strong></p>
                        <ul>
                            <li>Bubble Sort</li>
                            <li>Selection Sort</li>
                            <li>Insertion Sort</li>
                            <li>Merge Sort</li>
                            <li>Quicksort</li>
                            <li>Heap Sort</li>
                        </ul>
                        <em>(Any four)</em>

                        <p><strong>(b) (i) Purpose of `writeln;` (Pascal):</strong></p>
                        <p>The `writeln;` statement, when used without any arguments, outputs a newline character to the standard output device (usually the console). This effectively moves the cursor to the beginning of the next line, allowing subsequent output to start on a new line or creating a blank line for formatting purposes.</p>

                        <p><strong>(b) (ii) Pascal Program (Simple Interest Procedure):</strong></p>
                        <pre><code class="language-pascal">program SimpleInterestCalculator;

var
  borrowedAmount: Real;
  repaymentYears: Real; // Period usually in years for annual rate

// Procedure to calculate and display simple interest
procedure CalculateAndDisplayInterest(amount: Real; periodYears: Real);
const
  ANNUAL_RATE = 0.14; // 14%
var
  interest: Real;
begin
  if (amount >= 0) and (periodYears >= 0) then
  begin
    interest := amount * periodYears * ANNUAL_RATE;
    Writeln('---------------------------------');
    Writeln('Amount Borrowed: ', amount:0:2);
    Writeln('Repayment Period (Years): ', periodYears:0:1);
    Writeln('Annual Interest Rate: ', ANNUAL_RATE * 100:0:0, '%');
    Writeln('Calculated Simple Interest: ', interest:0:2);
    Writeln('---------------------------------');
  end
  else
  begin
    Writeln('Error: Amount and period must be non-negative.');
  end;
end;

begin // Main program
  Write('Enter the amount of money borrowed: ');
  Readln(borrowedAmount);

  Write('Enter the repayment period in years: ');
  Readln(repaymentYears);

  // Call the procedure
  CalculateAndDisplayInterest(borrowedAmount, repaymentYears);

  Readln; // Keep console window open
end.
</code></pre>

                        <p><strong>(c) Call by Value vs. Call by Reference:</strong></p>
                        <ul>
                            <li><strong>Call by Value:</strong> When an argument is passed by value, a *copy* of the argument's actual value is made and passed to the function/procedure's parameter. Any modifications made to the parameter *inside* the function/procedure affect only the local copy and do *not* change the original argument variable in the calling code.</li>
                            <li><strong>Call by Reference:</strong> When an argument is passed by reference (e.g., using `VAR` in Pascal or pointers in C), the *memory address* of the original argument variable is passed to the function/procedure's parameter. Any modifications made to the parameter *inside* the function/procedure directly affect the original argument variable in the calling code because both the parameter and the original argument refer to the same memory location.</li>
                        </ul>

                        <p><strong>(d) Pascal Program Interpretation:</strong></p>
                        <ol>
                            <li>The program `alpha` is defined.</li>
                            <li>A character variable `X` and an integer variable `y` are declared globally.</li>
                            <li>A procedure `beta` is defined, which accepts a character `x` and an integer `y` *by reference* (indicated by `VAR`).</li>
                            <li>Inside `beta`, the integer parameter `y` is assigned the ASCII ordinal value of the character parameter `x` using the `ORD()` function.</li>
                            <li>The main program block begins.</li>
                            <li>The global variable `X` is assigned the character 'A'.</li>
                            <li>Procedure `beta` is called, passing the global variable `X` and the global variable `y` by reference.</li>
                            <li>Inside `beta`, the `y` parameter (which refers to the global `y`) is assigned `ORD('A')`, which is 65. The `x` parameter refers to the global `X`, but `X` is not modified within `beta`.</li>
                            <li>Control returns to the main block.</li>
                            <li>`Writeln` prints the string 'ASCII code for ', followed by the current value of the global `X` ('A'), followed by the string ' is ', followed by the current value of the global `y` (65).</li>
                        </ol>
                        <p><strong>Output:</strong></p>
                        <pre><code>ASCII code for A is 65</code></pre>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 4 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) Outline three reasons for preparing a program documentation. (3 marks)</p>
                        <p>(ii) Explain two inbuilt Pascal functions used to manipulate an enumerated data type. (4 marks)</p>
                        <p>(b) Outline the purpose of each of the following operators in a C program: (3 marks)</p>
                        <p>(i) <code>&&</code></p>
                        <p>(ii) <code>%</code></p>
                        <p>(iii) <code>!=</code></p>
                        <p>(c) Write a program in C language that prompts a user to enter a positive integer. The program then determines and outputs the factors of the integer. (5 marks)</p>
                        <p>(d) Write a program in Pascal language that generates the following output when executed: (5 marks)</p>
                        <pre><code>*
**
***
****
*****</code></pre>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) (i) Reasons for Program Documentation:</strong></p>
                        <ul>
                            <li><strong>Maintenance:</strong> Helps developers understand the code later to fix bugs or add features.</li>
                            <li><strong>Communication/Teamwork:</strong> Allows multiple developers to collaborate effectively by understanding the system's design and components.</li>
                            <li><strong>User Support/Training:</strong> Provides information for end-users on how to use the software (user manuals, tutorials).</li>
                            <li><strong>Knowledge Preservation:</strong> Captures design decisions and system knowledge that might otherwise be lost if developers leave.</li>
                            <li><strong>Quality Assurance:</strong> Facilitates testing and verification against requirements.</li>
                        </ul>
                        <em>(Any three distinct reasons - similar to 2021n Q4a(i))</em>

                        <p><strong>(a) (ii) Inbuilt Pascal Functions for Enumerated Types:</strong></p>
                        <ul>
                            <li><strong><code>Ord(enum_value)</code>:</strong> Returns the ordinal (integer) position of the enumerated value within its defined list (starting from 0).</li>
                            <li><strong><code>Pred(enum_value)</code>:</strong> Returns the predecessor (previous) value in the enumerated list. Causes a runtime error if called on the first value.</li>
                            <li><strong><code>Succ(enum_value)</code>:</strong> Returns the successor (next) value in the enumerated list. Causes a runtime error if called on the last value.</li>
                        </ul>
                         <em>(Any two)</em>

                        <p><strong>(b) Purpose of C Operators:</strong></p>
                        <ul>
                            <li><strong>(i) <code>&&</code> (Logical AND):</strong> Returns true (1) if *both* its left operand and its right operand evaluate to true (non-zero). Otherwise, it returns false (0). It uses short-circuit evaluation (if the left operand is false, the right operand is not evaluated).</li>
                            <li><strong>(ii) <code>%</code> (Modulo):</strong> Returns the integer remainder of the division of its left operand by its right operand. Both operands must be integers.</li>
                            <li><strong>(iii) <code>!=</code> (Not Equal To):</strong> Returns true (1) if its left operand is *not* equal to its right operand. Otherwise, it returns false (0).</li>
                        </ul>

                        <p><strong>(c) C Program (Factors of an Integer):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int number;
    int i;

    // Prompt user for a positive integer
    printf("Enter a positive integer: ");
    if (scanf("%d", &number) != 1 || number <= 0) {
        printf("Invalid input. Please enter a positive integer.\n");
        return 1; // Indicate error
    }

    printf("Factors of %d are: ", number);

    // Loop from 1 up to the number
    for (i = 1; i <= number; ++i) {
        // If i divides number exactly (remainder is 0), it's a factor
        if (number % i == 0) {
            printf("%d ", i);
        }
    }

    printf("\n"); // Print a final newline

    return 0;
}
</code></pre>

                        <p><strong>(d) Pascal Program (Asterisk Triangle Output):</strong></p>
                        <pre><code class="language-pascal">program PrintAsteriskTriangle;
var
  row, col: Integer; // Loop counters
begin
  for row := 1 to 5 do // Outer loop for rows
  begin
    for col := 1 to row do // Inner loop for columns (asterisks) in each row
    begin
      Write('*'); // Print an asterisk
    end;
    Writeln; // Move to the next line after printing asterisks for the row
  end;
  Readln; // Keep console window open
end.
</code></pre>
                        <p><em>(Note: This is similar to Q1(c) in 2021n, but uses '*' instead of '&')</em></p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 5 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) State the differences between r+ and w+ file commands as used in C programming. (4 marks)</p>
                        <p>(b) Describe two types of file organisation techniques that could be adopted during program writing. (4 marks)</p>
                        <p>(c) Write a Pascal program that prompts a user to read a number. The program checks to determine whether the number is a positive integer. The program then computes and outputs the square root of the number using a predefined function. (6 marks)</p>
                        <p>(d) Given the nodes: 6, 2, 5, 1, 7, 4 and 3:</p>
                        <p>(i) Construct a binary tree. (4 marks)</p>
                        <p>(ii) Write the output generated when the tree in (i) is traversed using pre-order traversal strategy. (2 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Differences between `r+` and `w+` File Modes (C):</strong></p>
                        <ul>
                            <li><strong><code>r+</code> (Read and Update):</strong>
                                <ul>
                                    <li>Opens an *existing* file for both reading and writing.</li>
                                    <li>If the file does not exist, `fopen()` fails and returns `NULL`.</li>
                                    <li>The initial file position for reading/writing is at the beginning of the file.</li>
                                    <li>Reading and writing can be interleaved, but typically requires an intervening file positioning function (`fseek`, `fsetpos`, `rewind`) between reads and writes, or vice-versa (except when switching from write to read if an `fflush` occurs implicitly or explicitly).</li>
                                </ul>
                            </li>
                            <li><strong><code>w+</code> (Write and Read - Truncate):</strong>
                                <ul>
                                    <li>Opens a file for both reading and writing.</li>
                                    <li>If the file *exists*, its contents are discarded (truncated to zero length).</li>
                                    <li>If the file does *not* exist, it is created.</li>
                                    <li>The initial file position is at the beginning of the (now empty or newly created) file.</li>
                                    <li>Reading and writing can be interleaved, subject to the same positioning rules as `r+`.</li>
                                </ul>
                            </li>
                        </ul>
                        <p><strong>Key Differences Summarized:</strong> `r+` requires the file to exist and preserves its content initially, while `w+` creates the file if needed but always discards existing content.</p>

                        <p><strong>(b) File Organisation Techniques:</strong></p>
                        <ul>
                            <li><strong>Sequential Organisation:</strong> Records are stored in a specific order, usually based on a key field. To access a record, the file must typically be read from the beginning up to the desired record. Suitable for batch processing where most records are processed in order. (e.g., magnetic tapes, simple text files processed line-by-line).</li>
                            <li><strong>Direct (or Random) Access Organisation:</strong> Records can be accessed directly using their physical address or a key-to-address transformation (hashing). This allows for fast retrieval of specific records without reading through others. Suitable for interactive applications requiring quick access to individual records. (e.g., magnetic disks, hash files).</li>
                            <li><strong>Indexed Sequential Organisation (ISAM/VSAM):</strong> A hybrid approach combining sequential storage with an index. Records are stored sequentially based on a key, but an index allows for relatively fast direct access to records or the starting point for sequential reading. Offers a balance between sequential processing efficiency and random access capability. (e.g., database systems often use variations of this).</li>
                        </ul>
                         <em>(Any two)</em>

                        <p><strong>(c) Pascal Program (Square Root of Positive Integer):</strong></p>
                        <pre><code class="language-pascal">program SquareRootPositiveInt;
uses
  Math; // Include Math unit for Sqrt function

var
  inputValue: Real; // Read as Real to handle potential non-integer input
  intValue: Integer;
  rootValue: Real;
  isPositiveInt: Boolean;

begin
  Write('Enter a number: ');
  Readln(inputValue);

  // Check if it's a positive integer
  isPositiveInt := False;
  if inputValue > 0 then // Check if positive
  begin
    // Check if it has no fractional part (is an integer)
    if Frac(inputValue) = 0.0 then
    begin
       intValue := Trunc(inputValue); // Convert to integer
       isPositiveInt := True;
    end;
  end;

  if isPositiveInt then
  begin
    // Calculate square root using the Sqrt function
    rootValue := Sqrt(intValue); // Or Sqrt(inputValue)

    // Display the result
    Writeln('The number ', intValue, ' is a positive integer.');
    Writeln('The square root is: ', rootValue:0:4); // Display with 4 decimal places
  end
  else
  begin
     Writeln('The number entered (', inputValue:0:4, ') is not a positive integer.');
  end;

  Readln; // Keep console window open
end.
</code></pre>
                        <p><em>Note: This program first checks if the input is positive and then if it's an integer by checking if its fractional part is zero.</em></p>

                        <p><strong>(d) Binary Tree Construction and Traversal:</strong></p>
                        <p>Nodes: 6, 2, 5, 1, 7, 4, 3</p>
                        <p><strong>(i) Binary Tree Construction (assuming standard BST rules):</strong></p>
                        <pre class="diagram-code">
      6
     / \
    2   7
   / \
  1   5
     /
    4
   /
  3
                        </pre>
                        <p><em>Insertion Steps: 6(root), 2(L), 5(L-R), 1(L-L), 7(R), 4(L-R-L), 3(L-R-L-L)</em></p>

                        <p><strong>(ii) Pre-order Traversal (Root, Left, Right):</strong></p>
                        <p>6 -> 2 -> 1 -> 5 -> 4 -> 3 -> 7</p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 6 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) Outline two operations that could be performed on a stack data structure. (2 marks)</p>
                        <p>(ii) Explain the purpose of a packed array in Pascal programming. (2 marks)</p>
                        <p>(b) (i) Outline three factors considered when selecting an appropriate programming language. (3 marks)</p>
                        <p>(ii) Explain each of the following approaches to programming: (4 marks)</p>
                        <p>(I) monolithic;</p>
                        <p>(II) visual.</p>
                        <p>(c) Differentiate between bubble and selection sort techniques. (4 marks)</p>
                        <p>(d) Write a segment code in C programming language that deletes an element from queue data structure. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) (i) Stack Operations:</strong></p>
                        <ul>
                            <li><strong>Push:</strong> Adding/inserting an element onto the top of the stack.</li>
                            <li><strong>Pop:</strong> Removing/deleting the element from the top of the stack.</li>
                            <li><strong>Peek (or Top):</strong> Viewing the top element of the stack without removing it.</li>
                            <li><strong>IsEmpty:</strong> Checking if the stack contains any elements.</li>
                            <li><strong>IsFull:</strong> Checking if the stack has reached its maximum capacity (relevant for array-based implementations).</li>
                        </ul>
                        <em>(Any two, typically Push and Pop)</em>

                        <p><strong>(a) (ii) Purpose of Packed Array (Pascal):</strong></p>
                        <p>The `PACKED` keyword in older Pascal versions was a suggestion to the compiler to store the array elements in a way that minimizes memory usage, potentially at the cost of slightly slower access time. For example, an array of characters or booleans might be stored with multiple elements per machine word instead of one element per word. In modern compilers, this keyword often has little or no effect as compilers perform optimizations automatically.</p>

                        <p><strong>(b) (i) Factors for Selecting Programming Language:</strong></p>
                        <ul>
                            <li><strong>Problem Domain/Application Type:</strong> Some languages are better suited for specific tasks (e.g., Python for data science, JavaScript for web front-end, C for system programming).</li>
                            <li><strong>Platform/Environment:</strong> The target operating system, hardware, or existing infrastructure might favor certain languages or have specific requirements.</li>
                            <li><strong>Developer Availability/Expertise:</strong> The skills and experience of the development team influence the choice.</li>
                            <li><strong>Performance Requirements:</strong> Critical applications might require languages that compile to efficient machine code (like C++) versus interpreted languages.</li>
                            <li><strong>Available Libraries/Frameworks/Tools:</strong> The ecosystem around a language can significantly speed up development.</li>
                            <li><strong>Maintainability & Scalability Needs:</strong> Language features supporting modularity, readability, and large-scale development might be important.</li>
                        </ul>
                        <em>(Any three distinct factors)</em>

                        <p><strong>(b) (ii) Programming Approaches:</strong></p>
                        <ul>
                            <li><strong>(I) Monolithic:</strong> A programming approach where the entire application is built as a single, large, tightly-coupled unit. All functionalities (user interface, business logic, data access) are part of the same codebase and often run within a single process. Changes often require recompiling and redeploying the entire application. (See also 2021n Q4a(i) for disadvantages).</li>
                            <li><strong>(II) Visual Programming:</strong> An approach that allows users to create programs by manipulating graphical elements (like icons, blocks, forms) rather than writing textual code. It often involves using a graphical user interface (GUI) builder and connecting predefined components or blocks to define program flow and behavior. Examples include Scratch, LabVIEW, and the GUI design aspects of environments like Visual Basic or Delphi.</li>
                        </ul>

                        <p><strong>(c) Bubble Sort vs. Selection Sort:</strong></p>
                        <ul>
                            <li><strong>Bubble Sort:</strong> Works by repeatedly stepping through the list, comparing adjacent elements, and swapping them if they are in the wrong order. Passes continue until no swaps are needed, indicating the list is sorted. Larger elements "bubble" up to the end of the list. It makes many swaps.</li>
                            <li><strong>Selection Sort:</strong> Works by repeatedly finding the minimum element from the unsorted part of the list and swapping it with the element at the beginning of the unsorted part. The sorted portion grows from the beginning. It makes fewer swaps than bubble sort (at most n-1 swaps) but still has O(n²) time complexity due to the comparisons needed to find the minimum in each pass.</li>
                        </ul>

                        <p><strong>(d) C Code Segment (Dequeue - Delete from Queue):</strong></p>
                        <p><em>Assumptions: Array-based circular queue implementation with `front`, `rear` indices, `count` for number of elements, and `queueArray`.</em></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;
#define MAX_SIZE 10 // Example size

// Assume these are declared globally or passed appropriately
int queueArray[MAX_SIZE];
int front = 0;
int rear = -1; // Or initialize front=0, rear=0 depending on specific implementation
int count = 0;

// Function to delete (dequeue) an element
int dequeue() {
    int item;

    if (count == 0) { // Check if queue is empty
        printf("Queue Underflow! Cannot delete.\n");
        return -1; // Return an error indicator
    } else {
        item = queueArray[front]; // Get the item from the front
        front = (front + 1) % MAX_SIZE; // Move front, wrap around if necessary
        count--; // Decrement the count of items
        printf("Dequeued item: %d\n", item);
        return item; // Return the dequeued item
    }
}

// Example usage (not part of the segment itself)
/*
int main() {
    // ... (code to enqueue some items first) ...
    dequeue();
    dequeue();
    return 0;
}
*/
</code></pre>
                        <p><em>Note: This is a basic segment. Robust implementations might handle the empty queue case differently (e.g., returning a boolean status and using a pointer parameter for the item). The specific initialization of `front` and `rear` and the empty/full conditions depend on the chosen circular queue implementation strategy.</em></p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 7 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Explain two benefits of a compiler in programming. (4 marks)</p>
                        <p>(b) Outline four factors to consider when naming constant identifiers. (4 marks)</p>
                        <p>(c) Write a program in Pascal language that would prompt a user to enter two numbers. The program then computes the sum of the two numbers using a function and displays the results. (6 marks)</p>
                        <p>(d) The following elements are stored in an array; 45, 34, 65, 30, 25 and 56. Write a program in C language that would search for the element 30 and display an appropriate message. Use linear search technique. (6 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Benefits of a Compiler:</strong></p>
                        <ul>
                            <li><strong>Translation to Executable Code:</strong> The primary benefit is translating human-readable high-level source code into machine-readable object code or executable code that the computer can directly run, making program execution possible.</li>
                            <li><strong>Optimization:</strong> Compilers often perform optimizations on the code during translation, which can lead to programs that run faster and/or use less memory than equivalent interpreted code or unoptimized compiled code.</li>
                            <li><strong>Error Detection (Compile-time):</strong> Compilers perform extensive checks for syntax errors and often some static semantic errors before execution, catching many common programming mistakes early in the development cycle.</li>
                            <li><strong>Code Protection:</strong> Distributing compiled code (executables) makes it harder for end-users to view or modify the original source code compared to distributing interpreted scripts.</li>
                        </ul>
                        <em>(Any two distinct benefits)</em>

                        <p><strong>(b) Factors for Naming Constant Identifiers:</strong></p>
                        <ul>
                            <li><strong>Readability/Meaningfulness:</strong> The name should clearly indicate the purpose or value of the constant (e.g., `MAX_STUDENTS`, `PI`, `INTEREST_RATE`).</li>
                            <li><strong>Convention/Style Guide:</strong> Follow established naming conventions for constants (e.g., using all uppercase letters with underscores like `MAX_VALUE` in C/Pascal, or specific casing in other languages) for consistency within the codebase or team.</li>
                            <li><strong>Scope Avoidance:</strong> Ensure the constant name doesn't clash with variable names or other identifiers within the same scope.</li>
                            <li><strong>Conciseness (within reason):</strong> While clarity is key, overly long names can be cumbersome. Balance descriptiveness with reasonable length.</li>
                            <li><strong>Avoid Magic Numbers/Strings:</strong> Use named constants instead of embedding literal values ("magic numbers" or strings) directly in the code, improving maintainability (change the value in one place) and readability.</li>
                        </ul>
                         <em>(Any four distinct factors)</em>

                        <p><strong>(c) Pascal Program (Sum using Function):</strong></p>
                        <pre><code class="language-pascal">program SumOfTwoNumbers;

var
  num1, num2: Real; // Use Real to allow non-integer input
  sumResult: Real;

// Function to calculate the sum
function CalculateSum(a, b: Real): Real;
begin
  CalculateSum := a + b;
end;

begin // Main program
  Write('Enter the first number: ');
  Readln(num1);

  Write('Enter the second number: ');
  Readln(num2);

  // Call the function to compute the sum
  sumResult := CalculateSum(num1, num2);

  // Display the result
  Writeln('The sum of ', num1:0:2, ' and ', num2:0:2, ' is: ', sumResult:0:2);

  Readln; // Keep console window open
end.
</code></pre>

                        <p><strong>(d) C Program (Linear Search for 30):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int numbers[] = {45, 34, 65, 30, 25, 56};
    int arraySize = sizeof(numbers) / sizeof(numbers[0]); // Calculate array size
    int searchValue = 30;
    int i;
    int found = 0; // Flag to indicate if the value was found (0=false, 1=true)

    // Perform linear search
    for (i = 0; i < arraySize; ++i) {
        if (numbers[i] == searchValue) {
            found = 1; // Set flag to true
            break;     // Exit loop once found
        }
    }

    // Display appropriate message
    if (found == 1) { // Or just if (found)
        printf("Element %d found in the array at index %d.\n", searchValue, i);
    } else {
        printf("Element %d not found in the array.\n", searchValue);
    }

    return 0;
}
</code></pre>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 8 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline six conversion specifiers used in C programming language. (3 marks)</p>
                        <p>(b) (i) Outline two importance of creating subprograms when programming. (2 marks)</p>
                        <p>(ii) Susan created a documentation for a program. Outline four elements that she could have included to it for easy referencing. (4 marks)</p>
                        <p>(c) Draw a program flowchart that would declare two sides of a rectangle as constant with values 70 and 130 respectively. The program then calculates and outputs the area of the rectangle. (6 marks)</p>
                        <p>(d) Write a program in C language that prompts a user to enter three different numbers. The program then determines and displays the largest among the numbers. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) C Conversion Specifiers (Format Specifiers):</strong></p>
                        <p>Used with functions like `printf` and `scanf`:</p>
                        <ul>
                            <li><strong><code>%d</code> or <code>%i</code>:</strong> Signed decimal integer.</li>
                            <li><strong><code>%u</code>:</strong> Unsigned decimal integer.</li>
                            <li><strong><code>%f</code>:</strong> Floating-point number (decimal notation).</li>
                            <li><strong><code>%e</code> or <code>%E</code>:</strong> Floating-point number (scientific notation).</li>
                            <li><strong><code>%c</code>:</strong> Single character.</li>
                            <li><strong><code>%s</code>:</strong> String of characters (null-terminated).</li>
                            <li><strong><code>%p</code>:</strong> Pointer address.</li>
                            <li><strong><code>%x</code> or <code>%X</code>:</strong> Unsigned hexadecimal integer.</li>
                            <li><strong><code>%o</code>:</strong> Unsigned octal integer.</li>
                            <li><strong><code>%%</code>:</strong> A literal percent sign.</li>
                        </ul>
                        <em>(Any six)</em>

                        <p><strong>(b) (i) Importance of Creating Subprograms (Functions/Procedures):</strong></p>
                        <ul>
                            <li><strong>Modularity/Code Organization:</strong> Breaks down a large program into smaller, manageable, self-contained units, making the code easier to understand, develop, and maintain.</li>
                            <li><strong>Code Reusability:</strong> Allows a block of code that performs a specific task to be written once and called multiple times from different parts of the program, reducing redundancy and effort.</li>
                            <li><strong>Abstraction:</strong> Hides the implementation details of a task behind a simple interface (the function call), allowing programmers to use the functionality without needing to know the specifics of how it works.</li>
                            <li><strong>Easier Debugging/Testing:</strong> Individual subprograms can be tested independently, making it easier to isolate and fix errors.</li>
                        </ul>
                        <em>(Any two)</em>

                        <p><strong>(b) (ii) Elements for Easy Referencing in Documentation:</strong></p>
                        <ul>
                            <li><strong>Table of Contents:</strong> Provides an overview and links to major sections.</li>
                            <li><strong>Index:</strong> Alphabetical list of keywords/topics with page numbers/links.</li>
                            <li><strong>Glossary:</strong> Definitions of terms.</li>
                            <li><strong>Cross-References/Hyperlinks:</strong> Links between related topics.</li>
                            <li><strong>Consistent Headings/Structure:</strong> Logical organization for easy scanning.</li>
                            <li><strong>Search Functionality (if electronic):</strong> Allows keyword searching.</li>
                            <li><strong>Clear Examples:</strong> Illustrate concepts or usage.</li>
                        </ul>
                         <em>(Any four - similar to 2021n Q6a)</em>

                        <p><strong>(c) Flowchart (Rectangle Area Calculation):</strong></p>
                        <pre class="diagram-code">
+-------+
| START |
+-------+
    |
    V
+-------------------+
| CONST LENGTH = 70 |
| CONST WIDTH = 130 |
+-------------------+
    |
    V
+-------------------+
| Area = LENGTH *   |
|        WIDTH      |
+-------------------+
    |
    V
+-------------------+
| Output Area       |
+-------------------+
    |
    V
+-----+
| END |
+-----+
                        </pre>

                        <p><strong>(d) C Program (Largest of Three Numbers):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    float num1, num2, num3, largest;

    // Prompt user for three different numbers
    printf("Enter three different numbers:\n");

    printf("Number 1: ");
    if (scanf("%f", &num1) != 1) {
        printf("Invalid input.\n");
        return 1;
    }

    printf("Number 2: ");
    if (scanf("%f", &num2) != 1) {
        printf("Invalid input.\n");
        return 1;
    }
     // Basic check for difference (could be more robust)
    if (num2 == num1) {
        printf("Please enter three *different* numbers.\n");
        return 1;
    }

    printf("Number 3: ");
    if (scanf("%f", &num3) != 1) {
        printf("Invalid input.\n");
        return 1;
    }
    // Basic check for difference
    if (num3 == num1 || num3 == num2) {
         printf("Please enter three *different* numbers.\n");
        return 1;
    }


    // Determine the largest using nested if-else or sequential comparisons
    // Method 1: Sequential Comparisons
    largest = num1; // Assume num1 is largest initially
    if (num2 > largest) {
        largest = num2;
    }
    if (num3 > largest) {
        largest = num3;
    }

    /* // Method 2: Nested if-else
    if (num1 >= num2 && num1 >= num3) {
        largest = num1;
    } else if (num2 >= num1 && num2 >= num3) {
        largest = num2;
    } else {
        largest = num3;
    }
    */

    // Display the largest number
    printf("The largest number entered is: %.2f\n", largest);

    return 0;
}
</code></pre>
                        <p><em>Note: Added basic checks to encourage entering different numbers as requested by the prompt, although the logic finds the largest even if they are the same. Using float to allow non-integers.</em></p>
                        </div>
                    </div>
                </div>
            </section>

            <div class="paper-navigation bottom"><a href="2019july.html" class="btn">Previous Paper</a><a href="2021n.html" class="btn">Next Paper</a></div>
        </main>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 Subject Past Papers Collection | Kenya National Examinations Council</p>
        </div>
    </footer>
</body>
</html>