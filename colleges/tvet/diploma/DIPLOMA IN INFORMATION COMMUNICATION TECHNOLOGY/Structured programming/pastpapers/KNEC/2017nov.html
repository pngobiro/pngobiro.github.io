<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structured Programming - November 2017 | KNEC Past Papers</title>
    <link rel="stylesheet" href="styles.css">
    <script src="js/sidebar-navigation.js" defer></script>
    <!-- Add MathJax scripts if needed -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>STRUCTURED PROGRAMMING</h1>
            <h2>November 2017</h2>
            <div class="exam-details">
                <p>Paper Code: 2920/103</p>
                <p>Duration: 3 hours</p>
                <p>Module: MODULE I</p>
            </div>
        </div>
    </header>

    <div class="container main-content">
        <div class="sidebar">
            <div class="sidebar-header"><h3>Past Papers</h3></div>
            <nav class="sidebar-nav">
                <ul>
                    <li>
                        <h4>2022</h4>
                        <ul><li><a href="2022j.html">July 2022</a></li></ul>
                    </li>
                    <li>
                        <h4>2021</h4>
                        <ul>
                            <li><a href="2021n.html">November 2021</a></li>
                            <li><a href="2021j.html">July 2021</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2019</h4>
                        <ul><li><a href="2019july.html">July 2019</a></li></ul>
                    </li>
                    <li>
                        <h4>2018</h4>
                        <ul><li><a href="2018j.html">July 2018</a></li></ul>
                    </li>
                    <li>
                        <h4>2017</h4>
                        <ul>
                            <li><a href="2017nov.html">November 2017</a></li>
                            <li><a href="2017july.html">July 2017</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2016</h4>
                        <ul>
                            <li><a href="2016nov.html">November 2016</a></li>
                            <li><a href="2016july.html">July 2016</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2015</h4>
                        <ul><li><a href="2015nov.html">November 2015</a></li></ul>
                    </li>
                    <li>
                        <h4>2014</h4>
                        <ul>
                            <li><a href="2014n.html">November 2014</a></li>
                            <li><a href="2014july.html">July 2014</a></li>
                        </ul>
                    </li>
                    <li>
                        <h4>2013</h4>
                        <ul><li><a href="2013nov.html">November 2013</a></li></ul>
                    </li>
                    <li>
                        <h4>2012</h4>
                        <ul><li><a href="2012july.html">July 2012</a></li></ul>
                    </li>
                    <li>
                        <h4>2011</h4>
                        <ul>
                            <li><a href="2011n.html">November 2011</a></li>
                            <li><a href="2011july.html">July 2011</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </div>
        <main>
            <div class="paper-navigation top"><a href="2017july.html" class="btn">Previous Paper</a><a href="2018j.html" class="btn">Next Paper</a></div>

            <section class="paper-intro">
                <h3>INSTRUCTIONS TO CANDIDATES</h3>
                <p>This paper consists of EIGHT questions.</p>
                <p>Answer any FIVE of the EIGHT questions in the answer booklet provided.</p>
                <p>ALL questions carry equal marks.</p>
                <p>Candidates should answer the questions in English.</p>
                <p>This paper consists of 4 printed pages.</p>
                <p>Candidates should check the question paper to ascertain that all the pages are printed as indicated and that no questions are missing.</p>
            </section>

            <section class="paper-content">
                <div class="question">
                    <h3>Question 1 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline four characteristics of low level programming languages. (4 marks)</p>
                        <p>(b) Explain the term algorithm as used in programming. (2 marks)</p>
                        <p>(c) During a programming lesson, a student was required to write a program that would generate and display even numbers between 2 and 50. Represent the program logic using a flowchart. (5 marks)</p>
                        <p>(d) (i) Describe two modes that are used to write a file in a C Program. (4 marks)</p>
                        <p>(ii) Write a program in C language that implements a null pointer. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Characteristics of Low-Level Programming Languages:</strong></p>
                        <ul>
                            <li><strong>Machine Dependent:</strong> Code is specific to a particular processor architecture and hardware.</li>
                            <li><strong>Little/No Abstraction:</strong> Programmers work directly with hardware details like registers and memory addresses.</li>
                            <li><strong>Difficult to Read/Write:</strong> Syntax is mnemonic (Assembly) or binary (Machine Code), making it harder for humans to understand and use compared to high-level languages.</li>
                            <li><strong>High Performance/Efficiency:</strong> Allows for fine-grained control, potentially leading to highly optimized and fast code.</li>
                            <li><strong>Poor Portability:</strong> Code written for one type of processor usually cannot run on another without significant modification or complete rewriting.</li>
                        </ul>
                        <em>(Any four)</em>

                        <p><strong>(b) Algorithm:</strong></p>
                        <p>An algorithm is a finite, well-defined sequence of unambiguous, effective steps or instructions designed to solve a specific problem or perform a computation. It takes some input values and produces some output values, terminating after a finite number of steps.</p>
                        <em>(Similar to 2019july Q3a(i))</em>

                        <p><strong>(c) Flowchart (Even Numbers 2 to 50):</strong></p>
                        <pre class="diagram-code">
+-------+
| START |
+-------+
    |
    V
+-------------------+
| Set Number = 2    |
+-------------------+
    |
    V
+-------------------+  <--+
| Is Number <= 50 ? |     |
+-------------------+     |
    | YES                 |
    V                     |
+-------------------+     |
| Display Number    |     |
+-------------------+     |
    |                     |
    V                     |
+-------------------+     |
| Number = Number + 2|-----+
+-------------------+
    | NO
    V
+-----+
| END |
+-----+
                        </pre>

                        <p><strong>(d) (i) C File Writing Modes:</strong></p>
                        <ul>
                            <li><strong><code>"w"</code> (Write):</strong> Opens a file for writing. If the file exists, its contents are discarded (truncated). If the file does not exist, it is created.</li>
                            <li><strong><code>"a"</code> (Append):</strong> Opens a file for writing at the end of the file (appending). If the file does not exist, it is created. Existing contents are preserved.</li>
                            <li><strong><code>"w+"</code> (Write and Read - Truncate):</strong> Opens a file for both reading and writing. If the file exists, its contents are discarded. If it doesn't exist, it's created.</li>
                            <li><strong><code>"a+"</code> (Append and Read):</strong> Opens a file for both reading and appending. Reading starts at the beginning, but writing always happens at the end. If the file doesn't exist, it's created.</li>
                            <li><em>Binary versions (<code>"wb"</code>, <code>"ab"</code>, <code>"wb+"</code>, <code>"ab+"</code>) behave similarly but are used for binary files.</em></li>
                        </ul>
                        <em>(Any two modes primarily used for writing, e.g., "w" and "a")</em>

                        <p><strong>(d) (ii) C Program Implementing a Null Pointer:</strong></p>
                        <p>A null pointer is a pointer that does not point to any valid memory location. It's often used to indicate the absence of a target or an error condition. In C, the macro `NULL` (defined in headers like `<stdio.h>`, `<stdlib.h>`, `<stddef.h>`) represents a null pointer constant.</p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; // For NULL definition (though often in stdio.h too)

int main() {
    int *ptr = NULL; // Declare an integer pointer and initialize it to NULL

    printf("Value of ptr (address it points to): %p\n", (void *)ptr);

    // Attempting to dereference a null pointer leads to undefined behavior (often a crash)
    // Uncommenting the next line would likely cause a segmentation fault:
    // printf("Value at the address pointed to by ptr: %d\n", *ptr);

    // Null pointers are often used to check if an allocation failed or if a pointer is valid
    int *dynamic_ptr = (int *)malloc(sizeof(int) * 10); // Try to allocate memory

    if (dynamic_ptr == NULL) {
        printf("Memory allocation failed! dynamic_ptr is NULL.\n");
        // Handle error, maybe exit
        return 1;
    } else {
        printf("Memory allocated successfully. dynamic_ptr points to: %p\n", (void *)dynamic_ptr);
        // Use the allocated memory...
        dynamic_ptr[0] = 100;
        printf("Value at dynamic_ptr[0]: %d\n", dynamic_ptr[0]);

        // Don't forget to free allocated memory
        free(dynamic_ptr);
        dynamic_ptr = NULL; // Good practice to set pointer to NULL after freeing
    }

     printf("After free, dynamic_ptr is: %p\n", (void *)dynamic_ptr);


    return 0;
}
</code></pre>
                        <p><em>This program demonstrates declaring a null pointer, printing its value (usually shown as 0 or (nil)), and using NULL to check the success of a memory allocation.</em></p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 2 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Explain each of the following terms as used in programming:</p>
                        <p>(i) coupling; (2 marks)</p>
                        <p>(ii) cohesion. (2 marks)</p>
                        <p>(b) Jane, a programmer, intends to write a program for a client. Explain three factors that she could consider when selecting a programming language to use. (6 marks)</p>
                        <p>(c) (i) Outline three properties of an array. (3 marks)</p> <!-- Corrected mark allocation based on content -->
                        <p>(ii) Explain the purpose of the command packed in Pascal programming language. (3 marks)</p> <!-- Corrected mark allocation based on content -->
                        <p>(d) Write a program in Pascal language that prompts the user to enter the radius of a circle in the main program. The program then passes the value of the radius to a subprogram named calculate which computes the circumference and the area of the circle. The subprogram then returns the results to the main program for output. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Programming Terms:</strong></p>
                        <ul>
                            <li><strong>(i) Coupling:</strong> Refers to the degree of interdependence between software modules. Low coupling (modules are independent) is desirable, as it means changes in one module have minimal impact on others. High coupling makes systems harder to maintain and understand.</li>
                            <li><strong>(ii) Cohesion:</strong> Refers to the degree to which the elements inside a single module belong together or are focused on a single task. High cohesion (elements are strongly related and focused) is desirable, leading to more understandable, reusable, and maintainable modules.</li>
                        </ul>

                        <p><strong>(b) Factors for Selecting Programming Language:</strong></p>
                        <ul>
                            <li><strong>Problem Domain/Suitability:</strong> How well the language's features match the type of problem being solved (e.g., scientific computing, web development, systems programming).</li>
                            <li><strong>Developer Expertise/Availability:</strong> The skills and familiarity of the development team with the language.</li>
                            <li><strong>Platform Constraints:</strong> The target operating system, hardware, or environment where the program will run.</li>
                            <li><strong>Performance Requirements:</strong> The need for execution speed or efficient memory usage might favor certain languages (e.g., compiled vs. interpreted).</li>
                            <li><strong>Ecosystem (Libraries/Tools):</strong> Availability of relevant libraries, frameworks, and development tools can significantly impact productivity.</li>
                            <li><strong>Maintainability/Scalability:</strong> Language features supporting code organization, readability, and large project development.</li>
                        </ul>
                        <em>(Any three - similar to 2021j Q6b(i))</em>

                        <p><strong>(c) (i) Properties of an Array:</strong></p>
                        <ul>
                            <li><strong>Homogeneous Elements:</strong> All elements stored in an array must be of the same data type.</li>
                            <li><strong>Fixed Size (Static Arrays):</strong> The size of a standard array is typically fixed at compile time and cannot change during execution (dynamic arrays are often implemented using pointers).</li>
                            <li><strong>Contiguous Memory:</strong> Elements are stored in adjacent memory locations, allowing for efficient access using index calculations.</li>
                            <li><strong>Indexed Access:</strong> Elements are accessed directly using an integer index or subscript (usually starting from 0 or 1).</li>
                        </ul>
                         <em>(Any three)</em>

                        <p><strong>(c) (ii) Purpose of `packed` (Pascal):</strong></p>
                        <p>The `PACKED` keyword in older Pascal versions was a directive to the compiler to store data structures (like arrays or records) in a way that minimizes memory usage, possibly by storing multiple elements within a single machine word if they fit (e.g., booleans, characters). This could potentially lead to slower access times compared to unpacked structures. Modern compilers often ignore this keyword or perform packing optimizations automatically.</p>
                        <em>(Similar to 2021j Q6a(ii))</em>

                        <p><strong>(d) Pascal Program (Circle Calculations Subprogram):</strong></p>
                        <pre><code class="language-pascal">program CircleCalculator;
uses
  Math; // For Pi

var
  radiusInput: Real;
  circumferenceResult: Real;
  areaResult: Real;

// Subprogram (Procedure) to calculate area and circumference
// Uses VAR parameters to "return" multiple values
procedure CalculateCircleMetrics(r: Real; var circumference: Real; var area: Real);
begin
  if r >= 0 then
  begin
    circumference := 2 * Pi * r;
    area := Pi * Sqr(r); // Sqr(r) is r * r
  end
  else
  begin
    // Indicate error for negative radius
    circumference := -1.0;
    area := -1.0;
  end;
end;

begin // Main program
  Write('Enter the radius of the circle: ');
  Readln(radiusInput);

  // Call the procedure, passing variables to receive the results
  CalculateCircleMetrics(radiusInput, circumferenceResult, areaResult);

  // Display the results, checking for error indication
  Writeln; // Blank line
  Writeln('Radius entered: ', radiusInput:0:2);
  if (circumferenceResult >= 0) and (areaResult >= 0) then
  begin
    Writeln('Calculated Circumference: ', circumferenceResult:0:2);
    Writeln('Calculated Area: ', areaResult:0:2);
  end
  else
  begin
    Writeln('Cannot calculate metrics for a negative radius.');
  end;

  Readln; // Keep console window open
end.
</code></pre>
                        <p><em>Note: This uses a procedure with `VAR` parameters to return the two calculated values (circumference and area) back to the main program, as requested by the prompt mentioning a "subprogram" returning results. Using two separate functions would also be a valid approach.</em></p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 3 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline four reasons for compiling a program. (4 marks)</p>
                        <p>(b) A student was required to prepare documentation for a program.</p>
                        <p>(i) Describe two areas of technical information that the student may include in this documentation. (4 marks)</p>
                        <p>(ii) Outline three user-oriented contents that should be included. (3 marks)</p>
                        <p>(c) Write a program in C language that prompts a user to input a four-digit year. The program then determines whether the year entered is a leap year or not and displays an appropriate message. (Hint: A leap year is divisible by 4) (5 marks)</p>
                        <p>(d) Distinguish between an array and a record as used in Pascal programming language. (4 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Reasons for Compiling a Program:</strong></p>
                        <ul>
                            <li><strong>Translation to Executable Code:</strong> To convert human-readable source code into machine-readable code (object code or executable) that the computer can run.</li>
                            <li><strong>Performance Optimization:</strong> Compilers often optimize the code for speed and efficiency during the translation process.</li>
                            <li><strong>Error Detection:</strong> To check the source code for syntax errors and some static semantic errors before execution.</li>
                            <li><strong>Distribution:</strong> Compiled code (executables) can be distributed to users without requiring them to have the compiler or view the source code.</li>
                        </ul>
                        <em>(Similar to 2021j Q7a)</em>

                        <p><strong>(b) Program Documentation Contents:</strong></p>
                        <ul>
                            <li><strong>(i) Technical Information:</strong>
                                <ol>
                                    <li><strong>System Design/Architecture:</strong> High-level overview of the program structure, modules, and their interactions.</li>
                                    <li><strong>Algorithms and Data Structures:</strong> Detailed explanation of complex algorithms used and the structure of data being processed or stored.</li>
                                    <li><strong>API Documentation:</strong> Description of functions/procedures/classes, including parameters, return values, and purpose, for developers using or maintaining the code.</li>
                                    <li><strong>Code Comments:</strong> Explanations within the source code itself.</li>
                                </ol>
                                <em>(Any two distinct areas)</em>
                            </li>
                            <li><strong>(ii) User-Oriented Contents:</strong>
                                <ol>
                                    <li><strong>Installation Guide:</strong> Instructions on how to install the software.</li>
                                    <li><strong>User Manual/Tutorial:</strong> Explanation of features and step-by-step guides on how to use the program.</li>
                                    <li><strong>Troubleshooting/FAQ:</strong> Solutions to common problems or answers to frequently asked questions.</li>
                                    <li><strong>Examples:</strong> Concrete examples of how to use specific features or achieve certain tasks.</li>
                                </ol>
                                <em>(Any three distinct contents - similar to 2021n Q3a(ii))</em>
                            </li>
                        </ul>

                        <p><strong>(c) C Program (Leap Year Check):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int year;
    int isLeap = 0; // Flag: 0 = not leap, 1 = leap

    // Prompt user for a four-digit year
    printf("Enter a four-digit year: ");
    if (scanf("%d", &year) != 1) {
        printf("Invalid input.\n");
        return 1;
    }

    // Basic check for four digits (optional, but good practice)
    if (year < 1000 || year > 9999) {
        printf("Please enter a four-digit year.\n");
        // Decide whether to proceed or exit - proceeding based on hint
    }

    // Determine if it's a leap year based on the hint (divisible by 4)
    // Note: Full leap year logic is more complex:
    // (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
    // But we follow the hint provided.
    if (year % 4 == 0) {
        isLeap = 1;
    }

    // Display the result
    if (isLeap == 1) { // or just if (isLeap)
        printf("%d is a leap year (according to the rule: divisible by 4).\n", year);
    } else {
        printf("%d is not a leap year (according to the rule: divisible by 4).\n", year);
    }

    return 0;
}
</code></pre>
                        <p><em>Note: The program implements the simplified leap year rule given in the hint (divisible by 4). The standard Gregorian calendar rules are more complex but not required by the question's hint.</em></p>

                        <p><strong>(d) Array vs. Record (Pascal):</strong></p>
                        <ul>
                            <li><strong>Array:</strong> A collection of elements all of the *same* data type, accessed using an integer index. Used for storing lists or sequences of homogeneous data. Size is often fixed.</li>
                            <li><strong>Record:</strong> A collection of elements (fields) that can be of *different* data types, grouped under a single name. Used for representing entities with multiple attributes. Fields are accessed by name.</li>
                        </ul>
                        <em>(Similar to 2018j Q7b)</em>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 4 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Explain each of following terms as used in programming:</p>
                        <p>(i) dry run; (2 marks)</p>
                        <p>(ii) debug. (2 marks)</p>
                        <p>(b) (i) Outline three elements that constitute a for control structure as used in C programming language. (3 marks)</p>
                        <p>(ii) With the aid of a chart, describe a repeat...until control structure as used in Pascal programming. (4 marks)</p>
                        <p>(c) The following is a segment of a C program. Use it to answer the question that follows.</p>
                        <pre><code class="language-c">// Assuming this is the intended segment with corrections
#include &lt;stdio.h&gt;

int main() { // Added main function wrapper for context
    int a = 14;
    int b = 0; // Division by zero error potential
    int c;

    // Original logic seems flawed, division by zero occurs before check
    // Rewritten to check before division:
    if (b != 0) {
        c = a / b;
        printf("%d divided by %d is %d\n", a, b, c); // Corrected printf format
    } else {
        printf("Division by zero is not allowed.\n"); // Meaningful error message
    }
    return 0;
}</code></pre>
                        <p>Rewrite the program segment correctly. (4 marks)</p>
                        <p>(d) Write a program in Pascal language that prompts the user to enter an alphabetic character. The program then displays its equivalent numeric ASCII code. (5 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Programming Terms:</strong></p>
                        <ul>
                            <li><strong>(i) Dry Run:</strong> Manually tracing the execution of code on paper with sample inputs to check the logic step-by-step before running it on a computer.</li>
                            <li><strong>(ii) Debug:</strong> The process of finding and fixing errors (bugs) in a program's source code that cause it to behave incorrectly or crash. Often involves using debugging tools.</li>
                        </ul>
                        <em>(Similar to 2021n Q5a(ii))</em>

                        <p><strong>(b) (i) Elements of C `for` Loop:</strong></p>
                        <p>General structure: <code>for (initialization; condition; update) { /* body */ }</code></p>
                        <ol>
                            <li><strong>Initialization:</strong> An expression executed once before the loop begins. Typically used to initialize a loop counter variable (e.g., `i = 0`).</li>
                            <li><strong>Condition:</strong> An expression evaluated *before* each potential iteration. If the condition is true (non-zero), the loop body executes. If it's false (zero), the loop terminates. (e.g., `i < 10`).</li>
                            <li><strong>Update:</strong> An expression executed *after* each iteration of the loop body. Typically used to modify the loop counter (e.g., `i++`, `i += 2`).</li>
                        </ol>

                        <p><strong>(b) (ii) Pascal `Repeat...Until` Structure:</strong></p>
                        <p>This is a post-test loop structure.</p>
                        <p>Flowchart:</p>
                        <pre class="diagram-code">
+-------------------+
|       ...         | // Code before loop
+-------------------+
    |
    V
+-------------------+  <--+ // Loop entry point
|                   |     |
|   Execute Loop    |     |
|       Body        |     |
|                   |     |
+-------------------+     |
    |                     |
    V                     |
+-------------------+ NO  |
| Is Condition True?|-----+ // Condition checked AFTER body
+-------------------+
    | YES
    V
+-------------------+
|       ...         | // Code after loop
+-------------------+
                        </pre>
                        <p><em>Description:</em> The loop body is executed first. Then, the `UNTIL` condition is evaluated. If the condition is false, the loop body executes again. This repeats until the condition becomes true, at which point the loop terminates. The body always executes at least once.</p>
                        <em>(Similar to 2018j Q8c)</em>

                        <p><strong>(c) Corrected C Program Segment:</strong></p>
                        <p>Original segment issues: undeclared variables, division by zero before check, incorrect `printf` syntax, missing `main` function structure.</p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;

int main() { // Added main function for a complete segment
    int a = 14;
    int b = 0; // Potential division by zero
    int c;     // Result variable

    // Check for division by zero BEFORE attempting division
    if (b == 0) {
        printf("Error: Division by zero is not allowed.\n");
    } else {
        c = a / b;
        // Correct printf syntax with format specifiers
        printf("%d divided by %d is %d\n", a, b, c);
    }

    // Removed the original 'Else' part as it doesn't make sense
    // after correcting the division-by-zero check.

    return 0; // Standard return for main
}
</code></pre>
                        <p><em>Corrections: Added `main`, declared `c`, checked `b` *before* division, corrected `printf` syntax and message. The original `Else` logic was flawed given the likely intent.</em></p>

                        <p><strong>(d) Pascal Program (Character to ASCII):</strong></p>
                        <pre><code class="language-pascal">program CharToAscii;
var
  inputChar: Char;
  asciiValue: Integer;
begin
  Write('Enter an alphabetic character: ');
  Readln(inputChar);

  // Check if it's alphabetic (optional, but good practice)
  if (inputChar >= 'A' and inputChar <= 'Z') or (inputChar >= 'a' and inputChar <= 'z') then
  begin
    // Get the ASCII value using Ord()
    asciiValue := Ord(inputChar);
    Writeln('The ASCII code for ''', inputChar, ''' is: ', asciiValue);
  end
  else
  begin
    Writeln('Input was not an alphabetic character.');
  end;

  Readln; // Keep console window open
end.
</code></pre>
                        <em>(Similar to 2021n Q1a(ii))</em>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 5 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline three advantages of using a pseudocode when designing a program. (3 marks)</p>
                        <p>(b) Write a program in C language that calls a function that returns the absolute value of a number passed to it. (5 marks)</p>
                        <p>(c) With the aid of a diagram in each case, distinguish between a stack and a queue. (4 marks)</p>
                        <p>(d) Dorcas wrote a program during a programming lesson.</p>
                        <p>(i) State two categories of test data that she could use. (2 marks)</p>
                        <p>(ii) Describe three types of errors that she could have encountered while testing the program citing an example in each case. (6 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Advantages of Using Pseudocode:</strong></p>
                        <ul>
                            <li><strong>Language Agnostic:</strong> Can be understood by programmers familiar with different programming languages, facilitating communication.</li>
                            <li><strong>Focus on Logic:</strong> Allows the designer to concentrate on the algorithm's steps and logic without getting bogged down by strict syntax rules of a specific language.</li>
                            <li><strong>Ease of Translation:</strong> Easier to translate into actual code in any programming language compared to translating from plain English or complex diagrams.</li>
                            <li><strong>Design Documentation:</strong> Serves as a clear intermediate step between the problem description and the final code, useful for documentation and review.</li>
                        </ul>
                        <em>(Any three - similar to 2021n Q7b(ii))</em>

                        <p><strong>(b) C Program (Absolute Value using Function):</strong></p>
                        <pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt; // Required for fabs() or implement manually

// Function to return absolute value (using math.h)
double absoluteValue(double num) {
    return fabs(num); // fabs() works for floating-point types
}

// Alternative manual implementation
/*
double absoluteValue(double num) {
    if (num < 0) {
        return -num;
    } else {
        return num;
    }
}
*/

int main() {
    double number, absVal;

    printf("Enter a number: ");
    if (scanf("%lf", &number) != 1) {
        printf("Invalid input.\n");
        return 1;
    }

    // Call the function
    absVal = absoluteValue(number);

    printf("The absolute value of %.2lf is %.2lf\n", number, absVal);

    return 0;
}
</code></pre>
                        <p><em>Note: Using `fabs()` from `math.h` is standard for floating-point absolute value. An integer version `abs()` exists in `<stdlib.h>`. A manual implementation is also shown.</em></p>

                        <p><strong>(c) Stack vs. Queue:</strong></p>
                        <ul>
                            <li><strong>Stack:</strong>
                                <ul>
                                    <li>Access Principle: Last-In, First-Out (LIFO).</li>
                                    <li>Operations: Push (add to top), Pop (remove from top).</li>
                                    <li>Analogy: A stack of plates.</li>
                                    <li>Diagram:
                                        <pre class="diagram-code">
  ---> Push ---> [ Item3 ] <-- Top
                 [ Item2 ]
                 [ Item1 ]
  <--- Pop  <--- [ Bottom]
                                        </pre>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>Queue:</strong>
                                <ul>
                                    <li>Access Principle: First-In, First-Out (FIFO).</li>
                                    <li>Operations: Enqueue (add to rear), Dequeue (remove from front).</li>
                                    <li>Analogy: A waiting line or queue.</li>
                                    <li>Diagram:
                                        <pre class="diagram-code">
Front ---> [ Item1 | Item2 | Item3 ] <--- Rear <--- Enqueue
  |
  +---> Dequeue
                                        </pre>
                                    </li>
                                </ul>
                            </li>
                        </ul>

                        <p><strong>(d) (i) Categories of Test Data:</strong></p>
                        <ul>
                            <li>Normal/Valid Data</li>
                            <li>Boundary Data</li>
                            <li>Invalid/Erroneous Data</li>
                        </ul>
                        <em>(Any two - similar to 2018j Q4a(ii))</em>

                        <p><strong>(d) (ii) Types of Errors Encountered During Testing:</strong></p>
                        <ol>
                            <li><strong>Syntax Errors:</strong> Mistakes in using the programming language rules (grammar). These are usually caught by the compiler *before* testing can even begin.
                                <ul><li><em>Example:</em> Missing semicolon `printf("Hello")` instead of `printf("Hello");` in C.</li></ul>
                            </li>
                            <li><strong>Runtime Errors:</strong> Errors that occur *during* the execution of the program, often dependent on specific inputs or conditions. The program compiles successfully but crashes or behaves unexpectedly when run.
                                <ul><li><em>Example:</em> Division by zero (`result = 10 / divisor;` where `divisor` becomes 0 during execution). Attempting to access an array element outside its valid index range (`myArray[10]` when the array size is only 10). Null pointer dereference.</li></ul>
                            </li>
                            <li><strong>Logic Errors:</strong> Errors where the program compiles and runs without crashing, but produces incorrect or unexpected output because the programmer's algorithm or implementation logic is flawed.
                                <ul><li><em>Example:</em> Using `>` instead of `>=` in a condition (`if (score > 50)` instead of `if (score >= 50)` leading to incorrect grading). Calculating area using `length + width` instead of `length * width`.</li></ul>
                            </li>
                        </ol>
                        <em>(Description and example for three types)</em>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 6 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) (i) Outline two reasons for declaring a variable as global. (2 marks)</p>
                        <p>(ii) State two syntax used to add comments in each of the following languages:</p>
                        <p>I. C (2 marks)</p>
                        <p>II. Pascal. (2 marks)</p>
                        <p>(b) Peter, a programmer, would like to create a program file to store numerous data items. Describe a search technique that would be the most appropriate for this program. Justify your answer. (4 marks)</p>
                        <p>(c) Distinguish between selection and quick sort methods. (4 marks)</p>
                        <p>(d) Write a program in Pascal language that would be used to store rainfall readings at four different times in a day from three different locations. (6 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) (i) Reasons for Declaring Global Variables:</strong></p>
                        <ul>
                            <li><strong>Shared Data Access:</strong> When multiple functions or modules within a program need to access and potentially modify the same piece of data frequently.</li>
                            <li><strong>Constants:</strong> To define constants that are used throughout the program (though dedicated `const` declarations are often preferred).</li>
                            <li><strong>State Management (Use with Caution):</strong> In some simpler programs or specific scenarios, global variables might be used to maintain the overall state of the application, although this can quickly become hard to manage.</li>
                        </ul>
                        <em>(Any two. Note: Overuse of global variables is generally discouraged due to potential side effects and reduced maintainability.)</em>

                        <p><strong>(a) (ii) Comment Syntax:</strong></p>
                        <ul>
                            <li><strong>I. C:</strong>
                                <ul>
                                    <li><code>// Single-line comment</code></li>
                                    <li><code>/* Multi-line comment */</code></li>
                                </ul>
                            </li>
                            <li><strong>II. Pascal:</strong>
                                <ul>
                                    <li><code>{ Single or multi-line comment }</code></li>
                                    <li><code>(* Single or multi-line comment *)</code></li>
                                </ul>
                            </li>
                        </ul>

                        <p><strong>(b) Most Appropriate Search Technique for Numerous Data Items:</strong></p>
                        <p>The most appropriate technique depends heavily on whether the data file is **sorted** or **unsorted** and the **access pattern** (how often searches occur).</p>
                        <ul>
                            <li><strong>If the data is SORTED (or can be sorted):</strong> <strong>Binary Search</strong> is generally the most appropriate for numerous items.
                                <ul><li><em>Justification:</em> It has a logarithmic time complexity (O(log n)), making it extremely efficient for large datasets compared to linear search (O(n)). It quickly narrows down the search space by repeatedly dividing it in half.</li></ul>
                            </li>
                            <li><strong>If the data is UNSORTED (and sorting is too costly or not feasible):</strong> <strong>Linear Search</strong> (or Sequential Search) is the only option.
                                <ul><li><em>Justification:</em> It checks each item one by one until the target is found or the end of the list is reached. While inefficient for large datasets (O(n)), it doesn't require the data to be sorted beforehand.</li></ul>
                            </li>
                             <li><strong>If frequent searches are needed on unsorted data and memory allows:</strong> Building a <strong>Hash Table</strong> upon initial load might be appropriate.
                                <ul><li><em>Justification:</em> Provides average O(1) search time after the initial O(n) cost of building the table. Best if search speed is paramount and data doesn't change constantly.</li></ul>
                            </li>
                        </ul>
                        <p><em>Conclusion: Assuming the "numerous data items" implies efficiency is important, **Binary Search** is most appropriate *if the data can be kept sorted*. Otherwise, Linear Search is the fallback.</em></p>

                        <p><strong>(c) Selection Sort vs. Quick Sort:</strong></p>
                        <ul>
                            <li><strong>Selection Sort:</strong>
                                <ul>
                                    <li>Method: Repeatedly finds the minimum element in the unsorted portion and swaps it to the beginning of the unsorted portion.</li>
                                    <li>Time Complexity: O(n²) in all cases (worst, average, best).</li>
                                    <li>Swaps: Makes few swaps (at most n-1).</li>
                                    <li>Space Complexity: O(1) (in-place).</li>
                                    <li>Stability: Not stable by default.</li>
                                </ul>
                            </li>
                            <li><strong>Quick Sort:</strong>
                                <ul>
                                    <li>Method: Divide and conquer. Selects a pivot, partitions the array around the pivot, and recursively sorts the sub-arrays.</li>
                                    <li>Time Complexity: Average case O(n log n), Worst case O(n²).</li>
                                    <li>Swaps: Variable number of swaps depending on partitioning.</li>
                                    <li>Space Complexity: O(log n) average (due to recursion stack), O(n) worst case. (In-place partitioning).</li>
                                    <li>Stability: Not stable by default.</li>
                                </ul>
                            </li>
                        </ul>
                        <p><em>Key Differences: Quicksort is generally much faster (average O(n log n)) than Selection Sort (O(n²)), but Selection Sort has a predictable O(n²) performance and minimizes swaps.</em></p>

                        <p><strong>(d) Pascal Program (Store Rainfall Readings):</strong></p>
                        <pre><code class="language-pascal">program RainfallRecorder;

const
  NUM_LOCATIONS = 3;
  NUM_TIMES = 4;

type
  LocationIndex = 1..NUM_LOCATIONS;
  TimeIndex = 1..NUM_TIMES;
  // Declare a 2D array to store readings
  RainfallArray = array[LocationIndex, TimeIndex] of Real;

var
  readings: RainfallArray;
  loc: LocationIndex;
  time: TimeIndex;

begin
  Writeln('Enter Rainfall Readings (e.g., in mm):');

  // Loop through locations
  for loc := 1 to NUM_LOCATIONS do
  begin
    Writeln; // Blank line for separation
    Writeln('--- Location ', loc, ' ---');
    // Loop through times for each location
    for time := 1 to NUM_TIMES do
    begin
      Write('  Enter reading for time ', time, ': ');
      // Input validation could be added here (e.g., check for non-negative)
      Readln(readings[loc, time]);
    end;
  end;

  // Optional: Display the stored readings for verification
  Writeln;
  Writeln('--- Stored Rainfall Readings ---');
  Write('Loc |');
  for time := 1 to NUM_TIMES do Write(' Time ', time, ' |');
  Writeln;
  Write('----+');
  for time := 1 to NUM_TIMES do Write('--------+');
  Writeln;

  for loc := 1 to NUM_LOCATIONS do
  begin
    Write(loc:3, ' |');
    for time := 1 to NUM_TIMES do
    begin
       Write(readings[loc, time]:7:2, ' |'); // Format output
    end;
    Writeln;
  end;

  Writeln;
  Writeln('Data entry complete.');
  Readln; // Keep console window open
end.
</code></pre>
                        <p><em>Note: This program declares a 2D array and uses nested loops to prompt the user and store the readings for each location at each time. It includes an optional section to display the stored data.</em></p>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 7 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline three characteristics of a sequence control structure. (3 marks)</p>
                        <p>(b) Explain the term error handling as used in programming. (2 marks)</p>
                        <p>(c) (i) Describe two approaches a programmer would use to improve the readability of a program. (4 marks)</p>
                        <p>(ii) Distinguish between source and object codes. (4 marks)</p>
                        <p>(d) Mawezo College hired a programmer to design a hostel rooms allocation program. The requirements are as follows:</p>
                        <p>There are two categories of students; regular and part time. Part time students are not allowed to stay in the college’s hostels. First year regular students are allocated double room if they have cleared the fees. Other students are allocated a hostel as follows; fees clearance, a single room otherwise a double room.</p>
                        <p>Draw a decision tree to represent this program logic. (7 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Characteristics of Sequence Control Structure:</strong></p>
                        <ul>
                            <li><strong>Orderly Execution:</strong> Statements are executed one after another in the exact order they appear in the code.</li>
                            <li><strong>No Jumps or Skips:</strong> Control flows directly from one statement to the next without unconditional branching (like `goto`) or skipping blocks (unless part of a selection/iteration structure).</li>
                            <li><strong>Default Structure:</strong> It's the fundamental way statements are executed unless altered by selection (if/case) or iteration (loops) constructs.</li>
                        </ul>

                        <p><strong>(b) Error Handling:</strong></p>
                        <p>Error handling is the process within a program of anticipating, detecting, and responding to errors or exceptional conditions that might occur during execution. This involves writing code to gracefully manage unexpected situations (like invalid user input, file not found, division by zero, memory allocation failure) rather than letting the program crash abruptly. Techniques include checking return codes, using try-catch blocks (in languages that support them), validating input, and providing informative error messages to the user.</p>

                        <p><strong>(c) (i) Approaches to Improve Program Readability:</strong></p>
                        <ul>
                            <li><strong>Meaningful Naming:</strong> Using clear, descriptive names for variables, functions, constants, etc.</li>
                            <li><strong>Consistent Formatting/Indentation:</strong> Applying a standard visual layout to the code to highlight structure.</li>
                            <li><strong>Modularity:</strong> Breaking the program into smaller, focused functions/procedures.</li>
                            <li><strong>Comments:</strong> Adding explanations for complex or non-obvious code sections.</li>
                        </ul>
                        <em>(Any two - similar to 2021n Q3b(i))</em>

                        <p><strong>(c) (ii) Source vs. Object Code:</strong></p>
                        <ul>
                            <li><strong>Source Code:</strong> Human-readable code written by programmers in a specific language (e.g., C, Pascal).</li>
                            <li><strong>Object Code:</strong> Machine-readable code generated by a compiler/assembler from the source code. Not easily human-readable.</li>
                        </ul>
                        <em>(Similar to 2021n Q1b)</em>

                        <p><strong>(d) Decision Tree (Hostel Allocation):</strong></p>
                        <pre class="diagram-code">
                      +-----------------+
                      | Student Category? |
                      +-----------------+
                     /                   \
          (Part Time) /                     \ (Regular)
                   /                       \
      +-------------------+           +-----------------+
      | No Hostel Allowed |           |   Student Year? |
      +-------------------+           +-----------------+
                                     /                   \
                           (First Year) /                     \ (Other Year)
                                     /                       \
                           +-----------------+           +-----------------+
                           | Fees Cleared?   |           | Fees Cleared?   |
                           +-----------------+           +-----------------+
                          /         \                 /         \
                 (Yes)   /           \ (No)    (Yes)   /           \ (No)
                      /             \               /             \
          +-------------+   +-------------+   +-------------+   +-------------+
          | Double Room |   | No Hostel*  |   | Single Room |   | Double Room |
          +-------------+   +-------------+   +-------------+   +-------------+

*Note: The logic implies First Years who haven't cleared fees might not get a room,
 or might get a double room if available later. The tree assumes "No Hostel"
 if fees aren't cleared for First Years based on the strict reading.
                        </pre>
                        </div>
                    </div>
                </div>

                <div class="question">
                    <h3>Question 8 (20 marks)</h3>
                    <div class="question-content">
                        <p>(a) Outline the use of each of the following in C programming language:</p>
                        <p>(i) <code>;</code></p>
                        <p>(ii) <code>#</code></p>
                        <p>(iii) <code>{}</code> (3 marks)</p>
                        <p>(b) Outline the order of evaluation of logical operators in C programming language. (2 marks)</p>
                        <p>(c) Write a program in Pascal language that enumerates the days of the week. The program then displays a message “IT IS A WEEKDAY” if the day ranges between Monday and Friday otherwise “IT IS A WEEKEND”. Use relational operators. (6 marks)</p>
                        <p>(d) (i) Draw a four level complete binary tree. Serialise the nodes from A. (5 marks)</p>
                        <p>(ii) Write the order of the nodes when the tree in (i) is traversed using each of the following strategies:</p>
                        <p>I. Pre-order; (2 marks)</p>
                        <p>II. Post-order. (2 marks)</p>
                    </div>
                    <div class="answer-section">
                        <h4>Answer</h4>
                        <div class="answer-content">
                        <p><strong>(a) Use of C Punctuation/Symbols:</strong></p>
                        <ul>
                            <li><strong>(i) <code>;</code> (Semicolon):</strong> Acts as a statement terminator. It marks the end of most individual statements in C (like assignments, function calls, declarations).</li>
                            <li><strong>(ii) <code>#</code> (Hash/Pound Sign):</strong> Used to introduce preprocessor directives. These are instructions processed before the actual compilation begins (e.g., <code>#include</code> to insert header files, <code>#define</code> to create macros or constants).</li>
                            <li><strong>(iii) <code>{}</code> (Curly Braces):</strong> Used to define a block of code or a compound statement. They group multiple statements together, typically used for function bodies, loop bodies, conditional statement blocks (if/else), and structure/union definitions.</li>
                        </ul>

                        <p><strong>(b) Order of Evaluation of Logical Operators (C):</strong></p>
                        <p>Based on standard C precedence rules:</p>
                        <ol>
                            <li><code>!</code> (Logical NOT) - Highest precedence</li>
                            <li><code>&&</code> (Logical AND)</li>
                            <li><code>||</code> (Logical OR) - Lowest precedence</li>
                        </ol>
                        <p>Operators with the same precedence are typically evaluated left-to-right. Both <code>&&</code> and <code>||</code> use short-circuit evaluation.</p>

                        <p><strong>(c) Pascal Program (Weekday/Weekend Check):</strong></p>
                        <pre><code class="language-pascal">program DayChecker;

type
  // Enumerate the days of the week
  DayOfWeek = (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday);

var
  today: DayOfWeek;
  // Optional: Variable to read input if needed, but example uses enumeration directly

begin
  // Example: Assign a day (could also read input and convert)
  today := Wednesday; // Example assignment

  Writeln('Checking day: ', Ord(today) + 1); // Display ordinal value for context

  // Use relational operators on the enumerated type
  if (today >= Monday) and (today <= Friday) then
  begin
    Writeln('IT IS A WEEKDAY');
  end
  else // Otherwise it must be Saturday or Sunday
  begin
    Writeln('IT IS A WEEKEND');
  end;

  // Example with Saturday
  today := Saturday;
  Writeln;
  Writeln('Checking day: ', Ord(today) + 1);
  if (today >= Monday) and (today <= Friday) then
     Writeln('IT IS A WEEKDAY')
  else
     Writeln('IT IS A WEEKEND');


  Readln; // Keep console window open
end.
</code></pre>
                        <p><em>Note: This uses an enumerated type for clarity. Relational operators (`>=`, `<=`, `and`) work directly on enumerated types based on their defined order.</em></p>

                        <p><strong>(d) (i) Four-Level Complete Binary Tree (Serialized A-O):</strong></p>
                        <p>A complete binary tree is filled level by level, left to right. A 4-level tree has nodes up to level 3 (root is level 0). Max nodes = 2^(h+1) - 1 = 2^4 - 1 = 15. Nodes A-O.</p>
                        <pre class="diagram-code">
Level 0:              A
                    /   \
Level 1:           B     C
                  / \   / \
Level 2:         D   E F   G
                / \ / \ / \ / \
Level 3:       H  I J K L M N O
                        </pre>

                        <p><strong>(d) (ii) Tree Traversals:</strong></p>
                        <ul>
                            <li><strong>I. Pre-order (Root, Left, Right):</strong> A, B, D, H, I, E, J, K, C, F, L, M, G, N, O</li>
                            <li><strong>II. Post-order (Left, Right, Root):</strong> H, I, D, J, K, E, B, L, M, F, N, O, G, C, A</li>
                        </ul>
                        </div>
                    </div>
                </div>
            </section>

            <div class="paper-navigation bottom"><a href="2017july.html" class="btn">Previous Paper</a><a href="2018j.html" class="btn">Next Paper</a></div>
        </main>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2025 Subject Past Papers Collection | Kenya National Examinations Council</p>
        </div>
    </footer>
</body>
</html>