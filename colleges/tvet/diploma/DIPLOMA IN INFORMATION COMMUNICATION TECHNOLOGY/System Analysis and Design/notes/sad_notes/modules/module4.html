
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>System Design and Implementation - SYSTEM ANALYSIS AND DESIGN (SAD)</title>
  <meta name="description" content="Details on system design and implementation.">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <div class="container">
    <article class="learning-module" data-module="4">
      <!-- Navigation (top) -->
        <nav class="module-nav">
            <div class="nav-links">
            <a href="../index.html" class="nav-button">
                <span class="nav-icon">←</span>
                <span class="nav-text">Home</span>
            </a>
            <a href="module3.html" class="nav-button">
                <span class="nav-icon">←</span>
                <span class="nav-text">Previous</span>
            </a>
            <div class="module-progress">
                <div class="progress-bar">
                <div class="progress-fill" style="width: 60%;"></div>
                </div>
                <span class="progress-text">Module 4 of 5</span>
            </div>
            <a href="module5.html" class="nav-button">
                <span class="nav-text">Next</span>
                <span class="nav-icon">→</span>
            </a>
            </div>
        </nav>

      <header class="module-header">
        <div class="title-container">
          <span class="module-badge">Module 4</span>
          <h1 class="module-title">System Design and Implementation</h1>
        </div>
        <div class="title-underline"></div>
          <section class="module-objectives">
              <h2 class="section-heading">
                <span class="heading-icon">🎯</span>
                <span class="heading-text">Learning Objectives</span>
              </h2>
              <ul class="objectives-list">
                <li class="objective-item">Understand the objectives and constraints of system design.</li>
                <li class="objective-item">Differentiate between logical and physical design.</li>
                <li class="objective-item">Learn about program design, including modularization and specification.</li>
                <li class="objective-item">Explore the contents of a system specification document.</li>
                <li class="objective-item">Understand the activities involved in the production stage: programming, testing, and documentation.</li>
                <li class="objective-item">Learn about different testing techniques: white box and black box testing.</li>
                <li class="objective-item">Understand the purpose and process of structured walkthroughs.</li>
                <li class="objective-item">Grasp the importance and objectives of good documentation.</li>
                <li class="objective-item">Learn about system implementation activities, including hardware/software acquisition and user training.</li>
                  <li class="objective-item">Understand different change-over methods.</li>
              </ul>
            </section>
      </header>

      <main class="module-content">

        <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">DESIGN STAGE (SYSTEM DESIGN)</span>
          </h2>
            <div class="content-block">
          <p>The system design objective is to put a logical structure of the real system in a form that can be interpreted by other people from the designer.  The analyst should derive a logical model of the way existing system works. This assumption that the existing system provides a good guide to what is required of a new system.  It should be different from the new system is to achieve the given requirement.</p>
                <p><strong>Limitations.</strong></p>
            <ol>
                <li>There could be come requirements of the new systems that are not currently being satisfied by the current system.  These requirements should not be taken into account.</li>
                  <li>Inefficiency in the current system may be translated into a logical model and these will be transferred to the new system.  Ideally, the models should reveal the logic of an efficient system and should be amended accordingly.
                </li>
                  <li>It’s likely that physical aspects of the existing system may be transferred to the logical analysis.  The analysts should guard against that.</li>
            </ol>
                <p><strong>How to deal with above limitations</strong></p>
           <ol>
            <li>Treatment of the new recruitment<strong>: </strong>The new requirement can be estimated through <strong>   </strong>interview with management and users.  It’s important that the logical model be amended to reflect the new requirement.  They are likely to lead to new processes which are added to higher level design.
            </li>
                 <li>Treatment of inefficiencies. The model should be adjusted through the decomposition of top level design tools e.g DFD.  The lower level data flow diagram tend to be determined partly by what is done in existing system to fulfill a specific function.</li>
              <li>Treatment of the physical aspects<strong>:</strong> Certain physical consideration may have shifted into a logical model e.g to incorporate separate files.  There are two types of system design<strong>:</strong></li>
              </ol>
                 <p><strong> </strong>Logical design and physical design.</p>
            </div>
        </section>
          
            <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Logical Design</span>
          </h2>
              <div class="content-block">
            <p>A logical design produces specifications of major features of the new system, which meets the systems objectives. The delivered products of the logical design is a blue-print of the new system.  It includes<strong>:</strong></p>
            <p><strong> </strong>The requirement of existing system components<strong>:</strong></p>
              </div>
            
            <div class="content-block">
          <ol>
            <li>Outputs (reports, displays, timings, frequencies etc)</li>
            <li>Inputs (dialogs, forms, screens etc)</li>
               <li>Storage (requirements for data to be stored in database.</li>
          
          
            <li>Procedures (To collect, transform and output data)</li>
         
          
            <li>Controls (requirements for data integrity, security, data recovery procedures)</li>
              </ol>
          <p><strong>NB:  </strong>Logical design of the system is viewed in terms of what process i.e procedures, inputs, outputs storage and control the new system should have.</p>
                </div>
                
               
        </section>
          
          <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Physical design </span>
          </h2>
                
                <div class="content-block">
          <p>It takes the logical design blue print and produces the program specification, physical files of database and user interface for the selected or targeted hardware and software.</p>
                    <p>Physical design is mostly concerned with how the current or future system works in terms of how the program are written, files organized in a storage, media tasks carried for user interface with the system.</p>
                    </div>
        </section>
          
             <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">System Design Objectives</span>
          </h2>
                  
                <div class="content-block">
          <p>System Design should design that meets the following criteria<strong>:</strong></p>
                  </div>
                   <div class="content-block">
          <ol>
            <li>User needs as cost effectively as possible.</li>
            <li>One that is within the constraints laid down in the TQR i.e terms of Reference.</li>
            <li>Produce correct outputs by processing data accurately and efficiency.</li>
            <li>Simple to operate i.e easy to use.</li>
            <li>One with sufficient in-built controls and provide feedback to it’s user.</li>
            <li>Should be reliable.</li>
            <li>Should be functional etc.</li>
          </ol>
                       </div>
        </section>

          <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">System design constraints</span>
          </h2>
             <div class="content-block">
          <ol>
            <li><strong>T</strong>he <strong>b</strong>udget<strong>:</strong>  Better design system incurs greater expenses.  The total system cost of the objectives must be considered in the light with available budget.</li>
            <li><strong>T</strong>ime:      Time taken to produce very usable, would increase development cost and delay system delivery.</li>
            <li><strong>I</strong>ntegration with      Existing and planned system may limit option available other existing system.        features of the system.</li>
            <li><strong>S</strong>kills <strong>l</strong>imitation       May arise from the range of skills and level of competence in both the design team and the system users.</li>
            <li><strong>T</strong>he <strong>s</strong>tandards       Standards may drive the design tasks in a specified direction.</li>
          </ol>
            </div>
        </section>

         <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">PROGRAM DESIGN</span>
          </h2>
             <div class="content-block">
          <p>The following terms may be used to represent a program module, a process, a unit, routine procedure function macro segment or fragment.</p>
            <p>The following are some important aspects about a program<strong>:</strong></p>
          <ol>
            <li>One function<strong>: </strong>A program should carry out only one task.  If several interrelated programs are linked together, they form a system which is easy to maintain for it comprises several units.</li>
            <li>Size<strong>:</strong>  A program should be small enough so that its easy to maintain can take less memory and make optimal use of CPU.</li>
            <li>Cohesion<strong>:</strong>   This measures the strength of relation within a program.  This implies that what happens in one sub-routine or other programs.  A program that performs more than one function has a low cohesion.  A high degree cohesion within a program results in lower coupling between programs.</li>
            <li>Coupling<strong>:   </strong>Is a measure of the strength of the bond between programs.<strong>  </strong>Ideally, program should have little dependences on other program in the system.</li>
            </ol>
            
            <p>This is so that any amendment to the program should have little or no impact on other programs of the system. Programs should thus be developed in modules.</p>
          
            <p><strong>Why break a system into modules</strong></p>
            <p>One program should be written by one programmer.  If a system has only one program, it will take a programmer time influenced by his competence in programming. Small programs are easier to specify, test and modify than large programs, thus errors of the impact of a change are contained within fewer lines of code when modules are used.  Also a programmer can choose the area of the system that interests them to code which is motivating to them.  A large number of small programs make re-scheduling work easier i.e some programs can be assigned to someone else to write if the first programmer is taking longer than estimated for a particular program.</p>
              
                <p>To breakdown a system into modules there should be good program specification.</p>
              </div>
        </section>
          
            <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">SYSTEM SPECIFICATION</span>
          </h2>
                <div class="content-block">
          <p>It is a form document produced at the design stage of system development life cycle.  It represents the conceptual system or the logical system.  There is a system in paper-form.</p>
          
            <p><strong>Contents of System Specification:</strong></p>
            <ol>
                <li>Introduction of existing system i.e Details of its objective and a brief description of how these objectives are met.</li>
                <li>Description of the proposed system as a solution to the problem as specified in T.O.R.</li>
                <li>Justification of proposed system as a solution to the problem as specified in T.OR Costs and benefits justification for the proposed system should be shown.</li>
                <li>Comparison of both existing and proposed system in terms of inputs i.e specifications of frequency, volume, timings etc.</li>
                <li>Proposed system file descriptions<strong>:</strong> This should include file names, organization methods, access method, Nature of the system, the storage media, record structures and file activities.</li>
                <li>Proposed system control specifications i.e error handling procedures, recovery procedures, in built – can handle both hardware and software related.</li>
            </ol>
          </div>
            </section>

         <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">PRODUCTION STAGE:</span>
          </h2>
              
               <div class="content-block">
          <p>It involves following activities<strong>:</strong> Programming, testing and documentation.</p>
                <p><strong>Programming:</strong></p>
          <p>This activity involves translation of system specification into program codes.  A programmer should interface a requirement into the computer system.  Programming standards should be adhered to e.g use of a standard programming language.</p>
                <p>Decomposition of a program into smaller units or modules etc.  It’s necessary that programming team work in lia to improve quality of programs produced.</p>
              </div>
            </section>
         
           <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Contents of good program specification:</span>
          </h3>
            <div class="content-block">
           <ol start="3">
              <li><strong>D</strong>ocument <strong>d</strong>etails<strong>:                     </strong>This include file, program identifier i.e name, author, version number., reviewer of the program etc.</li>
              <li><strong>I</strong>ntroduction<strong>:  </strong>Contain a brief summary of what the program does in business application area.</li>
              <li><strong>A</strong>ssumption and <strong>r</strong>estriction<strong>: </strong>This list any constraints of the program or information which affects the logic causing the problem.</li>
              <li><strong>A</strong>ttributes:  This outlines the program environment e.g hardware, operating system, programming language etc.</li>
              <li><strong>D</strong>ata<strong>:  </strong>i.e inputs and outputs of the program.</li>
              <li><strong>F</strong>unctional <strong>D</strong>escription<strong>:</strong>          i.e  the processing or tasks carried out to convert Program input into meaningful outputs.</li>
              <li><strong>D</strong>etailed <strong>P</strong>rocessing <strong>R</strong>equirement<strong>: </strong>Indicates functional description i.e low level detailed view of the processing paths.</li>
              <li><strong>O</strong>peration <strong>C</strong>onsideration<strong>:  </strong>Then describes how operations interacts with the program in the normal running and how he can save or restore the program if anything goes wrong.</li>
              <li><strong>S</strong>ub-<strong>r</strong>outines<strong>:</strong> These are modules or segments used by the program as well as their input parameters.</li>
              <li><strong>M</strong>essages<strong>: </strong>Identifies message sent and received by the program and their purpose.</li>
              <li><strong>P</strong>rint <strong>L</strong>ayout<strong>: </strong>Describes print or screen dialogue or layout of theprogram.</li>
            </ol>
                 </div>
               </section>

             <section class="content-section">
          <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Testing:</span>
          </h2>
                    
                 <div class="content-block">
          <p>Program testing also called unit testing involves testing of a program i.e individual program which are part of the entire suite.  Generally all programs should be tested before the system conversion.  There are two major testing techniques i.e white box and black box testing.</p>
          <p><strong><em>W</em></strong><em>hite <strong>b</strong>ox <strong>t</strong>esting</em>:   It mainly concentrates on internal construction of a program.  It’s carried out on the following aspects<strong>:</strong></p>
               </div>
                <div class="content-block">
          <p><strong>(i)</strong>        Cyclomatic Complexity   – Are measures of logical complexity of a program.</p>
          <p><strong>(ii)</strong>       Graph Matrix (matrices) – Are used for condition testing.</p>
          <p><strong>(iii)</strong>      Data Flow Testing – Commonly associated with SS ADM.  It is used to select paths of a program according to location and definition of variables.</p>
               </div>
                 <div class="content-block">
          <p><strong>(iv)</strong>      The Loop Testing – It focuses on exclusive validity of loops within a program.</p>
          <p><strong><em>Black box testing</em></strong><strong>:</strong></p>
          <p>It focuses on functional requirement of software.     It attempts to find errors in the following categories.</p>
           <p>Incorrect or missing function<strong>:</strong></p>
            <ul>
            <li>Interface errors.</li>
            <li>Data structured errors.</li>
            <li>Performance errors.</li>
             <li>Initialization and termination errors.</li>
            </ul>
             </div>
                 
            <div class="content-block">
          <p>These method is based on the input and output to end form software.  They do not emphasize on structure of a software.</p>
                <p>Software testing is conducted in the following aspects or stages<strong>:</strong></p>
           </div>
            
            
                <div class="content-block">
        <ol start="2">
            <li><strong>Unit Testing</strong> – Is testing of program segments that do a specific function. It emphasize the local data structures, boundaries, interfaces etc.</li>
            <li><strong>Modular Testing</strong> – Involves testing of interrelated units within a program which perform a specific task.  Debugging and correction of errors during each individual program segment could be part of modular testing.</li>
            <li><strong>Integration Testing </strong>– Also known as verification of program construction testing. It involves moving downwards through a control hierarchy i.e from subordinate modules it can either be top down integration or bottom up integration.  Top down integration verifies major controlled and decision points early in testing process.  Bottom up integration uses drivers to co-ordinate a test cases.</li>
              <li><strong>System testing</strong> – It involves linking all modules of a suite to test whether they are interfacing properly.  Its primary purpose is to fully test functionality of a computer based system.  Integration testing is testing of modules during the time they are linked up or combined together into a suite.</li>
          
            <li><strong>Accepted testing</strong> – This is carried out by Software User and management representative for the following reasons<strong>:</strong> –        To discover software not yet detected.<br>
            –    To discover the actual and exact demands of the system.<br>
            –    To discover whether any major changer are requires by the system can be adopted.</li>
          </ol>
                    </div>
        </section>


      <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">STRUCTURED WALK THROUGH:</span>
          </h2>
                
            <div class="content-block">    
          <p>(Peer Review) It’s a planned review of system by people not involved in it’s development effort. It’s carried out to establish areas where improvement can be made in the system or it’s development process.  The review is done by between 5 – 10 people as a software quality assurance measure.</p>
               </div>
        </section>
       
        <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Types of walk through:</span>
          </h3>
            <div class="content-block">   
          <p><strong>♦</strong><strong> Requirement Review –</strong>It’s conducted to examine a proposed system as formulated by the system analyst.  If there are any inconsistencies between the requirements stated by the users and those that the analyst is proposing.  The walk through should be able to uncover such inconsistencies so that they can be dealt with early enough.</p>
                 <p><strong>♦</strong><strong> Design Review     –      </strong>It’s purpose is to determine whether the proposed design will meet the requirement, they should give solutions to such discrepancies<strong>.</strong></p>
              <p><strong>♦</strong><strong> Program Review –      </strong>This is conducted to examine the program development along with it’s documentation.  The programs are compared with their specific design specifications to determine whether the specifications are being satisfied.  Any programming errors are detected and dealt with.</p>
                 <p><strong>♦</strong><strong> Testing review:    </strong>–     It assists in development of test data that can be used to detect system design errors.  The system testing strategy is not to prove programmer correctness but assess reliability and suitability of the system through detecting critical system errors</p>
                 </div>
            </section>
         
            
            <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Walk Through Team Members:</span>
          </h2>
            <div class="content-block">  
          <p><strong><em>Chairman</em></strong><strong>: – </strong>  He controls the overall direction of a walk through and ensures that its agenda is adhered to.  He gives approval by formerly signing the project milestones when users are satisfied as each development stage.</p>
            <p><strong><em>Author</em></strong><strong>: –         </strong>He is the creator or designer of the systems.  He presents and explains the materials that are being walked through.</p>
          <p><strong><em>Recorder:</em></strong> –    Acts as the secretary of the team and ensures that all agreed actions pointed out, are noted and followed up.</p>
              <p><strong><em>Reviewers:</em></strong> – They get in advance the materials being walked through a working model.  They walk through the proposed system and check whether it falls short of required quality.</p>
          <p><strong>User Representative:</strong></p>
          <p>Approve their understanding and satisfaction of what they will do with the system when it becomes operational.  The representatives may be senior managers, auditors etc.</p>
                  </div>
        </section>
            
             <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Importance of Structured Walk-through.</span>
          </h3>
             <div class="content-block">   
          <ol>
            <li>It identifies error, omissions and inconsistencies in a system.</li>
            <li>It focuses on quality of good practices in system operation generally.</li>
            <li>It involves the users and gives them an opportunity to give a feedback on critical appraisal of their work.</li>
          <li>It avoids description about who is responsible for what, thus encouraging team work.</li>
          <li>It reduces user resistance since they are incorporated and recognized by the development team.<strong> </strong></li>
        </ol>
                 </div>
        </section>

         <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">DOCUMENTATION:</span>
          </h2>
             
               <div class="content-block">
          <p>Software documentation is a description of a software or system after its development.  Software product therefore, comprises of codes and documentation</p>
            <p>–           Documentation includes a wide range of technical and non technical manuals, books, description and diagrams relating to the use and operation of produced software.  It’s vital for success of software engineering to allocate time to the software engineering particularly
            documentation through out its development.</p>
                   <p><strong>Documentation is aimed at 3 different audiences’ i.e</strong></p>
          <ol>
           <li><strong>S</strong>ystem <strong>d</strong>eveloper – Who will depend on documents from previous life cycle stages to guide continues development and subsequent maintenance of the software/system.</li>
            <li><strong>M</strong>anagement –  Who uses documents from past project to plan and understand current projects.</li>
              <li><strong>S</strong>ystem <strong>U</strong>ser-   Who learns how to use a software/ system from its narrative, description. or documentation.</li>
            </ol>
              </div>
               <div class="content-block">
          <p>In an organization, decisions have to be recorded in some permanent form as a baseline for continuing development of products.  Such base line documentation can only be changed with special authorization.</p>
         <p>This is particularly true when documentation form a part of project database (recording about project progress and reporting allow one to access information quickly and always provides exact information requested by any interested party.  It gives needed feasibility to the progress of the project.  Users are justified when they judge a product e.g software on the basis of its documentation rather than its performance.</p>
            <p>The best program in the world is useless if one does not know how to co-operate or maintain it.  The most critical aspect of software development is the creation of excellent documentation and not the production of working codes or program thus documentation is more important than programming since even the program becomes useful after or only through documentation.</p>
            </div>
        </section>

           <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Objectives of Good Documentation:</span>
          </h2>
              
          <div class="content-block">    
          <p>The following factors should be considered when preparing a good documentation.</p>
          <ol>
            <li>Documentation should be complete<strong>: </strong>This implies that all known aspects of components of documents should be given somewhere.</li>
            <li>Documentation should be consistent<strong>: </strong>Inconsistency will destroy the reader’s confidence in the documentation.  The biggest challenge is not consistence in the original documentation but maintaining consistency through all the changes the software or products may undergo.</li>
            <li>Documentation should be targeted at the right levels i.e for its intended audience e.g a training manual demands as much from its readers as a design documentation to the programmer one has thus to identify the audience, determine its characters, background and needs and plan documentation accordingly o, one should use appropriate level of formality and appropriate vocabulary in the documentation presentation.  The right approach should also be selected in presenting information so that it can be understood clearly.  One should choose the format of text, technical manual, tutorial, video or audio tapes on line help packs etc.</li>
             </ol>
            <p>Illustration and tables should be used since they organize and present large amount of materials for quick comprehension.  Supplementary materials e.g exercises, glossaries, appendices etc should he used.</p>
            </div>
        </section>

           <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">There are two major reasons why software engineers dislike producing documentation.</span>
          </h3>
                <div class="content-block">
            <p><strong>(i)</strong>        They do not see the need for it because it may indicate that one is new to the profession and has not yet had time to appreciate the benefits of documentation.  It may indicate also that one is so wrapped up in pressure of the moment that long range goals have become absurd.</p>
              <p><strong>(ii)</strong>       They do not feel capable of doing it.  Although sometimes the feeling of inadequacy derives inability to talk about technical subjects with non technical people.</p>
                </div>
             </section>
            
              <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Importance of System Documentation</span>
          </h3>
                  <div class="content-block">
          <ol>
            <li>It guides the development team at various stages of development life-cycle.</li>
            <li>Can be used as a system back up copy to recover the system, should something happen to its implementation.</li>
            <li>It aids or assists during system maintenance since it guides in identification of system modules to be changed.</li>
            <li>It can effectively provide a check list of items to be covered during subsequent system audit or a system maintenance.</li>
            <li>It guides against loss of system understanding particularly when the author leaves the company or dies.</li>
            <li>It may act as a training guide or document to ones programmers, analyst or users who may join after system implementation.</li>
          </ol>
                    </div>
        </section>
               <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Contents of system documentation.</span>
          </h3>
           
           
            <div class="content-block">
            <ol>
            <li><strong>T</strong>able of contents – Acts as document index.</li>
            <li><strong>I</strong>ntroduction – Indicates the systems capabilities and constraints or limitation.</li>
            <li><strong>S</strong>ystem specification – it specifies the conceptual system in term of process, data structures, files etc.</li>
              <li><strong>A</strong> list of files to be used by the system – used for reference should something go wrong when the system is live.</li>
                <li><strong>S</strong>ystem JSP – There are pictorial diagrams that describe how the system operates and relationship between various components.</li>
              <li><strong>T</strong>est Data – Shows the data used to evaluate system function ability.</li>
            <li><strong>R</strong>ecovery procedures – guides the user on how to recover the system should something go wrong when the system is running..</li>
              <li><strong>S</strong>amples of input and output /results<strong>: </strong>These helps the user to identify errors when they occur during system- live – running.</li>
                 <li><strong>B</strong>ack-up procedures<strong>:</strong> It advises the reader on how to make security copies of files for use to recover the system incase something goes wrong during the system live running.</li>
                  <li><strong>C</strong>ontact Address/ Telephone number – to be used by the operator to seek help if other options fail.</li>
              </ol>
             </div>
         </section>

          <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">IMPLEMENTATION</span>
          </h2>
            
              
             <div class="content-block">
          <p>This phase involves the following activities</p>
          <ol>
            <li>Hardware selection, acquisitions and installation.</li>
            <li>User training</li>
            <li>File conversion / creation</li>
            <li>Change over.</li>
          </ol>
            </div>
              
            <div class="content-block">    
         <p><strong>Hardware and Software Acquisition.</strong></p>
          <p>A user may acquire the hardware and software directly from a manufacturer and developer respectively.  He may also purchase them from an intermediate supplier.  Whichever way a carefully, controlled purchasing procedures should be followed.  The procedure should include. invitation to tender and comparative analysis to determine appropriate supplier of the required hardware and software.</p>
            </div>
             <div class="content-block">
          <p><strong>Invitation to tender (ITT)</strong></p>
          <p>It is issued to a range of suppliers.  ITT sets put specifications for the required equipment and software and should explore how the hardware will be used and the time scale for implementation.  It sets the performance criteria required for the new system.</p>
            </div>
        </section>

        <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Contents of ITT.</span>
          </h3>
            <div class="content-block">  
          <p>Background information and the companies together with an indication of the purpose of the system.  These includes<strong>:</strong></p>
          <ol>
            <li>The volume of data to be processed by the system. Complexity of the processing requirements and system interfaces should be stated.</li>
            <li>The number of individuals who will want to access the computer system after installation and whether access needs to be instant or not.</li>
            <li>The speed of processing required and expected.</li>
            <li>Input and Output derived.</li>
            <li>The type of processing methods preferred.</li>
            <li>Estimated life of the system.</li>
            <li>Possible upgrades or expansion anticipated.</li>
            <li>Other general consideration include<strong>: </strong>contact person in the company.
               <ul>
                <li>Overall financial constraints.</li>
                <li>The form that sub-mission is to take.</li>
                <li>Closing date for sub-mission of tender.</li>
                <li>The address to which tender is to be sent.</li>
                <li>The reference person to which tender is to be addressed.</li>
              </ul> </li>
          </ol>
          
          <p>While all the above features are necessary to consider, it’s important to decide the financing methods.  This includes purchasing where the buyer acquires ownership of item after payment of an agreed amount upon time.</p>
          <p>Leasing involves formation of an agreement between the lessee and lesser detailing the use of equipment, the length of time to use the equipment and the periodical payment.</p>
        <p>Renting involves a single agreement where one party agrees to use another party.  Resources at certain periodical payments.  The agreement is not as binding as that of lease agreement.</p>
               </div>
         </section>
          <section class="content-section">
            <h2 class="section-heading">
                <span class="heading-icon">📚</span>
                 <span class="heading-text">Evaluation of Vendor Proposal</span>
            </h2>
                 
              <div class="content-block">
                 <ol>
<li>Bench marks – Tests how long it takes for a machine to run through a particular set of programs.  Its carried out to compare performance of a piece of software or hardware against present criteria e.g speed of performance, response times and user friendliness of the equipment.</li>
            <li>Stimulation Test – It uses synthetic program written specifically for testing purpose. They are programmed in cooperated with routines designed to test a variety of situations.  Other features or factors include:</li>
          
            <li>Supplies reliability i, e both financial stability and Tract record.</li>
            <li>Cost i.e equipment cost, installation cost and training costs.</li>
            <li>Utility software supported and preloaded in the hardware.</li>
            <li>The warrant period, units and maintenance commitments.</li>
            <li>Software support upgrades maintenance.</li>
            <li>Training requirements which includes timings, number of personnel etc.</li>
            </ol>
              </div>
        </section>
        <section class="content-section">
              <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Software Factors:</span>
          </h3>
          <div class="content-block">
          <ol start="9">
            <li><strong>U</strong>ser <strong>r</strong>equirements<strong>: </strong>the selected software or package should fit user requirement as closely as possible.</li>
            <li><strong>P</strong>rocessing <strong>t</strong>ime<strong>: </strong>these involves the response time e.g if the response time is slow the user might consider software or package as unsuccessful.</li>
            <li><strong>D</strong>ocumentation<strong>: </strong>the software should be accompanied by manual, which is easy to understand, by non technical person.  The manual should not contain technical jargon.</li>
            <li><strong>U</strong>ser <strong>f</strong>riendliness<strong>: </strong>The package should be easier to use with clear on screen prompts, menu driven and extensive on screen help facilities etc.</li>
            <li><strong>C</strong>ontrols<strong>: </strong>The software should have in-built controls which may include password options, validation checking audit trail or trace facilities etc.</li>
            <li><strong>U</strong>p-to <strong>d</strong>atedness: The software should be upto date e.g should have changes or corrections in line with business procedures.</li>
            <li><strong>M</strong>odification: One should be up to date e.g should have changes or corrections in line with business procedures.</li>
            <li><strong>I</strong>ts <strong>s</strong>uccess <strong>i</strong>n the <strong>m</strong>arket<strong>:</strong> One should consider how many users are using the software and how long it has to be in the market.</li>
            <li><strong>C</strong>ompatibility of the <strong>s</strong>oftware<strong> :</strong> i.e how the software integrates with other software and how long it has to be in the market.</li>
            <li><strong>P</strong>ortability<strong>:</strong> One should consider how the software runs on the user computer and whether there will be need for the user to upgrade his hardware.</li>
            <li><strong>C</strong>ost<strong>: </strong>The user company should consider its financial position to establish whether it can afford the software required for efficient operations rather than the least cost packages software available.</li>
            <li><strong> Software Contracts:</strong></li>
               </ol>
           <p>Software contracts includes the costs, purpose and capacity of the software it describes what it cannot do.  In summary the following are covered in software contracts.</p>
              </div>
            <div class="content-block">
                 <ol>
            <li>Warrant terms.</li>
            <li>Support available</li>
            <li>Arrangement for upgrades.</li>
            <li>Maintenance arrangement.</li>
            <li>Delivery period / time for especially written software.</li>
            <li>Performance criteria</li>
          </ol>
                </div>
        </section>

           <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Software Licensing:</span>
          </h2>
                
             <div class="content-block">   
          <p>Software licensing covers the following<strong>:</strong></p>
          <ol>
            <li>Number of users that can install and use the software legally.</li>
            <li>Whether the software can be copied without infringing copyrights.</li>
            <li>Whether it can be altered without the developer’s consent.</li>
            <li>Circumstances under which the licensing can be terminated.</li>
            <li>Limitation of liability e.g of the user commits fraud using the software.</li>
            <li>Obligation to correct errors or bugs if they exist in the software.</li>
          </ol>
               </div>
        </section>

           <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Installation:</span>
          </h2>
              <div class="content-block">   
               <p>Software and Hardware Installation is done by supplier technicians or the user organization appointed person to avoid the risks associated with improper installation of the equipment.  The system analyst and other development team members may be called to assist where appropriate<strong>.</strong></p>
            <p><strong>User training</strong></p>
            <p>It’s important that the system users be trained to familiarize themselves with hardware and the system before the actual change over.</p>
            <p><strong>AIMS OF USER TRAINING:</strong><strong> </strong></p>
               </div>
             
                  <div class="content-block">
          <ol>
            <li>To reduce errors arising from learning through trial and error method.</li>
            <li>To make the system to be more acceptable to the users.</li>
            <li>To improve security by reducing accidental destruction of data.</li>
            <li>To improve quality of operation and services to the users.</li>
            <li>To reduce the cost of maintenance by minimizing accidental destruction of data or hardware.</li>
            <li>To ensure efficiency in system operation when it goes live.</li>
          </ol>
                      </div>
             
            <div class="content-block">
          <p><strong>Persons to be trained:</strong></p>
          <ol>
            <li>Persons operating the system when it becomes operation (system operators).</li>
            <li>Senior managers.</li>
            <li>Middle managers.</li>
            <li>Any person generally affected by system directly or indirectly.</li>
            </ol>
              <p>Training should cover current staff and recruited personnel.</p>
<p><strong><em>Recruitment of new personnel involves:</em></strong>  Job specification,  advertising salary and interviewing those to be recruited for training to be effective e.g lectures, tutorials, case studies etc  It must be clear what the objectives of the training is i.e what it is trying to achieve form of education or training</p>
                </div>
            </section>
           
          <div class="content-block">
        <ul>
            <li>For successful implementation of a system, training should be planned well right to the project onset.  The following may be in co-operated in education and in training plans to meet charging circumstances.</li>
             <li>To organize classroom sessions with user groups depending on specific areas of interest to be discussed.</li>
             <li> To use leaflets and manuals and distribute to relevant recipient.</li>
            <li>To demonstrate and allow hands on training on training on technical aspect.  These is necessary when skills are required to be developed.</li>
        </ul>
             </div>
           
           <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Areas to emphasize</span>
          </h3>
               
                <div class="content-block">
           <ol>
            <li>Background information which may help user to understand and therefore co-operation.</li>
            <li>Developers expectation of the users during the entire system development process and post implementation activities.</li>
             <li>The developer’s expectation of the user when the system becomes live or operational.</li>
              <li>How user activities fit in the rest of the development team.</li>
               <li>How the system failures can affect the users.</li>
             </ol>
            </div>
        </section>

         <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Timing of User’s Training</span>
          </h2>
                
                <div class="content-block">
          <ol>
            <li>Before the feasibility study when the users are given general explanation of computer systems, their relevance in function application and reason for desire to introduce a computer in the specific functions.</li>
            <li>Before investigation where the user’s are explained about the impact to the new system and importance of their involvement in development.  This may help gain user confidence and facilitate their acceptance of the system.</li>
            <li>During the fact-finding so that they can co-operate and provide useful information to guide system developer analysis stage of SDLC.</li>
            <li>Before programming so that they can prepare themselves for specific roles at the implementation stage.  These may include testing activities roles.</li>
            <li>Before implementation to enable the users to co-operate and play their roles assigned to them.</li>
            <li>After implementation in-order to assist in evaluation of system performance.</li>
            </ol>
                </div>
        </section>

                <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">FILE CONVERSION:</span>
          </h2>
                
            <div class="content-block">      
         <p>This involves changing of existing form of files into a form suitable for the new system when it becomes operational.  It may require that the analyst creates the file from scratch if there are no existing computer based files.  In an on event that computer based files exist they should be converted to a form relevant or sensible to the new system.</p>
           </div>
                    </section>
               
            <section class="content-section">
            <h3 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">File conversion procedure:</span>
          </h3>
                
                 <div class="content-block">
        <ol>
            <li>Record manually the existing data i.e the old master file.</li>
             <li>Transfer the recorded data to special form required by the new system.</li>
            <li>Insert any new data into the file i.e update the file already in the new form (form should include data contents and their corresponding formats and layout).</li>
             <li>Transcribe the completed form into a medium or storage relevant for the new system.</li>
            <li>Validate the file contents to ensure that they are error free before they can be used in the new system.</li>
           </ol>
            </div>
         </section>

         <section class="content-section">
              <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Problems associated with file creation / conversion</span>
              </h2>
             
              
             <div class="content-block"> 
             <ol>
            <li>Records may be stored or located at different places or locations, thus may be difficult to gather them all.</li>
              <li>Some record may require up-dating which may slow down changes over plan.</li>
            <li>Records may be too numerous i.e too large in volume which may slow down the change-over plan since transaction will take long.</li>
           <li>Some records may not exist at all e.g a customer who makes an order through a phone call.</li>
           </ol>
            
                <p>There will be no hard copy record left to rely on.</p>
              </div>
            
            <div class="content-block">
            <p><strong> </strong></p>
            <p><strong>Methods of file conversion</strong></p>
            <p><strong><em>F</em></strong><em>ile <strong>c</strong>onversion <strong>m</strong>ethods <strong>a</strong>re<strong>:</strong></em></p>
            <p>(i)         Straight file conversion / creation.</p>
            <p>(ii)        Dummy file conversion / creation</p>
            <p>(iii)       Phased file conversion</p>
            </div>
            
              <div class="content-block">
            <p><strong><em>S</em></strong><em>traight <strong>f</strong>ile <strong>c</strong>onversion</em></p>
          <p>It requires that the files be converted by bit phases.  This implies that instead of changing e.g a whole department file, the file is charged on section by section basis.  It may suitably be applicable on phased change.</p>
            </div>
              </section>
                
            <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">THE CHANGE – OVER METHODS</span>
          </h2>
                <div class="content-block">
          <p>It involves changing or switching from existing system to the new developed system.  Either of the following method can be adopted i.e.</p>
          <ol>
            <li>i) Direct change over</li>
            <li>ii) Parallel change over</li>
           
            <li>Phased change over</li>
             </ol>
            <p>Pilot change over </p>
          <p>The old system ceases its operation one day and the new system commence operation the next day.  The old system is made redundant in all its aspect as illustrated below<strong>:</strong></p>
                </div>
              
                
                <div class="content-block">  
            <p>________________________________</p>
            <p> </p>
            <p> </p>
            <p>Old system running</p>
            <p> </p>
            <p>___________________________________________________________</p>
            <p> </p>
            <p>New system being                                              New System</p>
            <p>Developed                                                       running live</p>
            <p> </p>
            <p>___________________________________________________________</p>
            <p> </p>
              </div>  
                <div class="content-block"> 
            <p>This method is applicable in the following circumstances<strong>:</strong></p>
            <ul>
             <li>When the new system and simple.</li>
             <li>When both new and old system are substantially.</li>
            <li>When extra staff to oversee or undertake parallel running of both systems are available or Unavailable</li>
              <li>When the management has complete confidence that the new system will work</li>
            </ul>
              </div>
             
                  <div class="content-block">
            <p><strong>Advantages:</strong></p>
          <ol>
            <li>It’s relatively cheap</li>
            <li>It prevents the weakness of the old system from being passed over to the new system.</li>
            <li>It reduces system implementation duration.</li>
          </ol>
                </div>
           <div class="content-block">
            <p><strong>Disadvantages:</strong></p>
          <ol>
            <li>It’s very risky especially if the new system fails. The cost of switching back to the old system will be high.</li>
            <li>If not properly planned, it may interrupt user organization operations and bring confusion amongst staff members.</li>
             </ol>
        </div>
        </section>
           <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Parallel Change Over</span>
          </h2>
               <div class="content-block"> 
                   <p>A method where new and old systems are allowed to run side by side until its proved beyond reasonable doubts that the new system is sophisticated and very careful change-over is require.  When development team has no confidence in the new system.  Where there are more staff to cope up with operations of both system running parallel as illustrated below.</p>

               </div>
            
            <div class="content-block">   
                <p><strong>Both system are running in parallel</strong></p>
            </div>
                <div class="content-block">
            <p><strong>Advantages</strong></p>
          <ol start="2">
            <li>Users become familiar with the new system prior to the change-over which may enhance their efficiency</li>
            <li>The organization is exposed to less risk in case the new system fails.</li>
            <li>There would be less interruption and inconveniences in the organization operations during the change over period.</li>
          </ol>
          <p>Disadvantages<strong>:</strong></p>
          <ol>
            <li>It’s an expensive method.</li>
            <li>It might delay system implementation schedule or period.</li>
          </ol>
                </div>
        </section>
        
        <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Phased Change Over</span>
          </h2>
            
          <div class="content-block">      
          <p>The method involves implementation of a system on step on step approach.  This implies that only a portion pf the system is implemented initially.  Other portions are implemented later in phases as illustrated below.</p>
            </div>
            
                <div class="content-block">  
            <p>Previous System        Part of previous      Part of the</p>
            <p>Running Live              System and             previous system</p>
          <p>__________________________________________________________________________</p>
          <p>Phase 1, 2, 3 of the        Phase 1 of the        Phase 1 & 2 of            New system</p>
          <p>New system being        New system            the new system           Running live</p>
          <p>developed                      running                  running LIVE</p>
          <p>_________________________________________________________________________</p>
          <p>Phase 2and 3 of</p>
          <p>the new system</p>
          <p>being developed</p>
          <p>___________________________________________________</p>
             </div>
        </section>
        
                <section class="content-section">
            <h2 class="section-heading">
            <span class="heading-icon">📚</span>
            <span class="heading-text">Pilot Change Over</span>
          </h2>
         <div class="content-block">            
          <p>It involves installation of new system but using it only in one part of organization on experimental basis e.g A bank wishing to computerize its operations may install a computerized system on one branch on experimental basis.</p>

           <p> When the system is proved to be successful, it is transferred to another etc until the entire bank is computerized.  Any refinement that ought to be done on the system should be done before its installed in the next branch.</p>
        <p>Both pilot and phased change over method share the same advantages and disadvantages as follows<strong>:</strong></p>
           </div>   
                 <div class="content-block">  
        <p><strong>Advantages:</strong></p>
        <ul>
            <li>Allow a new system to be implemented quickly with minimum risks.</li>
            <li>Allow training of personnel on the new system during its implementation.</li>
             <li>They cause minimum interruption to operations during system’s implementation.</li>
            <li>The peak demands are lighter on the ends user and the operational environment.</li>
             <li>They are less costly.</li>
            <li>The risks associated with errors and system failures are minimized.</li>
            </ul>
               </div>
           <div class="content-block">   
        <p><strong>Disadvantages:</strong></p>
        <ul>
          <li>Interfacing both the new and the old system may usually bring problems.</li>
          <li>They may be additional costs associated with running both systems at the same time.
            </li>
            </ul>
          
            <p>Change over plan should include the following<strong>:</strong></p>
          <ol>
            <li>Time limit for the parallel run.</li>
            <li>Instructions on error handling procedures.</li>
            <li>Instruction on how to cope with major problem in the new system.</li>
          </ol>
               </div>
            </section>

          <section class="summary-section">
              <div class="summary-container">
                <div class="summary-header">
                  <span class="summary-icon">📝</span>
                  <h3 class="summary-title">Key Takeaways</h3>
                </div>
                <div class="summary-content">
                  <ul class="takeaway-list">
                    <li class="takeaway-item">
                      <span class="takeaway-marker">01</span>
                      <p>System design translates requirements into a blueprint for the new system.</p>
                    </li>
                      <li class="takeaway-item">
                      <span class="takeaway-marker">02</span>
                      <p>Program design involves modularization and detailed specification.</p>
                    </li>
                    <li class="takeaway-item">
                      <span class="takeaway-marker">03</span>
                      <p>Testing is crucial, including unit, modular, integration, and system testing.</p>
                    </li>
                    <li class="takeaway-item">
                      <span class="takeaway-marker">04</span>
                      <p>Implementation includes hardware/software acquisition, user training, and change-over.</p>
                    </li>
                      <li class="takeaway-item">
                      <span class="takeaway-marker">05</span>
                      <p>Change-over methods include direct, parallel, phased, and pilot approaches.</p>
                    </li>
                  </ul>
                </div>
              </div>
            </section>



        </main>

      <!-- Navigation (bottom - identical to top) -->
       <nav class="module-nav">
        <div class="nav-links">
          <a href="../index.html" class="nav-button">
            <span class="nav-icon">←</span>
            <span class="nav-text">Home</span>
          </a>
          <a href="module3.html" class="nav-button">
            <span class="nav-icon">←</span>
            <span class="nav-text">Previous</span>
          </a>
          <div class="module-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 60%;"></div>
            </div>
            <span class="progress-text">Module 4 of 5</span>
          </div>
          <a href="module5.html" class="nav-button">
            <span class="nav-text">Next</span>
            <span class="nav-icon">→</span>
          </a>
        </div>
      </nav>
    </article>
  </div>
</body>
</html>

