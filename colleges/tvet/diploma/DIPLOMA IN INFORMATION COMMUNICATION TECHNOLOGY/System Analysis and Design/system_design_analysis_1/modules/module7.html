<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 7: SYSTEMS DESIGN AND DEVELOPMENT - System Analysis and Design</title>
  <meta name="description" content="Module 7 explores the principles of systems design and development, design models, components, methodologies, and tools.">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <article class="learning-module" data-module="7">
    <nav class="module-nav">
      <div class="nav-links">
        <a href="../index.html" class="nav-button">
          <span>‚Üê</span> Home
        </a>
        <a href="module6.html" class="nav-button">
          <span>‚Üê</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 7 of 13</span>
        </div>
        <a href="module8.html" class="nav-button">
          Next <span>‚Üí</span>
        </a>
      </div>
    </nav>
    <header class="module-header">
      <h1>Module 7: SYSTEMS DESIGN AND DEVELOPMENT</h1>
      <section class="module-objectives">
        <h2>üéØ Learning Objectives</h2>
        <ul>
          <li>Understand the concept of system design and its meaning.</li>
          <li>Identify the qualities of a good system design.</li>
          <li>Learn about inputs and outputs to system design.</li>
          <li>Explore system design models and components.</li>
          <li>Understand different software/system analysis and design tools.</li>
          <li>Learn about design methodologies and selection criteria.</li>
        </ul>
      </section>
    </header>
    <main class="module-content">
      <section>
        <h2>üìö CHAPTER 7: SYSTEMS DESIGN AND DEVELOPMENT</h2>
        <section>
          <h3>Introduction to System design</h3>
          <p>System design is the phase that bridges the gap between problem domain and the existing system in a manageable way. This phase focuses on the solution domain, i.e. ‚Äúhow to implement?"</p>
          <section>
            <h4>Meaning</h4>
            <p>Systems design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. Systems design could be seen as the application of systems theory to product development.</p>
          </section>
          <section>
            <h4>Importance</h4>
            <p>Importance of this phase may be understood by reason of the fact that it involves identifying data sources, the nature and type of data that is available. For example, in order to design a salary system, there is a need for using inputs, such as, attendance, leave details, additions or deductions etc.</p>
            <p>This facilitates understanding what kind of data is available and by whom it is supplied to the system so that the system may be designed considering all the relevant factors.</p>
            <p>In addition, system designing leads to ensure that the system is created in such a way that it fulfills the need of the users and keep them at ease being user-oriented.</p>
            <p>In terms of the flexibility, one of the main objectives of this phase is that it is intended to design such a system which can be dynamic in nature and responsive to the changes if required.</p>
            <p>Another important objective is that the phase of system designing is concerned with creating the system which can work efficiently providing the required output and being responsive to the time within a given time limit.</p>
            <p>The aspect of reliability and physical security of data cannot be ignored. With this respect, the system designing phase ensures security measures of the system effectively and efficiently.</p>
          </section>
          <section>
            <h4>Objective</h4>
            <p>It is the phase where the SRS document is converted into a format that can be implemented and decides how the system will operate.</p>
            <p>In this phase, the complex activity of system development is divided into several smaller sub-activities, which coordinate with each other to achieve the main objective of system development.</p>
          </section>
        </section>
        <section>
          <h3>Qualities of Good Design</h3>
          <p>From this profound question of design characteristics, there can list ten qualities that are hard to argue. For architects, this list makes a great checklist as you move through the design process:</p>
          <ol>
            <li><strong>Sustainable:</strong><br>The problem with sustainable design is that it's easier to talk about than to do properly. Unfortunately, green washing and marketing spin are often substitutes for real change.<br>Architects can't hide anymore. The word is out. The buildings we design and the energy they require generate more carbon dioxide than cars. Yes, the auto makers that we all complain about have less impact than architects and their clients. It's time to do the right thing.</li>
            <li><strong>Accessible</strong><br>What is good design if it's only available to some. Here in the US, detailed codes dictate that our built environment be accessible to those with disabilities. Often times it is important to look beyond these minimum standards.</li>
            <li><strong>Functional</strong><br>This should be the simplest attribute of good design, but it is often the hardest to achieve. Apple makes products that look great, but at their core, they are successful by creating easy to use hardware and software that surpasses the competition.</li>
            <li><strong>Well Made</strong><br>Architects don't make anything. Our say in how well a building is built is limited to a set of instructions we provide. The end people that actually build it have little to no actual interaction with the architect. This means our instructions better be good, and just as important, easy to understand.</li>
            <li><strong>Emotionally Resonant</strong><br>People rarely forget the feeling of walking into the Pantheon in Rome. Now compare that to the bland sameness found in the bulk of our suburban developments.<br>Not every building can be the Pantheon, but every design should be an attempt to stir the senses.</li>
            <li><strong>Enduring</strong><br>Buildings need both structural and aesthetic longevity. It's important to innovate, but you don't want a design that looks outdated before that last coat of paint dries.<br>The time frame for enduring is uncertain. No question the Pantheon (126 A.D.) is enduring. Is Gehry's Guggenheim (1997) in Bilbao?</li>
            <li><strong>Socially Beneficial</strong><br>Whether you like it or not, all architecture is public architecture. Architects have a responsibility to look both within and beyond the walls of our buildings to see what we can do to help.</li>
            <li><strong>Beautiful</strong><br>Beauty is subjective, right?</li>
            <li><strong>Ergonomic</strong><br>Buildings must relate to the scale of the people that inhabit them. Often this idea is lost in the the array of 3D computer modeling technologies that architects use these days. Stop and take a step back. Put a person in that model. Even if they're digital.</li>
            <li><strong>Affordable</strong><br>This is one of the hardest for architects. The reason is simple. Architects typically get clients by waiting for the phone to ring. Someone with money, land and an idea that wants our services. This client type represents a small portion of society, yet makes up almost all of an architect's client√®le.<br>Creating affordable architecture is more difficult. It involves entrepreneurship on the part of the architect. An upfront investment to invent an affordable solution that the masses can afford.</li>
          </ol>
        </section>
        <section>
          <h3>Inputs/Output to System Design</h3>
          <p>System design takes the following inputs</p>
          <ul>
            <li>Statement of work</li>
            <li>Requirement determination plan</li>
            <li>Current situation analysis</li>
            <li>Proposed system requirements including a conceptual data model, modified DFDs, and Metadata (data about data).</li>
          </ul>
          <p>System design gives the following outputs ‚Äì</p>
          <ul>
            <li>Infrastructure and organizational changes for the proposed system.</li>
            <li>A data schema, often a relational schema.</li>
            <li>Metadata to define the tables/files and columns/data-items.</li>
            <li>A function hierarchy diagram or web page map that graphically describes the program structure.</li>
            <li>Actual or pseudocode for each module in the program.</li>
            <li>A prototype for the proposed system.</li>
          </ul>
        </section>
        <section>
          <h3>System design models</h3>
          <section>
            <h4>Logical/Architectural design</h4>
            <p>Deals with the overall model structure other than the details of the design</p>
            <p>The logical design of a system pertains to an abstract representation of the data flows, inputs and outputs of the system. This is often conducted via modeling, using an over-abstract (and sometimes graphical) model of the actual system. In the context of systems design are included. Logical design includes ER Diagrams i.e Entity Relationship Diagrams</p>
          </section>
          <section>
            <h4>Physical/Detailed design</h4>
            <p>Means you refine the modules you introduced during architectural design</p>
            <p>The physical design relates to the actual input and output processes of the system. This is laid down in terms of how data is input into a system, how it is verified/authenticated, how it is processed, and how it is displayed as output.</p>
            <p>In Physical design, the following requirements about the system are decided.</p>
            <ol>
              <li>Input requirement,</li>
              <li>Output requirements,</li>
              <li>Storage requirements,</li>
              <li>Processing Requirements,</li>
              <li>System control and backup or recovery.</li>
            </ol>
            <p>Put another way, the physical portion of systems design can generally be broken down into three sub-tasks:</p>
            <ol>
              <li>User Interface Design</li>
              <li>Data Design</li>
              <li>Process Design</li>
            </ol>
            <p>User Interface Design is concerned with how users add information to the system and with how the system presents information back to them. Data Design is concerned with how the data is represented and stored within the system. Finally, Process Design is concerned with how data moves through the system, and with how and where it is validated, secured and/or transformed as it flows into, through and out of the system.</p>
          </section>
        </section>
        <section>
          <h3>Software/system Analysis & Design Tools</h3>
          <p>Software analysis and design includes all activities, which help the transformation of requirement specification into implementation. Requirement specifications specify all functional and non-functional expectations from the software. These requirement specifications come in the shape of human readable and understandable documents, to which a computer has nothing to do.</p>
          <p>Software analysis and design is the intermediate stage, which helps human-readable requirements to be transformed into actual code.</p>
          <p>Let us see few analysis and design tools used by software designers:</p>
          <ol>
            <li><strong>Flow charts</strong><br>Tool: Work Systems Analysis/Flowchart
              <section>
                <h5>WHAT IT IS -</h5>
                <p>A tool used to closely examine the structure of the work and the way information and knowledge are applied.</p>
              </section>
              <section>
                <h5>WHEN TO USE IT -</h5>
                <p>During the design phase of the change process in order to assess whether the planned change is feasible.</p>
              </section>
              <section>
                <h5>HOW TO USE IT</h5>
                <ol type="a">
                  <li>Identify the major steps of the process (including material and information flow).<br>Use standard flowchart symbols to illustrate the process:</li>
                </ol>
                <img src="../assets/diagrams/module7-flowchart-symbols.svg" alt="Flowchart Symbols" width="600" height="300">
                <ol type="a" start="2">
                  <li>Identify the key variances (deviations between the desired and actual outcomes). Mark where they are first noticed and why they occur. Identify who can control or correct them.</li>
                  <li>Determine the impact of the variances on organizational success measures and choose which ones to address, in priority order. Consider the frequency and impact on other areas and the effort required to address them.</li>
                  <li>Identify how variances are handled now and what is needed to eliminate them or reduce their impact.</li>
                </ol>
              </section>
            </li>
          </ol>
          <img src="../assets/images/module7-flowchart-example.png" alt="Flowchart Example" width="600" height="600">
          <ol type="1" start="2">
            <li><strong>Data Flow Diagram</strong><br>Data flow diagram is graphical representation of flow of data in an information system. It is capable of depicting incoming data flow, outgoing data flow and stored data. The DFD does not mention anything about how data flows through the system.<br>There is a prominent difference between DFD and Flowchart. The flowchart depicts flow of control in program modules. DFDs depict flow of data in the system at various levels. DFD does not contain any control or branch elements.<br><strong>Types of DFD</strong><br>Data Flow Diagrams are either Logical or Physical.
              <ul>
                <li><strong>Logical DFD</strong> - This type of DFD concentrates on the system process, and flow of data in the system. For example in a Banking software system, how data is moved between different entities.</li>
                <li><strong>Physical DFD</strong> - This type of DFD shows how the data flow is actually implemented in the system. It is more specific and close to the implementation.</li>
              </ul>
              <h5>DFD Components</h5>
              <p>DFD can represent Source, destination, storage and flow of data using the following set of components ‚Äì</p>
              <img src="../assets/diagrams/module7-dfd-components.svg" alt="DFD Components Diagram" width="600" height="200">
              <ul>
                <li><strong>Entities</strong> - Entities are source and destination of information data. Entities are represented by a rectangles with their respective names.</li>
                <li><strong>Process</strong> - Activities and action taken on the data are represented by Circle or Round-edged rectangles.</li>
                <li><strong>Data Storage</strong> - There are two variants of data storage - it can either be represented as a rectangle with absence of both smaller sides or as an open-sided rectangle with only one side missing.</li>
                <li><strong>Data Flow</strong> - Movement of data is shown by pointed arrows. Data movement is shown from the base of arrow as its source towards head of the arrow as destination.</li>
              </ul>
              <h5>Levels of DFD</h5>
              <ul>
                <li><strong>Level 0</strong> - Highest abstraction level DFD is known as Level 0 DFD, which depicts the entire information system as one diagram concealing all the underlying details. Level 0 DFDs are also known as context level DFDs.</li>
              </ul>
              <img src="../assets/diagrams/module7-online-shopping-system-level0-dfd.svg" alt="Online Shopping System Level 0 DFD" width="600" height="300">
              <ul>
                <li><strong>Level 1</strong> - The Level 0 DFD is broken down into more specific, Level 1 DFD. Level 1 DFD depicts basic modules in the system and flow of data among various modules. Level 1 DFD also mentions basic processes and sources of information.</li>
              </ul>
              <img src="../assets/diagrams/module7-online-shopping-system-level1-dfd.svg" alt="Online Shopping System Level 1 DFD" width="600" height="450">
            </li>
            <li><strong>Structure Charts</strong><br>Structure chart is a chart derived from Data Flow Diagram. It represents the system in more detail than DFD. It breaks down the entire system into lowest functional modules, describes functions and sub-functions of each module of the system to a greater detail than DFD.<br>Structure chart represents hierarchical structure of modules. At each layer a specific task is performed.<br>Here are the symbols used in construction of structure charts -</li>
          </ol>
          <img src="../assets/diagrams/module7-structure-chart-symbols.svg" alt="Structure Chart Symbols Diagram" width="600" height="600">
          <ol type="1" start="4">
            <li><strong>HIPO Diagram</strong><br>HIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to analyze the system and provide the means of documentation. HIPO model was developed by IBM in year 1970.<br>HIPO diagram represents the hierarchy of modules in the software system. Analyst uses HIPO diagram in order to obtain high-level view of system functions. It decomposes functions into sub-functions in a hierarchical manner. It depicts the functions performed by system.<br>HIPO diagrams are good for documentation purpose. Their graphical representation makes it easier for designers and managers to get the pictorial idea of the system structure.</li>
          </ol>
          <img src="../assets/diagrams/module7-online-sales-hipo-diagram.svg" alt="Online Sales HIPO Diagram" width="600" height="450">
          <p>In contrast to IPO (Input Process Output) diagram, which depicts the flow of control and data in a module, HIPO does not provide any information about data flow or control flow.</p>
          <img src="../assets/diagrams/module7-authentication-hipo-diagram.svg" alt="Authentication HIPO Diagram" width="600" height="300">
          <ol type="1" start="5">
            <li><strong>Structured English</strong><br>Most programmers are unaware of the large picture of software so they only rely on what their managers tell them to do. It is the responsibility of higher software management to provide accurate information to the programmers to develop accurate yet fast code.<br>Other forms of methods, which use graphs or diagrams, may are sometimes interpreted differently by different people.<br>Hence, analysts and designers of the software come up with tools such as Structured English. It is nothing but the description of what is required to code and how to code it. Structured English helps the programmer to write error-free code.</li>
            <li><strong>Pseudo-Code</strong><br>Pseudo-Code Pseudo code is written more close to programming language. It may be considered as augmented programming language, full of comments and descriptions.<br>Pseudo code avoids variable declaration but they are written using some actual programming language's constructs, like C, Fortran, Pascal etc.<br>Pseudo code contains more programming details than Structured English. It provides a method to perform the task, as if a computer is executing the code.</li>
          </ol>
          <img src="../assets/images/module7-functional-decomposition-example.png" alt="Functional Decomposition Example" width="600" height="600">
        </section>
        <section>
          <h3>Design Methodology</h3>
          <p>Design methodology refers to the development of a system or method for a unique situation.</p>
          <p>The key to design methodology is finding the best solution for each design situation, whether it be in industrial design, architecture or technology.</p>
          <p>Several design methodology approaches have developed in the technology industry. Each was a reaction to a different type of problem. Some common technology design methodologies include:</p>
          <ul>
            <li><strong>Top Down Design or Stepwise Refinement/SDLC</strong> [systems development lifecycle]: This starts from the end solution and works backwards, refining each step along the way.</li>
            <li><strong>Bottom Up Design:</strong> This methodology starts with a foundation and works up towards a solution.</li>
            <li><strong>Structured Design:</strong> This is an industry standard. The technique starts by identifying inputs and desired outputs to create a graphical representation.</li>
            <li><strong>Structured Analysis and Design Technique:</strong> This approach utilizes a diagram to describe the hierarchy of a system's functions.</li>
            <li><strong>Data Structured Systems Development:</strong> Data structure determines the system structure in this methodology.</li>
            <li><strong>Object Oriented Design:</strong> This methodology is based on a system of interacting objects.</li>
          </ul>
        </section>
        <section>
          <h3>Selection criteria for a development methodology</h3>
          <p>A preliminary study indicated the following set of criteria as important: The list is ordered from most important to least important according to the feedback received from the research respondents.</p>
          <ol>
            <li>Risk Clearness - Are all of the risks known?</li>
            <li>Scope Clearness - Are the scope boundaries set or will it be possible for the development team to get lost in the detail?</li>
            <li>Requirements Maturity - Does the customer have a firm grasp of all the requirements?</li>
            <li>Changes Expected - Will the requirements change often?</li>
            <li>Development Costs - What is the Cost of Quality and Total Cost of Ownership?</li>
            <li>Team Relationship - Are some members of the team geographically separated? Is the team focused on teamwork or are they individual contributors?</li>
            <li>Stakeholders Flexibility - Can stakeholders adjust to the process and team?</li>
            <li>Team Experience - Low, average or highly skilled team?</li>
            <li>Clients Commitment - Can the client commit to being dedicated to the development team for the duration of the project?</li>
            <li>Documentation Required - Is handover documentation required for future reference?</li>
            <li>Complexity of Application - High, average or low complexity?</li>
            <li>Size Plateau of Application - Is the plateau small, medium or large in scale?</li>
            <li>Environmental Stability - What does the software development environment look like?</li>
            <li>Team Size - It is a small, medium or big team?</li>
            <li>Applications Familiarity - Is it new or familiar technology?</li>
            <li>Programming languages to use - Is the requirement dependant on the availability of scarce skills?</li>
            <li>Method of Contracting - Costing based on fixed price or time and materials?</li>
            <li>Departments Influence - Is there a preference for a methodology within another influential department?</li>
          </ol>
        </section>
        <section>
          <h3>System design methods</h3>
          <p>Design methods is a broad area that focuses on: Divergence ‚Äì Exploring possibilities and constraints of inherited situations by applying critical thinking through qualitative and quantitative research methods to create new understanding (problem space) toward better design solutions.</p>
          <section>
            <h4>Methods</h4>
            <ol>
              <li><strong>Structured Systems Analysis and Design Method [SSADM]</strong><br>SSADM follows the waterfall life cycle model starting from the feasibility study to the physical design stage of development. One of the main features of SSADM is the intensive user involvement in the requirements analysis stage. The users are made to sign off each stage as they are completed assuring that requirements are met. The users are provided with clear, easily understandable documentation consisting of various diagrammatic representations of the system.<br>SSADM breaks up a development project into stages, modules, steps and tasks. The first and foremost model developed in SSADM is the data model. It is a part of requirements gathering and consists of well-defined stages, steps and products. The techniques used in SSADM are logical data modeling, data flow modeling and entity behavior modeling.</li>
            </ol>
            <ul>
              <li><strong>Logical Data Modeling:</strong> This involves the process of identifying, modeling and documenting data as a part of system requirements gathering. The data are classified further into entities and relationships.</li>
              <li><strong>Data Flow Modeling:</strong> This involves tracking the data flow in an information system. It clearly analyzes the processes, data stores, external entities and data movement.</li>
              <li><strong>Entity Behavior Modeling:</strong> This involves identifying and documenting the events influencing each entity and the sequence in which these events happen.</li>
            </ul>
            <p>Some of the important characteristics of SSADM are:</p>
            <ul>
              <li>Dividing a project into small modules with well defined objectives</li>
              <li>Useful during requirements specification and system design stage</li>
              <li>Diagrammatic representation and other useful modeling techniques</li>
              <li>Simple and easily understood by clients and developers</li>
              <li>Performing activities in a sequence</li>
            </ul>
            <p>The stages of SSADM include:</p>
            <ul>
              <li>Determining feasibility</li>
              <li>Investigating the current environment</li>
              <li>Determining business systems options</li>
              <li>Defining requirements</li>
              <li>Determining technical system options</li>
              <li>Creating the logical design</li>
              <li>Creating the physical design</li>
            </ul>
            <p>Each of these stages applies certain techniques and a sequence of analysis. They include conventions and procedures for recording and interpreting the information with the help of diagrams and text.</p>
            <p>SSADM application development projects are divided into different modules:</p>
            <ol>
              <li>Feasibility Study: Determines whether a given project is feasible.</li>
              <li>Current Environment Investigation: SSADM developers become familiar with a system's data requirements. This is because the new system is likely to be based on the same underlying data.</li>
              <li>Business System Options: The overall design of the new system is determined.</li>
              <li>Requirement Specification: The full logical specification of what the new system must do is determined.</li>
              <li>Technical System Options: Options for implementation of the new system are developed and the possible choices are narrowed down.</li>
              <li>Logical Design: Specifies the user interface such as menu and command structures.</li>
              <li>Physical Design: Specifications are converted to real hardware and software.</li>
            </ol>
          </section>
          <section>
            <ol type="1" start="2">
              <li><strong>Prototyping</strong><br>Software/system prototyping is the development approach of activities during software development, the creation of prototypes, i.e., incomplete versions of the software program being developed.<br>The basic principles are:</li>
            </ol>
            <ul>
              <li>Not a standalone, complete development methodology, but rather an approach to handle selected parts of a larger, more traditional development methodology (i.e. incremental, spiral, or rapid application development (RAD)).</li>
              <li>Attempts to reduce inherent project risk by breaking a project into smaller segments and providing more ease-of-change during the development process.</li>
              <li>User is involved throughout the development process, which increases the likelihood of user acceptance of the final implementation.</li>
              <li>Small-scale mock-ups of the system are developed following an iterative modification process until the prototype evolves to meet the users' requirements.</li>
              <li>While most prototypes are developed with the expectation that they will be discarded, it is possible in some cases to evolve from prototype to working system.</li>
              <li>A basic understanding of the fundamental business problem is necessary to avoid solving the wrong problems.</li>
            </ul>
            <p>The process of prototyping involves the following steps</p>
            <ol>
              <li>Identify basic requirements - Determine basic requirements including the input and output information desired. Details, such as security, can typically be ignored.</li>
              <li>Develop Initial Prototype - The initial prototype is developed that includes only user interfaces. (See Horizontal Prototype, below)</li>
              <li>Review - The customers, including end-users, examine the prototype and provide feedback on additions or changes.</li>
              <li>Revise and Enhance the Prototype - Using the feedback both the specifications and the prototype can be improved. Negotiation about what is within the scope of the contract/product may be necessary. If changes are introduced then a repeat of steps #3 and #4 may be needed.</li>
            </ol>
            <h5>Dimensions of prototypes</h5>
            <p><strong>Horizontal Prototype</strong> - A common term for a user interface prototype is the horizontal prototype. It provides a broad view of an entire system or subsystem, focusing on user interaction more than low-level system functionality, such as database access. Horizontal prototypes are useful for:</p>
            <ul>
              <li>Confirmation of user interface requirements and system scope,</li>
              <li>Demonstration version of the system to obtain buy-in from the business,</li>
              <li>Develop preliminary estimates of development time, cost and effort.</li>
            </ul>
            <p><strong>Vertical Prototype</strong> - A vertical prototype is a more complete elaboration of a single subsystem or function. It is useful for obtaining detailed requirements for a given function, with the following benefits:</p>
            <ul>
              <li>Refinement database design,</li>
              <li>Obtain information on data volumes and system interface needs, for network sizing and performance engineering,</li>
              <li>Clarify complex requirements by drilling down to actual system functionality.</li>
            </ul>
            <h5>Types of prototyping</h5>
            <ul>
              <li><strong>Throwaway</strong> - refers to the creation of a model that will eventually be discarded rather than becoming part of the final delivered software.</li>
              <li><strong>Evolutionary Prototyping</strong> (also known as breadboard prototyping) - builds a very robust prototype in a structured manner and constantly refine it.</li>
              <li><strong>Incremental</strong> - The final product is built as separate prototypes. At the end the separate prototypes are merged in an overall design. By the help of incremental prototyping we can reduce the time gap between user and software developer.</li>
            </ul>
            <h6>Advantages to using prototyping</h6>
            <ol>
              <li><strong>Reduced time and costs:</strong> Prototyping can improve the quality of requirements and specifications provided to developers. Because changes cost exponentially more to implement as they are detected later in development, the early determination of what the user really wants can result in faster and less expensive software.</li>
              <li><strong>Improved and increased user involvement:</strong> Prototyping requires user involvement and allows them to see and interact with a prototype allowing them to provide better and more complete feedback and specifications.</li>
            </ol>
            <h6>Prototyping disadvantages.</h6>
            <ol>
              <li>Insufficient analysis</li>
              <li>User confusion of prototype and finished system</li>
              <li>Developer misunderstanding of user objectives</li>
              <li>Developer attachment to prototype</li>
              <li>Excessive development time of the prototype</li>
              <li>Expense of implementing prototyping</li>
            </ol>
          </section>
          <section>
            <ol type="1" start="3">
              <li><strong>Jackson system development (JSD)</strong><br>It's a method of system development that covers the software life cycle either directly or, by providing a framework into which more specialized techniques can fit.<br>Three basic principles of operation of JSD is that:</li>
            </ol>
            <ul>
              <li>Development must start with describing and modelling the real world, rather than specifying or structuring the function performed by the system. A system made using JSD method performs the simulation of the real world before any direct attention is paid to function or purpose of the system.</li>
              <li>An adequate model of a time-ordered world must itself be time-ordered. Main aim is to map progress in the real world on progress in the system that models it.</li>
              <li>The way of implementing the system is based on transformation of specification into efficient set of processes. These processes should be designed in such a manner that it would be possible to run them on available software and hardware.</li>
            </ul>
            <h5>JSD steps</h5>
            <p>When it was originally presented by Jackson in 1982, the method consisted of six steps:</p>
            <ol>
              <li>Entity/action step</li>
              <li>Initial model step</li>
              <li>Interactive function step</li>
              <li>Information function step</li>
              <li>System timing step</li>
              <li>System implementation step</li>
            </ol>
            <p>Later, some steps were combined to create a method with only three steps.</p>
            <ol>
              <li>Modeling stage (analysis): with the entity/action step and entity structures step.</li>
              <li>Network stage (design): with the initial model step, function step, and system timing step.</li>
              <li>Implementation stage (realization): the implementation step.</li>
            </ol>
          </section>
          <section>
            <ol type="1" start="4">
              <li><strong>Function decomposition</strong><br>A function model or functional model in systems design and is a structured representation of the functions (activities, actions, processes, operations) within the modeled system or subject area.</li>
            </ol>
            <p>A functional model must thus achieve two aims in order to be of use. It must furnish a throughput description mechanics capable of completely defining the first and last throughput states, and perhaps some of the intervening states. It must also offer some means by which any input, correctly described in terms of this mechanics, can be used to generate an output which is an equally correct description of the output which the actual system would have given for the input concerned. It may also be noted that there are two other things which a functional model may do, but which are not necessary to all functional models. Thus such a system may, but need not, describe the system throughputs other than at the input and output, and it may also contain a description of the operation which each element carries out on the throughput, but once again this is not.</p>
            <p>Functional decomposition refers broadly to the process of resolving a functional relationship into its constituent parts in such a way that the original function can be reconstructed from those parts by function composition. In general, this process of decomposition is undertaken either for the purpose of gaining insight into the identity of the constituent components, or for the purpose of obtaining a compressed representation of the global function, a task which is feasible only when the constituent processes possess a certain level of modularity.</p>
          </section>
          <img src="../assets/images/module7-functional-decomposition-example-2.png" alt="Functional Decomposition Example 2" width="600" height="600">
        </section>
      </section>
    </main>
    <footer class="module-footer">
    </footer>
    <nav class="module-nav">
      <div class="nav-links">
        <a href="../index.html" class="nav-button">
          <span>‚Üê</span> Home
        </a>
        <a href="module6.html" class="nav-button">
          <span>‚Üê</span> Previous
        </a>
        <div class="module-progress">
          <span>Module 7 of 13</span>
        </div>
        <a href="module8.html" class="nav-button">
          Next <span>‚Üí</span>
        </a>
      </div>
    </nav>
  </article>
</body>
</html>